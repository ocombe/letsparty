(function() {
  var undefined;
  var arrayPool = [], objectPool = [];
  var idCounter = 0;
  var indicatorObject = {};
  var keyPrefix = +new Date() + "";
  var largeArraySize = 75;
  var maxPoolSize = 40;
  var whitespace = " 	\f ﻿" + "\n\r\u2028\u2029" + " ᠎             　";
  var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  var reFlags = /\w*$/;
  var reFuncName = /^\s*function[ \n\r\t]+\w/;
  var reInterpolate = /<%=([\s\S]+?)%>/g;
  var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
  var reNoMatch = /($^)/;
  var reThis = /\bthis\b/;
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
  var contextProps = [ "Array", "Boolean", "Date", "Error", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
  var shadowedProps = [ "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf" ];
  var templateCounter = 0;
  var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", errorClass = "[object Error]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
  var debounceOptions = {
    leading: false,
    maxWait: 0,
    trailing: false
  };
  var descriptor = {
    configurable: false,
    enumerable: false,
    value: null,
    writable: false
  };
  var iteratorData = {
    args: "",
    array: null,
    bottom: "",
    firstArg: "",
    init: "",
    keys: null,
    loop: "",
    shadowedProps: null,
    support: null,
    top: "",
    useHas: false
  };
  var objectTypes = {
    "boolean": false,
    "function": true,
    object: true,
    number: false,
    string: false,
    undefined: false
  };
  var stringEscapes = {
    "\\": "\\",
    "'": "'",
    "\n": "n",
    "\r": "r",
    "	": "t",
    "\u2028": "u2028",
    "\u2029": "u2029"
  };
  var root = objectTypes[typeof window] && window || this;
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;
    if (type == "boolean" || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != "number" && type != "string") {
      type = "object";
    }
    var key = type == "number" ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];
    return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
  }
  function cachePush(value) {
    var cache = this.cache, type = typeof value;
    if (type == "boolean" || value == null) {
      cache[value] = true;
    } else {
      if (type != "number" && type != "string") {
        type = "object";
      }
      var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
      if (type == "object") {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }
  function compareAscending(a, b) {
    var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
    while (++index < length) {
      var value = ac[index], other = bc[index];
      if (value !== other) {
        if (value > other || typeof value == "undefined") {
          return 1;
        }
        if (value < other || typeof other == "undefined") {
          return -1;
        }
      }
    }
    return a.index - b.index;
  }
  function createCache(array) {
    var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
    if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
      return false;
    }
    var cache = getObject();
    cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;
    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }
  function escapeStringChar(match) {
    return "\\" + stringEscapes[match];
  }
  function getArray() {
    return arrayPool.pop() || [];
  }
  function getObject() {
    return objectPool.pop() || {
      array: null,
      cache: null,
      criteria: null,
      "false": false,
      index: 0,
      "null": false,
      number: null,
      object: null,
      push: null,
      string: null,
      "true": false,
      undefined: false,
      value: null
    };
  }
  function isNode(value) {
    return typeof value.toString != "function" && typeof (value + "") == "string";
  }
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == "undefined") {
      end = array ? array.length : 0;
    }
    var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }
  function runInContext(context) {
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
    var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
    var arrayRef = [];
    var errorProto = Error.prototype, objectProto = Object.prototype, stringProto = String.prototype;
    var oldDash = context._;
    var toString = objectProto.toString;
    var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
    var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
    var defineProperty = function() {
      try {
        var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
      } catch (e) {}
      return result;
    }();
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;
    var nonEnumProps = {};
    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
      constructor: true,
      toLocaleString: true,
      toString: true,
      valueOf: true
    };
    nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
      constructor: true,
      toString: true,
      valueOf: true
    };
    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
      constructor: true,
      toString: true
    };
    nonEnumProps[objectClass] = {
      constructor: true
    };
    (function() {
      var length = shadowedProps.length;
      while (length--) {
        var key = shadowedProps[length];
        for (var className in nonEnumProps) {
          if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
            nonEnumProps[className][key] = false;
          }
        }
      }
    })();
    function lodash(value) {
      return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
    }
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    lodashWrapper.prototype = lodash.prototype;
    var support = lodash.support = {};
    (function() {
      var ctor = function() {
        this.x = 1;
      }, object = {
        "0": 1,
        length: 1
      }, props = [];
      ctor.prototype = {
        valueOf: 1,
        y: 1
      };
      for (var key in new ctor()) {
        props.push(key);
      }
      for (key in arguments) {}
      support.argsClass = toString.call(arguments) == argsClass;
      support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);
      support.enumErrorProps = propertyIsEnumerable.call(errorProto, "message") || propertyIsEnumerable.call(errorProto, "name");
      support.enumPrototypes = propertyIsEnumerable.call(ctor, "prototype");
      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
      support.funcNames = typeof Function.name == "string";
      support.nonEnumArgs = key != 0;
      support.nonEnumShadows = !/valueOf/.test(props);
      support.ownLast = props[0] != "x";
      support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
      support.unindexedChars = "x"[0] + Object("x")[0] != "xx";
      try {
        support.nodeClass = !(toString.call(document) == objectClass && !({
          toString: 0
        } + ""));
      } catch (e) {
        support.nodeClass = true;
      }
    })(1);
    lodash.templateSettings = {
      escape: /<%-([\s\S]+?)%>/g,
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: reInterpolate,
      variable: "",
      imports: {
        _: lodash
      }
    };
    var iteratorTemplate = function(obj) {
      var __p = "var index, iterable = " + obj.firstArg + ", result = " + obj.init + ";\nif (!iterable) return result;\n" + obj.top + ";";
      if (obj.array) {
        __p += "\nvar length = iterable.length; index = -1;\nif (" + obj.array + ") {  ";
        if (support.unindexedChars) {
          __p += "\n  if (isString(iterable)) {\n    iterable = iterable.split('')\n  }  ";
        }
        __p += "\n  while (++index < length) {\n    " + obj.loop + ";\n  }\n}\nelse {  ";
      } else if (support.nonEnumArgs) {
        __p += "\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += '';\n      " + obj.loop + ";\n    }\n  } else {  ";
      }
      if (support.enumPrototypes) {
        __p += "\n  var skipProto = typeof iterable == 'function';\n  ";
      }
      if (support.enumErrorProps) {
        __p += "\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ";
      }
      var conditions = [];
      if (support.enumPrototypes) {
        conditions.push('!(skipProto && index == "prototype")');
      }
      if (support.enumErrorProps) {
        conditions.push('!(skipErrorProps && (index == "message" || index == "name"))');
      }
      if (obj.useHas && obj.keys) {
        __p += "\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n";
        if (conditions.length) {
          __p += "    if (" + conditions.join(" && ") + ") {\n  ";
        }
        __p += obj.loop + ";    ";
        if (conditions.length) {
          __p += "\n    }";
        }
        __p += "\n  }  ";
      } else {
        __p += "\n  for (index in iterable) {\n";
        if (obj.useHas) {
          conditions.push("hasOwnProperty.call(iterable, index)");
        }
        if (conditions.length) {
          __p += "    if (" + conditions.join(" && ") + ") {\n  ";
        }
        __p += obj.loop + ";    ";
        if (conditions.length) {
          __p += "\n    }";
        }
        __p += "\n  }    ";
        if (support.nonEnumShadows) {
          __p += "\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ";
          for (k = 0; k < 7; k++) {
            __p += "\n    index = '" + obj.shadowedProps[k] + "';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))";
            if (!obj.useHas) {
              __p += " || (!nonEnum[index] && iterable[index] !== objectProto[index])";
            }
            __p += ") {\n      " + obj.loop + ";\n    }      ";
          }
          __p += "\n  }    ";
        }
      }
      if (obj.array || support.nonEnumArgs) {
        __p += "\n}";
      }
      __p += obj.bottom + ";\nreturn result";
      return __p;
    };
    function baseBind(bindData) {
      var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
      function bound() {
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (this instanceof bound) {
          var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != "undefined") {
          return result;
        }
      }
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className] || !support.nodeClass && isNode(value)) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
         case boolClass:
         case dateClass:
          return new ctor(+value);

         case numberClass:
         case stringClass:
          return new ctor(value);

         case regexpClass:
          result = ctor(value.source, reFlags.exec(value));
          result.lastIndex = value.lastIndex;
          return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());
        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      } else {
        result = isArr ? slice(value) : assign({}, value);
      }
      if (isArr) {
        if (hasOwnProperty.call(value, "index")) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, "input")) {
          result.input = value.input;
        }
      }
      if (!isDeep) {
        return result;
      }
      stackA.push(value);
      stackB.push(result);
      (isArr ? baseEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });
      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    if (!nativeCreate) {
      baseCreate = function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object();
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }();
    }
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != "function") {
        return identity;
      }
      if (typeof thisArg == "undefined" || !("prototype" in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == "undefined") {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      if (bindData === false || bindData !== true && bindData[1] & 1) {
        return func;
      }
      switch (argCount) {
       case 1:
        return function(value) {
          return func.call(thisArg, value);
        };

       case 2:
        return function(a, b) {
          return func.call(thisArg, a, b);
        };

       case 3:
        return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };

       case 4:
        return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }
    function baseCreateWrapper(bindData) {
      var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
      var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }
    function baseDifference(array, values) {
      var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1, valLength = value.length, resIndex = result.length;
          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      if (callback) {
        var result = callback(a, b);
        if (typeof result != "undefined") {
          return !!result;
        }
      }
      if (a === b) {
        return a !== 0 || 1 / a == 1 / b;
      }
      var type = typeof a, otherType = typeof b;
      if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
        return false;
      }
      if (a == null || b == null) {
        return a === b;
      }
      var className = toString.call(a), otherClass = toString.call(b);
      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
       case boolClass:
       case dateClass:
        return +a == +b;

       case numberClass:
        return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

       case regexpClass:
       case stringClass:
        return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        if (className != objectClass || !support.nodeClass && (isNode(a) || isNode(b))) {
          return false;
        }
        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor, ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
        if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
          return false;
        }
      }
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());
      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;
      stackA.push(a);
      stackB.push(b);
      if (isArr) {
        length = a.length;
        size = b.length;
        result = size == length;
        if (result || isWhere) {
          while (size--) {
            var index = length, value = b[size];
            if (isWhere) {
              while (index--) {
                if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      } else {
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            size++;
            return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
          }
        });
        if (result && !isWhere) {
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              return result = --size > -1;
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();
      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found, isArr, result = source, value = object[key];
        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          var stackLength = stackA.length;
          while (stackLength--) {
            if (found = stackA[stackLength] == source) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if (isShallow = typeof result != "undefined") {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
            }
            stackA.push(source);
            stackB.push(value);
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        } else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == "undefined") {
              result = source;
            }
          }
          if (typeof result != "undefined") {
            value = result;
          }
        }
        object[key] = value;
      });
    }
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }
    function baseUniq(array, isSorted, callback) {
      var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index], computed = callback ? callback(value, index, array) : value;
        if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);
        if (isArray(collection)) {
          var index = -1, length = collection.length;
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
      if (!isBindKey && !isFunction(func)) {
        throw new TypeError();
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
      return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
    }
    function createIterator() {
      iteratorData.shadowedProps = shadowedProps;
      iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = "";
      iteratorData.init = "iterable";
      iteratorData.useHas = true;
      for (var object, index = 0; object = arguments[index]; index++) {
        for (var key in object) {
          iteratorData[key] = object[key];
        }
      }
      var args = iteratorData.args;
      iteratorData.firstArg = /^[^,]+/.exec(args)[0];
      var factory = Function("baseCreateCallback, errorClass, errorProto, hasOwnProperty, " + "indicatorObject, isArguments, isArray, isString, keys, objectProto, " + "objectTypes, nonEnumProps, stringClass, stringProto, toString", "return function(" + args + ") {\n" + iteratorTemplate(iteratorData) + "\n}");
      return factory(baseCreateCallback, errorClass, errorProto, hasOwnProperty, indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString);
    }
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }
    function isNative(value) {
      return typeof value == "function" && reNative.test(value);
    }
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, "__bindData__", descriptor);
    };
    function shimIsPlainObject(value) {
      var ctor, result;
      if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
      isFunction(ctor) && !(ctor instanceof ctor)) || !support.argsClass && isArguments(value) || !support.nodeClass && isNode(value)) {
        return false;
      }
      if (support.ownLast) {
        forIn(value, function(value, key, object) {
          result = hasOwnProperty.call(object, key);
          return false;
        });
        return result !== false;
      }
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == "undefined" || hasOwnProperty.call(value, result);
    }
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }
    function isArguments(value) {
      return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
    }
    if (!support.argsClass) {
      isArguments = function(value) {
        return value && typeof value == "object" && typeof value.length == "number" && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee") || false;
      };
    }
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
    };
    var shimKeys = createIterator({
      args: "object",
      init: "[]",
      top: "if (!(objectTypes[typeof object])) return result",
      loop: "result.push(index)"
    });
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      if (support.enumPrototypes && typeof object == "function" || support.nonEnumArgs && object.length && isArguments(object)) {
        return shimKeys(object);
      }
      return nativeKeys(object);
    };
    var eachIteratorOptions = {
      args: "collection, callback, thisArg",
      top: "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
      array: "typeof length == 'number'",
      keys: keys,
      loop: "if (callback(iterable[index], index, collection) === false) return result"
    };
    var defaultsIteratorOptions = {
      args: "object, source, guard",
      top: "var args = arguments,\n" + "    argsIndex = 0,\n" + "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" + "while (++argsIndex < argsLength) {\n" + "  iterable = args[argsIndex];\n" + "  if (iterable && objectTypes[typeof iterable]) {",
      keys: keys,
      loop: "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
      bottom: "  }\n}"
    };
    var forOwnIteratorOptions = {
      top: "if (!objectTypes[typeof iterable]) return result;\n" + eachIteratorOptions.top,
      array: false
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = invert(htmlEscapes);
    var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
    var baseEach = createIterator(eachIteratorOptions);
    var assign = createIterator(defaultsIteratorOptions, {
      top: defaultsIteratorOptions.top.replace(";", ";\n" + "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" + "  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n" + "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" + "  callback = args[--argsLength];\n" + "}"),
      loop: "result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]"
    });
    function clone(value, isDeep, callback, thisArg) {
      if (typeof isDeep != "boolean" && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
    }
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
    }
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }
    var defaults = createIterator(defaultsIteratorOptions);
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
      useHas: false
    });
    function forInRight(object, callback, thisArg) {
      var pairs = [];
      forIn(object, function(value, key) {
        pairs.push(key, value);
      });
      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }
    var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object), length = props.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }
    function invert(object) {
      var index = -1, props = keys(object), length = props.length, result = {};
      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }
    function isBoolean(value) {
      return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
    }
    function isDate(value) {
      return value && typeof value == "object" && toString.call(value) == dateClass || false;
    }
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value), length = value.length;
      if (className == arrayClass || className == stringClass || (support.argsClass ? className == argsClass : isArguments(value)) || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
        return !length;
      }
      forOwn(value, function() {
        return result = false;
      });
      return result;
    }
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
    }
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }
    function isFunction(value) {
      return typeof value == "function";
    }
    if (isFunction(/x/)) {
      isFunction = function(value) {
        return typeof value == "function" && toString.call(value) == funcClass;
      };
    }
    function isObject(value) {
      return !!(value && objectTypes[typeof value]);
    }
    function isNaN(value) {
      return isNumber(value) && value != +value;
    }
    function isNull(value) {
      return value === null;
    }
    function isNumber(value) {
      return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
    }
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass) || !support.argsClass && isArguments(value)) {
        return false;
      }
      var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
      return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
    };
    function isRegExp(value) {
      return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
    }
    function isString(value) {
      return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
    }
    function isUndefined(value) {
      return typeof value == "undefined";
    }
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }
    function merge(object) {
      var args = arguments, length = 2;
      if (!isObject(object)) {
        return object;
      }
      if (typeof args[2] != "number") {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == "function") {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == "function") {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != "function") {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }
    function pairs(object) {
      var index = -1, props = keys(object), length = props.length, result = Array(length);
      while (++index < length) {
        var key = props[index];
        result[index] = [ key, object[key] ];
      }
      return result;
    }
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != "function") {
        var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor, proto = ctor && ctor.prototype;
          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? baseEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }
    function values(object) {
      var index = -1, props = keys(object), length = props.length, result = Array(length);
      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }
    function at(collection) {
      var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
      if (support.unindexedChars && isString(collection)) {
        collection = collection.split("");
      }
      while (++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }
    function contains(collection, target, fromIndex) {
      var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == "number") {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        baseEach(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
    });
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);
      if (isArray(collection)) {
        var index = -1, length = collection.length;
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        baseEach(collection, function(value, index, collection) {
          return result = !!callback(value, index, collection);
        });
      }
      return result;
    }
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);
      if (isArray(collection)) {
        var index = -1, length = collection.length;
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        baseEach(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      if (isArray(collection)) {
        var index = -1, length = collection.length;
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        baseEach(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }
    function forEach(collection, callback, thisArg) {
      if (callback && typeof thisArg == "undefined" && isArray(collection)) {
        var index = -1, length = collection.length;
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        baseEach(collection, callback, thisArg);
      }
      return collection;
    }
    function forEachRight(collection, callback, thisArg) {
      var iterable = collection, length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
      if (isArray(collection)) {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        if (typeof length != "number") {
          var props = keys(collection);
          length = props.length;
        } else if (support.unindexedChars && isString(collection)) {
          iterable = collection.split("");
        }
        baseEach(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(iterable[key], key, collection);
        });
      }
      return collection;
    }
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });
    function invoke(collection, methodName) {
      var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }
    function map(collection, callback, thisArg) {
      var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
      callback = lodash.createCallback(callback, thisArg, 3);
      if (isArray(collection)) {
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        baseEach(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }
    function max(collection, callback, thisArg) {
      var computed = -Infinity, result = computed;
      if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1, length = collection.length;
        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
        baseEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }
    function min(collection, callback, thisArg) {
      var computed = Infinity, result = computed;
      if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1, length = collection.length;
        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
        baseEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }
    var pluck = map;
    function reduce(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      if (isArray(collection)) {
        var index = -1, length = collection.length;
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        baseEach(collection, function(value, index, collection) {
          accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
        });
      }
      return accumulator;
    }
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != "number") {
        collection = values(collection);
      } else if (support.unindexedChars && isString(collection)) {
        collection = collection.split("");
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }
    function shuffle(collection) {
      var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == "number" ? length : keys(collection).length;
    }
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      if (isArray(collection)) {
        var index = -1, length = collection.length;
        while (++index < length) {
          if (result = callback(collection[index], index, collection)) {
            break;
          }
        }
      } else {
        baseEach(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }
    function sortBy(collection, callback, thisArg) {
      var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) {
            return value[key];
          });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });
      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }
    function toArray(collection) {
      if (collection && typeof collection.length == "number") {
        return support.unindexedChars && isString(collection) ? collection.split("") : slice(collection);
      }
      return values(collection);
    }
    var where = filter;
    function compact(array) {
      var index = -1, length = array ? array.length : 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }
    function findIndex(array, callback, thisArg) {
      var index = -1, length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }
    function first(array, callback, thisArg) {
      var n = 0, length = array ? array.length : 0;
      if (typeof callback != "number" && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }
    function flatten(array, isShallow, callback, thisArg) {
      if (typeof isShallow != "boolean" && isShallow != null) {
        thisArg = callback;
        callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == "number") {
        var length = array ? array.length : 0;
        fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }
    function initial(array, callback, thisArg) {
      var n = 0, length = array ? array.length : 0;
      if (typeof callback != "number" && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback == null || thisArg ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }
    function intersection() {
      var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0], index = -1, length = array ? array.length : 0, result = [];
      outer: while (++index < length) {
        var cache = caches[0];
        value = array[index];
        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }
    function last(array, callback, thisArg) {
      var n = 0, length = array ? array.length : 0;
      if (typeof callback != "number" && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == "number") {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function pull(array) {
      var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
      while (++argsIndex < argsLength) {
        var index = -1, value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == "number" ? step : +step || 1;
      if (end == null) {
        end = start;
        start = 0;
      }
      var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }
    function remove(array, callback, thisArg) {
      var index = -1, length = array ? array.length : 0, result = [];
      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }
    function rest(array, callback, thisArg) {
      if (typeof callback != "number" && callback != null) {
        var n = 0, index = -1, length = array ? array.length : 0;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback == null || thisArg ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0, high = array ? array.length : low;
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);
      while (low < high) {
        var mid = low + high >>> 1;
        callback(array[mid]) < value ? low = mid + 1 : high = mid;
      }
      return low;
    }
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }
    function uniq(array, isSorted, callback, thisArg) {
      if (typeof isSorted != "boolean" && isSorted != null) {
        thisArg = callback;
        callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }
    function xor() {
      var index = -1, length = arguments.length;
      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
        }
      }
      return result || [];
    }
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }
    function zipObject(keys, values) {
      var index = -1, length = keys ? keys.length : 0, result = {};
      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError();
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }
    function bind(func, thisArg) {
      return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
    }
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }
    function bindKey(object, key) {
      return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
    }
    function compose() {
      var funcs = arguments, length = funcs.length;
      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError();
        }
      }
      return function() {
        var args = arguments, length = funcs.length;
        while (length--) {
          args = [ funcs[length].apply(this, args) ];
        }
        return args[0];
      };
    }
    function curry(func, arity) {
      arity = typeof arity == "number" ? arity : +arity || func.length;
      return createWrapper(func, 4, null, null, null, arity);
    }
    function debounce(func, wait, options) {
      var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
      if (!isFunction(func)) {
        throw new TypeError();
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = "trailing" in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };
      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || maxWait !== wait) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };
      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);
        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          } else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        } else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError();
      }
      var args = slice(arguments, 1);
      return setTimeout(function() {
        func.apply(undefined, args);
      }, 1);
    }
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError();
      }
      var args = slice(arguments, 2);
      return setTimeout(function() {
        func.apply(undefined, args);
      }, wait);
    }
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError();
      }
      var memoized = function() {
        var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
        return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
      };
      memoized.cache = {};
      return memoized;
    }
    function once(func) {
      var ran, result;
      if (!isFunction(func)) {
        throw new TypeError();
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);
        func = null;
        return result;
      };
    }
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (!isFunction(func)) {
        throw new TypeError();
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = "leading" in options ? options.leading : leading;
        trailing = "trailing" in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;
      return debounce(func, wait, debounceOptions);
    }
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [ value ]);
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == "function") {
        return baseCreateCallback(func, thisArg, argCount);
      }
      if (type != "object") {
        return property(func);
      }
      var props = keys(func), key = props[0], a = func[key];
      if (props.length == 1 && a === a && !isObject(a)) {
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || 1 / a == 1 / b);
        };
      }
      return function(object) {
        var length = props.length, result = false;
        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }
    function escape(string) {
      return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }
    function identity(value) {
      return value;
    }
    function mixin(object, source, options) {
      var chain = true, methodNames = source && functions(source);
      if (!source || !options && !methodNames.length) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && "chain" in options) {
        chain = options.chain;
      }
      var ctor = object, isFunc = isFunction(ctor);
      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }
    function noConflict() {
      context._ = oldDash;
      return this;
    }
    function noop() {}
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };
    var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
    };
    function property(key) {
      return function(object) {
        return object[key];
      };
    }
    function random(min, max, floating) {
      var noMin = min == null, noMax = max == null;
      if (floating == null) {
        if (typeof min == "boolean" && noMax) {
          floating = min;
          min = 1;
        } else if (!noMax && typeof max == "boolean") {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
      }
      return baseRandom(min, max);
    }
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }
    function template(text, data, options) {
      var settings = lodash.templateSettings;
      text = String(text || "");
      options = defaults({}, options, settings);
      var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
      var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
      var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;
        return match;
      });
      source += "';\n";
      var variable = options.variable, hasVariable = variable;
      if (!hasVariable) {
        variable = "obj";
        source = "with (" + variable + ") {\n" + source + "\n}\n";
      }
      source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
      source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
      var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
      try {
        var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
      } catch (e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      result.source = source;
      return result;
    }
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1, result = Array(n);
      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }
    function unescape(string) {
      return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? "" : prefix) + id;
    }
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }
    function wrapperToString() {
      return String(this.__wrapped__);
    }
    function wrapperValueOf() {
      return this.__wrapped__;
    }
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;
    mixin(lodash);
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;
    mixin(function() {
      var source = {};
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;
    lodash.take = first;
    lodash.head = first;
    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== "sample";
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName] = function(n, guard) {
          var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
          return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
        };
      }
    });
    lodash.VERSION = "2.4.1";
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;
    baseEach([ "join", "pop", "shift" ], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
        return chainAll ? new lodashWrapper(result, chainAll) : result;
      };
    });
    baseEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });
    baseEach([ "concat", "slice", "splice" ], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });
    if (!support.spliceObjects) {
      baseEach([ "pop", "shift", "splice" ], function(methodName) {
        var func = arrayRef[methodName], isSplice = methodName == "splice";
        lodash.prototype[methodName] = function() {
          var chainAll = this.__chain__, value = this.__wrapped__, result = func.apply(value, arguments);
          if (value.length === 0) {
            delete value[0];
          }
          return chainAll || isSplice ? new lodashWrapper(result, chainAll) : result;
        };
      });
    }
    return lodash;
  }
  var _ = runInContext();
  if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
    root._ = _;
    define(function() {
      return _;
    });
  } else if (freeExports && freeModule) {
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    } else {
      freeExports._ = _;
    }
  } else {
    root._ = _;
  }
}).call(this);
(function(window, document, undefined) {
  "use strict";
  function minErr(module) {
    return function() {
      var code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1], templateArgs = arguments, stringify = function(obj) {
        if (typeof obj === "function") {
          return obj.toString().replace(/ \{[\s\S]*$/, "");
        } else if (typeof obj === "undefined") {
          return "undefined";
        } else if (typeof obj !== "string") {
          return JSON.stringify(obj);
        }
        return obj;
      }, message, i;
      message = prefix + template.replace(/\{\d+\}/g, function(match) {
        var index = +match.slice(1, -1), arg;
        if (index + 2 < templateArgs.length) {
          arg = templateArgs[index + 2];
          if (typeof arg === "function") {
            return arg.toString().replace(/ ?\{[\s\S]*$/, "");
          } else if (typeof arg === "undefined") {
            return "undefined";
          } else if (typeof arg !== "string") {
            return toJson(arg);
          }
          return arg;
        }
        return match;
      });
      message = message + "\nhttp://errors.angularjs.org/1.2.26/" + (module ? module + "/" : "") + code;
      for (i = 2; i < arguments.length; i++) {
        message = message + (i == 2 ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(stringify(arguments[i]));
      }
      return new Error(message);
    };
  }
  var VALIDITY_STATE_PROPERTY = "validity";
  var lowercase = function(string) {
    return isString(string) ? string.toLowerCase() : string;
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var uppercase = function(string) {
    return isString(string) ? string.toUpperCase() : string;
  };
  var manualLowercase = function(s) {
    return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
      return String.fromCharCode(ch.charCodeAt(0) | 32);
    }) : s;
  };
  var manualUppercase = function(s) {
    return isString(s) ? s.replace(/[a-z]/g, function(ch) {
      return String.fromCharCode(ch.charCodeAt(0) & ~32);
    }) : s;
  };
  if ("i" !== "I".toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
  }
  var msie, jqLite, jQuery, slice = [].slice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), angularModule, nodeName_, uid = [ "0", "0", "0" ];
  msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);
  if (isNaN(msie)) {
    msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);
  }
  function isArrayLike(obj) {
    if (obj == null || isWindow(obj)) {
      return false;
    }
    var length = obj.length;
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return isString(obj) || isArray(obj) || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }
  function forEach(obj, iterator, context) {
    var key;
    if (obj) {
      if (isFunction(obj)) {
        for (key in obj) {
          if (key != "prototype" && key != "length" && key != "name" && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
            iterator.call(context, obj[key], key);
          }
        }
      } else if (isArray(obj) || isArrayLike(obj)) {
        for (key = 0; key < obj.length; key++) {
          iterator.call(context, obj[key], key);
        }
      } else if (obj.forEach && obj.forEach !== forEach) {
        obj.forEach(iterator, context);
      } else {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      }
    }
    return obj;
  }
  function sortedKeys(obj) {
    var keys = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        keys.push(key);
      }
    }
    return keys.sort();
  }
  function forEachSorted(obj, iterator, context) {
    var keys = sortedKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
  }
  function reverseParams(iteratorFn) {
    return function(value, key) {
      iteratorFn(key, value);
    };
  }
  function nextUid() {
    var index = uid.length;
    var digit;
    while (index) {
      index--;
      digit = uid[index].charCodeAt(0);
      if (digit == 57) {
        uid[index] = "A";
        return uid.join("");
      }
      if (digit == 90) {
        uid[index] = "0";
      } else {
        uid[index] = String.fromCharCode(digit + 1);
        return uid.join("");
      }
    }
    uid.unshift("0");
    return uid.join("");
  }
  function setHashKey(obj, h) {
    if (h) {
      obj.$$hashKey = h;
    } else {
      delete obj.$$hashKey;
    }
  }
  function extend(dst) {
    var h = dst.$$hashKey;
    forEach(arguments, function(obj) {
      if (obj !== dst) {
        forEach(obj, function(value, key) {
          dst[key] = value;
        });
      }
    });
    setHashKey(dst, h);
    return dst;
  }
  function int(str) {
    return parseInt(str, 10);
  }
  function inherit(parent, extra) {
    return extend(new (extend(function() {}, {
      prototype: parent
    }))(), extra);
  }
  function noop() {}
  noop.$inject = [];
  function identity($) {
    return $;
  }
  identity.$inject = [];
  function valueFn(value) {
    return function() {
      return value;
    };
  }
  function isUndefined(value) {
    return typeof value === "undefined";
  }
  function isDefined(value) {
    return typeof value !== "undefined";
  }
  function isObject(value) {
    return value != null && typeof value === "object";
  }
  function isString(value) {
    return typeof value === "string";
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  function isDate(value) {
    return toString.call(value) === "[object Date]";
  }
  var isArray = function() {
    if (!isFunction(Array.isArray)) {
      return function(value) {
        return toString.call(value) === "[object Array]";
      };
    }
    return Array.isArray;
  }();
  function isFunction(value) {
    return typeof value === "function";
  }
  function isRegExp(value) {
    return toString.call(value) === "[object RegExp]";
  }
  function isWindow(obj) {
    return obj && obj.document && obj.location && obj.alert && obj.setInterval;
  }
  function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
  }
  function isFile(obj) {
    return toString.call(obj) === "[object File]";
  }
  function isBlob(obj) {
    return toString.call(obj) === "[object Blob]";
  }
  function isBoolean(value) {
    return typeof value === "boolean";
  }
  function isPromiseLike(obj) {
    return obj && isFunction(obj.then);
  }
  var trim = function() {
    if (!String.prototype.trim) {
      return function(value) {
        return isString(value) ? value.replace(/^\s\s*/, "").replace(/\s\s*$/, "") : value;
      };
    }
    return function(value) {
      return isString(value) ? value.trim() : value;
    };
  }();
  function isElement(node) {
    return !!(node && (node.nodeName || node.prop && node.attr && node.find));
  }
  function makeMap(str) {
    var obj = {}, items = str.split(","), i;
    for (i = 0; i < items.length; i++) obj[items[i]] = true;
    return obj;
  }
  if (msie < 9) {
    nodeName_ = function(element) {
      element = element.nodeName ? element : element[0];
      return element.scopeName && element.scopeName != "HTML" ? uppercase(element.scopeName + ":" + element.nodeName) : element.nodeName;
    };
  } else {
    nodeName_ = function(element) {
      return element.nodeName ? element.nodeName : element[0].nodeName;
    };
  }
  function map(obj, iterator, context) {
    var results = [];
    forEach(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  }
  function size(obj, ownPropsOnly) {
    var count = 0, key;
    if (isArray(obj) || isString(obj)) {
      return obj.length;
    } else if (isObject(obj)) {
      for (key in obj) if (!ownPropsOnly || obj.hasOwnProperty(key)) count++;
    }
    return count;
  }
  function includes(array, obj) {
    return indexOf(array, obj) != -1;
  }
  function indexOf(array, obj) {
    if (array.indexOf) return array.indexOf(obj);
    for (var i = 0; i < array.length; i++) {
      if (obj === array[i]) return i;
    }
    return -1;
  }
  function arrayRemove(array, value) {
    var index = indexOf(array, value);
    if (index >= 0) array.splice(index, 1);
    return value;
  }
  function isLeafNode(node) {
    if (node) {
      switch (node.nodeName) {
       case "OPTION":
       case "PRE":
       case "TITLE":
        return true;
      }
    }
    return false;
  }
  function copy(source, destination, stackSource, stackDest) {
    if (isWindow(source) || isScope(source)) {
      throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
    }
    if (!destination) {
      destination = source;
      if (source) {
        if (isArray(source)) {
          destination = copy(source, [], stackSource, stackDest);
        } else if (isDate(source)) {
          destination = new Date(source.getTime());
        } else if (isRegExp(source)) {
          destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
          destination.lastIndex = source.lastIndex;
        } else if (isObject(source)) {
          destination = copy(source, {}, stackSource, stackDest);
        }
      }
    } else {
      if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
      stackSource = stackSource || [];
      stackDest = stackDest || [];
      if (isObject(source)) {
        var index = indexOf(stackSource, source);
        if (index !== -1) return stackDest[index];
        stackSource.push(source);
        stackDest.push(destination);
      }
      var result;
      if (isArray(source)) {
        destination.length = 0;
        for (var i = 0; i < source.length; i++) {
          result = copy(source[i], null, stackSource, stackDest);
          if (isObject(source[i])) {
            stackSource.push(source[i]);
            stackDest.push(result);
          }
          destination.push(result);
        }
      } else {
        var h = destination.$$hashKey;
        if (isArray(destination)) {
          destination.length = 0;
        } else {
          forEach(destination, function(value, key) {
            delete destination[key];
          });
        }
        for (var key in source) {
          result = copy(source[key], null, stackSource, stackDest);
          if (isObject(source[key])) {
            stackSource.push(source[key]);
            stackDest.push(result);
          }
          destination[key] = result;
        }
        setHashKey(destination, h);
      }
    }
    return destination;
  }
  function shallowCopy(src, dst) {
    if (isArray(src)) {
      dst = dst || [];
      for (var i = 0; i < src.length; i++) {
        dst[i] = src[i];
      }
    } else if (isObject(src)) {
      dst = dst || {};
      for (var key in src) {
        if (hasOwnProperty.call(src, key) && !(key.charAt(0) === "$" && key.charAt(1) === "$")) {
          dst[key] = src[key];
        }
      }
    }
    return dst || src;
  }
  function equals(o1, o2) {
    if (o1 === o2) return true;
    if (o1 === null || o2 === null) return false;
    if (o1 !== o1 && o2 !== o2) return true;
    var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
    if (t1 == t2) {
      if (t1 == "object") {
        if (isArray(o1)) {
          if (!isArray(o2)) return false;
          if ((length = o1.length) == o2.length) {
            for (key = 0; key < length; key++) {
              if (!equals(o1[key], o2[key])) return false;
            }
            return true;
          }
        } else if (isDate(o1)) {
          if (!isDate(o2)) return false;
          return isNaN(o1.getTime()) && isNaN(o2.getTime()) || o1.getTime() === o2.getTime();
        } else if (isRegExp(o1) && isRegExp(o2)) {
          return o1.toString() == o2.toString();
        } else {
          if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;
          keySet = {};
          for (key in o1) {
            if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
            if (!equals(o1[key], o2[key])) return false;
            keySet[key] = true;
          }
          for (key in o2) {
            if (!keySet.hasOwnProperty(key) && key.charAt(0) !== "$" && o2[key] !== undefined && !isFunction(o2[key])) return false;
          }
          return true;
        }
      }
    }
    return false;
  }
  var csp = function() {
    if (isDefined(csp.isActive_)) return csp.isActive_;
    var active = !!(document.querySelector("[ng-csp]") || document.querySelector("[data-ng-csp]"));
    if (!active) {
      try {
        new Function("");
      } catch (e) {
        active = true;
      }
    }
    return csp.isActive_ = active;
  };
  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }
  function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
  }
  function bind(self, fn) {
    var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) && !(fn instanceof RegExp)) {
      return curryArgs.length ? function() {
        return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs);
      } : function() {
        return arguments.length ? fn.apply(self, arguments) : fn.call(self);
      };
    } else {
      return fn;
    }
  }
  function toJsonReplacer(key, value) {
    var val = value;
    if (typeof key === "string" && key.charAt(0) === "$") {
      val = undefined;
    } else if (isWindow(value)) {
      val = "$WINDOW";
    } else if (value && document === value) {
      val = "$DOCUMENT";
    } else if (isScope(value)) {
      val = "$SCOPE";
    }
    return val;
  }
  function toJson(obj, pretty) {
    if (typeof obj === "undefined") return undefined;
    return JSON.stringify(obj, toJsonReplacer, pretty ? "  " : null);
  }
  function fromJson(json) {
    return isString(json) ? JSON.parse(json) : json;
  }
  function toBoolean(value) {
    if (typeof value === "function") {
      value = true;
    } else if (value && value.length !== 0) {
      var v = lowercase("" + value);
      value = !(v == "f" || v == "0" || v == "false" || v == "no" || v == "n" || v == "[]");
    } else {
      value = false;
    }
    return value;
  }
  function startingTag(element) {
    element = jqLite(element).clone();
    try {
      element.empty();
    } catch (e) {}
    var TEXT_NODE = 3;
    var elemHtml = jqLite("<div>").append(element).html();
    try {
      return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
        return "<" + lowercase(nodeName);
      });
    } catch (e) {
      return lowercase(elemHtml);
    }
  }
  function tryDecodeURIComponent(value) {
    try {
      return decodeURIComponent(value);
    } catch (e) {}
  }
  function parseKeyValue(keyValue) {
    var obj = {}, key_value, key;
    forEach((keyValue || "").split("&"), function(keyValue) {
      if (keyValue) {
        key_value = keyValue.replace(/\+/g, "%20").split("=");
        key = tryDecodeURIComponent(key_value[0]);
        if (isDefined(key)) {
          var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
          if (!hasOwnProperty.call(obj, key)) {
            obj[key] = val;
          } else if (isArray(obj[key])) {
            obj[key].push(val);
          } else {
            obj[key] = [ obj[key], val ];
          }
        }
      }
    });
    return obj;
  }
  function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function(value, key) {
      if (isArray(value)) {
        forEach(value, function(arrayValue) {
          parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
        });
      } else {
        parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
      }
    });
    return parts.length ? parts.join("&") : "";
  }
  function encodeUriSegment(val) {
    return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
  }
  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
  }
  function angularInit(element, bootstrap) {
    var elements = [ element ], appElement, module, names = [ "ng:app", "ng-app", "x-ng-app", "data-ng-app" ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
    function append(element) {
      element && elements.push(element);
    }
    forEach(names, function(name) {
      names[name] = true;
      append(document.getElementById(name));
      name = name.replace(":", "\\:");
      if (element.querySelectorAll) {
        forEach(element.querySelectorAll("." + name), append);
        forEach(element.querySelectorAll("." + name + "\\:"), append);
        forEach(element.querySelectorAll("[" + name + "]"), append);
      }
    });
    forEach(elements, function(element) {
      if (!appElement) {
        var className = " " + element.className + " ";
        var match = NG_APP_CLASS_REGEXP.exec(className);
        if (match) {
          appElement = element;
          module = (match[2] || "").replace(/\s+/g, ",");
        } else {
          forEach(element.attributes, function(attr) {
            if (!appElement && names[attr.name]) {
              appElement = element;
              module = attr.value;
            }
          });
        }
      }
    });
    if (appElement) {
      bootstrap(appElement, module ? [ module ] : []);
    }
  }
  function bootstrap(element, modules) {
    var doBootstrap = function() {
      element = jqLite(element);
      if (element.injector()) {
        var tag = element[0] === document ? "document" : startingTag(element);
        throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
      }
      modules = modules || [];
      modules.unshift([ "$provide", function($provide) {
        $provide.value("$rootElement", element);
      } ]);
      modules.unshift("ng");
      var injector = createInjector(modules);
      injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", "$animate", function(scope, element, compile, injector, animate) {
        scope.$apply(function() {
          element.data("$injector", injector);
          compile(element)(scope);
        });
      } ]);
      return injector;
    };
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
      return doBootstrap();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
    angular.resumeBootstrap = function(extraModules) {
      forEach(extraModules, function(module) {
        modules.push(module);
      });
      doBootstrap();
    };
  }
  var SNAKE_CASE_REGEXP = /[A-Z]/g;
  function snake_case(name, separator) {
    separator = separator || "_";
    return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
      return (pos ? separator : "") + letter.toLowerCase();
    });
  }
  function bindJQuery() {
    jQuery = window.jQuery;
    if (jQuery && jQuery.fn.on) {
      jqLite = jQuery;
      extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        isolateScope: JQLitePrototype.isolateScope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData
      });
      jqLitePatchJQueryRemove("remove", true, true, false);
      jqLitePatchJQueryRemove("empty", false, false, false);
      jqLitePatchJQueryRemove("html", false, false, true);
    } else {
      jqLite = JQLite;
    }
    angular.element = jqLite;
  }
  function assertArg(arg, name, reason) {
    if (!arg) {
      throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
    }
    return arg;
  }
  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
    }
    assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
    return arg;
  }
  function assertNotHasOwnProperty(name, context) {
    if (name === "hasOwnProperty") {
      throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
    }
  }
  function getter(obj, path, bindFnToScope) {
    if (!path) return obj;
    var keys = path.split(".");
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      if (obj) {
        obj = (lastInstance = obj)[key];
      }
    }
    if (!bindFnToScope && isFunction(obj)) {
      return bind(lastInstance, obj);
    }
    return obj;
  }
  function getBlockElements(nodes) {
    var startNode = nodes[0], endNode = nodes[nodes.length - 1];
    if (startNode === endNode) {
      return jqLite(startNode);
    }
    var element = startNode;
    var elements = [ element ];
    do {
      element = element.nextSibling;
      if (!element) break;
      elements.push(element);
    } while (element !== endNode);
    return jqLite(elements);
  }
  function setupModuleLoader(window) {
    var $injectorMinErr = minErr("$injector");
    var ngMinErr = minErr("ng");
    function ensure(obj, name, factory) {
      return obj[name] || (obj[name] = factory());
    }
    var angular = ensure(window, "angular", Object);
    angular.$$minErr = angular.$$minErr || minErr;
    return ensure(angular, "module", function() {
      var modules = {};
      return function module(name, requires, configFn) {
        var assertNotHasOwnProperty = function(name, context) {
          if (name === "hasOwnProperty") {
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
          }
        };
        assertNotHasOwnProperty(name, "module");
        if (requires && modules.hasOwnProperty(name)) {
          modules[name] = null;
        }
        return ensure(modules, name, function() {
          if (!requires) {
            throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
          }
          var invokeQueue = [];
          var runBlocks = [];
          var config = invokeLater("$injector", "invoke");
          var moduleInstance = {
            _invokeQueue: invokeQueue,
            _runBlocks: runBlocks,
            requires: requires,
            name: name,
            provider: invokeLater("$provide", "provider"),
            factory: invokeLater("$provide", "factory"),
            service: invokeLater("$provide", "service"),
            value: invokeLater("$provide", "value"),
            constant: invokeLater("$provide", "constant", "unshift"),
            animation: invokeLater("$animateProvider", "register"),
            filter: invokeLater("$filterProvider", "register"),
            controller: invokeLater("$controllerProvider", "register"),
            directive: invokeLater("$compileProvider", "directive"),
            config: config,
            run: function(block) {
              runBlocks.push(block);
              return this;
            }
          };
          if (configFn) {
            config(configFn);
          }
          return moduleInstance;
          function invokeLater(provider, method, insertMethod) {
            return function() {
              invokeQueue[insertMethod || "push"]([ provider, method, arguments ]);
              return moduleInstance;
            };
          }
        });
      };
    });
  }
  var version = {
    full: "1.2.26",
    major: 1,
    minor: 2,
    dot: 26,
    codeName: "captivating-disinterest"
  };
  function publishExternalAPI(angular) {
    extend(angular, {
      bootstrap: bootstrap,
      copy: copy,
      extend: extend,
      equals: equals,
      element: jqLite,
      forEach: forEach,
      injector: createInjector,
      noop: noop,
      bind: bind,
      toJson: toJson,
      fromJson: fromJson,
      identity: identity,
      isUndefined: isUndefined,
      isDefined: isDefined,
      isString: isString,
      isFunction: isFunction,
      isObject: isObject,
      isNumber: isNumber,
      isElement: isElement,
      isArray: isArray,
      version: version,
      isDate: isDate,
      lowercase: lowercase,
      uppercase: uppercase,
      callbacks: {
        counter: 0
      },
      $$minErr: minErr,
      $$csp: csp
    });
    angularModule = setupModuleLoader(window);
    try {
      angularModule("ngLocale");
    } catch (e) {
      angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
    }
    angularModule("ng", [ "ngLocale" ], [ "$provide", function ngModule($provide) {
      $provide.provider({
        $$sanitizeUri: $$SanitizeUriProvider
      });
      $provide.provider("$compile", $CompileProvider).directive({
        a: htmlAnchorDirective,
        input: inputDirective,
        textarea: inputDirective,
        form: formDirective,
        script: scriptDirective,
        select: selectDirective,
        style: styleDirective,
        option: optionDirective,
        ngBind: ngBindDirective,
        ngBindHtml: ngBindHtmlDirective,
        ngBindTemplate: ngBindTemplateDirective,
        ngClass: ngClassDirective,
        ngClassEven: ngClassEvenDirective,
        ngClassOdd: ngClassOddDirective,
        ngCloak: ngCloakDirective,
        ngController: ngControllerDirective,
        ngForm: ngFormDirective,
        ngHide: ngHideDirective,
        ngIf: ngIfDirective,
        ngInclude: ngIncludeDirective,
        ngInit: ngInitDirective,
        ngNonBindable: ngNonBindableDirective,
        ngPluralize: ngPluralizeDirective,
        ngRepeat: ngRepeatDirective,
        ngShow: ngShowDirective,
        ngStyle: ngStyleDirective,
        ngSwitch: ngSwitchDirective,
        ngSwitchWhen: ngSwitchWhenDirective,
        ngSwitchDefault: ngSwitchDefaultDirective,
        ngOptions: ngOptionsDirective,
        ngTransclude: ngTranscludeDirective,
        ngModel: ngModelDirective,
        ngList: ngListDirective,
        ngChange: ngChangeDirective,
        required: requiredDirective,
        ngRequired: requiredDirective,
        ngValue: ngValueDirective
      }).directive({
        ngInclude: ngIncludeFillContentDirective
      }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
      $provide.provider({
        $anchorScroll: $AnchorScrollProvider,
        $animate: $AnimateProvider,
        $browser: $BrowserProvider,
        $cacheFactory: $CacheFactoryProvider,
        $controller: $ControllerProvider,
        $document: $DocumentProvider,
        $exceptionHandler: $ExceptionHandlerProvider,
        $filter: $FilterProvider,
        $interpolate: $InterpolateProvider,
        $interval: $IntervalProvider,
        $http: $HttpProvider,
        $httpBackend: $HttpBackendProvider,
        $location: $LocationProvider,
        $log: $LogProvider,
        $parse: $ParseProvider,
        $rootScope: $RootScopeProvider,
        $q: $QProvider,
        $sce: $SceProvider,
        $sceDelegate: $SceDelegateProvider,
        $sniffer: $SnifferProvider,
        $templateCache: $TemplateCacheProvider,
        $timeout: $TimeoutProvider,
        $window: $WindowProvider,
        $$rAF: $$RAFProvider,
        $$asyncCallback: $$AsyncCallbackProvider
      });
    } ]);
  }
  JQLite.expando = "ng339";
  var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = window.document.addEventListener ? function(element, type, fn) {
    element.addEventListener(type, fn, false);
  } : function(element, type, fn) {
    element.attachEvent("on" + type, fn);
  }, removeEventListenerFn = window.document.removeEventListener ? function(element, type, fn) {
    element.removeEventListener(type, fn, false);
  } : function(element, type, fn) {
    element.detachEvent("on" + type, fn);
  };
  var jqData = JQLite._data = function(node) {
    return this.cache[node[this.expando]] || {};
  };
  function jqNextId() {
    return ++jqId;
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  var jqLiteMinErr = minErr("jqLite");
  function camelCase(name) {
    return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).replace(MOZ_HACK_REGEXP, "Moz$1");
  }
  function jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
    var originalJqFn = jQuery.fn[name];
    originalJqFn = originalJqFn.$original || originalJqFn;
    removePatch.$original = originalJqFn;
    jQuery.fn[name] = removePatch;
    function removePatch(param) {
      var list = filterElems && param ? [ this.filter(param) ] : [ this ], fireEvent = dispatchThis, set, setIndex, setLength, element, childIndex, childLength, children;
      if (!getterIfNoArguments || param != null) {
        while (list.length) {
          set = list.shift();
          for (setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
            element = jqLite(set[setIndex]);
            if (fireEvent) {
              element.triggerHandler("$destroy");
            } else {
              fireEvent = !fireEvent;
            }
            for (childIndex = 0, childLength = (children = element.children()).length; childIndex < childLength; childIndex++) {
              list.push(jQuery(children[childIndex]));
            }
          }
        }
      }
      return originalJqFn.apply(this, arguments);
    }
  }
  var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
  var HTML_REGEXP = /<|&#?\w+;/;
  var TAG_NAME_REGEXP = /<([\w:]+)/;
  var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
  var wrapMap = {
    option: [ 1, '<select multiple="multiple">', "</select>" ],
    thead: [ 1, "<table>", "</table>" ],
    col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
    tr: [ 2, "<table><tbody>", "</tbody></table>" ],
    td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
    _default: [ 0, "", "" ]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function jqLiteIsTextNode(html) {
    return !HTML_REGEXP.test(html);
  }
  function jqLiteBuildFragment(html, context) {
    var elem, tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i, j, jj;
    if (jqLiteIsTextNode(html)) {
      nodes.push(context.createTextNode(html));
    } else {
      tmp = fragment.appendChild(context.createElement("div"));
      tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase();
      wrap = wrapMap[tag] || wrapMap._default;
      tmp.innerHTML = "<div>&#160;</div>" + wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
      tmp.removeChild(tmp.firstChild);
      i = wrap[0];
      while (i--) {
        tmp = tmp.lastChild;
      }
      for (j = 0, jj = tmp.childNodes.length; j < jj; ++j) nodes.push(tmp.childNodes[j]);
      tmp = fragment.firstChild;
      tmp.textContent = "";
    }
    fragment.textContent = "";
    fragment.innerHTML = "";
    return nodes;
  }
  function jqLiteParseHTML(html, context) {
    context = context || document;
    var parsed;
    if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
      return [ context.createElement(parsed[1]) ];
    }
    return jqLiteBuildFragment(html, context);
  }
  function JQLite(element) {
    if (element instanceof JQLite) {
      return element;
    }
    if (isString(element)) {
      element = trim(element);
    }
    if (!(this instanceof JQLite)) {
      if (isString(element) && element.charAt(0) != "<") {
        throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
      }
      return new JQLite(element);
    }
    if (isString(element)) {
      jqLiteAddNodes(this, jqLiteParseHTML(element));
      var fragment = jqLite(document.createDocumentFragment());
      fragment.append(this);
    } else {
      jqLiteAddNodes(this, element);
    }
  }
  function jqLiteClone(element) {
    return element.cloneNode(true);
  }
  function jqLiteDealoc(element) {
    jqLiteRemoveData(element);
    for (var i = 0, children = element.childNodes || []; i < children.length; i++) {
      jqLiteDealoc(children[i]);
    }
  }
  function jqLiteOff(element, type, fn, unsupported) {
    if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
    var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle");
    if (!handle) return;
    if (isUndefined(type)) {
      forEach(events, function(eventHandler, type) {
        removeEventListenerFn(element, type, eventHandler);
        delete events[type];
      });
    } else {
      forEach(type.split(" "), function(type) {
        if (isUndefined(fn)) {
          removeEventListenerFn(element, type, events[type]);
          delete events[type];
        } else {
          arrayRemove(events[type] || [], fn);
        }
      });
    }
  }
  function jqLiteRemoveData(element, name) {
    var expandoId = element.ng339, expandoStore = jqCache[expandoId];
    if (expandoStore) {
      if (name) {
        delete jqCache[expandoId].data[name];
        return;
      }
      if (expandoStore.handle) {
        expandoStore.events.$destroy && expandoStore.handle({}, "$destroy");
        jqLiteOff(element);
      }
      delete jqCache[expandoId];
      element.ng339 = undefined;
    }
  }
  function jqLiteExpandoStore(element, key, value) {
    var expandoId = element.ng339, expandoStore = jqCache[expandoId || -1];
    if (isDefined(value)) {
      if (!expandoStore) {
        element.ng339 = expandoId = jqNextId();
        expandoStore = jqCache[expandoId] = {};
      }
      expandoStore[key] = value;
    } else {
      return expandoStore && expandoStore[key];
    }
  }
  function jqLiteData(element, key, value) {
    var data = jqLiteExpandoStore(element, "data"), isSetter = isDefined(value), keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key);
    if (!data && !isSimpleGetter) {
      jqLiteExpandoStore(element, "data", data = {});
    }
    if (isSetter) {
      data[key] = value;
    } else {
      if (keyDefined) {
        if (isSimpleGetter) {
          return data && data[key];
        } else {
          extend(data, key);
        }
      } else {
        return data;
      }
    }
  }
  function jqLiteHasClass(element, selector) {
    if (!element.getAttribute) return false;
    return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
  }
  function jqLiteRemoveClass(element, cssClasses) {
    if (cssClasses && element.setAttribute) {
      forEach(cssClasses.split(" "), function(cssClass) {
        element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
      });
    }
  }
  function jqLiteAddClass(element, cssClasses) {
    if (cssClasses && element.setAttribute) {
      var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
      forEach(cssClasses.split(" "), function(cssClass) {
        cssClass = trim(cssClass);
        if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
          existingClasses += cssClass + " ";
        }
      });
      element.setAttribute("class", trim(existingClasses));
    }
  }
  function jqLiteAddNodes(root, elements) {
    if (elements) {
      elements = !elements.nodeName && isDefined(elements.length) && !isWindow(elements) ? elements : [ elements ];
      for (var i = 0; i < elements.length; i++) {
        root.push(elements[i]);
      }
    }
  }
  function jqLiteController(element, name) {
    return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
  }
  function jqLiteInheritedData(element, name, value) {
    if (element.nodeType == 9) {
      element = element.documentElement;
    }
    var names = isArray(name) ? name : [ name ];
    while (element) {
      for (var i = 0, ii = names.length; i < ii; i++) {
        if ((value = jqLite.data(element, names[i])) !== undefined) return value;
      }
      element = element.parentNode || element.nodeType === 11 && element.host;
    }
  }
  function jqLiteEmpty(element) {
    for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
      jqLiteDealoc(childNodes[i]);
    }
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
  }
  var JQLitePrototype = JQLite.prototype = {
    ready: function(fn) {
      var fired = false;
      function trigger() {
        if (fired) return;
        fired = true;
        fn();
      }
      if (document.readyState === "complete") {
        setTimeout(trigger);
      } else {
        this.on("DOMContentLoaded", trigger);
        JQLite(window).on("load", trigger);
      }
    },
    toString: function() {
      var value = [];
      forEach(this, function(e) {
        value.push("" + e);
      });
      return "[" + value.join(", ") + "]";
    },
    eq: function(index) {
      return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
    },
    length: 0,
    push: push,
    sort: [].sort,
    splice: [].splice
  };
  var BOOLEAN_ATTR = {};
  forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
    BOOLEAN_ATTR[lowercase(value)] = value;
  });
  var BOOLEAN_ELEMENTS = {};
  forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
    BOOLEAN_ELEMENTS[uppercase(value)] = true;
  });
  function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
  }
  forEach({
    data: jqLiteData,
    removeData: jqLiteRemoveData
  }, function(fn, name) {
    JQLite[name] = fn;
  });
  forEach({
    data: jqLiteData,
    inheritedData: jqLiteInheritedData,
    scope: function(element) {
      return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
    },
    isolateScope: function(element) {
      return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
    },
    controller: jqLiteController,
    injector: function(element) {
      return jqLiteInheritedData(element, "$injector");
    },
    removeAttr: function(element, name) {
      element.removeAttribute(name);
    },
    hasClass: jqLiteHasClass,
    css: function(element, name, value) {
      name = camelCase(name);
      if (isDefined(value)) {
        element.style[name] = value;
      } else {
        var val;
        if (msie <= 8) {
          val = element.currentStyle && element.currentStyle[name];
          if (val === "") val = "auto";
        }
        val = val || element.style[name];
        if (msie <= 8) {
          val = val === "" ? undefined : val;
        }
        return val;
      }
    },
    attr: function(element, name, value) {
      var lowercasedName = lowercase(name);
      if (BOOLEAN_ATTR[lowercasedName]) {
        if (isDefined(value)) {
          if (!!value) {
            element[name] = true;
            element.setAttribute(name, lowercasedName);
          } else {
            element[name] = false;
            element.removeAttribute(lowercasedName);
          }
        } else {
          return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
        }
      } else if (isDefined(value)) {
        element.setAttribute(name, value);
      } else if (element.getAttribute) {
        var ret = element.getAttribute(name, 2);
        return ret === null ? undefined : ret;
      }
    },
    prop: function(element, name, value) {
      if (isDefined(value)) {
        element[name] = value;
      } else {
        return element[name];
      }
    },
    text: function() {
      var NODE_TYPE_TEXT_PROPERTY = [];
      if (msie < 9) {
        NODE_TYPE_TEXT_PROPERTY[1] = "innerText";
        NODE_TYPE_TEXT_PROPERTY[3] = "nodeValue";
      } else {
        NODE_TYPE_TEXT_PROPERTY[1] = NODE_TYPE_TEXT_PROPERTY[3] = "textContent";
      }
      getText.$dv = "";
      return getText;
      function getText(element, value) {
        var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType];
        if (isUndefined(value)) {
          return textProp ? element[textProp] : "";
        }
        element[textProp] = value;
      }
    }(),
    val: function(element, value) {
      if (isUndefined(value)) {
        if (nodeName_(element) === "SELECT" && element.multiple) {
          var result = [];
          forEach(element.options, function(option) {
            if (option.selected) {
              result.push(option.value || option.text);
            }
          });
          return result.length === 0 ? null : result;
        }
        return element.value;
      }
      element.value = value;
    },
    html: function(element, value) {
      if (isUndefined(value)) {
        return element.innerHTML;
      }
      for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
        jqLiteDealoc(childNodes[i]);
      }
      element.innerHTML = value;
    },
    empty: jqLiteEmpty
  }, function(fn, name) {
    JQLite.prototype[name] = function(arg1, arg2) {
      var i, key;
      var nodeCount = this.length;
      if (fn !== jqLiteEmpty && (fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2) === undefined) {
        if (isObject(arg1)) {
          for (i = 0; i < nodeCount; i++) {
            if (fn === jqLiteData) {
              fn(this[i], arg1);
            } else {
              for (key in arg1) {
                fn(this[i], key, arg1[key]);
              }
            }
          }
          return this;
        } else {
          var value = fn.$dv;
          var jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount;
          for (var j = 0; j < jj; j++) {
            var nodeValue = fn(this[j], arg1, arg2);
            value = value ? value + nodeValue : nodeValue;
          }
          return value;
        }
      } else {
        for (i = 0; i < nodeCount; i++) {
          fn(this[i], arg1, arg2);
        }
        return this;
      }
    };
  });
  function createEventHandler(element, events) {
    var eventHandler = function(event, type) {
      if (!event.preventDefault) {
        event.preventDefault = function() {
          event.returnValue = false;
        };
      }
      if (!event.stopPropagation) {
        event.stopPropagation = function() {
          event.cancelBubble = true;
        };
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (isUndefined(event.defaultPrevented)) {
        var prevent = event.preventDefault;
        event.preventDefault = function() {
          event.defaultPrevented = true;
          prevent.call(event);
        };
        event.defaultPrevented = false;
      }
      event.isDefaultPrevented = function() {
        return event.defaultPrevented || event.returnValue === false;
      };
      var eventHandlersCopy = shallowCopy(events[type || event.type] || []);
      forEach(eventHandlersCopy, function(fn) {
        fn.call(element, event);
      });
      if (msie <= 8) {
        event.preventDefault = null;
        event.stopPropagation = null;
        event.isDefaultPrevented = null;
      } else {
        delete event.preventDefault;
        delete event.stopPropagation;
        delete event.isDefaultPrevented;
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  }
  forEach({
    removeData: jqLiteRemoveData,
    dealoc: jqLiteDealoc,
    on: function onFn(element, type, fn, unsupported) {
      if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
      var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle");
      if (!events) jqLiteExpandoStore(element, "events", events = {});
      if (!handle) jqLiteExpandoStore(element, "handle", handle = createEventHandler(element, events));
      forEach(type.split(" "), function(type) {
        var eventFns = events[type];
        if (!eventFns) {
          if (type == "mouseenter" || type == "mouseleave") {
            var contains = document.body.contains || document.body.compareDocumentPosition ? function(a, b) {
              var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
              return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
              if (b) {
                while (b = b.parentNode) {
                  if (b === a) {
                    return true;
                  }
                }
              }
              return false;
            };
            events[type] = [];
            var eventmap = {
              mouseleave: "mouseout",
              mouseenter: "mouseover"
            };
            onFn(element, eventmap[type], function(event) {
              var target = this, related = event.relatedTarget;
              if (!related || related !== target && !contains(target, related)) {
                handle(event, type);
              }
            });
          } else {
            addEventListenerFn(element, type, handle);
            events[type] = [];
          }
          eventFns = events[type];
        }
        eventFns.push(fn);
      });
    },
    off: jqLiteOff,
    one: function(element, type, fn) {
      element = jqLite(element);
      element.on(type, function onFn() {
        element.off(type, fn);
        element.off(type, onFn);
      });
      element.on(type, fn);
    },
    replaceWith: function(element, replaceNode) {
      var index, parent = element.parentNode;
      jqLiteDealoc(element);
      forEach(new JQLite(replaceNode), function(node) {
        if (index) {
          parent.insertBefore(node, index.nextSibling);
        } else {
          parent.replaceChild(node, element);
        }
        index = node;
      });
    },
    children: function(element) {
      var children = [];
      forEach(element.childNodes, function(element) {
        if (element.nodeType === 1) children.push(element);
      });
      return children;
    },
    contents: function(element) {
      return element.contentDocument || element.childNodes || [];
    },
    append: function(element, node) {
      forEach(new JQLite(node), function(child) {
        if (element.nodeType === 1 || element.nodeType === 11) {
          element.appendChild(child);
        }
      });
    },
    prepend: function(element, node) {
      if (element.nodeType === 1) {
        var index = element.firstChild;
        forEach(new JQLite(node), function(child) {
          element.insertBefore(child, index);
        });
      }
    },
    wrap: function(element, wrapNode) {
      wrapNode = jqLite(wrapNode)[0];
      var parent = element.parentNode;
      if (parent) {
        parent.replaceChild(wrapNode, element);
      }
      wrapNode.appendChild(element);
    },
    remove: function(element) {
      jqLiteDealoc(element);
      var parent = element.parentNode;
      if (parent) parent.removeChild(element);
    },
    after: function(element, newElement) {
      var index = element, parent = element.parentNode;
      forEach(new JQLite(newElement), function(node) {
        parent.insertBefore(node, index.nextSibling);
        index = node;
      });
    },
    addClass: jqLiteAddClass,
    removeClass: jqLiteRemoveClass,
    toggleClass: function(element, selector, condition) {
      if (selector) {
        forEach(selector.split(" "), function(className) {
          var classCondition = condition;
          if (isUndefined(classCondition)) {
            classCondition = !jqLiteHasClass(element, className);
          }
          (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
        });
      }
    },
    parent: function(element) {
      var parent = element.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    next: function(element) {
      if (element.nextElementSibling) {
        return element.nextElementSibling;
      }
      var elm = element.nextSibling;
      while (elm != null && elm.nodeType !== 1) {
        elm = elm.nextSibling;
      }
      return elm;
    },
    find: function(element, selector) {
      if (element.getElementsByTagName) {
        return element.getElementsByTagName(selector);
      } else {
        return [];
      }
    },
    clone: jqLiteClone,
    triggerHandler: function(element, event, extraParameters) {
      var dummyEvent, eventFnsCopy, handlerArgs;
      var eventName = event.type || event;
      var eventFns = (jqLiteExpandoStore(element, "events") || {})[eventName];
      if (eventFns) {
        dummyEvent = {
          preventDefault: function() {
            this.defaultPrevented = true;
          },
          isDefaultPrevented: function() {
            return this.defaultPrevented === true;
          },
          stopPropagation: noop,
          type: eventName,
          target: element
        };
        if (event.type) {
          dummyEvent = extend(dummyEvent, event);
        }
        eventFnsCopy = shallowCopy(eventFns);
        handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ];
        forEach(eventFnsCopy, function(fn) {
          fn.apply(element, handlerArgs);
        });
      }
    }
  }, function(fn, name) {
    JQLite.prototype[name] = function(arg1, arg2, arg3) {
      var value;
      for (var i = 0; i < this.length; i++) {
        if (isUndefined(value)) {
          value = fn(this[i], arg1, arg2, arg3);
          if (isDefined(value)) {
            value = jqLite(value);
          }
        } else {
          jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
        }
      }
      return isDefined(value) ? value : this;
    };
    JQLite.prototype.bind = JQLite.prototype.on;
    JQLite.prototype.unbind = JQLite.prototype.off;
  });
  function hashKey(obj, nextUidFn) {
    var objType = typeof obj, key;
    if (objType == "function" || objType == "object" && obj !== null) {
      if (typeof (key = obj.$$hashKey) == "function") {
        key = obj.$$hashKey();
      } else if (key === undefined) {
        key = obj.$$hashKey = (nextUidFn || nextUid)();
      }
    } else {
      key = obj;
    }
    return objType + ":" + key;
  }
  function HashMap(array, isolatedUid) {
    if (isolatedUid) {
      var uid = 0;
      this.nextUid = function() {
        return ++uid;
      };
    }
    forEach(array, this.put, this);
  }
  HashMap.prototype = {
    put: function(key, value) {
      this[hashKey(key, this.nextUid)] = value;
    },
    get: function(key) {
      return this[hashKey(key, this.nextUid)];
    },
    remove: function(key) {
      var value = this[key = hashKey(key, this.nextUid)];
      delete this[key];
      return value;
    }
  };
  var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
  var FN_ARG_SPLIT = /,/;
  var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
  var $injectorMinErr = minErr("$injector");
  function annotate(fn) {
    var $inject, fnText, argDecl, last;
    if (typeof fn === "function") {
      if (!($inject = fn.$inject)) {
        $inject = [];
        if (fn.length) {
          fnText = fn.toString().replace(STRIP_COMMENTS, "");
          argDecl = fnText.match(FN_ARGS);
          forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
            arg.replace(FN_ARG, function(all, underscore, name) {
              $inject.push(name);
            });
          });
        }
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = fn.length - 1;
      assertArgFn(fn[last], "fn");
      $inject = fn.slice(0, last);
    } else {
      assertArgFn(fn, "fn", true);
    }
    return $inject;
  }
  function createInjector(modulesToLoad) {
    var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], true), providerCache = {
      $provide: {
        provider: supportObject(provider),
        factory: supportObject(factory),
        service: supportObject(service),
        value: supportObject(value),
        constant: supportObject(constant),
        decorator: decorator
      }
    }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function() {
      throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
    }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(servicename) {
      var provider = providerInjector.get(servicename + providerSuffix);
      return instanceInjector.invoke(provider.$get, provider);
    });
    forEach(loadModules(modulesToLoad), function(fn) {
      instanceInjector.invoke(fn || noop);
    });
    return instanceInjector;
    function supportObject(delegate) {
      return function(key, value) {
        if (isObject(key)) {
          forEach(key, reverseParams(delegate));
        } else {
          return delegate(key, value);
        }
      };
    }
    function provider(name, provider_) {
      assertNotHasOwnProperty(name, "service");
      if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
      }
      if (!provider_.$get) {
        throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
      }
      return providerCache[name + providerSuffix] = provider_;
    }
    function factory(name, factoryFn) {
      return provider(name, {
        $get: factoryFn
      });
    }
    function service(name, constructor) {
      return factory(name, [ "$injector", function($injector) {
        return $injector.instantiate(constructor);
      } ]);
    }
    function value(name, val) {
      return factory(name, valueFn(val));
    }
    function constant(name, value) {
      assertNotHasOwnProperty(name, "constant");
      providerCache[name] = value;
      instanceCache[name] = value;
    }
    function decorator(serviceName, decorFn) {
      var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
      origProvider.$get = function() {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, {
          $delegate: origInstance
        });
      };
    }
    function loadModules(modulesToLoad) {
      var runBlocks = [], moduleFn, invokeQueue, i, ii;
      forEach(modulesToLoad, function(module) {
        if (loadedModules.get(module)) return;
        loadedModules.put(module, true);
        try {
          if (isString(module)) {
            moduleFn = angularModule(module);
            runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
            for (invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
              var invokeArgs = invokeQueue[i], provider = providerInjector.get(invokeArgs[0]);
              provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            }
          } else if (isFunction(module)) {
            runBlocks.push(providerInjector.invoke(module));
          } else if (isArray(module)) {
            runBlocks.push(providerInjector.invoke(module));
          } else {
            assertArgFn(module, "module");
          }
        } catch (e) {
          if (isArray(module)) {
            module = module[module.length - 1];
          }
          if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
            e = e.message + "\n" + e.stack;
          }
          throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
        }
      });
      return runBlocks;
    }
    function createInternalInjector(cache, factory) {
      function getService(serviceName) {
        if (cache.hasOwnProperty(serviceName)) {
          if (cache[serviceName] === INSTANTIATING) {
            throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
          }
          return cache[serviceName];
        } else {
          try {
            path.unshift(serviceName);
            cache[serviceName] = INSTANTIATING;
            return cache[serviceName] = factory(serviceName);
          } catch (err) {
            if (cache[serviceName] === INSTANTIATING) {
              delete cache[serviceName];
            }
            throw err;
          } finally {
            path.shift();
          }
        }
      }
      function invoke(fn, self, locals) {
        var args = [], $inject = annotate(fn), length, i, key;
        for (i = 0, length = $inject.length; i < length; i++) {
          key = $inject[i];
          if (typeof key !== "string") {
            throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
          }
          args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key));
        }
        if (isArray(fn)) {
          fn = fn[length];
        }
        return fn.apply(self, args);
      }
      function instantiate(Type, locals) {
        var Constructor = function() {}, instance, returnedValue;
        Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
        instance = new Constructor();
        returnedValue = invoke(Type, instance, locals);
        return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
      }
      return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: annotate,
        has: function(name) {
          return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
        }
      };
    }
  }
  function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function() {
      autoScrollingEnabled = false;
    };
    this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
      var document = $window.document;
      function getFirstAnchor(list) {
        var result = null;
        forEach(list, function(element) {
          if (!result && lowercase(element.nodeName) === "a") result = element;
        });
        return result;
      }
      function scroll() {
        var hash = $location.hash(), elm;
        if (!hash) $window.scrollTo(0, 0); else if (elm = document.getElementById(hash)) elm.scrollIntoView(); else if (elm = getFirstAnchor(document.getElementsByName(hash))) elm.scrollIntoView(); else if (hash === "top") $window.scrollTo(0, 0);
      }
      if (autoScrollingEnabled) {
        $rootScope.$watch(function autoScrollWatch() {
          return $location.hash();
        }, function autoScrollWatchAction() {
          $rootScope.$evalAsync(scroll);
        });
      }
      return scroll;
    } ];
  }
  var $animateMinErr = minErr("$animate");
  var $AnimateProvider = [ "$provide", function($provide) {
    this.$$selectors = {};
    this.register = function(name, factory) {
      var key = name + "-animation";
      if (name && name.charAt(0) != ".") throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
      this.$$selectors[name.substr(1)] = key;
      $provide.factory(key, factory);
    };
    this.classNameFilter = function(expression) {
      if (arguments.length === 1) {
        this.$$classNameFilter = expression instanceof RegExp ? expression : null;
      }
      return this.$$classNameFilter;
    };
    this.$get = [ "$timeout", "$$asyncCallback", function($timeout, $$asyncCallback) {
      function async(fn) {
        fn && $$asyncCallback(fn);
      }
      return {
        enter: function(element, parent, after, done) {
          if (after) {
            after.after(element);
          } else {
            if (!parent || !parent[0]) {
              parent = after.parent();
            }
            parent.append(element);
          }
          async(done);
        },
        leave: function(element, done) {
          element.remove();
          async(done);
        },
        move: function(element, parent, after, done) {
          this.enter(element, parent, after, done);
        },
        addClass: function(element, className, done) {
          className = isString(className) ? className : isArray(className) ? className.join(" ") : "";
          forEach(element, function(element) {
            jqLiteAddClass(element, className);
          });
          async(done);
        },
        removeClass: function(element, className, done) {
          className = isString(className) ? className : isArray(className) ? className.join(" ") : "";
          forEach(element, function(element) {
            jqLiteRemoveClass(element, className);
          });
          async(done);
        },
        setClass: function(element, add, remove, done) {
          forEach(element, function(element) {
            jqLiteAddClass(element, add);
            jqLiteRemoveClass(element, remove);
          });
          async(done);
        },
        enabled: noop
      };
    } ];
  } ];
  function $$AsyncCallbackProvider() {
    this.$get = [ "$$rAF", "$timeout", function($$rAF, $timeout) {
      return $$rAF.supported ? function(fn) {
        return $$rAF(fn);
      } : function(fn) {
        return $timeout(fn, 0, false);
      };
    } ];
  }
  function Browser(window, document, $log, $sniffer) {
    var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function() {
      outstandingRequestCount++;
    };
    function completeOutstandingRequest(fn) {
      try {
        fn.apply(null, sliceArgs(arguments, 1));
      } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
          while (outstandingRequestCallbacks.length) {
            try {
              outstandingRequestCallbacks.pop()();
            } catch (e) {
              $log.error(e);
            }
          }
        }
      }
    }
    self.notifyWhenNoOutstandingRequests = function(callback) {
      forEach(pollFns, function(pollFn) {
        pollFn();
      });
      if (outstandingRequestCount === 0) {
        callback();
      } else {
        outstandingRequestCallbacks.push(callback);
      }
    };
    var pollFns = [], pollTimeout;
    self.addPollFn = function(fn) {
      if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
      pollFns.push(fn);
      return fn;
    };
    function startPoller(interval, setTimeout) {
      (function check() {
        forEach(pollFns, function(pollFn) {
          pollFn();
        });
        pollTimeout = setTimeout(check, interval);
      })();
    }
    var lastBrowserUrl = location.href, baseElement = document.find("base"), newLocation = null;
    self.url = function(url, replace) {
      if (location !== window.location) location = window.location;
      if (history !== window.history) history = window.history;
      if (url) {
        if (lastBrowserUrl == url) return;
        lastBrowserUrl = url;
        if ($sniffer.history) {
          if (replace) history.replaceState(null, "", url); else {
            history.pushState(null, "", url);
            baseElement.attr("href", baseElement.attr("href"));
          }
        } else {
          newLocation = url;
          if (replace) {
            location.replace(url);
          } else {
            location.href = url;
          }
        }
        return self;
      } else {
        return newLocation || location.href.replace(/%27/g, "'");
      }
    };
    var urlChangeListeners = [], urlChangeInit = false;
    function fireUrlChange() {
      newLocation = null;
      if (lastBrowserUrl == self.url()) return;
      lastBrowserUrl = self.url();
      forEach(urlChangeListeners, function(listener) {
        listener(self.url());
      });
    }
    self.onUrlChange = function(callback) {
      if (!urlChangeInit) {
        if ($sniffer.history) jqLite(window).on("popstate", fireUrlChange);
        if ($sniffer.hashchange) jqLite(window).on("hashchange", fireUrlChange); else self.addPollFn(fireUrlChange);
        urlChangeInit = true;
      }
      urlChangeListeners.push(callback);
      return callback;
    };
    self.$$checkUrlChange = fireUrlChange;
    self.baseHref = function() {
      var href = baseElement.attr("href");
      return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
    };
    var lastCookies = {};
    var lastCookieString = "";
    var cookiePath = self.baseHref();
    self.cookies = function(name, value) {
      var cookieLength, cookieArray, cookie, i, index;
      if (name) {
        if (value === undefined) {
          rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT";
        } else {
          if (isString(value)) {
            cookieLength = (rawDocument.cookie = escape(name) + "=" + escape(value) + ";path=" + cookiePath).length + 1;
            if (cookieLength > 4096) {
              $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
            }
          }
        }
      } else {
        if (rawDocument.cookie !== lastCookieString) {
          lastCookieString = rawDocument.cookie;
          cookieArray = lastCookieString.split("; ");
          lastCookies = {};
          for (i = 0; i < cookieArray.length; i++) {
            cookie = cookieArray[i];
            index = cookie.indexOf("=");
            if (index > 0) {
              name = unescape(cookie.substring(0, index));
              if (lastCookies[name] === undefined) {
                lastCookies[name] = unescape(cookie.substring(index + 1));
              }
            }
          }
        }
        return lastCookies;
      }
    };
    self.defer = function(fn, delay) {
      var timeoutId;
      outstandingRequestCount++;
      timeoutId = setTimeout(function() {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
      }, delay || 0);
      pendingDeferIds[timeoutId] = true;
      return timeoutId;
    };
    self.defer.cancel = function(deferId) {
      if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
      }
      return false;
    };
  }
  function $BrowserProvider() {
    this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
      return new Browser($window, $document, $log, $sniffer);
    } ];
  }
  function $CacheFactoryProvider() {
    this.$get = function() {
      var caches = {};
      function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
          throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
        }
        var size = 0, stats = extend({}, options, {
          id: cacheId
        }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
        return caches[cacheId] = {
          put: function(key, value) {
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key] || (lruHash[key] = {
                key: key
              });
              refresh(lruEntry);
            }
            if (isUndefined(value)) return;
            if (!(key in data)) size++;
            data[key] = value;
            if (size > capacity) {
              this.remove(staleEnd.key);
            }
            return value;
          },
          get: function(key) {
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key];
              if (!lruEntry) return;
              refresh(lruEntry);
            }
            return data[key];
          },
          remove: function(key) {
            if (capacity < Number.MAX_VALUE) {
              var lruEntry = lruHash[key];
              if (!lruEntry) return;
              if (lruEntry == freshEnd) freshEnd = lruEntry.p;
              if (lruEntry == staleEnd) staleEnd = lruEntry.n;
              link(lruEntry.n, lruEntry.p);
              delete lruHash[key];
            }
            delete data[key];
            size--;
          },
          removeAll: function() {
            data = {};
            size = 0;
            lruHash = {};
            freshEnd = staleEnd = null;
          },
          destroy: function() {
            data = null;
            stats = null;
            lruHash = null;
            delete caches[cacheId];
          },
          info: function() {
            return extend({}, stats, {
              size: size
            });
          }
        };
        function refresh(entry) {
          if (entry != freshEnd) {
            if (!staleEnd) {
              staleEnd = entry;
            } else if (staleEnd == entry) {
              staleEnd = entry.n;
            }
            link(entry.n, entry.p);
            link(entry, freshEnd);
            freshEnd = entry;
            freshEnd.n = null;
          }
        }
        function link(nextEntry, prevEntry) {
          if (nextEntry != prevEntry) {
            if (nextEntry) nextEntry.p = prevEntry;
            if (prevEntry) prevEntry.n = nextEntry;
          }
        }
      }
      cacheFactory.info = function() {
        var info = {};
        forEach(caches, function(cache, cacheId) {
          info[cacheId] = cache.info();
        });
        return info;
      };
      cacheFactory.get = function(cacheId) {
        return caches[cacheId];
      };
      return cacheFactory;
    };
  }
  function $TemplateCacheProvider() {
    this.$get = [ "$cacheFactory", function($cacheFactory) {
      return $cacheFactory("templates");
    } ];
  }
  var $compileMinErr = minErr("$compile");
  $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
  function $CompileProvider($provide, $$sanitizeUriProvider) {
    var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w_\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\d\w_\-]+)(?:\:([^;]+))?;?)/;
    var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
    this.directive = function registerDirective(name, directiveFactory) {
      assertNotHasOwnProperty(name, "directive");
      if (isString(name)) {
        assertArg(directiveFactory, "directiveFactory");
        if (!hasDirectives.hasOwnProperty(name)) {
          hasDirectives[name] = [];
          $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
            var directives = [];
            forEach(hasDirectives[name], function(directiveFactory, index) {
              try {
                var directive = $injector.invoke(directiveFactory);
                if (isFunction(directive)) {
                  directive = {
                    compile: valueFn(directive)
                  };
                } else if (!directive.compile && directive.link) {
                  directive.compile = valueFn(directive.link);
                }
                directive.priority = directive.priority || 0;
                directive.index = index;
                directive.name = directive.name || name;
                directive.require = directive.require || directive.controller && directive.name;
                directive.restrict = directive.restrict || "A";
                directives.push(directive);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
            return directives;
          } ]);
        }
        hasDirectives[name].push(directiveFactory);
      } else {
        forEach(name, reverseParams(registerDirective));
      }
      return this;
    };
    this.aHrefSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
        return this;
      } else {
        return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
      }
    };
    this.imgSrcSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
        return this;
      } else {
        return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
      }
    };
    this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$http", "$templateCache", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
      var Attributes = function(element, attr) {
        this.$$element = element;
        this.$attr = attr || {};
      };
      Attributes.prototype = {
        $normalize: directiveNormalize,
        $addClass: function(classVal) {
          if (classVal && classVal.length > 0) {
            $animate.addClass(this.$$element, classVal);
          }
        },
        $removeClass: function(classVal) {
          if (classVal && classVal.length > 0) {
            $animate.removeClass(this.$$element, classVal);
          }
        },
        $updateClass: function(newClasses, oldClasses) {
          var toAdd = tokenDifference(newClasses, oldClasses);
          var toRemove = tokenDifference(oldClasses, newClasses);
          if (toAdd.length === 0) {
            $animate.removeClass(this.$$element, toRemove);
          } else if (toRemove.length === 0) {
            $animate.addClass(this.$$element, toAdd);
          } else {
            $animate.setClass(this.$$element, toAdd, toRemove);
          }
        },
        $set: function(key, value, writeAttr, attrName) {
          var booleanKey = getBooleanAttrName(this.$$element[0], key), normalizedVal, nodeName;
          if (booleanKey) {
            this.$$element.prop(key, value);
            attrName = booleanKey;
          }
          this[key] = value;
          if (attrName) {
            this.$attr[key] = attrName;
          } else {
            attrName = this.$attr[key];
            if (!attrName) {
              this.$attr[key] = attrName = snake_case(key, "-");
            }
          }
          nodeName = nodeName_(this.$$element);
          if (nodeName === "A" && key === "href" || nodeName === "IMG" && key === "src") {
            this[key] = value = $$sanitizeUri(value, key === "src");
          }
          if (writeAttr !== false) {
            if (value === null || value === undefined) {
              this.$$element.removeAttr(attrName);
            } else {
              this.$$element.attr(attrName, value);
            }
          }
          var $$observers = this.$$observers;
          $$observers && forEach($$observers[key], function(fn) {
            try {
              fn(value);
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        },
        $observe: function(key, fn) {
          var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}), listeners = $$observers[key] || ($$observers[key] = []);
          listeners.push(fn);
          $rootScope.$evalAsync(function() {
            if (!listeners.$$inter) {
              fn(attrs[key]);
            }
          });
          return fn;
        }
      };
      var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == "{{" || endSymbol == "}}" ? identity : function denormalizeTemplate(template) {
        return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
      }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
      return compile;
      function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
        if (!($compileNodes instanceof jqLite)) {
          $compileNodes = jqLite($compileNodes);
        }
        forEach($compileNodes, function(node, index) {
          if (node.nodeType == 3 && node.nodeValue.match(/\S+/)) {
            $compileNodes[index] = node = jqLite(node).wrap("<span></span>").parent()[0];
          }
        });
        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
        safeAddClass($compileNodes, "ng-scope");
        return function publicLinkFn(scope, cloneConnectFn, transcludeControllers, parentBoundTranscludeFn) {
          assertArg(scope, "scope");
          var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
          forEach(transcludeControllers, function(instance, name) {
            $linkNode.data("$" + name + "Controller", instance);
          });
          for (var i = 0, ii = $linkNode.length; i < ii; i++) {
            var node = $linkNode[i], nodeType = node.nodeType;
            if (nodeType === 1 || nodeType === 9) {
              $linkNode.eq(i).data("$scope", scope);
            }
          }
          if (cloneConnectFn) cloneConnectFn($linkNode, scope);
          if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
          return $linkNode;
        };
      }
      function safeAddClass($element, className) {
        try {
          $element.addClass(className);
        } catch (e) {}
      }
      function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
        var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound;
        for (var i = 0; i < nodeList.length; i++) {
          attrs = new Attributes();
          directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
          nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
          if (nodeLinkFn && nodeLinkFn.scope) {
            safeAddClass(attrs.$$element, "ng-scope");
          }
          childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
          linkFns.push(nodeLinkFn, childLinkFn);
          linkFnFound = linkFnFound || nodeLinkFn || childLinkFn;
          previousCompileContext = null;
        }
        return linkFnFound ? compositeLinkFn : null;
        function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
          var nodeLinkFn, childLinkFn, node, childScope, i, ii, n, childBoundTranscludeFn;
          var nodeListLength = nodeList.length, stableNodeList = new Array(nodeListLength);
          for (i = 0; i < nodeListLength; i++) {
            stableNodeList[i] = nodeList[i];
          }
          for (i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
            node = stableNodeList[n];
            nodeLinkFn = linkFns[i++];
            childLinkFn = linkFns[i++];
            if (nodeLinkFn) {
              if (nodeLinkFn.scope) {
                childScope = scope.$new();
                jqLite.data(node, "$scope", childScope);
              } else {
                childScope = scope;
              }
              if (nodeLinkFn.transcludeOnThisElement) {
                childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
              } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                childBoundTranscludeFn = parentBoundTranscludeFn;
              } else if (!parentBoundTranscludeFn && transcludeFn) {
                childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
              } else {
                childBoundTranscludeFn = null;
              }
              nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
            } else if (childLinkFn) {
              childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
            }
          }
        }
      }
      function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
        var boundTranscludeFn = function(transcludedScope, cloneFn, controllers) {
          var scopeCreated = false;
          if (!transcludedScope) {
            transcludedScope = scope.$new();
            transcludedScope.$$transcluded = true;
            scopeCreated = true;
          }
          var clone = transcludeFn(transcludedScope, cloneFn, controllers, previousBoundTranscludeFn);
          if (scopeCreated) {
            clone.on("$destroy", function() {
              transcludedScope.$destroy();
            });
          }
          return clone;
        };
        return boundTranscludeFn;
      }
      function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
        var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
        switch (nodeType) {
         case 1:
          addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), "E", maxPriority, ignoreDirective);
          for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
            var attrStartName = false;
            var attrEndName = false;
            attr = nAttrs[j];
            if (!msie || msie >= 8 || attr.specified) {
              name = attr.name;
              value = trim(attr.value);
              ngAttrName = directiveNormalize(name);
              if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                name = snake_case(ngAttrName.substr(6), "-");
              }
              var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
              if (ngAttrName === directiveNName + "Start") {
                attrStartName = name;
                attrEndName = name.substr(0, name.length - 5) + "end";
                name = name.substr(0, name.length - 6);
              }
              nName = directiveNormalize(name.toLowerCase());
              attrsMap[nName] = name;
              if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                attrs[nName] = value;
                if (getBooleanAttrName(node, nName)) {
                  attrs[nName] = true;
                }
              }
              addAttrInterpolateDirective(node, directives, value, nName);
              addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
            }
          }
          className = node.className;
          if (isString(className) && className !== "") {
            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
              nName = directiveNormalize(match[2]);
              if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[3]);
              }
              className = className.substr(match.index + match[0].length);
            }
          }
          break;

         case 3:
          addTextInterpolateDirective(directives, node.nodeValue);
          break;

         case 8:
          try {
            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
            if (match) {
              nName = directiveNormalize(match[1]);
              if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                attrs[nName] = trim(match[2]);
              }
            }
          } catch (e) {}
          break;
        }
        directives.sort(byPriority);
        return directives;
      }
      function groupScan(node, attrStart, attrEnd) {
        var nodes = [];
        var depth = 0;
        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
          var startNode = node;
          do {
            if (!node) {
              throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
            }
            if (node.nodeType == 1) {
              if (node.hasAttribute(attrStart)) depth++;
              if (node.hasAttribute(attrEnd)) depth--;
            }
            nodes.push(node);
            node = node.nextSibling;
          } while (depth > 0);
        } else {
          nodes.push(node);
        }
        return jqLite(nodes);
      }
      function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
        return function(scope, element, attrs, controllers, transcludeFn) {
          element = groupScan(element[0], attrStart, attrEnd);
          return linkFn(scope, element, attrs, controllers, transcludeFn);
        };
      }
      function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
        previousCompileContext = previousCompileContext || {};
        var terminalPriority = -Number.MAX_VALUE, newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, directiveValue;
        for (var i = 0, ii = directives.length; i < ii; i++) {
          directive = directives[i];
          var attrStart = directive.$$start;
          var attrEnd = directive.$$end;
          if (attrStart) {
            $compileNode = groupScan(compileNode, attrStart, attrEnd);
          }
          $template = undefined;
          if (terminalPriority > directive.priority) {
            break;
          }
          if (directiveValue = directive.scope) {
            newScopeDirective = newScopeDirective || directive;
            if (!directive.templateUrl) {
              assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
              if (isObject(directiveValue)) {
                newIsolateScopeDirective = directive;
              }
            }
          }
          directiveName = directive.name;
          if (!directive.templateUrl && directive.controller) {
            directiveValue = directive.controller;
            controllerDirectives = controllerDirectives || {};
            assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
            controllerDirectives[directiveName] = directive;
          }
          if (directiveValue = directive.transclude) {
            hasTranscludeDirective = true;
            if (!directive.$$tlb) {
              assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
              nonTlbTranscludeDirective = directive;
            }
            if (directiveValue == "element") {
              hasElementTranscludeDirective = true;
              terminalPriority = directive.priority;
              $template = $compileNode;
              $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " "));
              compileNode = $compileNode[0];
              replaceWith(jqCollection, sliceArgs($template), compileNode);
              childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                nonTlbTranscludeDirective: nonTlbTranscludeDirective
              });
            } else {
              $template = jqLite(jqLiteClone(compileNode)).contents();
              $compileNode.empty();
              childTranscludeFn = compile($template, transcludeFn);
            }
          }
          if (directive.template) {
            hasTemplate = true;
            assertNoDuplicate("template", templateDirective, directive, $compileNode);
            templateDirective = directive;
            directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
            directiveValue = denormalizeTemplate(directiveValue);
            if (directive.replace) {
              replaceDirective = directive;
              if (jqLiteIsTextNode(directiveValue)) {
                $template = [];
              } else {
                $template = jqLite(trim(directiveValue));
              }
              compileNode = $template[0];
              if ($template.length != 1 || compileNode.nodeType !== 1) {
                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
              }
              replaceWith(jqCollection, $compileNode, compileNode);
              var newTemplateAttrs = {
                $attr: {}
              };
              var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
              var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
              if (newIsolateScopeDirective) {
                markDirectivesAsIsolate(templateDirectives);
              }
              directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
              mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
              ii = directives.length;
            } else {
              $compileNode.html(directiveValue);
            }
          }
          if (directive.templateUrl) {
            hasTemplate = true;
            assertNoDuplicate("template", templateDirective, directive, $compileNode);
            templateDirective = directive;
            if (directive.replace) {
              replaceDirective = directive;
            }
            nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
              controllerDirectives: controllerDirectives,
              newIsolateScopeDirective: newIsolateScopeDirective,
              templateDirective: templateDirective,
              nonTlbTranscludeDirective: nonTlbTranscludeDirective
            });
            ii = directives.length;
          } else if (directive.compile) {
            try {
              linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
              if (isFunction(linkFn)) {
                addLinkFns(null, linkFn, attrStart, attrEnd);
              } else if (linkFn) {
                addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
              }
            } catch (e) {
              $exceptionHandler(e, startingTag($compileNode));
            }
          }
          if (directive.terminal) {
            nodeLinkFn.terminal = true;
            terminalPriority = Math.max(terminalPriority, directive.priority);
          }
        }
        nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
        nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
        nodeLinkFn.templateOnThisElement = hasTemplate;
        nodeLinkFn.transclude = childTranscludeFn;
        previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
        return nodeLinkFn;
        function addLinkFns(pre, post, attrStart, attrEnd) {
          if (pre) {
            if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
            pre.require = directive.require;
            pre.directiveName = directiveName;
            if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
              pre = cloneAndAnnotateFn(pre, {
                isolateScope: true
              });
            }
            preLinkFns.push(pre);
          }
          if (post) {
            if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
            post.require = directive.require;
            post.directiveName = directiveName;
            if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
              post = cloneAndAnnotateFn(post, {
                isolateScope: true
              });
            }
            postLinkFns.push(post);
          }
        }
        function getControllers(directiveName, require, $element, elementControllers) {
          var value, retrievalMethod = "data", optional = false;
          if (isString(require)) {
            while ((value = require.charAt(0)) == "^" || value == "?") {
              require = require.substr(1);
              if (value == "^") {
                retrievalMethod = "inheritedData";
              }
              optional = optional || value == "?";
            }
            value = null;
            if (elementControllers && retrievalMethod === "data") {
              value = elementControllers[require];
            }
            value = value || $element[retrievalMethod]("$" + require + "Controller");
            if (!value && !optional) {
              throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
            }
            return value;
          } else if (isArray(require)) {
            value = [];
            forEach(require, function(require) {
              value.push(getControllers(directiveName, require, $element, elementControllers));
            });
          }
          return value;
        }
        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
          var attrs, $element, i, ii, linkFn, controller, isolateScope, elementControllers = {}, transcludeFn;
          attrs = compileNode === linkNode ? templateAttrs : shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
          $element = attrs.$$element;
          if (newIsolateScopeDirective) {
            var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
            isolateScope = scope.$new(true);
            if (templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)) {
              $element.data("$isolateScope", isolateScope);
            } else {
              $element.data("$isolateScopeNoTemplate", isolateScope);
            }
            safeAddClass($element, "ng-isolate-scope");
            forEach(newIsolateScopeDirective.scope, function(definition, scopeName) {
              var match = definition.match(LOCAL_REGEXP) || [], attrName = match[3] || scopeName, optional = match[2] == "?", mode = match[1], lastValue, parentGet, parentSet, compare;
              isolateScope.$$isolateBindings[scopeName] = mode + attrName;
              switch (mode) {
               case "@":
                attrs.$observe(attrName, function(value) {
                  isolateScope[scopeName] = value;
                });
                attrs.$$observers[attrName].$$scope = scope;
                if (attrs[attrName]) {
                  isolateScope[scopeName] = $interpolate(attrs[attrName])(scope);
                }
                break;

               case "=":
                if (optional && !attrs[attrName]) {
                  return;
                }
                parentGet = $parse(attrs[attrName]);
                if (parentGet.literal) {
                  compare = equals;
                } else {
                  compare = function(a, b) {
                    return a === b || a !== a && b !== b;
                  };
                }
                parentSet = parentGet.assign || function() {
                  lastValue = isolateScope[scopeName] = parentGet(scope);
                  throw $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name);
                };
                lastValue = isolateScope[scopeName] = parentGet(scope);
                isolateScope.$watch(function parentValueWatch() {
                  var parentValue = parentGet(scope);
                  if (!compare(parentValue, isolateScope[scopeName])) {
                    if (!compare(parentValue, lastValue)) {
                      isolateScope[scopeName] = parentValue;
                    } else {
                      parentSet(scope, parentValue = isolateScope[scopeName]);
                    }
                  }
                  return lastValue = parentValue;
                }, null, parentGet.literal);
                break;

               case "&":
                parentGet = $parse(attrs[attrName]);
                isolateScope[scopeName] = function(locals) {
                  return parentGet(scope, locals);
                };
                break;

               default:
                throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", newIsolateScopeDirective.name, scopeName, definition);
              }
            });
          }
          transcludeFn = boundTranscludeFn && controllersBoundTransclude;
          if (controllerDirectives) {
            forEach(controllerDirectives, function(directive) {
              var locals = {
                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                $element: $element,
                $attrs: attrs,
                $transclude: transcludeFn
              }, controllerInstance;
              controller = directive.controller;
              if (controller == "@") {
                controller = attrs[directive.name];
              }
              controllerInstance = $controller(controller, locals);
              elementControllers[directive.name] = controllerInstance;
              if (!hasElementTranscludeDirective) {
                $element.data("$" + directive.name + "Controller", controllerInstance);
              }
              if (directive.controllerAs) {
                locals.$scope[directive.controllerAs] = controllerInstance;
              }
            });
          }
          for (i = 0, ii = preLinkFns.length; i < ii; i++) {
            try {
              linkFn = preLinkFns[i];
              linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          var scopeToChild = scope;
          if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
            scopeToChild = isolateScope;
          }
          childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
          for (i = postLinkFns.length - 1; i >= 0; i--) {
            try {
              linkFn = postLinkFns[i];
              linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function controllersBoundTransclude(scope, cloneAttachFn) {
            var transcludeControllers;
            if (arguments.length < 2) {
              cloneAttachFn = scope;
              scope = undefined;
            }
            if (hasElementTranscludeDirective) {
              transcludeControllers = elementControllers;
            }
            return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers);
          }
        }
      }
      function markDirectivesAsIsolate(directives) {
        for (var j = 0, jj = directives.length; j < jj; j++) {
          directives[j] = inherit(directives[j], {
            $$isolateScope: true
          });
        }
      }
      function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
        if (name === ignoreDirective) return null;
        var match = null;
        if (hasDirectives.hasOwnProperty(name)) {
          for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
            try {
              directive = directives[i];
              if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                if (startAttrName) {
                  directive = inherit(directive, {
                    $$start: startAttrName,
                    $$end: endAttrName
                  });
                }
                tDirectives.push(directive);
                match = directive;
              }
            } catch (e) {
              $exceptionHandler(e);
            }
          }
        }
        return match;
      }
      function mergeTemplateAttributes(dst, src) {
        var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
        forEach(dst, function(value, key) {
          if (key.charAt(0) != "$") {
            if (src[key] && src[key] !== value) {
              value += (key === "style" ? ";" : " ") + src[key];
            }
            dst.$set(key, value, true, srcAttr[key]);
          }
        });
        forEach(src, function(value, key) {
          if (key == "class") {
            safeAddClass($element, value);
            dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value;
          } else if (key == "style") {
            $element.attr("style", $element.attr("style") + ";" + value);
            dst["style"] = (dst["style"] ? dst["style"] + ";" : "") + value;
          } else if (key.charAt(0) != "$" && !dst.hasOwnProperty(key)) {
            dst[key] = value;
            dstAttr[key] = srcAttr[key];
          }
        });
      }
      function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
        var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
          templateUrl: null,
          transclude: null,
          replace: null,
          $$originalDirective: origAsyncDirective
        }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl;
        $compileNode.empty();
        $http.get($sce.getTrustedResourceUrl(templateUrl), {
          cache: $templateCache
        }).success(function(content) {
          var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
          content = denormalizeTemplate(content);
          if (origAsyncDirective.replace) {
            if (jqLiteIsTextNode(content)) {
              $template = [];
            } else {
              $template = jqLite(trim(content));
            }
            compileNode = $template[0];
            if ($template.length != 1 || compileNode.nodeType !== 1) {
              throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
            }
            tempTemplateAttrs = {
              $attr: {}
            };
            replaceWith($rootElement, $compileNode, compileNode);
            var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
            if (isObject(origAsyncDirective.scope)) {
              markDirectivesAsIsolate(templateDirectives);
            }
            directives = templateDirectives.concat(directives);
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
          } else {
            compileNode = beforeTemplateCompileNode;
            $compileNode.html(content);
          }
          directives.unshift(derivedSyncDirective);
          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
          forEach($rootElement, function(node, i) {
            if (node == compileNode) {
              $rootElement[i] = $compileNode[0];
            }
          });
          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
          while (linkQueue.length) {
            var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
              var oldClasses = beforeTemplateLinkNode.className;
              if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                linkNode = jqLiteClone(compileNode);
              }
              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
              safeAddClass(jqLite(linkNode), oldClasses);
            }
            if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
              childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
            } else {
              childBoundTranscludeFn = boundTranscludeFn;
            }
            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
          }
          linkQueue = null;
        }).error(function(response, code, headers, config) {
          throw $compileMinErr("tpload", "Failed to load template: {0}", config.url);
        });
        return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
          var childBoundTranscludeFn = boundTranscludeFn;
          if (linkQueue) {
            linkQueue.push(scope);
            linkQueue.push(node);
            linkQueue.push(rootElement);
            linkQueue.push(childBoundTranscludeFn);
          } else {
            if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
              childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
            }
            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
          }
        };
      }
      function byPriority(a, b) {
        var diff = b.priority - a.priority;
        if (diff !== 0) return diff;
        if (a.name !== b.name) return a.name < b.name ? -1 : 1;
        return a.index - b.index;
      }
      function assertNoDuplicate(what, previousDirective, directive, element) {
        if (previousDirective) {
          throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element));
        }
      }
      function addTextInterpolateDirective(directives, text) {
        var interpolateFn = $interpolate(text, true);
        if (interpolateFn) {
          directives.push({
            priority: 0,
            compile: function textInterpolateCompileFn(templateNode) {
              var parent = templateNode.parent(), hasCompileParent = parent.length;
              if (hasCompileParent) safeAddClass(templateNode.parent(), "ng-binding");
              return function textInterpolateLinkFn(scope, node) {
                var parent = node.parent(), bindings = parent.data("$binding") || [];
                bindings.push(interpolateFn);
                parent.data("$binding", bindings);
                if (!hasCompileParent) safeAddClass(parent, "ng-binding");
                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                  node[0].nodeValue = value;
                });
              };
            }
          });
        }
      }
      function getTrustedContext(node, attrNormalizedName) {
        if (attrNormalizedName == "srcdoc") {
          return $sce.HTML;
        }
        var tag = nodeName_(node);
        if (attrNormalizedName == "xlinkHref" || tag == "FORM" && attrNormalizedName == "action" || tag != "IMG" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc")) {
          return $sce.RESOURCE_URL;
        }
      }
      function addAttrInterpolateDirective(node, directives, value, name) {
        var interpolateFn = $interpolate(value, true);
        if (!interpolateFn) return;
        if (name === "multiple" && nodeName_(node) === "SELECT") {
          throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
        }
        directives.push({
          priority: 100,
          compile: function() {
            return {
              pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                var $$observers = attr.$$observers || (attr.$$observers = {});
                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                  throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                }
                interpolateFn = $interpolate(attr[name], true, getTrustedContext(node, name));
                if (!interpolateFn) return;
                attr[name] = interpolateFn(scope);
                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                  if (name === "class" && newValue != oldValue) {
                    attr.$updateClass(newValue, oldValue);
                  } else {
                    attr.$set(name, newValue);
                  }
                });
              }
            };
          }
        });
      }
      function replaceWith($rootElement, elementsToRemove, newNode) {
        var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
        if ($rootElement) {
          for (i = 0, ii = $rootElement.length; i < ii; i++) {
            if ($rootElement[i] == firstElementToRemove) {
              $rootElement[i++] = newNode;
              for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
              j2++) {
                if (j2 < jj) {
                  $rootElement[j] = $rootElement[j2];
                } else {
                  delete $rootElement[j];
                }
              }
              $rootElement.length -= removeCount - 1;
              break;
            }
          }
        }
        if (parent) {
          parent.replaceChild(newNode, firstElementToRemove);
        }
        var fragment = document.createDocumentFragment();
        fragment.appendChild(firstElementToRemove);
        newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
        for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
          var element = elementsToRemove[k];
          jqLite(element).remove();
          fragment.appendChild(element);
          delete elementsToRemove[k];
        }
        elementsToRemove[0] = newNode;
        elementsToRemove.length = 1;
      }
      function cloneAndAnnotateFn(fn, annotation) {
        return extend(function() {
          return fn.apply(null, arguments);
        }, fn, annotation);
      }
    } ];
  }
  var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
  function directiveNormalize(name) {
    return camelCase(name.replace(PREFIX_REGEXP, ""));
  }
  function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
  function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
  function tokenDifference(str1, str2) {
    var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
    outer: for (var i = 0; i < tokens1.length; i++) {
      var token = tokens1[i];
      for (var j = 0; j < tokens2.length; j++) {
        if (token == tokens2[j]) continue outer;
      }
      values += (values.length > 0 ? " " : "") + token;
    }
    return values;
  }
  function $ControllerProvider() {
    var controllers = {}, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
    this.register = function(name, constructor) {
      assertNotHasOwnProperty(name, "controller");
      if (isObject(name)) {
        extend(controllers, name);
      } else {
        controllers[name] = constructor;
      }
    };
    this.$get = [ "$injector", "$window", function($injector, $window) {
      return function(expression, locals) {
        var instance, match, constructor, identifier;
        if (isString(expression)) {
          match = expression.match(CNTRL_REG), constructor = match[1], identifier = match[3];
          expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || getter($window, constructor, true);
          assertArgFn(expression, constructor, true);
        }
        instance = $injector.instantiate(expression, locals);
        if (identifier) {
          if (!(locals && typeof locals.$scope === "object")) {
            throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", constructor || expression.name, identifier);
          }
          locals.$scope[identifier] = instance;
        }
        return instance;
      };
    } ];
  }
  function $DocumentProvider() {
    this.$get = [ "$window", function(window) {
      return jqLite(window.document);
    } ];
  }
  function $ExceptionHandlerProvider() {
    this.$get = [ "$log", function($log) {
      return function(exception, cause) {
        $log.error.apply($log, arguments);
      };
    } ];
  }
  function parseHeaders(headers) {
    var parsed = {}, key, val, i;
    if (!headers) return parsed;
    forEach(headers.split("\n"), function(line) {
      i = line.indexOf(":");
      key = lowercase(trim(line.substr(0, i)));
      val = trim(line.substr(i + 1));
      if (key) {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  }
  function headersGetter(headers) {
    var headersObj = isObject(headers) ? headers : undefined;
    return function(name) {
      if (!headersObj) headersObj = parseHeaders(headers);
      if (name) {
        return headersObj[lowercase(name)] || null;
      }
      return headersObj;
    };
  }
  function transformData(data, headers, fns) {
    if (isFunction(fns)) return fns(data, headers);
    forEach(fns, function(fn) {
      data = fn(data, headers);
    });
    return data;
  }
  function isSuccess(status) {
    return 200 <= status && status < 300;
  }
  function $HttpProvider() {
    var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/, CONTENT_TYPE_APPLICATION_JSON = {
      "Content-Type": "application/json;charset=utf-8"
    };
    var defaults = this.defaults = {
      transformResponse: [ function(data) {
        if (isString(data)) {
          data = data.replace(PROTECTION_PREFIX, "");
          if (JSON_START.test(data) && JSON_END.test(data)) data = fromJson(data);
        }
        return data;
      } ],
      transformRequest: [ function(d) {
        return isObject(d) && !isFile(d) && !isBlob(d) ? toJson(d) : d;
      } ],
      headers: {
        common: {
          Accept: "application/json, text/plain, */*"
        },
        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
      },
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN"
    };
    var interceptorFactories = this.interceptors = [];
    var responseInterceptorFactories = this.responseInterceptors = [];
    this.$get = [ "$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
      var defaultCache = $cacheFactory("$http");
      var reversedInterceptors = [];
      forEach(interceptorFactories, function(interceptorFactory) {
        reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
      });
      forEach(responseInterceptorFactories, function(interceptorFactory, index) {
        var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory);
        reversedInterceptors.splice(index, 0, {
          response: function(response) {
            return responseFn($q.when(response));
          },
          responseError: function(response) {
            return responseFn($q.reject(response));
          }
        });
      });
      function $http(requestConfig) {
        var config = {
          method: "get",
          transformRequest: defaults.transformRequest,
          transformResponse: defaults.transformResponse
        };
        var headers = mergeHeaders(requestConfig);
        extend(config, requestConfig);
        config.headers = headers;
        config.method = uppercase(config.method);
        var serverRequest = function(config) {
          headers = config.headers;
          var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);
          if (isUndefined(reqData)) {
            forEach(headers, function(value, header) {
              if (lowercase(header) === "content-type") {
                delete headers[header];
              }
            });
          }
          if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
            config.withCredentials = defaults.withCredentials;
          }
          return sendReq(config, reqData, headers).then(transformResponse, transformResponse);
        };
        var chain = [ serverRequest, undefined ];
        var promise = $q.when(config);
        forEach(reversedInterceptors, function(interceptor) {
          if (interceptor.request || interceptor.requestError) {
            chain.unshift(interceptor.request, interceptor.requestError);
          }
          if (interceptor.response || interceptor.responseError) {
            chain.push(interceptor.response, interceptor.responseError);
          }
        });
        while (chain.length) {
          var thenFn = chain.shift();
          var rejectFn = chain.shift();
          promise = promise.then(thenFn, rejectFn);
        }
        promise.success = function(fn) {
          promise.then(function(response) {
            fn(response.data, response.status, response.headers, config);
          });
          return promise;
        };
        promise.error = function(fn) {
          promise.then(null, function(response) {
            fn(response.data, response.status, response.headers, config);
          });
          return promise;
        };
        return promise;
        function transformResponse(response) {
          var resp = extend({}, response, {
            data: transformData(response.data, response.headers, config.transformResponse)
          });
          return isSuccess(response.status) ? resp : $q.reject(resp);
        }
        function mergeHeaders(config) {
          var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
          defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
          defaultHeadersIteration: for (defHeaderName in defHeaders) {
            lowercaseDefHeaderName = lowercase(defHeaderName);
            for (reqHeaderName in reqHeaders) {
              if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                continue defaultHeadersIteration;
              }
            }
            reqHeaders[defHeaderName] = defHeaders[defHeaderName];
          }
          execHeaders(reqHeaders);
          return reqHeaders;
          function execHeaders(headers) {
            var headerContent;
            forEach(headers, function(headerFn, header) {
              if (isFunction(headerFn)) {
                headerContent = headerFn();
                if (headerContent != null) {
                  headers[header] = headerContent;
                } else {
                  delete headers[header];
                }
              }
            });
          }
        }
      }
      $http.pendingRequests = [];
      createShortMethods("get", "delete", "head", "jsonp");
      createShortMethodsWithData("post", "put");
      $http.defaults = defaults;
      return $http;
      function createShortMethods(names) {
        forEach(arguments, function(name) {
          $http[name] = function(url, config) {
            return $http(extend(config || {}, {
              method: name,
              url: url
            }));
          };
        });
      }
      function createShortMethodsWithData(name) {
        forEach(arguments, function(name) {
          $http[name] = function(url, data, config) {
            return $http(extend(config || {}, {
              method: name,
              url: url,
              data: data
            }));
          };
        });
      }
      function sendReq(config, reqData, reqHeaders) {
        var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, url = buildUrl(config.url, config.params);
        $http.pendingRequests.push(config);
        promise.then(removePendingReq, removePendingReq);
        if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
          cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
        }
        if (cache) {
          cachedResp = cache.get(url);
          if (isDefined(cachedResp)) {
            if (isPromiseLike(cachedResp)) {
              cachedResp.then(removePendingReq, removePendingReq);
              return cachedResp;
            } else {
              if (isArray(cachedResp)) {
                resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
              } else {
                resolvePromise(cachedResp, 200, {}, "OK");
              }
            }
          } else {
            cache.put(url, promise);
          }
        }
        if (isUndefined(cachedResp)) {
          var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
          if (xsrfValue) {
            reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
          }
          $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
        }
        return promise;
        function done(status, response, headersString, statusText) {
          if (cache) {
            if (isSuccess(status)) {
              cache.put(url, [ status, response, parseHeaders(headersString), statusText ]);
            } else {
              cache.remove(url);
            }
          }
          resolvePromise(response, status, headersString, statusText);
          if (!$rootScope.$$phase) $rootScope.$apply();
        }
        function resolvePromise(response, status, headers, statusText) {
          status = Math.max(status, 0);
          (isSuccess(status) ? deferred.resolve : deferred.reject)({
            data: response,
            status: status,
            headers: headersGetter(headers),
            config: config,
            statusText: statusText
          });
        }
        function removePendingReq() {
          var idx = indexOf($http.pendingRequests, config);
          if (idx !== -1) $http.pendingRequests.splice(idx, 1);
        }
      }
      function buildUrl(url, params) {
        if (!params) return url;
        var parts = [];
        forEachSorted(params, function(value, key) {
          if (value === null || isUndefined(value)) return;
          if (!isArray(value)) value = [ value ];
          forEach(value, function(v) {
            if (isObject(v)) {
              if (isDate(v)) {
                v = v.toISOString();
              } else {
                v = toJson(v);
              }
            }
            parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
          });
        });
        if (parts.length > 0) {
          url += (url.indexOf("?") == -1 ? "?" : "&") + parts.join("&");
        }
        return url;
      }
    } ];
  }
  function createXhr(method) {
    if (msie <= 8 && (!method.match(/^(get|post|head|put|delete|options)$/i) || !window.XMLHttpRequest)) {
      return new window.ActiveXObject("Microsoft.XMLHTTP");
    } else if (window.XMLHttpRequest) {
      return new window.XMLHttpRequest();
    }
    throw minErr("$httpBackend")("noxhr", "This browser does not support XMLHttpRequest.");
  }
  function $HttpBackendProvider() {
    this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
      return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
    } ];
  }
  function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
    var ABORTED = -1;
    return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
      var status;
      $browser.$$incOutstandingRequestCount();
      url = url || $browser.url();
      if (lowercase(method) == "jsonp") {
        var callbackId = "_" + (callbacks.counter++).toString(36);
        callbacks[callbackId] = function(data) {
          callbacks[callbackId].data = data;
          callbacks[callbackId].called = true;
        };
        var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
          completeRequest(callback, status, callbacks[callbackId].data, "", text);
          callbacks[callbackId] = noop;
        });
      } else {
        var xhr = createXhr(method);
        xhr.open(method, url, true);
        forEach(headers, function(value, key) {
          if (isDefined(value)) {
            xhr.setRequestHeader(key, value);
          }
        });
        xhr.onreadystatechange = function() {
          if (xhr && xhr.readyState == 4) {
            var responseHeaders = null, response = null, statusText = "";
            if (status !== ABORTED) {
              responseHeaders = xhr.getAllResponseHeaders();
              response = "response" in xhr ? xhr.response : xhr.responseText;
            }
            if (!(status === ABORTED && msie < 10)) {
              statusText = xhr.statusText;
            }
            completeRequest(callback, status || xhr.status, response, responseHeaders, statusText);
          }
        };
        if (withCredentials) {
          xhr.withCredentials = true;
        }
        if (responseType) {
          try {
            xhr.responseType = responseType;
          } catch (e) {
            if (responseType !== "json") {
              throw e;
            }
          }
        }
        xhr.send(post || null);
      }
      if (timeout > 0) {
        var timeoutId = $browserDefer(timeoutRequest, timeout);
      } else if (isPromiseLike(timeout)) {
        timeout.then(timeoutRequest);
      }
      function timeoutRequest() {
        status = ABORTED;
        jsonpDone && jsonpDone();
        xhr && xhr.abort();
      }
      function completeRequest(callback, status, response, headersString, statusText) {
        timeoutId && $browserDefer.cancel(timeoutId);
        jsonpDone = xhr = null;
        if (status === 0) {
          status = response ? 200 : urlResolve(url).protocol == "file" ? 404 : 0;
        }
        status = status === 1223 ? 204 : status;
        statusText = statusText || "";
        callback(status, response, headersString, statusText);
        $browser.$$completeOutstandingRequest(noop);
      }
    };
    function jsonpReq(url, callbackId, done) {
      var script = rawDocument.createElement("script"), callback = null;
      script.type = "text/javascript";
      script.src = url;
      script.async = true;
      callback = function(event) {
        removeEventListenerFn(script, "load", callback);
        removeEventListenerFn(script, "error", callback);
        rawDocument.body.removeChild(script);
        script = null;
        var status = -1;
        var text = "unknown";
        if (event) {
          if (event.type === "load" && !callbacks[callbackId].called) {
            event = {
              type: "error"
            };
          }
          text = event.type;
          status = event.type === "error" ? 404 : 200;
        }
        if (done) {
          done(status, text);
        }
      };
      addEventListenerFn(script, "load", callback);
      addEventListenerFn(script, "error", callback);
      if (msie <= 8) {
        script.onreadystatechange = function() {
          if (isString(script.readyState) && /loaded|complete/.test(script.readyState)) {
            script.onreadystatechange = null;
            callback({
              type: "load"
            });
          }
        };
      }
      rawDocument.body.appendChild(script);
      return callback;
    }
  }
  var $interpolateMinErr = minErr("$interpolate");
  function $InterpolateProvider() {
    var startSymbol = "{{";
    var endSymbol = "}}";
    this.startSymbol = function(value) {
      if (value) {
        startSymbol = value;
        return this;
      } else {
        return startSymbol;
      }
    };
    this.endSymbol = function(value) {
      if (value) {
        endSymbol = value;
        return this;
      } else {
        return endSymbol;
      }
    };
    this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
      var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length;
      function $interpolate(text, mustHaveExpression, trustedContext) {
        var startIndex, endIndex, index = 0, parts = [], length = text.length, hasInterpolation = false, fn, exp, concat = [];
        while (index < length) {
          if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
            index != startIndex && parts.push(text.substring(index, startIndex));
            parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
            fn.exp = exp;
            index = endIndex + endSymbolLength;
            hasInterpolation = true;
          } else {
            index != length && parts.push(text.substring(index));
            index = length;
          }
        }
        if (!(length = parts.length)) {
          parts.push("");
          length = 1;
        }
        if (trustedContext && parts.length > 1) {
          throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
        }
        if (!mustHaveExpression || hasInterpolation) {
          concat.length = length;
          fn = function(context) {
            try {
              for (var i = 0, ii = length, part; i < ii; i++) {
                if (typeof (part = parts[i]) == "function") {
                  part = part(context);
                  if (trustedContext) {
                    part = $sce.getTrusted(trustedContext, part);
                  } else {
                    part = $sce.valueOf(part);
                  }
                  if (part == null) {
                    part = "";
                  } else {
                    switch (typeof part) {
                     case "string":
                      {
                        break;
                      }

                     case "number":
                      {
                        part = "" + part;
                        break;
                      }

                     default:
                      {
                        part = toJson(part);
                      }
                    }
                  }
                }
                concat[i] = part;
              }
              return concat.join("");
            } catch (err) {
              var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
              $exceptionHandler(newErr);
            }
          };
          fn.exp = text;
          fn.parts = parts;
          return fn;
        }
      }
      $interpolate.startSymbol = function() {
        return startSymbol;
      };
      $interpolate.endSymbol = function() {
        return endSymbol;
      };
      return $interpolate;
    } ];
  }
  function $IntervalProvider() {
    this.$get = [ "$rootScope", "$window", "$q", function($rootScope, $window, $q) {
      var intervals = {};
      function interval(fn, delay, count, invokeApply) {
        var setInterval = $window.setInterval, clearInterval = $window.clearInterval, deferred = $q.defer(), promise = deferred.promise, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply;
        count = isDefined(count) ? count : 0;
        promise.then(null, null, fn);
        promise.$$intervalId = setInterval(function tick() {
          deferred.notify(iteration++);
          if (count > 0 && iteration >= count) {
            deferred.resolve(iteration);
            clearInterval(promise.$$intervalId);
            delete intervals[promise.$$intervalId];
          }
          if (!skipApply) $rootScope.$apply();
        }, delay);
        intervals[promise.$$intervalId] = deferred;
        return promise;
      }
      interval.cancel = function(promise) {
        if (promise && promise.$$intervalId in intervals) {
          intervals[promise.$$intervalId].reject("canceled");
          $window.clearInterval(promise.$$intervalId);
          delete intervals[promise.$$intervalId];
          return true;
        }
        return false;
      };
      return interval;
    } ];
  }
  function $LocaleProvider() {
    this.$get = function() {
      return {
        id: "en-us",
        NUMBER_FORMATS: {
          DECIMAL_SEP: ".",
          GROUP_SEP: ",",
          PATTERNS: [ {
            minInt: 1,
            minFrac: 0,
            maxFrac: 3,
            posPre: "",
            posSuf: "",
            negPre: "-",
            negSuf: "",
            gSize: 3,
            lgSize: 3
          }, {
            minInt: 1,
            minFrac: 2,
            maxFrac: 2,
            posPre: "¤",
            posSuf: "",
            negPre: "(¤",
            negSuf: ")",
            gSize: 3,
            lgSize: 3
          } ],
          CURRENCY_SYM: "$"
        },
        DATETIME_FORMATS: {
          MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
          SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
          DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
          SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
          AMPMS: [ "AM", "PM" ],
          medium: "MMM d, y h:mm:ss a",
          "short": "M/d/yy h:mm a",
          fullDate: "EEEE, MMMM d, y",
          longDate: "MMMM d, y",
          mediumDate: "MMM d, y",
          shortDate: "M/d/yy",
          mediumTime: "h:mm:ss a",
          shortTime: "h:mm a"
        },
        pluralCat: function(num) {
          if (num === 1) {
            return "one";
          }
          return "other";
        }
      };
    };
  }
  var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
    http: 80,
    https: 443,
    ftp: 21
  };
  var $locationMinErr = minErr("$location");
  function encodePath(path) {
    var segments = path.split("/"), i = segments.length;
    while (i--) {
      segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join("/");
  }
  function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {
    var parsedUrl = urlResolve(absoluteUrl, appBase);
    locationObj.$$protocol = parsedUrl.protocol;
    locationObj.$$host = parsedUrl.hostname;
    locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
  }
  function parseAppUrl(relativeUrl, locationObj, appBase) {
    var prefixed = relativeUrl.charAt(0) !== "/";
    if (prefixed) {
      relativeUrl = "/" + relativeUrl;
    }
    var match = urlResolve(relativeUrl, appBase);
    locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname);
    locationObj.$$search = parseKeyValue(match.search);
    locationObj.$$hash = decodeURIComponent(match.hash);
    if (locationObj.$$path && locationObj.$$path.charAt(0) != "/") {
      locationObj.$$path = "/" + locationObj.$$path;
    }
  }
  function beginsWith(begin, whole) {
    if (whole.indexOf(begin) === 0) {
      return whole.substr(begin.length);
    }
  }
  function stripHash(url) {
    var index = url.indexOf("#");
    return index == -1 ? url : url.substr(0, index);
  }
  function stripFile(url) {
    return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
  }
  function serverBase(url) {
    return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
  }
  function LocationHtml5Url(appBase, basePrefix) {
    this.$$html5 = true;
    basePrefix = basePrefix || "";
    var appBaseNoFile = stripFile(appBase);
    parseAbsoluteUrl(appBase, this, appBase);
    this.$$parse = function(url) {
      var pathUrl = beginsWith(appBaseNoFile, url);
      if (!isString(pathUrl)) {
        throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
      }
      parseAppUrl(pathUrl, this, appBase);
      if (!this.$$path) {
        this.$$path = "/";
      }
      this.$$compose();
    };
    this.$$compose = function() {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
      this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
      this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
    };
    this.$$rewrite = function(url) {
      var appUrl, prevAppUrl;
      if ((appUrl = beginsWith(appBase, url)) !== undefined) {
        prevAppUrl = appUrl;
        if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
          return appBaseNoFile + (beginsWith("/", appUrl) || appUrl);
        } else {
          return appBase + prevAppUrl;
        }
      } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
        return appBaseNoFile + appUrl;
      } else if (appBaseNoFile == url + "/") {
        return appBaseNoFile;
      }
    };
  }
  function LocationHashbangUrl(appBase, hashPrefix) {
    var appBaseNoFile = stripFile(appBase);
    parseAbsoluteUrl(appBase, this, appBase);
    this.$$parse = function(url) {
      var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
      var withoutHashUrl = withoutBaseUrl.charAt(0) == "#" ? beginsWith(hashPrefix, withoutBaseUrl) : this.$$html5 ? withoutBaseUrl : "";
      if (!isString(withoutHashUrl)) {
        throw $locationMinErr("ihshprfx", 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix);
      }
      parseAppUrl(withoutHashUrl, this, appBase);
      this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
      this.$$compose();
      function removeWindowsDriveName(path, url, base) {
        var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
        var firstPathSegmentMatch;
        if (url.indexOf(base) === 0) {
          url = url.replace(base, "");
        }
        if (windowsFilePathExp.exec(url)) {
          return path;
        }
        firstPathSegmentMatch = windowsFilePathExp.exec(path);
        return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
      }
    };
    this.$$compose = function() {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
      this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
      this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
    };
    this.$$rewrite = function(url) {
      if (stripHash(appBase) == stripHash(url)) {
        return url;
      }
    };
  }
  function LocationHashbangInHtml5Url(appBase, hashPrefix) {
    this.$$html5 = true;
    LocationHashbangUrl.apply(this, arguments);
    var appBaseNoFile = stripFile(appBase);
    this.$$rewrite = function(url) {
      var appUrl;
      if (appBase == stripHash(url)) {
        return url;
      } else if (appUrl = beginsWith(appBaseNoFile, url)) {
        return appBase + hashPrefix + appUrl;
      } else if (appBaseNoFile === url + "/") {
        return appBaseNoFile;
      }
    };
    this.$$compose = function() {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
      this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
      this.$$absUrl = appBase + hashPrefix + this.$$url;
    };
  }
  LocationHashbangInHtml5Url.prototype = LocationHashbangUrl.prototype = LocationHtml5Url.prototype = {
    $$html5: false,
    $$replace: false,
    absUrl: locationGetter("$$absUrl"),
    url: function(url) {
      if (isUndefined(url)) return this.$$url;
      var match = PATH_MATCH.exec(url);
      if (match[1]) this.path(decodeURIComponent(match[1]));
      if (match[2] || match[1]) this.search(match[3] || "");
      this.hash(match[5] || "");
      return this;
    },
    protocol: locationGetter("$$protocol"),
    host: locationGetter("$$host"),
    port: locationGetter("$$port"),
    path: locationGetterSetter("$$path", function(path) {
      path = path ? path.toString() : "";
      return path.charAt(0) == "/" ? path : "/" + path;
    }),
    search: function(search, paramValue) {
      switch (arguments.length) {
       case 0:
        return this.$$search;

       case 1:
        if (isString(search) || isNumber(search)) {
          search = search.toString();
          this.$$search = parseKeyValue(search);
        } else if (isObject(search)) {
          forEach(search, function(value, key) {
            if (value == null) delete search[key];
          });
          this.$$search = search;
        } else {
          throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
        }
        break;

       default:
        if (isUndefined(paramValue) || paramValue === null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
      }
      this.$$compose();
      return this;
    },
    hash: locationGetterSetter("$$hash", function(hash) {
      return hash ? hash.toString() : "";
    }),
    replace: function() {
      this.$$replace = true;
      return this;
    }
  };
  function locationGetter(property) {
    return function() {
      return this[property];
    };
  }
  function locationGetterSetter(property, preprocess) {
    return function(value) {
      if (isUndefined(value)) return this[property];
      this[property] = preprocess(value);
      this.$$compose();
      return this;
    };
  }
  function $LocationProvider() {
    var hashPrefix = "", html5Mode = false;
    this.hashPrefix = function(prefix) {
      if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
      } else {
        return hashPrefix;
      }
    };
    this.html5Mode = function(mode) {
      if (isDefined(mode)) {
        html5Mode = mode;
        return this;
      } else {
        return html5Mode;
      }
    };
    this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", function($rootScope, $browser, $sniffer, $rootElement) {
      var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
      if (html5Mode) {
        appBase = serverBase(initialUrl) + (baseHref || "/");
        LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
      } else {
        appBase = stripHash(initialUrl);
        LocationMode = LocationHashbangUrl;
      }
      $location = new LocationMode(appBase, "#" + hashPrefix);
      $location.$$parse($location.$$rewrite(initialUrl));
      var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
      $rootElement.on("click", function(event) {
        if (event.ctrlKey || event.metaKey || event.which == 2) return;
        var elm = jqLite(event.target);
        while (lowercase(elm[0].nodeName) !== "a") {
          if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
        }
        var absHref = elm.prop("href");
        if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
          absHref = urlResolve(absHref.animVal).href;
        }
        if (IGNORE_URI_REGEXP.test(absHref)) return;
        if (LocationMode === LocationHashbangInHtml5Url) {
          var href = elm.attr("href") || elm.attr("xlink:href");
          if (href && href.indexOf("://") < 0) {
            var prefix = "#" + hashPrefix;
            if (href[0] == "/") {
              absHref = appBase + prefix + href;
            } else if (href[0] == "#") {
              absHref = appBase + prefix + ($location.path() || "/") + href;
            } else {
              var stack = $location.path().split("/"), parts = href.split("/");
              if (stack.length === 2 && !stack[1]) stack.length = 1;
              for (var i = 0; i < parts.length; i++) {
                if (parts[i] == ".") continue; else if (parts[i] == "..") stack.pop(); else if (parts[i].length) stack.push(parts[i]);
              }
              absHref = appBase + prefix + stack.join("/");
            }
          }
        }
        var rewrittenUrl = $location.$$rewrite(absHref);
        if (absHref && !elm.attr("target") && rewrittenUrl && !event.isDefaultPrevented()) {
          event.preventDefault();
          if (rewrittenUrl != $browser.url()) {
            $location.$$parse(rewrittenUrl);
            $rootScope.$apply();
            window.angular["ff-684208-preventDefault"] = true;
          }
        }
      });
      if ($location.absUrl() != initialUrl) {
        $browser.url($location.absUrl(), true);
      }
      $browser.onUrlChange(function(newUrl) {
        if ($location.absUrl() != newUrl) {
          $rootScope.$evalAsync(function() {
            var oldUrl = $location.absUrl();
            $location.$$parse(newUrl);
            if ($rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl).defaultPrevented) {
              $location.$$parse(oldUrl);
              $browser.url(oldUrl);
            } else {
              afterLocationChange(oldUrl);
            }
          });
          if (!$rootScope.$$phase) $rootScope.$digest();
        }
      });
      var changeCounter = 0;
      $rootScope.$watch(function $locationWatch() {
        var oldUrl = $browser.url();
        var currentReplace = $location.$$replace;
        if (!changeCounter || oldUrl != $location.absUrl()) {
          changeCounter++;
          $rootScope.$evalAsync(function() {
            if ($rootScope.$broadcast("$locationChangeStart", $location.absUrl(), oldUrl).defaultPrevented) {
              $location.$$parse(oldUrl);
            } else {
              $browser.url($location.absUrl(), currentReplace);
              afterLocationChange(oldUrl);
            }
          });
        }
        $location.$$replace = false;
        return changeCounter;
      });
      return $location;
      function afterLocationChange(oldUrl) {
        $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl);
      }
    } ];
  }
  function $LogProvider() {
    var debug = true, self = this;
    this.debugEnabled = function(flag) {
      if (isDefined(flag)) {
        debug = flag;
        return this;
      } else {
        return debug;
      }
    };
    this.$get = [ "$window", function($window) {
      return {
        log: consoleLog("log"),
        info: consoleLog("info"),
        warn: consoleLog("warn"),
        error: consoleLog("error"),
        debug: function() {
          var fn = consoleLog("debug");
          return function() {
            if (debug) {
              fn.apply(self, arguments);
            }
          };
        }()
      };
      function formatError(arg) {
        if (arg instanceof Error) {
          if (arg.stack) {
            arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
          } else if (arg.sourceURL) {
            arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
          }
        }
        return arg;
      }
      function consoleLog(type) {
        var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
        try {
          hasApply = !!logFn.apply;
        } catch (e) {}
        if (hasApply) {
          return function() {
            var args = [];
            forEach(arguments, function(arg) {
              args.push(formatError(arg));
            });
            return logFn.apply(console, args);
          };
        }
        return function(arg1, arg2) {
          logFn(arg1, arg2 == null ? "" : arg2);
        };
      }
    } ];
  }
  var $parseMinErr = minErr("$parse");
  var promiseWarningCache = {};
  var promiseWarning;
  function ensureSafeMemberName(name, fullExpression) {
    if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
      throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! " + "Expression: {0}", fullExpression);
    }
    return name;
  }
  function ensureSafeObject(obj, fullExpression) {
    if (obj) {
      if (obj.constructor === obj) {
        throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
      } else if (obj.document && obj.location && obj.alert && obj.setInterval) {
        throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
      } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
        throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
      } else if (obj === Object) {
        throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
      }
    }
    return obj;
  }
  var CALL = Function.prototype.call;
  var APPLY = Function.prototype.apply;
  var BIND = Function.prototype.bind;
  function ensureSafeFunction(obj, fullExpression) {
    if (obj) {
      if (obj.constructor === obj) {
        throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
      } else if (obj === CALL || obj === APPLY || BIND && obj === BIND) {
        throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
      }
    }
  }
  var OPERATORS = {
    "null": function() {
      return null;
    },
    "true": function() {
      return true;
    },
    "false": function() {
      return false;
    },
    undefined: noop,
    "+": function(self, locals, a, b) {
      a = a(self, locals);
      b = b(self, locals);
      if (isDefined(a)) {
        if (isDefined(b)) {
          return a + b;
        }
        return a;
      }
      return isDefined(b) ? b : undefined;
    },
    "-": function(self, locals, a, b) {
      a = a(self, locals);
      b = b(self, locals);
      return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
    },
    "*": function(self, locals, a, b) {
      return a(self, locals) * b(self, locals);
    },
    "/": function(self, locals, a, b) {
      return a(self, locals) / b(self, locals);
    },
    "%": function(self, locals, a, b) {
      return a(self, locals) % b(self, locals);
    },
    "^": function(self, locals, a, b) {
      return a(self, locals) ^ b(self, locals);
    },
    "=": noop,
    "===": function(self, locals, a, b) {
      return a(self, locals) === b(self, locals);
    },
    "!==": function(self, locals, a, b) {
      return a(self, locals) !== b(self, locals);
    },
    "==": function(self, locals, a, b) {
      return a(self, locals) == b(self, locals);
    },
    "!=": function(self, locals, a, b) {
      return a(self, locals) != b(self, locals);
    },
    "<": function(self, locals, a, b) {
      return a(self, locals) < b(self, locals);
    },
    ">": function(self, locals, a, b) {
      return a(self, locals) > b(self, locals);
    },
    "<=": function(self, locals, a, b) {
      return a(self, locals) <= b(self, locals);
    },
    ">=": function(self, locals, a, b) {
      return a(self, locals) >= b(self, locals);
    },
    "&&": function(self, locals, a, b) {
      return a(self, locals) && b(self, locals);
    },
    "||": function(self, locals, a, b) {
      return a(self, locals) || b(self, locals);
    },
    "&": function(self, locals, a, b) {
      return a(self, locals) & b(self, locals);
    },
    "|": function(self, locals, a, b) {
      return b(self, locals)(self, locals, a(self, locals));
    },
    "!": function(self, locals, a) {
      return !a(self, locals);
    }
  };
  var ESCAPE = {
    n: "\n",
    f: "\f",
    r: "\r",
    t: "	",
    v: "",
    "'": "'",
    '"': '"'
  };
  var Lexer = function(options) {
    this.options = options;
  };
  Lexer.prototype = {
    constructor: Lexer,
    lex: function(text) {
      this.text = text;
      this.index = 0;
      this.ch = undefined;
      this.lastCh = ":";
      this.tokens = [];
      while (this.index < this.text.length) {
        this.ch = this.text.charAt(this.index);
        if (this.is("\"'")) {
          this.readString(this.ch);
        } else if (this.isNumber(this.ch) || this.is(".") && this.isNumber(this.peek())) {
          this.readNumber();
        } else if (this.isIdent(this.ch)) {
          this.readIdent();
        } else if (this.is("(){}[].,;:?")) {
          this.tokens.push({
            index: this.index,
            text: this.ch
          });
          this.index++;
        } else if (this.isWhitespace(this.ch)) {
          this.index++;
          continue;
        } else {
          var ch2 = this.ch + this.peek();
          var ch3 = ch2 + this.peek(2);
          var fn = OPERATORS[this.ch];
          var fn2 = OPERATORS[ch2];
          var fn3 = OPERATORS[ch3];
          if (fn3) {
            this.tokens.push({
              index: this.index,
              text: ch3,
              fn: fn3
            });
            this.index += 3;
          } else if (fn2) {
            this.tokens.push({
              index: this.index,
              text: ch2,
              fn: fn2
            });
            this.index += 2;
          } else if (fn) {
            this.tokens.push({
              index: this.index,
              text: this.ch,
              fn: fn
            });
            this.index += 1;
          } else {
            this.throwError("Unexpected next character ", this.index, this.index + 1);
          }
        }
        this.lastCh = this.ch;
      }
      return this.tokens;
    },
    is: function(chars) {
      return chars.indexOf(this.ch) !== -1;
    },
    was: function(chars) {
      return chars.indexOf(this.lastCh) !== -1;
    },
    peek: function(i) {
      var num = i || 1;
      return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
    },
    isNumber: function(ch) {
      return "0" <= ch && ch <= "9";
    },
    isWhitespace: function(ch) {
      return ch === " " || ch === "\r" || ch === "	" || ch === "\n" || ch === "" || ch === " ";
    },
    isIdent: function(ch) {
      return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || ch === "$";
    },
    isExpOperator: function(ch) {
      return ch === "-" || ch === "+" || this.isNumber(ch);
    },
    throwError: function(error, start, end) {
      end = end || this.index;
      var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
      throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
    },
    readNumber: function() {
      var number = "";
      var start = this.index;
      while (this.index < this.text.length) {
        var ch = lowercase(this.text.charAt(this.index));
        if (ch == "." || this.isNumber(ch)) {
          number += ch;
        } else {
          var peekCh = this.peek();
          if (ch == "e" && this.isExpOperator(peekCh)) {
            number += ch;
          } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == "e") {
            number += ch;
          } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == "e") {
            this.throwError("Invalid exponent");
          } else {
            break;
          }
        }
        this.index++;
      }
      number = 1 * number;
      this.tokens.push({
        index: start,
        text: number,
        literal: true,
        constant: true,
        fn: function() {
          return number;
        }
      });
    },
    readIdent: function() {
      var parser = this;
      var ident = "";
      var start = this.index;
      var lastDot, peekIndex, methodName, ch;
      while (this.index < this.text.length) {
        ch = this.text.charAt(this.index);
        if (ch === "." || this.isIdent(ch) || this.isNumber(ch)) {
          if (ch === ".") lastDot = this.index;
          ident += ch;
        } else {
          break;
        }
        this.index++;
      }
      if (lastDot) {
        peekIndex = this.index;
        while (peekIndex < this.text.length) {
          ch = this.text.charAt(peekIndex);
          if (ch === "(") {
            methodName = ident.substr(lastDot - start + 1);
            ident = ident.substr(0, lastDot - start);
            this.index = peekIndex;
            break;
          }
          if (this.isWhitespace(ch)) {
            peekIndex++;
          } else {
            break;
          }
        }
      }
      var token = {
        index: start,
        text: ident
      };
      if (OPERATORS.hasOwnProperty(ident)) {
        token.fn = OPERATORS[ident];
        token.literal = true;
        token.constant = true;
      } else {
        var getter = getterFn(ident, this.options, this.text);
        token.fn = extend(function(self, locals) {
          return getter(self, locals);
        }, {
          assign: function(self, value) {
            return setter(self, ident, value, parser.text, parser.options);
          }
        });
      }
      this.tokens.push(token);
      if (methodName) {
        this.tokens.push({
          index: lastDot,
          text: "."
        });
        this.tokens.push({
          index: lastDot + 1,
          text: methodName
        });
      }
    },
    readString: function(quote) {
      var start = this.index;
      this.index++;
      var string = "";
      var rawString = quote;
      var escape = false;
      while (this.index < this.text.length) {
        var ch = this.text.charAt(this.index);
        rawString += ch;
        if (escape) {
          if (ch === "u") {
            var hex = this.text.substring(this.index + 1, this.index + 5);
            if (!hex.match(/[\da-f]{4}/i)) this.throwError("Invalid unicode escape [\\u" + hex + "]");
            this.index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var rep = ESCAPE[ch];
            string = string + (rep || ch);
          }
          escape = false;
        } else if (ch === "\\") {
          escape = true;
        } else if (ch === quote) {
          this.index++;
          this.tokens.push({
            index: start,
            text: rawString,
            string: string,
            literal: true,
            constant: true,
            fn: function() {
              return string;
            }
          });
          return;
        } else {
          string += ch;
        }
        this.index++;
      }
      this.throwError("Unterminated quote", start);
    }
  };
  var Parser = function(lexer, $filter, options) {
    this.lexer = lexer;
    this.$filter = $filter;
    this.options = options;
  };
  Parser.ZERO = extend(function() {
    return 0;
  }, {
    constant: true
  });
  Parser.prototype = {
    constructor: Parser,
    parse: function(text) {
      this.text = text;
      this.tokens = this.lexer.lex(text);
      var value = this.statements();
      if (this.tokens.length !== 0) {
        this.throwError("is an unexpected token", this.tokens[0]);
      }
      value.literal = !!value.literal;
      value.constant = !!value.constant;
      return value;
    },
    primary: function() {
      var primary;
      if (this.expect("(")) {
        primary = this.filterChain();
        this.consume(")");
      } else if (this.expect("[")) {
        primary = this.arrayDeclaration();
      } else if (this.expect("{")) {
        primary = this.object();
      } else {
        var token = this.expect();
        primary = token.fn;
        if (!primary) {
          this.throwError("not a primary expression", token);
        }
        primary.literal = !!token.literal;
        primary.constant = !!token.constant;
      }
      var next, context;
      while (next = this.expect("(", "[", ".")) {
        if (next.text === "(") {
          primary = this.functionCall(primary, context);
          context = null;
        } else if (next.text === "[") {
          context = primary;
          primary = this.objectIndex(primary);
        } else if (next.text === ".") {
          context = primary;
          primary = this.fieldAccess(primary);
        } else {
          this.throwError("IMPOSSIBLE");
        }
      }
      return primary;
    },
    throwError: function(msg, token) {
      throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
    },
    peekToken: function() {
      if (this.tokens.length === 0) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
      return this.tokens[0];
    },
    peek: function(e1, e2, e3, e4) {
      if (this.tokens.length > 0) {
        var token = this.tokens[0];
        var t = token.text;
        if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
          return token;
        }
      }
      return false;
    },
    expect: function(e1, e2, e3, e4) {
      var token = this.peek(e1, e2, e3, e4);
      if (token) {
        this.tokens.shift();
        return token;
      }
      return false;
    },
    consume: function(e1) {
      if (!this.expect(e1)) {
        this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
      }
    },
    unaryFn: function(fn, right) {
      return extend(function(self, locals) {
        return fn(self, locals, right);
      }, {
        constant: right.constant
      });
    },
    ternaryFn: function(left, middle, right) {
      return extend(function(self, locals) {
        return left(self, locals) ? middle(self, locals) : right(self, locals);
      }, {
        constant: left.constant && middle.constant && right.constant
      });
    },
    binaryFn: function(left, fn, right) {
      return extend(function(self, locals) {
        return fn(self, locals, left, right);
      }, {
        constant: left.constant && right.constant
      });
    },
    statements: function() {
      var statements = [];
      while (true) {
        if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) statements.push(this.filterChain());
        if (!this.expect(";")) {
          return statements.length === 1 ? statements[0] : function(self, locals) {
            var value;
            for (var i = 0; i < statements.length; i++) {
              var statement = statements[i];
              if (statement) {
                value = statement(self, locals);
              }
            }
            return value;
          };
        }
      }
    },
    filterChain: function() {
      var left = this.expression();
      var token;
      while (true) {
        if (token = this.expect("|")) {
          left = this.binaryFn(left, token.fn, this.filter());
        } else {
          return left;
        }
      }
    },
    filter: function() {
      var token = this.expect();
      var fn = this.$filter(token.text);
      var argsFn = [];
      while (true) {
        if (token = this.expect(":")) {
          argsFn.push(this.expression());
        } else {
          var fnInvoke = function(self, locals, input) {
            var args = [ input ];
            for (var i = 0; i < argsFn.length; i++) {
              args.push(argsFn[i](self, locals));
            }
            return fn.apply(self, args);
          };
          return function() {
            return fnInvoke;
          };
        }
      }
    },
    expression: function() {
      return this.assignment();
    },
    assignment: function() {
      var left = this.ternary();
      var right;
      var token;
      if (token = this.expect("=")) {
        if (!left.assign) {
          this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token);
        }
        right = this.ternary();
        return function(scope, locals) {
          return left.assign(scope, right(scope, locals), locals);
        };
      }
      return left;
    },
    ternary: function() {
      var left = this.logicalOR();
      var middle;
      var token;
      if (token = this.expect("?")) {
        middle = this.assignment();
        if (token = this.expect(":")) {
          return this.ternaryFn(left, middle, this.assignment());
        } else {
          this.throwError("expected :", token);
        }
      } else {
        return left;
      }
    },
    logicalOR: function() {
      var left = this.logicalAND();
      var token;
      while (true) {
        if (token = this.expect("||")) {
          left = this.binaryFn(left, token.fn, this.logicalAND());
        } else {
          return left;
        }
      }
    },
    logicalAND: function() {
      var left = this.equality();
      var token;
      if (token = this.expect("&&")) {
        left = this.binaryFn(left, token.fn, this.logicalAND());
      }
      return left;
    },
    equality: function() {
      var left = this.relational();
      var token;
      if (token = this.expect("==", "!=", "===", "!==")) {
        left = this.binaryFn(left, token.fn, this.equality());
      }
      return left;
    },
    relational: function() {
      var left = this.additive();
      var token;
      if (token = this.expect("<", ">", "<=", ">=")) {
        left = this.binaryFn(left, token.fn, this.relational());
      }
      return left;
    },
    additive: function() {
      var left = this.multiplicative();
      var token;
      while (token = this.expect("+", "-")) {
        left = this.binaryFn(left, token.fn, this.multiplicative());
      }
      return left;
    },
    multiplicative: function() {
      var left = this.unary();
      var token;
      while (token = this.expect("*", "/", "%")) {
        left = this.binaryFn(left, token.fn, this.unary());
      }
      return left;
    },
    unary: function() {
      var token;
      if (this.expect("+")) {
        return this.primary();
      } else if (token = this.expect("-")) {
        return this.binaryFn(Parser.ZERO, token.fn, this.unary());
      } else if (token = this.expect("!")) {
        return this.unaryFn(token.fn, this.unary());
      } else {
        return this.primary();
      }
    },
    fieldAccess: function(object) {
      var parser = this;
      var field = this.expect().text;
      var getter = getterFn(field, this.options, this.text);
      return extend(function(scope, locals, self) {
        return getter(self || object(scope, locals));
      }, {
        assign: function(scope, value, locals) {
          var o = object(scope, locals);
          if (!o) object.assign(scope, o = {});
          return setter(o, field, value, parser.text, parser.options);
        }
      });
    },
    objectIndex: function(obj) {
      var parser = this;
      var indexFn = this.expression();
      this.consume("]");
      return extend(function(self, locals) {
        var o = obj(self, locals), i = indexFn(self, locals), v, p;
        ensureSafeMemberName(i, parser.text);
        if (!o) return undefined;
        v = ensureSafeObject(o[i], parser.text);
        if (v && v.then && parser.options.unwrapPromises) {
          p = v;
          if (!("$$v" in v)) {
            p.$$v = undefined;
            p.then(function(val) {
              p.$$v = val;
            });
          }
          v = v.$$v;
        }
        return v;
      }, {
        assign: function(self, value, locals) {
          var key = ensureSafeMemberName(indexFn(self, locals), parser.text);
          var o = ensureSafeObject(obj(self, locals), parser.text);
          if (!o) obj.assign(self, o = {});
          return o[key] = value;
        }
      });
    },
    functionCall: function(fn, contextGetter) {
      var argsFn = [];
      if (this.peekToken().text !== ")") {
        do {
          argsFn.push(this.expression());
        } while (this.expect(","));
      }
      this.consume(")");
      var parser = this;
      return function(scope, locals) {
        var args = [];
        var context = contextGetter ? contextGetter(scope, locals) : scope;
        for (var i = 0; i < argsFn.length; i++) {
          args.push(ensureSafeObject(argsFn[i](scope, locals), parser.text));
        }
        var fnPtr = fn(scope, locals, context) || noop;
        ensureSafeObject(context, parser.text);
        ensureSafeFunction(fnPtr, parser.text);
        var v = fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
        return ensureSafeObject(v, parser.text);
      };
    },
    arrayDeclaration: function() {
      var elementFns = [];
      var allConstant = true;
      if (this.peekToken().text !== "]") {
        do {
          if (this.peek("]")) {
            break;
          }
          var elementFn = this.expression();
          elementFns.push(elementFn);
          if (!elementFn.constant) {
            allConstant = false;
          }
        } while (this.expect(","));
      }
      this.consume("]");
      return extend(function(self, locals) {
        var array = [];
        for (var i = 0; i < elementFns.length; i++) {
          array.push(elementFns[i](self, locals));
        }
        return array;
      }, {
        literal: true,
        constant: allConstant
      });
    },
    object: function() {
      var keyValues = [];
      var allConstant = true;
      if (this.peekToken().text !== "}") {
        do {
          if (this.peek("}")) {
            break;
          }
          var token = this.expect(), key = token.string || token.text;
          this.consume(":");
          var value = this.expression();
          keyValues.push({
            key: key,
            value: value
          });
          if (!value.constant) {
            allConstant = false;
          }
        } while (this.expect(","));
      }
      this.consume("}");
      return extend(function(self, locals) {
        var object = {};
        for (var i = 0; i < keyValues.length; i++) {
          var keyValue = keyValues[i];
          object[keyValue.key] = keyValue.value(self, locals);
        }
        return object;
      }, {
        literal: true,
        constant: allConstant
      });
    }
  };
  function setter(obj, path, setValue, fullExp, options) {
    ensureSafeObject(obj, fullExp);
    options = options || {};
    var element = path.split("."), key;
    for (var i = 0; element.length > 1; i++) {
      key = ensureSafeMemberName(element.shift(), fullExp);
      var propertyObj = ensureSafeObject(obj[key], fullExp);
      if (!propertyObj) {
        propertyObj = {};
        obj[key] = propertyObj;
      }
      obj = propertyObj;
      if (obj.then && options.unwrapPromises) {
        promiseWarning(fullExp);
        if (!("$$v" in obj)) {
          (function(promise) {
            promise.then(function(val) {
              promise.$$v = val;
            });
          })(obj);
        }
        if (obj.$$v === undefined) {
          obj.$$v = {};
        }
        obj = obj.$$v;
      }
    }
    key = ensureSafeMemberName(element.shift(), fullExp);
    ensureSafeObject(obj[key], fullExp);
    obj[key] = setValue;
    return setValue;
  }
  var getterFnCache = {};
  function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {
    ensureSafeMemberName(key0, fullExp);
    ensureSafeMemberName(key1, fullExp);
    ensureSafeMemberName(key2, fullExp);
    ensureSafeMemberName(key3, fullExp);
    ensureSafeMemberName(key4, fullExp);
    return !options.unwrapPromises ? function cspSafeGetter(scope, locals) {
      var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
      if (pathVal == null) return pathVal;
      pathVal = pathVal[key0];
      if (!key1) return pathVal;
      if (pathVal == null) return undefined;
      pathVal = pathVal[key1];
      if (!key2) return pathVal;
      if (pathVal == null) return undefined;
      pathVal = pathVal[key2];
      if (!key3) return pathVal;
      if (pathVal == null) return undefined;
      pathVal = pathVal[key3];
      if (!key4) return pathVal;
      if (pathVal == null) return undefined;
      pathVal = pathVal[key4];
      return pathVal;
    } : function cspSafePromiseEnabledGetter(scope, locals) {
      var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope, promise;
      if (pathVal == null) return pathVal;
      pathVal = pathVal[key0];
      if (pathVal && pathVal.then) {
        promiseWarning(fullExp);
        if (!("$$v" in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function(val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key1) return pathVal;
      if (pathVal == null) return undefined;
      pathVal = pathVal[key1];
      if (pathVal && pathVal.then) {
        promiseWarning(fullExp);
        if (!("$$v" in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function(val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key2) return pathVal;
      if (pathVal == null) return undefined;
      pathVal = pathVal[key2];
      if (pathVal && pathVal.then) {
        promiseWarning(fullExp);
        if (!("$$v" in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function(val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key3) return pathVal;
      if (pathVal == null) return undefined;
      pathVal = pathVal[key3];
      if (pathVal && pathVal.then) {
        promiseWarning(fullExp);
        if (!("$$v" in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function(val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key4) return pathVal;
      if (pathVal == null) return undefined;
      pathVal = pathVal[key4];
      if (pathVal && pathVal.then) {
        promiseWarning(fullExp);
        if (!("$$v" in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function(val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      return pathVal;
    };
  }
  function getterFn(path, options, fullExp) {
    if (getterFnCache.hasOwnProperty(path)) {
      return getterFnCache[path];
    }
    var pathKeys = path.split("."), pathKeysLength = pathKeys.length, fn;
    if (options.csp) {
      if (pathKeysLength < 6) {
        fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, options);
      } else {
        fn = function(scope, locals) {
          var i = 0, val;
          do {
            val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, options)(scope, locals);
            locals = undefined;
            scope = val;
          } while (i < pathKeysLength);
          return val;
        };
      }
    } else {
      var code = "var p;\n";
      forEach(pathKeys, function(key, index) {
        ensureSafeMemberName(key, fullExp);
        code += "if(s == null) return undefined;\n" + "s=" + (index ? "s" : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ";\n" + (options.unwrapPromises ? "if (s && s.then) {\n" + ' pw("' + fullExp.replace(/(["\r\n])/g, "\\$1") + '");\n' + ' if (!("$$v" in s)) {\n' + " p=s;\n" + " p.$$v = undefined;\n" + " p.then(function(v) {p.$$v=v;});\n" + "}\n" + " s=s.$$v\n" + "}\n" : "");
      });
      code += "return s;";
      var evaledFnGetter = new Function("s", "k", "pw", code);
      evaledFnGetter.toString = valueFn(code);
      fn = options.unwrapPromises ? function(scope, locals) {
        return evaledFnGetter(scope, locals, promiseWarning);
      } : evaledFnGetter;
    }
    if (path !== "hasOwnProperty") {
      getterFnCache[path] = fn;
    }
    return fn;
  }
  function $ParseProvider() {
    var cache = {};
    var $parseOptions = {
      csp: false,
      unwrapPromises: false,
      logPromiseWarnings: true
    };
    this.unwrapPromises = function(value) {
      if (isDefined(value)) {
        $parseOptions.unwrapPromises = !!value;
        return this;
      } else {
        return $parseOptions.unwrapPromises;
      }
    };
    this.logPromiseWarnings = function(value) {
      if (isDefined(value)) {
        $parseOptions.logPromiseWarnings = value;
        return this;
      } else {
        return $parseOptions.logPromiseWarnings;
      }
    };
    this.$get = [ "$filter", "$sniffer", "$log", function($filter, $sniffer, $log) {
      $parseOptions.csp = $sniffer.csp;
      promiseWarning = function promiseWarningFn(fullExp) {
        if (!$parseOptions.logPromiseWarnings || promiseWarningCache.hasOwnProperty(fullExp)) return;
        promiseWarningCache[fullExp] = true;
        $log.warn("[$parse] Promise found in the expression `" + fullExp + "`. " + "Automatic unwrapping of promises in Angular expressions is deprecated.");
      };
      return function(exp) {
        var parsedExpression;
        switch (typeof exp) {
         case "string":
          if (cache.hasOwnProperty(exp)) {
            return cache[exp];
          }
          var lexer = new Lexer($parseOptions);
          var parser = new Parser(lexer, $filter, $parseOptions);
          parsedExpression = parser.parse(exp);
          if (exp !== "hasOwnProperty") {
            cache[exp] = parsedExpression;
          }
          return parsedExpression;

         case "function":
          return exp;

         default:
          return noop;
        }
      };
    } ];
  }
  function $QProvider() {
    this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
      return qFactory(function(callback) {
        $rootScope.$evalAsync(callback);
      }, $exceptionHandler);
    } ];
  }
  function qFactory(nextTick, exceptionHandler) {
    var defer = function() {
      var pending = [], value, deferred;
      deferred = {
        resolve: function(val) {
          if (pending) {
            var callbacks = pending;
            pending = undefined;
            value = ref(val);
            if (callbacks.length) {
              nextTick(function() {
                var callback;
                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                  callback = callbacks[i];
                  value.then(callback[0], callback[1], callback[2]);
                }
              });
            }
          }
        },
        reject: function(reason) {
          deferred.resolve(createInternalRejectedPromise(reason));
        },
        notify: function(progress) {
          if (pending) {
            var callbacks = pending;
            if (pending.length) {
              nextTick(function() {
                var callback;
                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                  callback = callbacks[i];
                  callback[2](progress);
                }
              });
            }
          }
        },
        promise: {
          then: function(callback, errback, progressback) {
            var result = defer();
            var wrappedCallback = function(value) {
              try {
                result.resolve((isFunction(callback) ? callback : defaultCallback)(value));
              } catch (e) {
                result.reject(e);
                exceptionHandler(e);
              }
            };
            var wrappedErrback = function(reason) {
              try {
                result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
              } catch (e) {
                result.reject(e);
                exceptionHandler(e);
              }
            };
            var wrappedProgressback = function(progress) {
              try {
                result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress));
              } catch (e) {
                exceptionHandler(e);
              }
            };
            if (pending) {
              pending.push([ wrappedCallback, wrappedErrback, wrappedProgressback ]);
            } else {
              value.then(wrappedCallback, wrappedErrback, wrappedProgressback);
            }
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback) {
            function makePromise(value, resolved) {
              var result = defer();
              if (resolved) {
                result.resolve(value);
              } else {
                result.reject(value);
              }
              return result.promise;
            }
            function handleCallback(value, isResolved) {
              var callbackOutput = null;
              try {
                callbackOutput = (callback || defaultCallback)();
              } catch (e) {
                return makePromise(e, false);
              }
              if (isPromiseLike(callbackOutput)) {
                return callbackOutput.then(function() {
                  return makePromise(value, isResolved);
                }, function(error) {
                  return makePromise(error, false);
                });
              } else {
                return makePromise(value, isResolved);
              }
            }
            return this.then(function(value) {
              return handleCallback(value, true);
            }, function(error) {
              return handleCallback(error, false);
            });
          }
        }
      };
      return deferred;
    };
    var ref = function(value) {
      if (isPromiseLike(value)) return value;
      return {
        then: function(callback) {
          var result = defer();
          nextTick(function() {
            result.resolve(callback(value));
          });
          return result.promise;
        }
      };
    };
    var reject = function(reason) {
      var result = defer();
      result.reject(reason);
      return result.promise;
    };
    var createInternalRejectedPromise = function(reason) {
      return {
        then: function(callback, errback) {
          var result = defer();
          nextTick(function() {
            try {
              result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
            } catch (e) {
              result.reject(e);
              exceptionHandler(e);
            }
          });
          return result.promise;
        }
      };
    };
    var when = function(value, callback, errback, progressback) {
      var result = defer(), done;
      var wrappedCallback = function(value) {
        try {
          return (isFunction(callback) ? callback : defaultCallback)(value);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      var wrappedErrback = function(reason) {
        try {
          return (isFunction(errback) ? errback : defaultErrback)(reason);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      var wrappedProgressback = function(progress) {
        try {
          return (isFunction(progressback) ? progressback : defaultCallback)(progress);
        } catch (e) {
          exceptionHandler(e);
        }
      };
      nextTick(function() {
        ref(value).then(function(value) {
          if (done) return;
          done = true;
          result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback));
        }, function(reason) {
          if (done) return;
          done = true;
          result.resolve(wrappedErrback(reason));
        }, function(progress) {
          if (done) return;
          result.notify(wrappedProgressback(progress));
        });
      });
      return result.promise;
    };
    function defaultCallback(value) {
      return value;
    }
    function defaultErrback(reason) {
      return reject(reason);
    }
    function all(promises) {
      var deferred = defer(), counter = 0, results = isArray(promises) ? [] : {};
      forEach(promises, function(promise, key) {
        counter++;
        ref(promise).then(function(value) {
          if (results.hasOwnProperty(key)) return;
          results[key] = value;
          if (!--counter) deferred.resolve(results);
        }, function(reason) {
          if (results.hasOwnProperty(key)) return;
          deferred.reject(reason);
        });
      });
      if (counter === 0) {
        deferred.resolve(results);
      }
      return deferred.promise;
    }
    return {
      defer: defer,
      reject: reject,
      when: when,
      all: all
    };
  }
  function $$RAFProvider() {
    this.$get = [ "$window", "$timeout", function($window, $timeout) {
      var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
      var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.mozCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
      var rafSupported = !!requestAnimationFrame;
      var raf = rafSupported ? function(fn) {
        var id = requestAnimationFrame(fn);
        return function() {
          cancelAnimationFrame(id);
        };
      } : function(fn) {
        var timer = $timeout(fn, 16.66, false);
        return function() {
          $timeout.cancel(timer);
        };
      };
      raf.supported = rafSupported;
      return raf;
    } ];
  }
  function $RootScopeProvider() {
    var TTL = 10;
    var $rootScopeMinErr = minErr("$rootScope");
    var lastDirtyWatch = null;
    this.digestTtl = function(value) {
      if (arguments.length) {
        TTL = value;
      }
      return TTL;
    };
    this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
      function Scope() {
        this.$id = nextUid();
        this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
        this["this"] = this.$root = this;
        this.$$destroyed = false;
        this.$$asyncQueue = [];
        this.$$postDigestQueue = [];
        this.$$listeners = {};
        this.$$listenerCount = {};
        this.$$isolateBindings = {};
      }
      Scope.prototype = {
        constructor: Scope,
        $new: function(isolate) {
          var ChildScope, child;
          if (isolate) {
            child = new Scope();
            child.$root = this.$root;
            child.$$asyncQueue = this.$$asyncQueue;
            child.$$postDigestQueue = this.$$postDigestQueue;
          } else {
            if (!this.$$childScopeClass) {
              this.$$childScopeClass = function() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$id = nextUid();
                this.$$childScopeClass = null;
              };
              this.$$childScopeClass.prototype = this;
            }
            child = new this.$$childScopeClass();
          }
          child["this"] = child;
          child.$parent = this;
          child.$$prevSibling = this.$$childTail;
          if (this.$$childHead) {
            this.$$childTail.$$nextSibling = child;
            this.$$childTail = child;
          } else {
            this.$$childHead = this.$$childTail = child;
          }
          return child;
        },
        $watch: function(watchExp, listener, objectEquality) {
          var scope = this, get = compileToFn(watchExp, "watch"), array = scope.$$watchers, watcher = {
            fn: listener,
            last: initWatchVal,
            get: get,
            exp: watchExp,
            eq: !!objectEquality
          };
          lastDirtyWatch = null;
          if (!isFunction(listener)) {
            var listenFn = compileToFn(listener || noop, "listener");
            watcher.fn = function(newVal, oldVal, scope) {
              listenFn(scope);
            };
          }
          if (typeof watchExp == "string" && get.constant) {
            var originalFn = watcher.fn;
            watcher.fn = function(newVal, oldVal, scope) {
              originalFn.call(this, newVal, oldVal, scope);
              arrayRemove(array, watcher);
            };
          }
          if (!array) {
            array = scope.$$watchers = [];
          }
          array.unshift(watcher);
          return function deregisterWatch() {
            arrayRemove(array, watcher);
            lastDirtyWatch = null;
          };
        },
        $watchCollection: function(obj, listener) {
          var self = this;
          var newValue;
          var oldValue;
          var veryOldValue;
          var trackVeryOldValue = listener.length > 1;
          var changeDetected = 0;
          var objGetter = $parse(obj);
          var internalArray = [];
          var internalObject = {};
          var initRun = true;
          var oldLength = 0;
          function $watchCollectionWatch() {
            newValue = objGetter(self);
            var newLength, key, bothNaN;
            if (!isObject(newValue)) {
              if (oldValue !== newValue) {
                oldValue = newValue;
                changeDetected++;
              }
            } else if (isArrayLike(newValue)) {
              if (oldValue !== internalArray) {
                oldValue = internalArray;
                oldLength = oldValue.length = 0;
                changeDetected++;
              }
              newLength = newValue.length;
              if (oldLength !== newLength) {
                changeDetected++;
                oldValue.length = oldLength = newLength;
              }
              for (var i = 0; i < newLength; i++) {
                bothNaN = oldValue[i] !== oldValue[i] && newValue[i] !== newValue[i];
                if (!bothNaN && oldValue[i] !== newValue[i]) {
                  changeDetected++;
                  oldValue[i] = newValue[i];
                }
              }
            } else {
              if (oldValue !== internalObject) {
                oldValue = internalObject = {};
                oldLength = 0;
                changeDetected++;
              }
              newLength = 0;
              for (key in newValue) {
                if (newValue.hasOwnProperty(key)) {
                  newLength++;
                  if (oldValue.hasOwnProperty(key)) {
                    bothNaN = oldValue[key] !== oldValue[key] && newValue[key] !== newValue[key];
                    if (!bothNaN && oldValue[key] !== newValue[key]) {
                      changeDetected++;
                      oldValue[key] = newValue[key];
                    }
                  } else {
                    oldLength++;
                    oldValue[key] = newValue[key];
                    changeDetected++;
                  }
                }
              }
              if (oldLength > newLength) {
                changeDetected++;
                for (key in oldValue) {
                  if (oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key)) {
                    oldLength--;
                    delete oldValue[key];
                  }
                }
              }
            }
            return changeDetected;
          }
          function $watchCollectionAction() {
            if (initRun) {
              initRun = false;
              listener(newValue, newValue, self);
            } else {
              listener(newValue, veryOldValue, self);
            }
            if (trackVeryOldValue) {
              if (!isObject(newValue)) {
                veryOldValue = newValue;
              } else if (isArrayLike(newValue)) {
                veryOldValue = new Array(newValue.length);
                for (var i = 0; i < newValue.length; i++) {
                  veryOldValue[i] = newValue[i];
                }
              } else {
                veryOldValue = {};
                for (var key in newValue) {
                  if (hasOwnProperty.call(newValue, key)) {
                    veryOldValue[key] = newValue[key];
                  }
                }
              }
            }
          }
          return this.$watch($watchCollectionWatch, $watchCollectionAction);
        },
        $digest: function() {
          var watch, value, last, watchers, asyncQueue = this.$$asyncQueue, postDigestQueue = this.$$postDigestQueue, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg, asyncTask;
          beginPhase("$digest");
          $browser.$$checkUrlChange();
          lastDirtyWatch = null;
          do {
            dirty = false;
            current = target;
            while (asyncQueue.length) {
              try {
                asyncTask = asyncQueue.shift();
                asyncTask.scope.$eval(asyncTask.expression);
              } catch (e) {
                clearPhase();
                $exceptionHandler(e);
              }
              lastDirtyWatch = null;
            }
            traverseScopesLoop: do {
              if (watchers = current.$$watchers) {
                length = watchers.length;
                while (length--) {
                  try {
                    watch = watchers[length];
                    if (watch) {
                      if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value === "number" && typeof last === "number" && isNaN(value) && isNaN(last))) {
                        dirty = true;
                        lastDirtyWatch = watch;
                        watch.last = watch.eq ? copy(value, null) : value;
                        watch.fn(value, last === initWatchVal ? value : last, current);
                        if (ttl < 5) {
                          logIdx = 4 - ttl;
                          if (!watchLog[logIdx]) watchLog[logIdx] = [];
                          logMsg = isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp;
                          logMsg += "; newVal: " + toJson(value) + "; oldVal: " + toJson(last);
                          watchLog[logIdx].push(logMsg);
                        }
                      } else if (watch === lastDirtyWatch) {
                        dirty = false;
                        break traverseScopesLoop;
                      }
                    }
                  } catch (e) {
                    clearPhase();
                    $exceptionHandler(e);
                  }
                }
              }
              if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                while (current !== target && !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            } while (current = next);
            if ((dirty || asyncQueue.length) && !ttl--) {
              clearPhase();
              throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, toJson(watchLog));
            }
          } while (dirty || asyncQueue.length);
          clearPhase();
          while (postDigestQueue.length) {
            try {
              postDigestQueue.shift()();
            } catch (e) {
              $exceptionHandler(e);
            }
          }
        },
        $destroy: function() {
          if (this.$$destroyed) return;
          var parent = this.$parent;
          this.$broadcast("$destroy");
          this.$$destroyed = true;
          if (this === $rootScope) return;
          forEach(this.$$listenerCount, bind(null, decrementListenerCount, this));
          if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
          if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
          if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
          if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
          this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = null;
          this.$$listeners = {};
          this.$$watchers = this.$$asyncQueue = this.$$postDigestQueue = [];
          this.$destroy = this.$digest = this.$apply = noop;
          this.$on = this.$watch = function() {
            return noop;
          };
        },
        $eval: function(expr, locals) {
          return $parse(expr)(this, locals);
        },
        $evalAsync: function(expr) {
          if (!$rootScope.$$phase && !$rootScope.$$asyncQueue.length) {
            $browser.defer(function() {
              if ($rootScope.$$asyncQueue.length) {
                $rootScope.$digest();
              }
            });
          }
          this.$$asyncQueue.push({
            scope: this,
            expression: expr
          });
        },
        $$postDigest: function(fn) {
          this.$$postDigestQueue.push(fn);
        },
        $apply: function(expr) {
          try {
            beginPhase("$apply");
            return this.$eval(expr);
          } catch (e) {
            $exceptionHandler(e);
          } finally {
            clearPhase();
            try {
              $rootScope.$digest();
            } catch (e) {
              $exceptionHandler(e);
              throw e;
            }
          }
        },
        $on: function(name, listener) {
          var namedListeners = this.$$listeners[name];
          if (!namedListeners) {
            this.$$listeners[name] = namedListeners = [];
          }
          namedListeners.push(listener);
          var current = this;
          do {
            if (!current.$$listenerCount[name]) {
              current.$$listenerCount[name] = 0;
            }
            current.$$listenerCount[name]++;
          } while (current = current.$parent);
          var self = this;
          return function() {
            namedListeners[indexOf(namedListeners, listener)] = null;
            decrementListenerCount(self, 1, name);
          };
        },
        $emit: function(name, args) {
          var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
            name: name,
            targetScope: scope,
            stopPropagation: function() {
              stopPropagation = true;
            },
            preventDefault: function() {
              event.defaultPrevented = true;
            },
            defaultPrevented: false
          }, listenerArgs = concat([ event ], arguments, 1), i, length;
          do {
            namedListeners = scope.$$listeners[name] || empty;
            event.currentScope = scope;
            for (i = 0, length = namedListeners.length; i < length; i++) {
              if (!namedListeners[i]) {
                namedListeners.splice(i, 1);
                i--;
                length--;
                continue;
              }
              try {
                namedListeners[i].apply(null, listenerArgs);
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            if (stopPropagation) return event;
            scope = scope.$parent;
          } while (scope);
          return event;
        },
        $broadcast: function(name, args) {
          var target = this, current = target, next = target, event = {
            name: name,
            targetScope: target,
            preventDefault: function() {
              event.defaultPrevented = true;
            },
            defaultPrevented: false
          }, listenerArgs = concat([ event ], arguments, 1), listeners, i, length;
          while (current = next) {
            event.currentScope = current;
            listeners = current.$$listeners[name] || [];
            for (i = 0, length = listeners.length; i < length; i++) {
              if (!listeners[i]) {
                listeners.splice(i, 1);
                i--;
                length--;
                continue;
              }
              try {
                listeners[i].apply(null, listenerArgs);
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
              while (current !== target && !(next = current.$$nextSibling)) {
                current = current.$parent;
              }
            }
          }
          return event;
        }
      };
      var $rootScope = new Scope();
      return $rootScope;
      function beginPhase(phase) {
        if ($rootScope.$$phase) {
          throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
        }
        $rootScope.$$phase = phase;
      }
      function clearPhase() {
        $rootScope.$$phase = null;
      }
      function compileToFn(exp, name) {
        var fn = $parse(exp);
        assertArgFn(fn, name);
        return fn;
      }
      function decrementListenerCount(current, count, name) {
        do {
          current.$$listenerCount[name] -= count;
          if (current.$$listenerCount[name] === 0) {
            delete current.$$listenerCount[name];
          }
        } while (current = current.$parent);
      }
      function initWatchVal() {}
    } ];
  }
  function $$SanitizeUriProvider() {
    var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file):|data:image\/)/;
    this.aHrefSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        aHrefSanitizationWhitelist = regexp;
        return this;
      }
      return aHrefSanitizationWhitelist;
    };
    this.imgSrcSanitizationWhitelist = function(regexp) {
      if (isDefined(regexp)) {
        imgSrcSanitizationWhitelist = regexp;
        return this;
      }
      return imgSrcSanitizationWhitelist;
    };
    this.$get = function() {
      return function sanitizeUri(uri, isImage) {
        var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
        var normalizedVal;
        if (!msie || msie >= 8) {
          normalizedVal = urlResolve(uri).href;
          if (normalizedVal !== "" && !normalizedVal.match(regex)) {
            return "unsafe:" + normalizedVal;
          }
        }
        return uri;
      };
    };
  }
  var $sceMinErr = minErr("$sce");
  var SCE_CONTEXTS = {
    HTML: "html",
    CSS: "css",
    URL: "url",
    RESOURCE_URL: "resourceUrl",
    JS: "js"
  };
  function escapeForRegexp(s) {
    return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
  }
  function adjustMatcher(matcher) {
    if (matcher === "self") {
      return matcher;
    } else if (isString(matcher)) {
      if (matcher.indexOf("***") > -1) {
        throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
      }
      matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*");
      return new RegExp("^" + matcher + "$");
    } else if (isRegExp(matcher)) {
      return new RegExp("^" + matcher.source + "$");
    } else {
      throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
    }
  }
  function adjustMatchers(matchers) {
    var adjustedMatchers = [];
    if (isDefined(matchers)) {
      forEach(matchers, function(matcher) {
        adjustedMatchers.push(adjustMatcher(matcher));
      });
    }
    return adjustedMatchers;
  }
  function $SceDelegateProvider() {
    this.SCE_CONTEXTS = SCE_CONTEXTS;
    var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
    this.resourceUrlWhitelist = function(value) {
      if (arguments.length) {
        resourceUrlWhitelist = adjustMatchers(value);
      }
      return resourceUrlWhitelist;
    };
    this.resourceUrlBlacklist = function(value) {
      if (arguments.length) {
        resourceUrlBlacklist = adjustMatchers(value);
      }
      return resourceUrlBlacklist;
    };
    this.$get = [ "$injector", function($injector) {
      var htmlSanitizer = function htmlSanitizer(html) {
        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
      };
      if ($injector.has("$sanitize")) {
        htmlSanitizer = $injector.get("$sanitize");
      }
      function matchUrl(matcher, parsedUrl) {
        if (matcher === "self") {
          return urlIsSameOrigin(parsedUrl);
        } else {
          return !!matcher.exec(parsedUrl.href);
        }
      }
      function isResourceUrlAllowedByPolicy(url) {
        var parsedUrl = urlResolve(url.toString());
        var i, n, allowed = false;
        for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
          if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
            allowed = true;
            break;
          }
        }
        if (allowed) {
          for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
            if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
              allowed = false;
              break;
            }
          }
        }
        return allowed;
      }
      function generateHolderType(Base) {
        var holderType = function TrustedValueHolderType(trustedValue) {
          this.$$unwrapTrustedValue = function() {
            return trustedValue;
          };
        };
        if (Base) {
          holderType.prototype = new Base();
        }
        holderType.prototype.valueOf = function sceValueOf() {
          return this.$$unwrapTrustedValue();
        };
        holderType.prototype.toString = function sceToString() {
          return this.$$unwrapTrustedValue().toString();
        };
        return holderType;
      }
      var trustedValueHolderBase = generateHolderType(), byType = {};
      byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
      byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
      function trustAs(type, trustedValue) {
        var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
        if (!Constructor) {
          throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
        }
        if (trustedValue === null || trustedValue === undefined || trustedValue === "") {
          return trustedValue;
        }
        if (typeof trustedValue !== "string") {
          throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
        }
        return new Constructor(trustedValue);
      }
      function valueOf(maybeTrusted) {
        if (maybeTrusted instanceof trustedValueHolderBase) {
          return maybeTrusted.$$unwrapTrustedValue();
        } else {
          return maybeTrusted;
        }
      }
      function getTrusted(type, maybeTrusted) {
        if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === "") {
          return maybeTrusted;
        }
        var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
        if (constructor && maybeTrusted instanceof constructor) {
          return maybeTrusted.$$unwrapTrustedValue();
        }
        if (type === SCE_CONTEXTS.RESOURCE_URL) {
          if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
            return maybeTrusted;
          } else {
            throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
          }
        } else if (type === SCE_CONTEXTS.HTML) {
          return htmlSanitizer(maybeTrusted);
        }
        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
      }
      return {
        trustAs: trustAs,
        getTrusted: getTrusted,
        valueOf: valueOf
      };
    } ];
  }
  function $SceProvider() {
    var enabled = true;
    this.enabled = function(value) {
      if (arguments.length) {
        enabled = !!value;
      }
      return enabled;
    };
    this.$get = [ "$parse", "$sniffer", "$sceDelegate", function($parse, $sniffer, $sceDelegate) {
      if (enabled && $sniffer.msie && $sniffer.msieDocumentMode < 8) {
        throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks " + "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " + "document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
      }
      var sce = shallowCopy(SCE_CONTEXTS);
      sce.isEnabled = function() {
        return enabled;
      };
      sce.trustAs = $sceDelegate.trustAs;
      sce.getTrusted = $sceDelegate.getTrusted;
      sce.valueOf = $sceDelegate.valueOf;
      if (!enabled) {
        sce.trustAs = sce.getTrusted = function(type, value) {
          return value;
        };
        sce.valueOf = identity;
      }
      sce.parseAs = function sceParseAs(type, expr) {
        var parsed = $parse(expr);
        if (parsed.literal && parsed.constant) {
          return parsed;
        } else {
          return function sceParseAsTrusted(self, locals) {
            return sce.getTrusted(type, parsed(self, locals));
          };
        }
      };
      var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
      forEach(SCE_CONTEXTS, function(enumValue, name) {
        var lName = lowercase(name);
        sce[camelCase("parse_as_" + lName)] = function(expr) {
          return parse(enumValue, expr);
        };
        sce[camelCase("get_trusted_" + lName)] = function(value) {
          return getTrusted(enumValue, value);
        };
        sce[camelCase("trust_as_" + lName)] = function(value) {
          return trustAs(enumValue, value);
        };
      });
      return sce;
    } ];
  }
  function $SnifferProvider() {
    this.$get = [ "$window", "$document", function($window, $document) {
      var eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, documentMode = document.documentMode, vendorPrefix, vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = false, animations = false, match;
      if (bodyStyle) {
        for (var prop in bodyStyle) {
          if (match = vendorRegex.exec(prop)) {
            vendorPrefix = match[0];
            vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
            break;
          }
        }
        if (!vendorPrefix) {
          vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit";
        }
        transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle);
        animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle);
        if (android && (!transitions || !animations)) {
          transitions = isString(document.body.style.webkitTransition);
          animations = isString(document.body.style.webkitAnimation);
        }
      }
      return {
        history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
        hashchange: "onhashchange" in $window && (!documentMode || documentMode > 7),
        hasEvent: function(event) {
          if (event == "input" && msie == 9) return false;
          if (isUndefined(eventSupport[event])) {
            var divElm = document.createElement("div");
            eventSupport[event] = "on" + event in divElm;
          }
          return eventSupport[event];
        },
        csp: csp(),
        vendorPrefix: vendorPrefix,
        transitions: transitions,
        animations: animations,
        android: android,
        msie: msie,
        msieDocumentMode: documentMode
      };
    } ];
  }
  function $TimeoutProvider() {
    this.$get = [ "$rootScope", "$browser", "$q", "$exceptionHandler", function($rootScope, $browser, $q, $exceptionHandler) {
      var deferreds = {};
      function timeout(fn, delay, invokeApply) {
        var deferred = $q.defer(), promise = deferred.promise, skipApply = isDefined(invokeApply) && !invokeApply, timeoutId;
        timeoutId = $browser.defer(function() {
          try {
            deferred.resolve(fn());
          } catch (e) {
            deferred.reject(e);
            $exceptionHandler(e);
          } finally {
            delete deferreds[promise.$$timeoutId];
          }
          if (!skipApply) $rootScope.$apply();
        }, delay);
        promise.$$timeoutId = timeoutId;
        deferreds[timeoutId] = deferred;
        return promise;
      }
      timeout.cancel = function(promise) {
        if (promise && promise.$$timeoutId in deferreds) {
          deferreds[promise.$$timeoutId].reject("canceled");
          delete deferreds[promise.$$timeoutId];
          return $browser.defer.cancel(promise.$$timeoutId);
        }
        return false;
      };
      return timeout;
    } ];
  }
  var urlParsingNode = document.createElement("a");
  var originUrl = urlResolve(window.location.href, true);
  function urlResolve(url, base) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  function urlIsSameOrigin(requestUrl) {
    var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
    return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
  }
  function $WindowProvider() {
    this.$get = valueFn(window);
  }
  $FilterProvider.$inject = [ "$provide" ];
  function $FilterProvider($provide) {
    var suffix = "Filter";
    function register(name, factory) {
      if (isObject(name)) {
        var filters = {};
        forEach(name, function(filter, key) {
          filters[key] = register(key, filter);
        });
        return filters;
      } else {
        return $provide.factory(name + suffix, factory);
      }
    }
    this.register = register;
    this.$get = [ "$injector", function($injector) {
      return function(name) {
        return $injector.get(name + suffix);
      };
    } ];
    register("currency", currencyFilter);
    register("date", dateFilter);
    register("filter", filterFilter);
    register("json", jsonFilter);
    register("limitTo", limitToFilter);
    register("lowercase", lowercaseFilter);
    register("number", numberFilter);
    register("orderBy", orderByFilter);
    register("uppercase", uppercaseFilter);
  }
  function filterFilter() {
    return function(array, expression, comparator) {
      if (!isArray(array)) return array;
      var comparatorType = typeof comparator, predicates = [];
      predicates.check = function(value) {
        for (var j = 0; j < predicates.length; j++) {
          if (!predicates[j](value)) {
            return false;
          }
        }
        return true;
      };
      if (comparatorType !== "function") {
        if (comparatorType === "boolean" && comparator) {
          comparator = function(obj, text) {
            return angular.equals(obj, text);
          };
        } else {
          comparator = function(obj, text) {
            if (obj && text && typeof obj === "object" && typeof text === "object") {
              for (var objKey in obj) {
                if (objKey.charAt(0) !== "$" && hasOwnProperty.call(obj, objKey) && comparator(obj[objKey], text[objKey])) {
                  return true;
                }
              }
              return false;
            }
            text = ("" + text).toLowerCase();
            return ("" + obj).toLowerCase().indexOf(text) > -1;
          };
        }
      }
      var search = function(obj, text) {
        if (typeof text == "string" && text.charAt(0) === "!") {
          return !search(obj, text.substr(1));
        }
        switch (typeof obj) {
         case "boolean":
         case "number":
         case "string":
          return comparator(obj, text);

         case "object":
          switch (typeof text) {
           case "object":
            return comparator(obj, text);

           default:
            for (var objKey in obj) {
              if (objKey.charAt(0) !== "$" && search(obj[objKey], text)) {
                return true;
              }
            }
            break;
          }
          return false;

         case "array":
          for (var i = 0; i < obj.length; i++) {
            if (search(obj[i], text)) {
              return true;
            }
          }
          return false;

         default:
          return false;
        }
      };
      switch (typeof expression) {
       case "boolean":
       case "number":
       case "string":
        expression = {
          $: expression
        };

       case "object":
        for (var key in expression) {
          (function(path) {
            if (typeof expression[path] === "undefined") return;
            predicates.push(function(value) {
              return search(path == "$" ? value : value && value[path], expression[path]);
            });
          })(key);
        }
        break;

       case "function":
        predicates.push(expression);
        break;

       default:
        return array;
      }
      var filtered = [];
      for (var j = 0; j < array.length; j++) {
        var value = array[j];
        if (predicates.check(value)) {
          filtered.push(value);
        }
      }
      return filtered;
    };
  }
  currencyFilter.$inject = [ "$locale" ];
  function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function(amount, currencySymbol) {
      if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;
      return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol);
    };
  }
  numberFilter.$inject = [ "$locale" ];
  function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function(number, fractionSize) {
      return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
    };
  }
  var DECIMAL_SEP = ".";
  function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (number == null || !isFinite(number) || isObject(number)) return "";
    var isNegative = number < 0;
    number = Math.abs(number);
    var numStr = number + "", formatedText = "", parts = [];
    var hasExponent = false;
    if (numStr.indexOf("e") !== -1) {
      var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
      if (match && match[2] == "-" && match[3] > fractionSize + 1) {
        numStr = "0";
        number = 0;
      } else {
        formatedText = numStr;
        hasExponent = true;
      }
    }
    if (!hasExponent) {
      var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
      if (isUndefined(fractionSize)) {
        fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
      }
      number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
      if (number === 0) {
        isNegative = false;
      }
      var fraction = ("" + number).split(DECIMAL_SEP);
      var whole = fraction[0];
      fraction = fraction[1] || "";
      var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
      if (whole.length >= lgroup + group) {
        pos = whole.length - lgroup;
        for (i = 0; i < pos; i++) {
          if ((pos - i) % group === 0 && i !== 0) {
            formatedText += groupSep;
          }
          formatedText += whole.charAt(i);
        }
      }
      for (i = pos; i < whole.length; i++) {
        if ((whole.length - i) % lgroup === 0 && i !== 0) {
          formatedText += groupSep;
        }
        formatedText += whole.charAt(i);
      }
      while (fraction.length < fractionSize) {
        fraction += "0";
      }
      if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
    } else {
      if (fractionSize > 0 && number > -1 && number < 1) {
        formatedText = number.toFixed(fractionSize);
      }
    }
    parts.push(isNegative ? pattern.negPre : pattern.posPre);
    parts.push(formatedText);
    parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
    return parts.join("");
  }
  function padNumber(num, digits, trim) {
    var neg = "";
    if (num < 0) {
      neg = "-";
      num = -num;
    }
    num = "" + num;
    while (num.length < digits) num = "0" + num;
    if (trim) num = num.substr(num.length - digits);
    return neg + num;
  }
  function dateGetter(name, size, offset, trim) {
    offset = offset || 0;
    return function(date) {
      var value = date["get" + name]();
      if (offset > 0 || value > -offset) value += offset;
      if (value === 0 && offset == -12) value = 12;
      return padNumber(value, size, trim);
    };
  }
  function dateStrGetter(name, shortForm) {
    return function(date, formats) {
      var value = date["get" + name]();
      var get = uppercase(shortForm ? "SHORT" + name : name);
      return formats[get][value];
    };
  }
  function timeZoneGetter(date) {
    var zone = -1 * date.getTimezoneOffset();
    var paddedZone = zone >= 0 ? "+" : "";
    paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
  }
  function ampmGetter(date, formats) {
    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
  }
  var DATE_FORMATS = {
    yyyy: dateGetter("FullYear", 4),
    yy: dateGetter("FullYear", 2, 0, true),
    y: dateGetter("FullYear", 1),
    MMMM: dateStrGetter("Month"),
    MMM: dateStrGetter("Month", true),
    MM: dateGetter("Month", 2, 1),
    M: dateGetter("Month", 1, 1),
    dd: dateGetter("Date", 2),
    d: dateGetter("Date", 1),
    HH: dateGetter("Hours", 2),
    H: dateGetter("Hours", 1),
    hh: dateGetter("Hours", 2, -12),
    h: dateGetter("Hours", 1, -12),
    mm: dateGetter("Minutes", 2),
    m: dateGetter("Minutes", 1),
    ss: dateGetter("Seconds", 2),
    s: dateGetter("Seconds", 1),
    sss: dateGetter("Milliseconds", 3),
    EEEE: dateStrGetter("Day"),
    EEE: dateStrGetter("Day", true),
    a: ampmGetter,
    Z: timeZoneGetter
  };
  var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, NUMBER_STRING = /^\-?\d+$/;
  dateFilter.$inject = [ "$locale" ];
  function dateFilter($locale) {
    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    function jsonStringToDate(string) {
      var match;
      if (match = string.match(R_ISO8601_STR)) {
        var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
        if (match[9]) {
          tzHour = int(match[9] + match[10]);
          tzMin = int(match[9] + match[11]);
        }
        dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
        var h = int(match[4] || 0) - tzHour;
        var m = int(match[5] || 0) - tzMin;
        var s = int(match[6] || 0);
        var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
        timeSetter.call(date, h, m, s, ms);
        return date;
      }
      return string;
    }
    return function(date, format) {
      var text = "", parts = [], fn, match;
      format = format || "mediumDate";
      format = $locale.DATETIME_FORMATS[format] || format;
      if (isString(date)) {
        date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date);
      }
      if (isNumber(date)) {
        date = new Date(date);
      }
      if (!isDate(date)) {
        return date;
      }
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      forEach(parts, function(value) {
        fn = DATE_FORMATS[value];
        text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
      });
      return text;
    };
  }
  function jsonFilter() {
    return function(object) {
      return toJson(object, true);
    };
  }
  var lowercaseFilter = valueFn(lowercase);
  var uppercaseFilter = valueFn(uppercase);
  function limitToFilter() {
    return function(input, limit) {
      if (!isArray(input) && !isString(input)) return input;
      if (Math.abs(Number(limit)) === Infinity) {
        limit = Number(limit);
      } else {
        limit = int(limit);
      }
      if (isString(input)) {
        if (limit) {
          return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
        } else {
          return "";
        }
      }
      var out = [], i, n;
      if (limit > input.length) limit = input.length; else if (limit < -input.length) limit = -input.length;
      if (limit > 0) {
        i = 0;
        n = limit;
      } else {
        i = input.length + limit;
        n = input.length;
      }
      for (;i < n; i++) {
        out.push(input[i]);
      }
      return out;
    };
  }
  orderByFilter.$inject = [ "$parse" ];
  function orderByFilter($parse) {
    return function(array, sortPredicate, reverseOrder) {
      if (!isArrayLike(array)) return array;
      if (!sortPredicate) return array;
      sortPredicate = isArray(sortPredicate) ? sortPredicate : [ sortPredicate ];
      sortPredicate = map(sortPredicate, function(predicate) {
        var descending = false, get = predicate || identity;
        if (isString(predicate)) {
          if (predicate.charAt(0) == "+" || predicate.charAt(0) == "-") {
            descending = predicate.charAt(0) == "-";
            predicate = predicate.substring(1);
          }
          get = $parse(predicate);
          if (get.constant) {
            var key = get();
            return reverseComparator(function(a, b) {
              return compare(a[key], b[key]);
            }, descending);
          }
        }
        return reverseComparator(function(a, b) {
          return compare(get(a), get(b));
        }, descending);
      });
      var arrayCopy = [];
      for (var i = 0; i < array.length; i++) {
        arrayCopy.push(array[i]);
      }
      return arrayCopy.sort(reverseComparator(comparator, reverseOrder));
      function comparator(o1, o2) {
        for (var i = 0; i < sortPredicate.length; i++) {
          var comp = sortPredicate[i](o1, o2);
          if (comp !== 0) return comp;
        }
        return 0;
      }
      function reverseComparator(comp, descending) {
        return toBoolean(descending) ? function(a, b) {
          return comp(b, a);
        } : comp;
      }
      function compare(v1, v2) {
        var t1 = typeof v1;
        var t2 = typeof v2;
        if (t1 == t2) {
          if (isDate(v1) && isDate(v2)) {
            v1 = v1.valueOf();
            v2 = v2.valueOf();
          }
          if (t1 == "string") {
            v1 = v1.toLowerCase();
            v2 = v2.toLowerCase();
          }
          if (v1 === v2) return 0;
          return v1 < v2 ? -1 : 1;
        } else {
          return t1 < t2 ? -1 : 1;
        }
      }
    };
  }
  function ngDirective(directive) {
    if (isFunction(directive)) {
      directive = {
        link: directive
      };
    }
    directive.restrict = directive.restrict || "AC";
    return valueFn(directive);
  }
  var htmlAnchorDirective = valueFn({
    restrict: "E",
    compile: function(element, attr) {
      if (msie <= 8) {
        if (!attr.href && !attr.name) {
          attr.$set("href", "");
        }
        element.append(document.createComment("IE fix"));
      }
      if (!attr.href && !attr.xlinkHref && !attr.name) {
        return function(scope, element) {
          var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
          element.on("click", function(event) {
            if (!element.attr(href)) {
              event.preventDefault();
            }
          });
        };
      }
    }
  });
  var ngAttributeAliasDirectives = {};
  forEach(BOOLEAN_ATTR, function(propName, attrName) {
    if (propName == "multiple") return;
    var normalized = directiveNormalize("ng-" + attrName);
    ngAttributeAliasDirectives[normalized] = function() {
      return {
        priority: 100,
        link: function(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
      };
    };
  });
  forEach([ "src", "srcset", "href" ], function(attrName) {
    var normalized = directiveNormalize("ng-" + attrName);
    ngAttributeAliasDirectives[normalized] = function() {
      return {
        priority: 99,
        link: function(scope, element, attr) {
          var propName = attrName, name = attrName;
          if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
            name = "xlinkHref";
            attr.$attr[name] = "xlink:href";
            propName = null;
          }
          attr.$observe(normalized, function(value) {
            if (!value) {
              if (attrName === "href") {
                attr.$set(name, null);
              }
              return;
            }
            attr.$set(name, value);
            if (msie && propName) element.prop(propName, attr[name]);
          });
        }
      };
    };
  });
  var nullFormCtrl = {
    $addControl: noop,
    $removeControl: noop,
    $setValidity: noop,
    $setDirty: noop,
    $setPristine: noop
  };
  FormController.$inject = [ "$element", "$attrs", "$scope", "$animate" ];
  function FormController(element, attrs, $scope, $animate) {
    var form = this, parentForm = element.parent().controller("form") || nullFormCtrl, invalidCount = 0, errors = form.$error = {}, controls = [];
    form.$name = attrs.name || attrs.ngForm;
    form.$dirty = false;
    form.$pristine = true;
    form.$valid = true;
    form.$invalid = false;
    parentForm.$addControl(form);
    element.addClass(PRISTINE_CLASS);
    toggleValidCss(true);
    function toggleValidCss(isValid, validationErrorKey) {
      validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
      $animate.setClass(element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey);
    }
    form.$addControl = function(control) {
      assertNotHasOwnProperty(control.$name, "input");
      controls.push(control);
      if (control.$name) {
        form[control.$name] = control;
      }
    };
    form.$removeControl = function(control) {
      if (control.$name && form[control.$name] === control) {
        delete form[control.$name];
      }
      forEach(errors, function(queue, validationToken) {
        form.$setValidity(validationToken, true, control);
      });
      arrayRemove(controls, control);
    };
    form.$setValidity = function(validationToken, isValid, control) {
      var queue = errors[validationToken];
      if (isValid) {
        if (queue) {
          arrayRemove(queue, control);
          if (!queue.length) {
            invalidCount--;
            if (!invalidCount) {
              toggleValidCss(isValid);
              form.$valid = true;
              form.$invalid = false;
            }
            errors[validationToken] = false;
            toggleValidCss(true, validationToken);
            parentForm.$setValidity(validationToken, true, form);
          }
        }
      } else {
        if (!invalidCount) {
          toggleValidCss(isValid);
        }
        if (queue) {
          if (includes(queue, control)) return;
        } else {
          errors[validationToken] = queue = [];
          invalidCount++;
          toggleValidCss(false, validationToken);
          parentForm.$setValidity(validationToken, false, form);
        }
        queue.push(control);
        form.$valid = false;
        form.$invalid = true;
      }
    };
    form.$setDirty = function() {
      $animate.removeClass(element, PRISTINE_CLASS);
      $animate.addClass(element, DIRTY_CLASS);
      form.$dirty = true;
      form.$pristine = false;
      parentForm.$setDirty();
    };
    form.$setPristine = function() {
      $animate.removeClass(element, DIRTY_CLASS);
      $animate.addClass(element, PRISTINE_CLASS);
      form.$dirty = false;
      form.$pristine = true;
      forEach(controls, function(control) {
        control.$setPristine();
      });
    };
  }
  var formDirectiveFactory = function(isNgForm) {
    return [ "$timeout", function($timeout) {
      var formDirective = {
        name: "form",
        restrict: isNgForm ? "EAC" : "E",
        controller: FormController,
        compile: function() {
          return {
            pre: function(scope, formElement, attr, controller) {
              if (!attr.action) {
                var preventDefaultListener = function(event) {
                  event.preventDefault ? event.preventDefault() : event.returnValue = false;
                };
                addEventListenerFn(formElement[0], "submit", preventDefaultListener);
                formElement.on("$destroy", function() {
                  $timeout(function() {
                    removeEventListenerFn(formElement[0], "submit", preventDefaultListener);
                  }, 0, false);
                });
              }
              var parentFormCtrl = formElement.parent().controller("form"), alias = attr.name || attr.ngForm;
              if (alias) {
                setter(scope, alias, controller, alias);
              }
              if (parentFormCtrl) {
                formElement.on("$destroy", function() {
                  parentFormCtrl.$removeControl(controller);
                  if (alias) {
                    setter(scope, alias, undefined, alias);
                  }
                  extend(controller, nullFormCtrl);
                });
              }
            }
          };
        }
      };
      return formDirective;
    } ];
  };
  var formDirective = formDirectiveFactory();
  var ngFormDirective = formDirectiveFactory(true);
  var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
  var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
  var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
  var inputType = {
    text: textInputType,
    number: numberInputType,
    url: urlInputType,
    email: emailInputType,
    radio: radioInputType,
    checkbox: checkboxInputType,
    hidden: noop,
    button: noop,
    submit: noop,
    reset: noop,
    file: noop
  };
  function validate(ctrl, validatorName, validity, value) {
    ctrl.$setValidity(validatorName, validity);
    return validity ? value : undefined;
  }
  function testFlags(validity, flags) {
    var i, flag;
    if (flags) {
      for (i = 0; i < flags.length; ++i) {
        flag = flags[i];
        if (validity[flag]) {
          return true;
        }
      }
    }
    return false;
  }
  function addNativeHtml5Validators(ctrl, validatorName, badFlags, ignoreFlags, validity) {
    if (isObject(validity)) {
      ctrl.$$hasNativeValidators = true;
      var validator = function(value) {
        if (!ctrl.$error[validatorName] && !testFlags(validity, ignoreFlags) && testFlags(validity, badFlags)) {
          ctrl.$setValidity(validatorName, false);
          return;
        }
        return value;
      };
      ctrl.$parsers.push(validator);
    }
  }
  function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var validity = element.prop(VALIDITY_STATE_PROPERTY);
    var placeholder = element[0].placeholder, noevent = {};
    var type = lowercase(element[0].type);
    ctrl.$$validityState = validity;
    if (!$sniffer.android) {
      var composing = false;
      element.on("compositionstart", function(data) {
        composing = true;
      });
      element.on("compositionend", function() {
        composing = false;
        listener();
      });
    }
    var listener = function(ev) {
      if (composing) return;
      var value = element.val();
      if (msie && (ev || noevent).type === "input" && element[0].placeholder !== placeholder) {
        placeholder = element[0].placeholder;
        return;
      }
      if (type !== "password" && toBoolean(attr.ngTrim || "T")) {
        value = trim(value);
      }
      var revalidate = validity && ctrl.$$hasNativeValidators;
      if (ctrl.$viewValue !== value || value === "" && revalidate) {
        if (scope.$root.$$phase) {
          ctrl.$setViewValue(value);
        } else {
          scope.$apply(function() {
            ctrl.$setViewValue(value);
          });
        }
      }
    };
    if ($sniffer.hasEvent("input")) {
      element.on("input", listener);
    } else {
      var timeout;
      var deferListener = function() {
        if (!timeout) {
          timeout = $browser.defer(function() {
            listener();
            timeout = null;
          });
        }
      };
      element.on("keydown", function(event) {
        var key = event.keyCode;
        if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40) return;
        deferListener();
      });
      if ($sniffer.hasEvent("paste")) {
        element.on("paste cut", deferListener);
      }
    }
    element.on("change", listener);
    ctrl.$render = function() {
      element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue);
    };
    var pattern = attr.ngPattern, patternValidator, match;
    if (pattern) {
      var validateRegex = function(regexp, value) {
        return validate(ctrl, "pattern", ctrl.$isEmpty(value) || regexp.test(value), value);
      };
      match = pattern.match(/^\/(.*)\/([gim]*)$/);
      if (match) {
        pattern = new RegExp(match[1], match[2]);
        patternValidator = function(value) {
          return validateRegex(pattern, value);
        };
      } else {
        patternValidator = function(value) {
          var patternObj = scope.$eval(pattern);
          if (!patternObj || !patternObj.test) {
            throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", pattern, patternObj, startingTag(element));
          }
          return validateRegex(patternObj, value);
        };
      }
      ctrl.$formatters.push(patternValidator);
      ctrl.$parsers.push(patternValidator);
    }
    if (attr.ngMinlength) {
      var minlength = int(attr.ngMinlength);
      var minLengthValidator = function(value) {
        return validate(ctrl, "minlength", ctrl.$isEmpty(value) || value.length >= minlength, value);
      };
      ctrl.$parsers.push(minLengthValidator);
      ctrl.$formatters.push(minLengthValidator);
    }
    if (attr.ngMaxlength) {
      var maxlength = int(attr.ngMaxlength);
      var maxLengthValidator = function(value) {
        return validate(ctrl, "maxlength", ctrl.$isEmpty(value) || value.length <= maxlength, value);
      };
      ctrl.$parsers.push(maxLengthValidator);
      ctrl.$formatters.push(maxLengthValidator);
    }
  }
  var numberBadFlags = [ "badInput" ];
  function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    ctrl.$parsers.push(function(value) {
      var empty = ctrl.$isEmpty(value);
      if (empty || NUMBER_REGEXP.test(value)) {
        ctrl.$setValidity("number", true);
        return value === "" ? null : empty ? value : parseFloat(value);
      } else {
        ctrl.$setValidity("number", false);
        return undefined;
      }
    });
    addNativeHtml5Validators(ctrl, "number", numberBadFlags, null, ctrl.$$validityState);
    ctrl.$formatters.push(function(value) {
      return ctrl.$isEmpty(value) ? "" : "" + value;
    });
    if (attr.min) {
      var minValidator = function(value) {
        var min = parseFloat(attr.min);
        return validate(ctrl, "min", ctrl.$isEmpty(value) || value >= min, value);
      };
      ctrl.$parsers.push(minValidator);
      ctrl.$formatters.push(minValidator);
    }
    if (attr.max) {
      var maxValidator = function(value) {
        var max = parseFloat(attr.max);
        return validate(ctrl, "max", ctrl.$isEmpty(value) || value <= max, value);
      };
      ctrl.$parsers.push(maxValidator);
      ctrl.$formatters.push(maxValidator);
    }
    ctrl.$formatters.push(function(value) {
      return validate(ctrl, "number", ctrl.$isEmpty(value) || isNumber(value), value);
    });
  }
  function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var urlValidator = function(value) {
      return validate(ctrl, "url", ctrl.$isEmpty(value) || URL_REGEXP.test(value), value);
    };
    ctrl.$formatters.push(urlValidator);
    ctrl.$parsers.push(urlValidator);
  }
  function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var emailValidator = function(value) {
      return validate(ctrl, "email", ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value), value);
    };
    ctrl.$formatters.push(emailValidator);
    ctrl.$parsers.push(emailValidator);
  }
  function radioInputType(scope, element, attr, ctrl) {
    if (isUndefined(attr.name)) {
      element.attr("name", nextUid());
    }
    element.on("click", function() {
      if (element[0].checked) {
        scope.$apply(function() {
          ctrl.$setViewValue(attr.value);
        });
      }
    });
    ctrl.$render = function() {
      var value = attr.value;
      element[0].checked = value == ctrl.$viewValue;
    };
    attr.$observe("value", ctrl.$render);
  }
  function checkboxInputType(scope, element, attr, ctrl) {
    var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue;
    if (!isString(trueValue)) trueValue = true;
    if (!isString(falseValue)) falseValue = false;
    element.on("click", function() {
      scope.$apply(function() {
        ctrl.$setViewValue(element[0].checked);
      });
    });
    ctrl.$render = function() {
      element[0].checked = ctrl.$viewValue;
    };
    ctrl.$isEmpty = function(value) {
      return value !== trueValue;
    };
    ctrl.$formatters.push(function(value) {
      return value === trueValue;
    });
    ctrl.$parsers.push(function(value) {
      return value ? trueValue : falseValue;
    });
  }
  var inputDirective = [ "$browser", "$sniffer", function($browser, $sniffer) {
    return {
      restrict: "E",
      require: "?ngModel",
      link: function(scope, element, attr, ctrl) {
        if (ctrl) {
          (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser);
        }
      }
    };
  } ];
  var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty";
  var NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate) {
    this.$viewValue = Number.NaN;
    this.$modelValue = Number.NaN;
    this.$parsers = [];
    this.$formatters = [];
    this.$viewChangeListeners = [];
    this.$pristine = true;
    this.$dirty = false;
    this.$valid = true;
    this.$invalid = false;
    this.$name = $attr.name;
    var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign;
    if (!ngModelSet) {
      throw minErr("ngModel")("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
    }
    this.$render = noop;
    this.$isEmpty = function(value) {
      return isUndefined(value) || value === "" || value === null || value !== value;
    };
    var parentForm = $element.inheritedData("$formController") || nullFormCtrl, invalidCount = 0, $error = this.$error = {};
    $element.addClass(PRISTINE_CLASS);
    toggleValidCss(true);
    function toggleValidCss(isValid, validationErrorKey) {
      validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
      $animate.removeClass($element, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey);
      $animate.addClass($element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
    }
    this.$setValidity = function(validationErrorKey, isValid) {
      if ($error[validationErrorKey] === !isValid) return;
      if (isValid) {
        if ($error[validationErrorKey]) invalidCount--;
        if (!invalidCount) {
          toggleValidCss(true);
          this.$valid = true;
          this.$invalid = false;
        }
      } else {
        toggleValidCss(false);
        this.$invalid = true;
        this.$valid = false;
        invalidCount++;
      }
      $error[validationErrorKey] = !isValid;
      toggleValidCss(isValid, validationErrorKey);
      parentForm.$setValidity(validationErrorKey, isValid, this);
    };
    this.$setPristine = function() {
      this.$dirty = false;
      this.$pristine = true;
      $animate.removeClass($element, DIRTY_CLASS);
      $animate.addClass($element, PRISTINE_CLASS);
    };
    this.$setViewValue = function(value) {
      this.$viewValue = value;
      if (this.$pristine) {
        this.$dirty = true;
        this.$pristine = false;
        $animate.removeClass($element, PRISTINE_CLASS);
        $animate.addClass($element, DIRTY_CLASS);
        parentForm.$setDirty();
      }
      forEach(this.$parsers, function(fn) {
        value = fn(value);
      });
      if (this.$modelValue !== value) {
        this.$modelValue = value;
        ngModelSet($scope, value);
        forEach(this.$viewChangeListeners, function(listener) {
          try {
            listener();
          } catch (e) {
            $exceptionHandler(e);
          }
        });
      }
    };
    var ctrl = this;
    $scope.$watch(function ngModelWatch() {
      var value = ngModelGet($scope);
      if (ctrl.$modelValue !== value) {
        var formatters = ctrl.$formatters, idx = formatters.length;
        ctrl.$modelValue = value;
        while (idx--) {
          value = formatters[idx](value);
        }
        if (ctrl.$viewValue !== value) {
          ctrl.$viewValue = value;
          ctrl.$render();
        }
      }
      return value;
    });
  } ];
  var ngModelDirective = function() {
    return {
      require: [ "ngModel", "^?form" ],
      controller: NgModelController,
      link: function(scope, element, attr, ctrls) {
        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
        formCtrl.$addControl(modelCtrl);
        scope.$on("$destroy", function() {
          formCtrl.$removeControl(modelCtrl);
        });
      }
    };
  };
  var ngChangeDirective = valueFn({
    require: "ngModel",
    link: function(scope, element, attr, ctrl) {
      ctrl.$viewChangeListeners.push(function() {
        scope.$eval(attr.ngChange);
      });
    }
  });
  var requiredDirective = function() {
    return {
      require: "?ngModel",
      link: function(scope, elm, attr, ctrl) {
        if (!ctrl) return;
        attr.required = true;
        var validator = function(value) {
          if (attr.required && ctrl.$isEmpty(value)) {
            ctrl.$setValidity("required", false);
            return;
          } else {
            ctrl.$setValidity("required", true);
            return value;
          }
        };
        ctrl.$formatters.push(validator);
        ctrl.$parsers.unshift(validator);
        attr.$observe("required", function() {
          validator(ctrl.$viewValue);
        });
      }
    };
  };
  var ngListDirective = function() {
    return {
      require: "ngModel",
      link: function(scope, element, attr, ctrl) {
        var match = /\/(.*)\//.exec(attr.ngList), separator = match && new RegExp(match[1]) || attr.ngList || ",";
        var parse = function(viewValue) {
          if (isUndefined(viewValue)) return;
          var list = [];
          if (viewValue) {
            forEach(viewValue.split(separator), function(value) {
              if (value) list.push(trim(value));
            });
          }
          return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function(value) {
          if (isArray(value)) {
            return value.join(", ");
          }
          return undefined;
        });
        ctrl.$isEmpty = function(value) {
          return !value || !value.length;
        };
      }
    };
  };
  var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  var ngValueDirective = function() {
    return {
      priority: 100,
      compile: function(tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function ngValueConstantLink(scope, elm, attr) {
            attr.$set("value", scope.$eval(attr.ngValue));
          };
        } else {
          return function ngValueLink(scope, elm, attr) {
            scope.$watch(attr.ngValue, function valueWatchAction(value) {
              attr.$set("value", value);
            });
          };
        }
      }
    };
  };
  var ngBindDirective = ngDirective({
    compile: function(templateElement) {
      templateElement.addClass("ng-binding");
      return function(scope, element, attr) {
        element.data("$binding", attr.ngBind);
        scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
          element.text(value == undefined ? "" : value);
        });
      };
    }
  });
  var ngBindTemplateDirective = [ "$interpolate", function($interpolate) {
    return function(scope, element, attr) {
      var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
      element.addClass("ng-binding").data("$binding", interpolateFn);
      attr.$observe("ngBindTemplate", function(value) {
        element.text(value);
      });
    };
  } ];
  var ngBindHtmlDirective = [ "$sce", "$parse", function($sce, $parse) {
    return {
      compile: function(tElement) {
        tElement.addClass("ng-binding");
        return function(scope, element, attr) {
          element.data("$binding", attr.ngBindHtml);
          var parsed = $parse(attr.ngBindHtml);
          function getStringValue() {
            return (parsed(scope) || "").toString();
          }
          scope.$watch(getStringValue, function ngBindHtmlWatchAction(value) {
            element.html($sce.getTrustedHtml(parsed(scope)) || "");
          });
        };
      }
    };
  } ];
  function classDirective(name, selector) {
    name = "ngClass" + name;
    return [ "$animate", function($animate) {
      return {
        restrict: "AC",
        link: function(scope, element, attr) {
          var oldVal;
          scope.$watch(attr[name], ngClassWatchAction, true);
          attr.$observe("class", function(value) {
            ngClassWatchAction(scope.$eval(attr[name]));
          });
          if (name !== "ngClass") {
            scope.$watch("$index", function($index, old$index) {
              var mod = $index & 1;
              if (mod !== (old$index & 1)) {
                var classes = arrayClasses(scope.$eval(attr[name]));
                mod === selector ? addClasses(classes) : removeClasses(classes);
              }
            });
          }
          function addClasses(classes) {
            var newClasses = digestClassCounts(classes, 1);
            attr.$addClass(newClasses);
          }
          function removeClasses(classes) {
            var newClasses = digestClassCounts(classes, -1);
            attr.$removeClass(newClasses);
          }
          function digestClassCounts(classes, count) {
            var classCounts = element.data("$classCounts") || {};
            var classesToUpdate = [];
            forEach(classes, function(className) {
              if (count > 0 || classCounts[className]) {
                classCounts[className] = (classCounts[className] || 0) + count;
                if (classCounts[className] === +(count > 0)) {
                  classesToUpdate.push(className);
                }
              }
            });
            element.data("$classCounts", classCounts);
            return classesToUpdate.join(" ");
          }
          function updateClasses(oldClasses, newClasses) {
            var toAdd = arrayDifference(newClasses, oldClasses);
            var toRemove = arrayDifference(oldClasses, newClasses);
            toRemove = digestClassCounts(toRemove, -1);
            toAdd = digestClassCounts(toAdd, 1);
            if (toAdd.length === 0) {
              $animate.removeClass(element, toRemove);
            } else if (toRemove.length === 0) {
              $animate.addClass(element, toAdd);
            } else {
              $animate.setClass(element, toAdd, toRemove);
            }
          }
          function ngClassWatchAction(newVal) {
            if (selector === true || scope.$index % 2 === selector) {
              var newClasses = arrayClasses(newVal || []);
              if (!oldVal) {
                addClasses(newClasses);
              } else if (!equals(newVal, oldVal)) {
                var oldClasses = arrayClasses(oldVal);
                updateClasses(oldClasses, newClasses);
              }
            }
            oldVal = shallowCopy(newVal);
          }
        }
      };
      function arrayDifference(tokens1, tokens2) {
        var values = [];
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j]) continue outer;
          }
          values.push(token);
        }
        return values;
      }
      function arrayClasses(classVal) {
        if (isArray(classVal)) {
          return classVal;
        } else if (isString(classVal)) {
          return classVal.split(" ");
        } else if (isObject(classVal)) {
          var classes = [], i = 0;
          forEach(classVal, function(v, k) {
            if (v) {
              classes = classes.concat(k.split(" "));
            }
          });
          return classes;
        }
        return classVal;
      }
    } ];
  }
  var ngClassDirective = classDirective("", true);
  var ngClassOddDirective = classDirective("Odd", 0);
  var ngClassEvenDirective = classDirective("Even", 1);
  var ngCloakDirective = ngDirective({
    compile: function(element, attr) {
      attr.$set("ngCloak", undefined);
      element.removeClass("ng-cloak");
    }
  });
  var ngControllerDirective = [ function() {
    return {
      scope: true,
      controller: "@",
      priority: 500
    };
  } ];
  var ngEventDirectives = {};
  var forceAsyncEvents = {
    blur: true,
    focus: true
  };
  forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
    var directiveName = directiveNormalize("ng-" + eventName);
    ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
      return {
        compile: function($element, attr) {
          var fn = $parse(attr[directiveName]);
          return function ngEventHandler(scope, element) {
            element.on(eventName, function(event) {
              var callback = function() {
                fn(scope, {
                  $event: event
                });
              };
              if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                scope.$evalAsync(callback);
              } else {
                scope.$apply(callback);
              }
            });
          };
        }
      };
    } ];
  });
  var ngIfDirective = [ "$animate", function($animate) {
    return {
      transclude: "element",
      priority: 600,
      terminal: true,
      restrict: "A",
      $$tlb: true,
      link: function($scope, $element, $attr, ctrl, $transclude) {
        var block, childScope, previousElements;
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
          if (toBoolean(value)) {
            if (!childScope) {
              childScope = $scope.$new();
              $transclude(childScope, function(clone) {
                clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " ");
                block = {
                  clone: clone
                };
                $animate.enter(clone, $element.parent(), $element);
              });
            }
          } else {
            if (previousElements) {
              previousElements.remove();
              previousElements = null;
            }
            if (childScope) {
              childScope.$destroy();
              childScope = null;
            }
            if (block) {
              previousElements = getBlockElements(block.clone);
              $animate.leave(previousElements, function() {
                previousElements = null;
              });
              block = null;
            }
          }
        });
      }
    };
  } ];
  var ngIncludeDirective = [ "$http", "$templateCache", "$anchorScroll", "$animate", "$sce", function($http, $templateCache, $anchorScroll, $animate, $sce) {
    return {
      restrict: "ECA",
      priority: 400,
      terminal: true,
      transclude: "element",
      controller: angular.noop,
      compile: function(element, attr) {
        var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
        return function(scope, $element, $attr, ctrl, $transclude) {
          var changeCounter = 0, currentScope, previousElement, currentElement;
          var cleanupLastIncludeContent = function() {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              $animate.leave(currentElement, function() {
                previousElement = null;
              });
              previousElement = currentElement;
              currentElement = null;
            }
          };
          scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
            var afterAnimation = function() {
              if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                $anchorScroll();
              }
            };
            var thisChangeId = ++changeCounter;
            if (src) {
              $http.get(src, {
                cache: $templateCache
              }).success(function(response) {
                if (thisChangeId !== changeCounter) return;
                var newScope = scope.$new();
                ctrl.template = response;
                var clone = $transclude(newScope, function(clone) {
                  cleanupLastIncludeContent();
                  $animate.enter(clone, null, $element, afterAnimation);
                });
                currentScope = newScope;
                currentElement = clone;
                currentScope.$emit("$includeContentLoaded");
                scope.$eval(onloadExp);
              }).error(function() {
                if (thisChangeId === changeCounter) cleanupLastIncludeContent();
              });
              scope.$emit("$includeContentRequested");
            } else {
              cleanupLastIncludeContent();
              ctrl.template = null;
            }
          });
        };
      }
    };
  } ];
  var ngIncludeFillContentDirective = [ "$compile", function($compile) {
    return {
      restrict: "ECA",
      priority: -400,
      require: "ngInclude",
      link: function(scope, $element, $attr, ctrl) {
        $element.html(ctrl.template);
        $compile($element.contents())(scope);
      }
    };
  } ];
  var ngInitDirective = ngDirective({
    priority: 450,
    compile: function() {
      return {
        pre: function(scope, element, attrs) {
          scope.$eval(attrs.ngInit);
        }
      };
    }
  });
  var ngNonBindableDirective = ngDirective({
    terminal: true,
    priority: 1e3
  });
  var ngPluralizeDirective = [ "$locale", "$interpolate", function($locale, $interpolate) {
    var BRACE = /{}/g;
    return {
      restrict: "EA",
      link: function(scope, element, attr) {
        var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), isWhen = /^when(Minus)?(.+)$/;
        forEach(attr, function(expression, attributeName) {
          if (isWhen.test(attributeName)) {
            whens[lowercase(attributeName.replace("when", "").replace("Minus", "-"))] = element.attr(attr.$attr[attributeName]);
          }
        });
        forEach(whens, function(expression, key) {
          whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + "-" + offset + endSymbol));
        });
        scope.$watch(function ngPluralizeWatch() {
          var value = parseFloat(scope.$eval(numberExp));
          if (!isNaN(value)) {
            if (!(value in whens)) value = $locale.pluralCat(value - offset);
            return whensExpFns[value](scope, element, true);
          } else {
            return "";
          }
        }, function ngPluralizeWatchAction(newVal) {
          element.text(newVal);
        });
      }
    };
  } ];
  var ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
    var NG_REMOVED = "$$NG_REMOVED";
    var ngRepeatMinErr = minErr("ngRepeat");
    return {
      transclude: "element",
      priority: 1e3,
      terminal: true,
      $$tlb: true,
      link: function($scope, $element, $attr, ctrl, $transclude) {
        var expression = $attr.ngRepeat;
        var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/), trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier, hashFnLocals = {
          $id: hashKey
        };
        if (!match) {
          throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
        }
        lhs = match[1];
        rhs = match[2];
        trackByExp = match[3];
        if (trackByExp) {
          trackByExpGetter = $parse(trackByExp);
          trackByIdExpFn = function(key, value, index) {
            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
            hashFnLocals[valueIdentifier] = value;
            hashFnLocals.$index = index;
            return trackByExpGetter($scope, hashFnLocals);
          };
        } else {
          trackByIdArrayFn = function(key, value) {
            return hashKey(value);
          };
          trackByIdObjFn = function(key) {
            return key;
          };
        }
        match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
        if (!match) {
          throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
        }
        valueIdentifier = match[3] || match[1];
        keyIdentifier = match[2];
        var lastBlockMap = {};
        $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
          var index, length, previousNode = $element[0], nextNode, nextBlockMap = {}, arrayLength, childScope, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder = [], elementsToRemove;
          if (isArrayLike(collection)) {
            collectionKeys = collection;
            trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
          } else {
            trackByIdFn = trackByIdExpFn || trackByIdObjFn;
            collectionKeys = [];
            for (key in collection) {
              if (collection.hasOwnProperty(key) && key.charAt(0) != "$") {
                collectionKeys.push(key);
              }
            }
            collectionKeys.sort();
          }
          arrayLength = collectionKeys.length;
          length = nextBlockOrder.length = collectionKeys.length;
          for (index = 0; index < length; index++) {
            key = collection === collectionKeys ? index : collectionKeys[index];
            value = collection[key];
            trackById = trackByIdFn(key, value, index);
            assertNotHasOwnProperty(trackById, "`track by` id");
            if (lastBlockMap.hasOwnProperty(trackById)) {
              block = lastBlockMap[trackById];
              delete lastBlockMap[trackById];
              nextBlockMap[trackById] = block;
              nextBlockOrder[index] = block;
            } else if (nextBlockMap.hasOwnProperty(trackById)) {
              forEach(nextBlockOrder, function(block) {
                if (block && block.scope) lastBlockMap[block.id] = block;
              });
              throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, toJson(value));
            } else {
              nextBlockOrder[index] = {
                id: trackById
              };
              nextBlockMap[trackById] = false;
            }
          }
          for (key in lastBlockMap) {
            if (lastBlockMap.hasOwnProperty(key)) {
              block = lastBlockMap[key];
              elementsToRemove = getBlockElements(block.clone);
              $animate.leave(elementsToRemove);
              forEach(elementsToRemove, function(element) {
                element[NG_REMOVED] = true;
              });
              block.scope.$destroy();
            }
          }
          for (index = 0, length = collectionKeys.length; index < length; index++) {
            key = collection === collectionKeys ? index : collectionKeys[index];
            value = collection[key];
            block = nextBlockOrder[index];
            if (nextBlockOrder[index - 1]) previousNode = getBlockEnd(nextBlockOrder[index - 1]);
            if (block.scope) {
              childScope = block.scope;
              nextNode = previousNode;
              do {
                nextNode = nextNode.nextSibling;
              } while (nextNode && nextNode[NG_REMOVED]);
              if (getBlockStart(block) != nextNode) {
                $animate.move(getBlockElements(block.clone), null, jqLite(previousNode));
              }
              previousNode = getBlockEnd(block);
            } else {
              childScope = $scope.$new();
            }
            childScope[valueIdentifier] = value;
            if (keyIdentifier) childScope[keyIdentifier] = key;
            childScope.$index = index;
            childScope.$first = index === 0;
            childScope.$last = index === arrayLength - 1;
            childScope.$middle = !(childScope.$first || childScope.$last);
            childScope.$odd = !(childScope.$even = (index & 1) === 0);
            if (!block.scope) {
              $transclude(childScope, function(clone) {
                clone[clone.length++] = document.createComment(" end ngRepeat: " + expression + " ");
                $animate.enter(clone, null, jqLite(previousNode));
                previousNode = clone;
                block.scope = childScope;
                block.clone = clone;
                nextBlockMap[block.id] = block;
              });
            }
          }
          lastBlockMap = nextBlockMap;
        });
      }
    };
    function getBlockStart(block) {
      return block.clone[0];
    }
    function getBlockEnd(block) {
      return block.clone[block.clone.length - 1];
    }
  } ];
  var ngShowDirective = [ "$animate", function($animate) {
    return function(scope, element, attr) {
      scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
        $animate[toBoolean(value) ? "removeClass" : "addClass"](element, "ng-hide");
      });
    };
  } ];
  var ngHideDirective = [ "$animate", function($animate) {
    return function(scope, element, attr) {
      scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
        $animate[toBoolean(value) ? "addClass" : "removeClass"](element, "ng-hide");
      });
    };
  } ];
  var ngStyleDirective = ngDirective(function(scope, element, attr) {
    scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
      if (oldStyles && newStyles !== oldStyles) {
        forEach(oldStyles, function(val, style) {
          element.css(style, "");
        });
      }
      if (newStyles) element.css(newStyles);
    }, true);
  });
  var ngSwitchDirective = [ "$animate", function($animate) {
    return {
      restrict: "EA",
      require: "ngSwitch",
      controller: [ "$scope", function ngSwitchController() {
        this.cases = {};
      } ],
      link: function(scope, element, attr, ngSwitchController) {
        var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousElements = [], selectedScopes = [];
        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
          var i, ii;
          for (i = 0, ii = previousElements.length; i < ii; ++i) {
            previousElements[i].remove();
          }
          previousElements.length = 0;
          for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
            var selected = selectedElements[i];
            selectedScopes[i].$destroy();
            previousElements[i] = selected;
            $animate.leave(selected, function() {
              previousElements.splice(i, 1);
            });
          }
          selectedElements.length = 0;
          selectedScopes.length = 0;
          if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
            scope.$eval(attr.change);
            forEach(selectedTranscludes, function(selectedTransclude) {
              var selectedScope = scope.$new();
              selectedScopes.push(selectedScope);
              selectedTransclude.transclude(selectedScope, function(caseElement) {
                var anchor = selectedTransclude.element;
                selectedElements.push(caseElement);
                $animate.enter(caseElement, anchor.parent(), anchor);
              });
            });
          }
        });
      }
    };
  } ];
  var ngSwitchWhenDirective = ngDirective({
    transclude: "element",
    priority: 800,
    require: "^ngSwitch",
    link: function(scope, element, attrs, ctrl, $transclude) {
      ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [];
      ctrl.cases["!" + attrs.ngSwitchWhen].push({
        transclude: $transclude,
        element: element
      });
    }
  });
  var ngSwitchDefaultDirective = ngDirective({
    transclude: "element",
    priority: 800,
    require: "^ngSwitch",
    link: function(scope, element, attr, ctrl, $transclude) {
      ctrl.cases["?"] = ctrl.cases["?"] || [];
      ctrl.cases["?"].push({
        transclude: $transclude,
        element: element
      });
    }
  });
  var ngTranscludeDirective = ngDirective({
    link: function($scope, $element, $attrs, controller, $transclude) {
      if (!$transclude) {
        throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element));
      }
      $transclude(function(clone) {
        $element.empty();
        $element.append(clone);
      });
    }
  });
  var scriptDirective = [ "$templateCache", function($templateCache) {
    return {
      restrict: "E",
      terminal: true,
      compile: function(element, attr) {
        if (attr.type == "text/ng-template") {
          var templateUrl = attr.id, text = element[0].text;
          $templateCache.put(templateUrl, text);
        }
      }
    };
  } ];
  var ngOptionsMinErr = minErr("ngOptions");
  var ngOptionsDirective = valueFn({
    terminal: true
  });
  var selectDirective = [ "$compile", "$parse", function($compile, $parse) {
    var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nullModelCtrl = {
      $setViewValue: noop
    };
    return {
      restrict: "E",
      require: [ "select", "?ngModel" ],
      controller: [ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
        var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption;
        self.databound = $attrs.ngModel;
        self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
          ngModelCtrl = ngModelCtrl_;
          nullOption = nullOption_;
          unknownOption = unknownOption_;
        };
        self.addOption = function(value) {
          assertNotHasOwnProperty(value, '"option value"');
          optionsMap[value] = true;
          if (ngModelCtrl.$viewValue == value) {
            $element.val(value);
            if (unknownOption.parent()) unknownOption.remove();
          }
        };
        self.removeOption = function(value) {
          if (this.hasOption(value)) {
            delete optionsMap[value];
            if (ngModelCtrl.$viewValue == value) {
              this.renderUnknownOption(value);
            }
          }
        };
        self.renderUnknownOption = function(val) {
          var unknownVal = "? " + hashKey(val) + " ?";
          unknownOption.val(unknownVal);
          $element.prepend(unknownOption);
          $element.val(unknownVal);
          unknownOption.prop("selected", true);
        };
        self.hasOption = function(value) {
          return optionsMap.hasOwnProperty(value);
        };
        $scope.$on("$destroy", function() {
          self.renderUnknownOption = noop;
        });
      } ],
      link: function(scope, element, attr, ctrls) {
        if (!ctrls[1]) return;
        var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = false, emptyOption, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone();
        for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
          if (children[i].value === "") {
            emptyOption = nullOption = children.eq(i);
            break;
          }
        }
        selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
        if (multiple) {
          ngModelCtrl.$isEmpty = function(value) {
            return !value || value.length === 0;
          };
        }
        if (optionsExp) setupAsOptions(scope, element, ngModelCtrl); else if (multiple) setupAsMultiple(scope, element, ngModelCtrl); else setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
        function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
          ngModelCtrl.$render = function() {
            var viewValue = ngModelCtrl.$viewValue;
            if (selectCtrl.hasOption(viewValue)) {
              if (unknownOption.parent()) unknownOption.remove();
              selectElement.val(viewValue);
              if (viewValue === "") emptyOption.prop("selected", true);
            } else {
              if (isUndefined(viewValue) && emptyOption) {
                selectElement.val("");
              } else {
                selectCtrl.renderUnknownOption(viewValue);
              }
            }
          };
          selectElement.on("change", function() {
            scope.$apply(function() {
              if (unknownOption.parent()) unknownOption.remove();
              ngModelCtrl.$setViewValue(selectElement.val());
            });
          });
        }
        function setupAsMultiple(scope, selectElement, ctrl) {
          var lastView;
          ctrl.$render = function() {
            var items = new HashMap(ctrl.$viewValue);
            forEach(selectElement.find("option"), function(option) {
              option.selected = isDefined(items.get(option.value));
            });
          };
          scope.$watch(function selectMultipleWatch() {
            if (!equals(lastView, ctrl.$viewValue)) {
              lastView = shallowCopy(ctrl.$viewValue);
              ctrl.$render();
            }
          });
          selectElement.on("change", function() {
            scope.$apply(function() {
              var array = [];
              forEach(selectElement.find("option"), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              ctrl.$setViewValue(array);
            });
          });
        }
        function setupAsOptions(scope, selectElement, ctrl) {
          var match;
          if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
            throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5], groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) : null, optionGroupsCache = [ [ {
            element: selectElement,
            label: ""
          } ] ];
          if (nullOption) {
            $compile(nullOption)(scope);
            nullOption.removeClass("ng-scope");
            nullOption.remove();
          }
          selectElement.empty();
          selectElement.on("change", function() {
            scope.$apply(function() {
              var optionGroup, collection = valuesFn(scope) || [], locals = {}, key, value, optionElement, index, groupIndex, length, groupLength, trackIndex;
              if (multiple) {
                value = [];
                for (groupIndex = 0, groupLength = optionGroupsCache.length; groupIndex < groupLength; groupIndex++) {
                  optionGroup = optionGroupsCache[groupIndex];
                  for (index = 1, length = optionGroup.length; index < length; index++) {
                    if ((optionElement = optionGroup[index].element)[0].selected) {
                      key = optionElement.val();
                      if (keyName) locals[keyName] = key;
                      if (trackFn) {
                        for (trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                          locals[valueName] = collection[trackIndex];
                          if (trackFn(scope, locals) == key) break;
                        }
                      } else {
                        locals[valueName] = collection[key];
                      }
                      value.push(valueFn(scope, locals));
                    }
                  }
                }
              } else {
                key = selectElement.val();
                if (key == "?") {
                  value = undefined;
                } else if (key === "") {
                  value = null;
                } else {
                  if (trackFn) {
                    for (trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                      locals[valueName] = collection[trackIndex];
                      if (trackFn(scope, locals) == key) {
                        value = valueFn(scope, locals);
                        break;
                      }
                    }
                  } else {
                    locals[valueName] = collection[key];
                    if (keyName) locals[keyName] = key;
                    value = valueFn(scope, locals);
                  }
                }
              }
              ctrl.$setViewValue(value);
              render();
            });
          });
          ctrl.$render = render;
          scope.$watchCollection(valuesFn, render);
          scope.$watchCollection(function() {
            var locals = {}, values = valuesFn(scope);
            if (values) {
              var toDisplay = new Array(values.length);
              for (var i = 0, ii = values.length; i < ii; i++) {
                locals[valueName] = values[i];
                toDisplay[i] = displayFn(scope, locals);
              }
              return toDisplay;
            }
          }, render);
          if (multiple) {
            scope.$watchCollection(function() {
              return ctrl.$modelValue;
            }, render);
          }
          function getSelectedSet() {
            var selectedSet = false;
            if (multiple) {
              var modelValue = ctrl.$modelValue;
              if (trackFn && isArray(modelValue)) {
                selectedSet = new HashMap([]);
                var locals = {};
                for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) {
                  locals[valueName] = modelValue[trackIndex];
                  selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
                }
              } else {
                selectedSet = new HashMap(modelValue);
              }
            }
            return selectedSet;
          }
          function render() {
            var optionGroups = {
              "": []
            }, optionGroupNames = [ "" ], optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, modelValue = ctrl.$modelValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, key, groupLength, length, groupIndex, index, locals = {}, selected, selectedSet = getSelectedSet(), lastElement, element, label;
            for (index = 0; length = keys.length, index < length; index++) {
              key = index;
              if (keyName) {
                key = keys[index];
                if (key.charAt(0) === "$") continue;
                locals[keyName] = key;
              }
              locals[valueName] = values[key];
              optionGroupName = groupByFn(scope, locals) || "";
              if (!(optionGroup = optionGroups[optionGroupName])) {
                optionGroup = optionGroups[optionGroupName] = [];
                optionGroupNames.push(optionGroupName);
              }
              if (multiple) {
                selected = isDefined(selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)));
              } else {
                if (trackFn) {
                  var modelCast = {};
                  modelCast[valueName] = modelValue;
                  selected = trackFn(scope, modelCast) === trackFn(scope, locals);
                } else {
                  selected = modelValue === valueFn(scope, locals);
                }
                selectedSet = selectedSet || selected;
              }
              label = displayFn(scope, locals);
              label = isDefined(label) ? label : "";
              optionGroup.push({
                id: trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index,
                label: label,
                selected: selected
              });
            }
            if (!multiple) {
              if (nullOption || modelValue === null) {
                optionGroups[""].unshift({
                  id: "",
                  label: "",
                  selected: !selectedSet
                });
              } else if (!selectedSet) {
                optionGroups[""].unshift({
                  id: "?",
                  label: "",
                  selected: true
                });
              }
            }
            for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
              optionGroupName = optionGroupNames[groupIndex];
              optionGroup = optionGroups[optionGroupName];
              if (optionGroupsCache.length <= groupIndex) {
                existingParent = {
                  element: optGroupTemplate.clone().attr("label", optionGroupName),
                  label: optionGroup.label
                };
                existingOptions = [ existingParent ];
                optionGroupsCache.push(existingOptions);
                selectElement.append(existingParent.element);
              } else {
                existingOptions = optionGroupsCache[groupIndex];
                existingParent = existingOptions[0];
                if (existingParent.label != optionGroupName) {
                  existingParent.element.attr("label", existingParent.label = optionGroupName);
                }
              }
              lastElement = null;
              for (index = 0, length = optionGroup.length; index < length; index++) {
                option = optionGroup[index];
                if (existingOption = existingOptions[index + 1]) {
                  lastElement = existingOption.element;
                  if (existingOption.label !== option.label) {
                    lastElement.text(existingOption.label = option.label);
                  }
                  if (existingOption.id !== option.id) {
                    lastElement.val(existingOption.id = option.id);
                  }
                  if (lastElement[0].selected !== option.selected) {
                    lastElement.prop("selected", existingOption.selected = option.selected);
                    if (msie) {
                      lastElement.prop("selected", existingOption.selected);
                    }
                  }
                } else {
                  if (option.id === "" && nullOption) {
                    element = nullOption;
                  } else {
                    (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).attr("selected", option.selected).text(option.label);
                  }
                  existingOptions.push(existingOption = {
                    element: element,
                    label: option.label,
                    id: option.id,
                    selected: option.selected
                  });
                  selectCtrl.addOption(option.label, element);
                  if (lastElement) {
                    lastElement.after(element);
                  } else {
                    existingParent.element.append(element);
                  }
                  lastElement = element;
                }
              }
              index++;
              while (existingOptions.length > index) {
                option = existingOptions.pop();
                selectCtrl.removeOption(option.label);
                option.element.remove();
              }
            }
            while (optionGroupsCache.length > groupIndex) {
              optionGroupsCache.pop()[0].element.remove();
            }
          }
        }
      }
    };
  } ];
  var optionDirective = [ "$interpolate", function($interpolate) {
    var nullSelectCtrl = {
      addOption: noop,
      removeOption: noop
    };
    return {
      restrict: "E",
      priority: 100,
      compile: function(element, attr) {
        if (isUndefined(attr.value)) {
          var interpolateFn = $interpolate(element.text(), true);
          if (!interpolateFn) {
            attr.$set("value", element.text());
          }
        }
        return function(scope, element, attr) {
          var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
          if (selectCtrl && selectCtrl.databound) {
            element.prop("selected", false);
          } else {
            selectCtrl = nullSelectCtrl;
          }
          if (interpolateFn) {
            scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
              attr.$set("value", newVal);
              if (newVal !== oldVal) selectCtrl.removeOption(oldVal);
              selectCtrl.addOption(newVal);
            });
          } else {
            selectCtrl.addOption(attr.value);
          }
          element.on("$destroy", function() {
            selectCtrl.removeOption(attr.value);
          });
        };
      }
    };
  } ];
  var styleDirective = valueFn({
    restrict: "E",
    terminal: true
  });
  if (window.angular.bootstrap) {
    console.log("WARNING: Tried to load angular more than once.");
    return;
  }
  bindJQuery();
  publishExternalAPI(angular);
  jqLite(document).ready(function() {
    angularInit(document, bootstrap);
  });
})(window, document);

!window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}.ng-animate-block-transitions{transition:0s all!important;-webkit-transition:0s all!important;}.ng-hide-add-active,.ng-hide-remove{display:block!important;}</style>');
(function() {
  function Pusher(app_key, options) {
    checkAppKey(app_key);
    options = options || {};
    var self = this;
    this.key = app_key;
    this.config = Pusher.Util.extend(Pusher.getGlobalConfig(), options.cluster ? Pusher.getClusterConfig(options.cluster) : {}, options);
    this.channels = new Pusher.Channels();
    this.global_emitter = new Pusher.EventsDispatcher();
    this.sessionID = Math.floor(Math.random() * 1e9);
    this.timeline = new Pusher.Timeline(this.key, this.sessionID, {
      cluster: this.config.cluster,
      features: Pusher.Util.getClientFeatures(),
      params: this.config.timelineParams || {},
      limit: 50,
      level: Pusher.Timeline.INFO,
      version: Pusher.VERSION
    });
    if (!this.config.disableStats) {
      this.timelineSender = new Pusher.TimelineSender(this.timeline, {
        host: this.config.statsHost,
        path: "/timeline/v2/jsonp"
      });
    }
    var getStrategy = function(options) {
      var config = Pusher.Util.extend({}, self.config, options);
      return Pusher.StrategyBuilder.build(Pusher.getDefaultStrategy(config), config);
    };
    this.connection = new Pusher.ConnectionManager(this.key, Pusher.Util.extend({
      getStrategy: getStrategy,
      timeline: this.timeline,
      activityTimeout: this.config.activity_timeout,
      pongTimeout: this.config.pong_timeout,
      unavailableTimeout: this.config.unavailable_timeout
    }, this.config, {
      encrypted: this.isEncrypted()
    }));
    this.connection.bind("connected", function() {
      self.subscribeAll();
      if (self.timelineSender) {
        self.timelineSender.send(self.connection.isEncrypted());
      }
    });
    this.connection.bind("message", function(params) {
      var internal = params.event.indexOf("pusher_internal:") === 0;
      if (params.channel) {
        var channel = self.channel(params.channel);
        if (channel) {
          channel.handleEvent(params.event, params.data);
        }
      }
      if (!internal) {
        self.global_emitter.emit(params.event, params.data);
      }
    });
    this.connection.bind("disconnected", function() {
      self.channels.disconnect();
    });
    this.connection.bind("error", function(err) {
      Pusher.warn("Error", err);
    });
    Pusher.instances.push(this);
    this.timeline.info({
      instances: Pusher.instances.length
    });
    if (Pusher.isReady) {
      self.connect();
    }
  }
  var prototype = Pusher.prototype;
  Pusher.instances = [];
  Pusher.isReady = false;
  Pusher.debug = function() {
    if (!Pusher.log) {
      return;
    }
    Pusher.log(Pusher.Util.stringify.apply(this, arguments));
  };
  Pusher.warn = function() {
    var message = Pusher.Util.stringify.apply(this, arguments);
    if (window.console) {
      if (window.console.warn) {
        window.console.warn(message);
      } else if (window.console.log) {
        window.console.log(message);
      }
    }
    if (Pusher.log) {
      Pusher.log(message);
    }
  };
  Pusher.ready = function() {
    Pusher.isReady = true;
    for (var i = 0, l = Pusher.instances.length; i < l; i++) {
      Pusher.instances[i].connect();
    }
  };
  prototype.channel = function(name) {
    return this.channels.find(name);
  };
  prototype.allChannels = function() {
    return this.channels.all();
  };
  prototype.connect = function() {
    this.connection.connect();
    if (this.timelineSender) {
      if (!this.timelineSenderTimer) {
        var encrypted = this.connection.isEncrypted();
        var timelineSender = this.timelineSender;
        this.timelineSenderTimer = new Pusher.PeriodicTimer(6e4, function() {
          timelineSender.send(encrypted);
        });
      }
    }
  };
  prototype.disconnect = function() {
    this.connection.disconnect();
    if (this.timelineSenderTimer) {
      this.timelineSenderTimer.ensureAborted();
      this.timelineSenderTimer = null;
    }
  };
  prototype.bind = function(event_name, callback) {
    this.global_emitter.bind(event_name, callback);
    return this;
  };
  prototype.bind_all = function(callback) {
    this.global_emitter.bind_all(callback);
    return this;
  };
  prototype.subscribeAll = function() {
    var channelName;
    for (channelName in this.channels.channels) {
      if (this.channels.channels.hasOwnProperty(channelName)) {
        this.subscribe(channelName);
      }
    }
  };
  prototype.subscribe = function(channel_name) {
    var channel = this.channels.add(channel_name, this);
    if (this.connection.state === "connected") {
      channel.subscribe();
    }
    return channel;
  };
  prototype.unsubscribe = function(channel_name) {
    var channel = this.channels.remove(channel_name);
    if (this.connection.state === "connected") {
      channel.unsubscribe();
    }
  };
  prototype.send_event = function(event_name, data, channel) {
    return this.connection.send_event(event_name, data, channel);
  };
  prototype.isEncrypted = function() {
    if (Pusher.Util.getDocument().location.protocol === "https:") {
      return true;
    } else {
      return Boolean(this.config.encrypted);
    }
  };
  function checkAppKey(key) {
    if (key === null || key === undefined) {
      Pusher.warn("Warning", "You must pass your app key when you instantiate Pusher.");
    }
  }
  Pusher.HTTP = {};
  this.Pusher = Pusher;
}).call(this);

(function() {
  function clearTimeout(timer) {
    window.clearTimeout(timer);
  }
  function clearInterval(timer) {
    window.clearInterval(timer);
  }
  function GenericTimer(set, clear, delay, callback) {
    var self = this;
    this.clear = clear;
    this.timer = set(function() {
      if (self.timer !== null) {
        self.timer = callback(self.timer);
      }
    }, delay);
  }
  var prototype = GenericTimer.prototype;
  prototype.isRunning = function() {
    return this.timer !== null;
  };
  prototype.ensureAborted = function() {
    if (this.timer) {
      this.clear(this.timer);
      this.timer = null;
    }
  };
  Pusher.Timer = function(delay, callback) {
    return new GenericTimer(setTimeout, clearTimeout, delay, function(timer) {
      callback();
      return null;
    });
  };
  Pusher.PeriodicTimer = function(delay, callback) {
    return new GenericTimer(setInterval, clearInterval, delay, function(timer) {
      callback();
      return timer;
    });
  };
}).call(this);

(function() {
  Pusher.Util = {
    now: function() {
      if (Date.now) {
        return Date.now();
      } else {
        return new Date().valueOf();
      }
    },
    defer: function(callback) {
      return new Pusher.Timer(0, callback);
    },
    extend: function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var extensions = arguments[i];
        for (var property in extensions) {
          if (extensions[property] && extensions[property].constructor && extensions[property].constructor === Object) {
            target[property] = Pusher.Util.extend(target[property] || {}, extensions[property]);
          } else {
            target[property] = extensions[property];
          }
        }
      }
      return target;
    },
    stringify: function() {
      var m = [ "Pusher" ];
      for (var i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] === "string") {
          m.push(arguments[i]);
        } else {
          if (window.JSON === undefined) {
            m.push(arguments[i].toString());
          } else {
            m.push(JSON.stringify(arguments[i]));
          }
        }
      }
      return m.join(" : ");
    },
    arrayIndexOf: function(array, item) {
      var nativeIndexOf = Array.prototype.indexOf;
      if (array === null) {
        return -1;
      }
      if (nativeIndexOf && array.indexOf === nativeIndexOf) {
        return array.indexOf(item);
      }
      for (var i = 0, l = array.length; i < l; i++) {
        if (array[i] === item) {
          return i;
        }
      }
      return -1;
    },
    objectApply: function(object, f) {
      for (var key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          f(object[key], key, object);
        }
      }
    },
    keys: function(object) {
      var keys = [];
      Pusher.Util.objectApply(object, function(_, key) {
        keys.push(key);
      });
      return keys;
    },
    values: function(object) {
      var values = [];
      Pusher.Util.objectApply(object, function(value) {
        values.push(value);
      });
      return values;
    },
    apply: function(array, f, context) {
      for (var i = 0; i < array.length; i++) {
        f.call(context || window, array[i], i, array);
      }
    },
    map: function(array, f) {
      var result = [];
      for (var i = 0; i < array.length; i++) {
        result.push(f(array[i], i, array, result));
      }
      return result;
    },
    mapObject: function(object, f) {
      var result = {};
      Pusher.Util.objectApply(object, function(value, key) {
        result[key] = f(value);
      });
      return result;
    },
    filter: function(array, test) {
      test = test || function(value) {
        return !!value;
      };
      var result = [];
      for (var i = 0; i < array.length; i++) {
        if (test(array[i], i, array, result)) {
          result.push(array[i]);
        }
      }
      return result;
    },
    filterObject: function(object, test) {
      var result = {};
      Pusher.Util.objectApply(object, function(value, key) {
        if (test && test(value, key, object, result) || Boolean(value)) {
          result[key] = value;
        }
      });
      return result;
    },
    flatten: function(object) {
      var result = [];
      Pusher.Util.objectApply(object, function(value, key) {
        result.push([ key, value ]);
      });
      return result;
    },
    any: function(array, test) {
      for (var i = 0; i < array.length; i++) {
        if (test(array[i], i, array)) {
          return true;
        }
      }
      return false;
    },
    all: function(array, test) {
      for (var i = 0; i < array.length; i++) {
        if (!test(array[i], i, array)) {
          return false;
        }
      }
      return true;
    },
    method: function(name) {
      var boundArguments = Array.prototype.slice.call(arguments, 1);
      return function(object) {
        return object[name].apply(object, boundArguments.concat(arguments));
      };
    },
    getWindow: function() {
      return window;
    },
    getDocument: function() {
      return document;
    },
    getNavigator: function() {
      return navigator;
    },
    getLocalStorage: function() {
      try {
        return window.localStorage;
      } catch (e) {
        return undefined;
      }
    },
    getClientFeatures: function() {
      return Pusher.Util.keys(Pusher.Util.filterObject({
        ws: Pusher.WSTransport,
        flash: Pusher.FlashTransport
      }, function(t) {
        return t.isSupported({});
      }));
    },
    addWindowListener: function(event, listener) {
      var _window = Pusher.Util.getWindow();
      if (_window.addEventListener !== undefined) {
        _window.addEventListener(event, listener, false);
      } else {
        _window.attachEvent("on" + event, listener);
      }
    },
    removeWindowListener: function(event, listener) {
      var _window = Pusher.Util.getWindow();
      if (_window.addEventListener !== undefined) {
        _window.removeEventListener(event, listener, false);
      } else {
        _window.detachEvent("on" + event, listener);
      }
    },
    isXHRSupported: function() {
      var XHR = window.XMLHttpRequest;
      return Boolean(XHR) && new XHR().withCredentials !== undefined;
    },
    isXDRSupported: function(encrypted) {
      var protocol = encrypted ? "https:" : "http:";
      var documentProtocol = Pusher.Util.getDocument().location.protocol;
      return Boolean(window.XDomainRequest) && documentProtocol === protocol;
    }
  };
}).call(this);

(function() {
  Pusher.VERSION = "2.2.3";
  Pusher.PROTOCOL = 7;
  Pusher.host = "ws.pusherapp.com";
  Pusher.ws_port = 80;
  Pusher.wss_port = 443;
  Pusher.sockjs_host = "sockjs.pusher.com";
  Pusher.sockjs_http_port = 80;
  Pusher.sockjs_https_port = 443;
  Pusher.sockjs_path = "/pusher";
  Pusher.stats_host = "stats.pusher.com";
  Pusher.channel_auth_endpoint = "/pusher/auth";
  Pusher.channel_auth_transport = "ajax";
  Pusher.activity_timeout = 12e4;
  Pusher.pong_timeout = 3e4;
  Pusher.unavailable_timeout = 1e4;
  Pusher.cdn_http = "http://js.pusher.com/";
  Pusher.cdn_https = "https://js.pusher.com/";
  Pusher.dependency_suffix = "";
  Pusher.getDefaultStrategy = function(config) {
    var wsStrategy;
    if (config.encrypted) {
      wsStrategy = [ ":best_connected_ever", ":ws_loop", [ ":delayed", 2e3, [ ":http_fallback_loop" ] ] ];
    } else {
      wsStrategy = [ ":best_connected_ever", ":ws_loop", [ ":delayed", 2e3, [ ":wss_loop" ] ], [ ":delayed", 5e3, [ ":http_fallback_loop" ] ] ];
    }
    return [ [ ":def", "ws_options", {
      hostUnencrypted: config.wsHost + ":" + config.wsPort,
      hostEncrypted: config.wsHost + ":" + config.wssPort
    } ], [ ":def", "wss_options", [ ":extend", ":ws_options", {
      encrypted: true
    } ] ], [ ":def", "sockjs_options", {
      hostUnencrypted: config.httpHost + ":" + config.httpPort,
      hostEncrypted: config.httpHost + ":" + config.httpsPort,
      httpPath: config.httpPath
    } ], [ ":def", "timeouts", {
      loop: true,
      timeout: 15e3,
      timeoutLimit: 6e4
    } ], [ ":def", "ws_manager", [ ":transport_manager", {
      lives: 2,
      minPingDelay: 1e4,
      maxPingDelay: config.activity_timeout
    } ] ], [ ":def", "streaming_manager", [ ":transport_manager", {
      lives: 2,
      minPingDelay: 1e4,
      maxPingDelay: config.activity_timeout
    } ] ], [ ":def_transport", "ws", "ws", 3, ":ws_options", ":ws_manager" ], [ ":def_transport", "wss", "ws", 3, ":wss_options", ":ws_manager" ], [ ":def_transport", "flash", "flash", 2, ":ws_options", ":ws_manager" ], [ ":def_transport", "sockjs", "sockjs", 1, ":sockjs_options" ], [ ":def_transport", "xhr_streaming", "xhr_streaming", 1, ":sockjs_options", ":streaming_manager" ], [ ":def_transport", "xdr_streaming", "xdr_streaming", 1, ":sockjs_options", ":streaming_manager" ], [ ":def_transport", "xhr_polling", "xhr_polling", 1, ":sockjs_options" ], [ ":def_transport", "xdr_polling", "xdr_polling", 1, ":sockjs_options" ], [ ":def", "ws_loop", [ ":sequential", ":timeouts", ":ws" ] ], [ ":def", "wss_loop", [ ":sequential", ":timeouts", ":wss" ] ], [ ":def", "flash_loop", [ ":sequential", ":timeouts", ":flash" ] ], [ ":def", "sockjs_loop", [ ":sequential", ":timeouts", ":sockjs" ] ], [ ":def", "streaming_loop", [ ":sequential", ":timeouts", [ ":if", [ ":is_supported", ":xhr_streaming" ], ":xhr_streaming", ":xdr_streaming" ] ] ], [ ":def", "polling_loop", [ ":sequential", ":timeouts", [ ":if", [ ":is_supported", ":xhr_polling" ], ":xhr_polling", ":xdr_polling" ] ] ], [ ":def", "http_loop", [ ":if", [ ":is_supported", ":streaming_loop" ], [ ":best_connected_ever", ":streaming_loop", [ ":delayed", 4e3, [ ":polling_loop" ] ] ], [ ":polling_loop" ] ] ], [ ":def", "http_fallback_loop", [ ":if", [ ":is_supported", ":http_loop" ], [ ":http_loop" ], [ ":sockjs_loop" ] ] ], [ ":def", "strategy", [ ":cached", 18e5, [ ":first_connected", [ ":if", [ ":is_supported", ":ws" ], wsStrategy, [ ":if", [ ":is_supported", ":flash" ], [ ":best_connected_ever", ":flash_loop", [ ":delayed", 2e3, [ ":http_fallback_loop" ] ] ], [ ":http_fallback_loop" ] ] ] ] ] ] ];
  };
}).call(this);

(function() {
  Pusher.getGlobalConfig = function() {
    return {
      wsHost: Pusher.host,
      wsPort: Pusher.ws_port,
      wssPort: Pusher.wss_port,
      httpHost: Pusher.sockjs_host,
      httpPort: Pusher.sockjs_http_port,
      httpsPort: Pusher.sockjs_https_port,
      httpPath: Pusher.sockjs_path,
      statsHost: Pusher.stats_host,
      authEndpoint: Pusher.channel_auth_endpoint,
      authTransport: Pusher.channel_auth_transport,
      activity_timeout: Pusher.activity_timeout,
      pong_timeout: Pusher.pong_timeout,
      unavailable_timeout: Pusher.unavailable_timeout
    };
  };
  Pusher.getClusterConfig = function(clusterName) {
    return {
      wsHost: "ws-" + clusterName + ".pusher.com",
      httpHost: "sockjs-" + clusterName + ".pusher.com"
    };
  };
}).call(this);

(function() {
  function buildExceptionClass(name) {
    var constructor = function(message) {
      Error.call(this, message);
      this.name = name;
    };
    Pusher.Util.extend(constructor.prototype, Error.prototype);
    return constructor;
  }
  Pusher.Errors = {
    BadEventName: buildExceptionClass("BadEventName"),
    RequestTimedOut: buildExceptionClass("RequestTimedOut"),
    TransportPriorityTooLow: buildExceptionClass("TransportPriorityTooLow"),
    TransportClosed: buildExceptionClass("TransportClosed"),
    UnsupportedTransport: buildExceptionClass("UnsupportedTransport"),
    UnsupportedStrategy: buildExceptionClass("UnsupportedStrategy")
  };
}).call(this);

(function() {
  function EventsDispatcher(failThrough) {
    this.callbacks = new CallbackRegistry();
    this.global_callbacks = [];
    this.failThrough = failThrough;
  }
  var prototype = EventsDispatcher.prototype;
  prototype.bind = function(eventName, callback, context) {
    this.callbacks.add(eventName, callback, context);
    return this;
  };
  prototype.bind_all = function(callback) {
    this.global_callbacks.push(callback);
    return this;
  };
  prototype.unbind = function(eventName, callback, context) {
    this.callbacks.remove(eventName, callback, context);
    return this;
  };
  prototype.unbind_all = function(eventName, callback) {
    this.callbacks.remove(eventName, callback);
    return this;
  };
  prototype.emit = function(eventName, data) {
    var i;
    for (i = 0; i < this.global_callbacks.length; i++) {
      this.global_callbacks[i](eventName, data);
    }
    var callbacks = this.callbacks.get(eventName);
    if (callbacks && callbacks.length > 0) {
      for (i = 0; i < callbacks.length; i++) {
        callbacks[i].fn.call(callbacks[i].context || window, data);
      }
    } else if (this.failThrough) {
      this.failThrough(eventName, data);
    }
    return this;
  };
  function CallbackRegistry() {
    this._callbacks = {};
  }
  CallbackRegistry.prototype.get = function(name) {
    return this._callbacks[prefix(name)];
  };
  CallbackRegistry.prototype.add = function(name, callback, context) {
    var prefixedEventName = prefix(name);
    this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];
    this._callbacks[prefixedEventName].push({
      fn: callback,
      context: context
    });
  };
  CallbackRegistry.prototype.remove = function(name, callback, context) {
    if (!name && !callback && !context) {
      this._callbacks = {};
      return;
    }
    var names = name ? [ prefix(name) ] : Pusher.Util.keys(this._callbacks);
    if (callback || context) {
      Pusher.Util.apply(names, function(name) {
        this._callbacks[name] = Pusher.Util.filter(this._callbacks[name] || [], function(binding) {
          return callback && callback !== binding.fn || context && context !== binding.context;
        });
        if (this._callbacks[name].length === 0) {
          delete this._callbacks[name];
        }
      }, this);
    } else {
      Pusher.Util.apply(names, function(name) {
        delete this._callbacks[name];
      }, this);
    }
  };
  function prefix(name) {
    return "_" + name;
  }
  Pusher.EventsDispatcher = EventsDispatcher;
}).call(this);

(function() {
  function ScriptReceiverFactory(prefix, name) {
    this.lastId = 0;
    this.prefix = prefix;
    this.name = name;
  }
  var prototype = ScriptReceiverFactory.prototype;
  prototype.create = function(callback) {
    this.lastId++;
    var number = this.lastId;
    var id = this.prefix + number;
    var name = this.name + "[" + number + "]";
    var called = false;
    var callbackWrapper = function() {
      if (!called) {
        callback.apply(null, arguments);
        called = true;
      }
    };
    this[number] = callbackWrapper;
    return {
      number: number,
      id: id,
      name: name,
      callback: callbackWrapper
    };
  };
  prototype.remove = function(receiver) {
    delete this[receiver.number];
  };
  Pusher.ScriptReceiverFactory = ScriptReceiverFactory;
  Pusher.ScriptReceivers = new ScriptReceiverFactory("_pusher_script_", "Pusher.ScriptReceivers");
}).call(this);

(function() {
  function ScriptRequest(src) {
    this.src = src;
  }
  var prototype = ScriptRequest.prototype;
  prototype.send = function(receiver) {
    var self = this;
    var errorString = "Error loading " + self.src;
    self.script = document.createElement("script");
    self.script.id = receiver.id;
    self.script.src = self.src;
    self.script.type = "text/javascript";
    self.script.charset = "UTF-8";
    if (self.script.addEventListener) {
      self.script.onerror = function() {
        receiver.callback(errorString);
      };
      self.script.onload = function() {
        receiver.callback(null);
      };
    } else {
      self.script.onreadystatechange = function() {
        if (self.script.readyState === "loaded" || self.script.readyState === "complete") {
          receiver.callback(null);
        }
      };
    }
    if (self.script.async === undefined && document.attachEvent && /opera/i.test(navigator.userAgent)) {
      self.errorScript = document.createElement("script");
      self.errorScript.id = receiver.id + "_error";
      self.errorScript.text = receiver.name + "('" + errorString + "');";
      self.script.async = self.errorScript.async = false;
    } else {
      self.script.async = true;
    }
    var head = document.getElementsByTagName("head")[0];
    head.insertBefore(self.script, head.firstChild);
    if (self.errorScript) {
      head.insertBefore(self.errorScript, self.script.nextSibling);
    }
  };
  prototype.cleanup = function() {
    if (this.script) {
      this.script.onload = this.script.onerror = null;
      this.script.onreadystatechange = null;
    }
    if (this.script && this.script.parentNode) {
      this.script.parentNode.removeChild(this.script);
    }
    if (this.errorScript && this.errorScript.parentNode) {
      this.errorScript.parentNode.removeChild(this.errorScript);
    }
    this.script = null;
    this.errorScript = null;
  };
  Pusher.ScriptRequest = ScriptRequest;
}).call(this);

(function() {
  function DependencyLoader(options) {
    this.options = options;
    this.receivers = options.receivers || Pusher.ScriptReceivers;
    this.loading = {};
  }
  var prototype = DependencyLoader.prototype;
  prototype.load = function(name, callback) {
    var self = this;
    if (self.loading[name] && self.loading[name].length > 0) {
      self.loading[name].push(callback);
    } else {
      self.loading[name] = [ callback ];
      var request = new Pusher.ScriptRequest(self.getPath(name));
      var receiver = self.receivers.create(function(error) {
        self.receivers.remove(receiver);
        if (self.loading[name]) {
          var callbacks = self.loading[name];
          delete self.loading[name];
          var successCallback = function(wasSuccessful) {
            if (!wasSuccessful) {
              request.cleanup();
            }
          };
          for (var i = 0; i < callbacks.length; i++) {
            callbacks[i](error, successCallback);
          }
        }
      });
      request.send(receiver);
    }
  };
  prototype.getRoot = function(options) {
    var cdn;
    var protocol = Pusher.Util.getDocument().location.protocol;
    if (options && options.encrypted || protocol === "https:") {
      cdn = this.options.cdn_https;
    } else {
      cdn = this.options.cdn_http;
    }
    return cdn.replace(/\/*$/, "") + "/" + this.options.version;
  };
  prototype.getPath = function(name, options) {
    return this.getRoot(options) + "/" + name + this.options.suffix + ".js";
  };
  Pusher.DependencyLoader = DependencyLoader;
}).call(this);

(function() {
  Pusher.DependenciesReceivers = new Pusher.ScriptReceiverFactory("_pusher_dependencies", "Pusher.DependenciesReceivers");
  Pusher.Dependencies = new Pusher.DependencyLoader({
    cdn_http: Pusher.cdn_http,
    cdn_https: Pusher.cdn_https,
    version: Pusher.VERSION,
    suffix: Pusher.dependency_suffix,
    receivers: Pusher.DependenciesReceivers
  });
  function initialize() {
    Pusher.ready();
  }
  function onDocumentBody(callback) {
    if (document.body) {
      callback();
    } else {
      setTimeout(function() {
        onDocumentBody(callback);
      }, 0);
    }
  }
  function initializeOnDocumentBody() {
    onDocumentBody(initialize);
  }
  if (!window.JSON) {
    Pusher.Dependencies.load("json2", initializeOnDocumentBody);
  } else {
    initializeOnDocumentBody();
  }
})();

(function() {
  var Base64 = {
    encode: function(s) {
      return btoa(utob(s));
    }
  };
  var fromCharCode = String.fromCharCode;
  var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var b64tab = {};
  for (var i = 0, l = b64chars.length; i < l; i++) {
    b64tab[b64chars.charAt(i)] = i;
  }
  var cb_utob = function(c) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | cc & 63) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
  };
  var utob = function(u) {
    return u.replace(/[^\x00-\x7F]/g, cb_utob);
  };
  var cb_encode = function(ccc) {
    var padlen = [ 0, 2, 1 ][ccc.length % 3];
    var ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0);
    var chars = [ b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? "=" : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? "=" : b64chars.charAt(ord & 63) ];
    return chars.join("");
  };
  var btoa = window.btoa || function(b) {
    return b.replace(/[\s\S]{1,3}/g, cb_encode);
  };
  Pusher.Base64 = Base64;
}).call(this);

(function() {
  function JSONPRequest(url, data) {
    this.url = url;
    this.data = data;
  }
  var prototype = JSONPRequest.prototype;
  prototype.send = function(receiver) {
    if (this.request) {
      return;
    }
    var params = Pusher.Util.filterObject(this.data, function(value) {
      return value !== undefined;
    });
    var query = Pusher.Util.map(Pusher.Util.flatten(encodeParamsObject(params)), Pusher.Util.method("join", "=")).join("&");
    var url = this.url + "/" + receiver.number + "?" + query;
    this.request = new Pusher.ScriptRequest(url);
    this.request.send(receiver);
  };
  prototype.cleanup = function() {
    if (this.request) {
      this.request.cleanup();
    }
  };
  function encodeParamsObject(data) {
    return Pusher.Util.mapObject(data, function(value) {
      if (typeof value === "object") {
        value = JSON.stringify(value);
      }
      return encodeURIComponent(Pusher.Base64.encode(value.toString()));
    });
  }
  Pusher.JSONPRequest = JSONPRequest;
}).call(this);

(function() {
  function Timeline(key, session, options) {
    this.key = key;
    this.session = session;
    this.events = [];
    this.options = options || {};
    this.sent = 0;
    this.uniqueID = 0;
  }
  var prototype = Timeline.prototype;
  Timeline.ERROR = 3;
  Timeline.INFO = 6;
  Timeline.DEBUG = 7;
  prototype.log = function(level, event) {
    if (level <= this.options.level) {
      this.events.push(Pusher.Util.extend({}, event, {
        timestamp: Pusher.Util.now()
      }));
      if (this.options.limit && this.events.length > this.options.limit) {
        this.events.shift();
      }
    }
  };
  prototype.error = function(event) {
    this.log(Timeline.ERROR, event);
  };
  prototype.info = function(event) {
    this.log(Timeline.INFO, event);
  };
  prototype.debug = function(event) {
    this.log(Timeline.DEBUG, event);
  };
  prototype.isEmpty = function() {
    return this.events.length === 0;
  };
  prototype.send = function(sendJSONP, callback) {
    var self = this;
    var data = Pusher.Util.extend({
      session: self.session,
      bundle: self.sent + 1,
      key: self.key,
      lib: "js",
      version: self.options.version,
      cluster: self.options.cluster,
      features: self.options.features,
      timeline: self.events
    }, self.options.params);
    self.events = [];
    sendJSONP(data, function(error, result) {
      if (!error) {
        self.sent++;
      }
      if (callback) {
        callback(error, result);
      }
    });
    return true;
  };
  prototype.generateUniqueID = function() {
    this.uniqueID++;
    return this.uniqueID;
  };
  Pusher.Timeline = Timeline;
}).call(this);

(function() {
  function TimelineSender(timeline, options) {
    this.timeline = timeline;
    this.options = options || {};
  }
  var prototype = TimelineSender.prototype;
  prototype.send = function(encrypted, callback) {
    var self = this;
    if (self.timeline.isEmpty()) {
      return;
    }
    var sendJSONP = function(data, callback) {
      var scheme = "http" + (encrypted ? "s" : "") + "://";
      var url = scheme + (self.host || self.options.host) + self.options.path;
      var request = new Pusher.JSONPRequest(url, data);
      var receiver = Pusher.ScriptReceivers.create(function(error, result) {
        Pusher.ScriptReceivers.remove(receiver);
        request.cleanup();
        if (result && result.host) {
          self.host = result.host;
        }
        if (callback) {
          callback(error, result);
        }
      });
      request.send(receiver);
    };
    self.timeline.send(sendJSONP, callback);
  };
  Pusher.TimelineSender = TimelineSender;
}).call(this);

(function() {
  function BestConnectedEverStrategy(strategies) {
    this.strategies = strategies;
  }
  var prototype = BestConnectedEverStrategy.prototype;
  prototype.isSupported = function() {
    return Pusher.Util.any(this.strategies, Pusher.Util.method("isSupported"));
  };
  prototype.connect = function(minPriority, callback) {
    return connect(this.strategies, minPriority, function(i, runners) {
      return function(error, handshake) {
        runners[i].error = error;
        if (error) {
          if (allRunnersFailed(runners)) {
            callback(true);
          }
          return;
        }
        Pusher.Util.apply(runners, function(runner) {
          runner.forceMinPriority(handshake.transport.priority);
        });
        callback(null, handshake);
      };
    });
  };
  function connect(strategies, minPriority, callbackBuilder) {
    var runners = Pusher.Util.map(strategies, function(strategy, i, _, rs) {
      return strategy.connect(minPriority, callbackBuilder(i, rs));
    });
    return {
      abort: function() {
        Pusher.Util.apply(runners, abortRunner);
      },
      forceMinPriority: function(p) {
        Pusher.Util.apply(runners, function(runner) {
          runner.forceMinPriority(p);
        });
      }
    };
  }
  function allRunnersFailed(runners) {
    return Pusher.Util.all(runners, function(runner) {
      return Boolean(runner.error);
    });
  }
  function abortRunner(runner) {
    if (!runner.error && !runner.aborted) {
      runner.abort();
      runner.aborted = true;
    }
  }
  Pusher.BestConnectedEverStrategy = BestConnectedEverStrategy;
}).call(this);

(function() {
  function CachedStrategy(strategy, transports, options) {
    this.strategy = strategy;
    this.transports = transports;
    this.ttl = options.ttl || 1800 * 1e3;
    this.encrypted = options.encrypted;
    this.timeline = options.timeline;
  }
  var prototype = CachedStrategy.prototype;
  prototype.isSupported = function() {
    return this.strategy.isSupported();
  };
  prototype.connect = function(minPriority, callback) {
    var encrypted = this.encrypted;
    var info = fetchTransportCache(encrypted);
    var strategies = [ this.strategy ];
    if (info && info.timestamp + this.ttl >= Pusher.Util.now()) {
      var transport = this.transports[info.transport];
      if (transport) {
        this.timeline.info({
          cached: true,
          transport: info.transport,
          latency: info.latency
        });
        strategies.push(new Pusher.SequentialStrategy([ transport ], {
          timeout: info.latency * 2 + 1e3,
          failFast: true
        }));
      }
    }
    var startTimestamp = Pusher.Util.now();
    var runner = strategies.pop().connect(minPriority, function cb(error, handshake) {
      if (error) {
        flushTransportCache(encrypted);
        if (strategies.length > 0) {
          startTimestamp = Pusher.Util.now();
          runner = strategies.pop().connect(minPriority, cb);
        } else {
          callback(error);
        }
      } else {
        storeTransportCache(encrypted, handshake.transport.name, Pusher.Util.now() - startTimestamp);
        callback(null, handshake);
      }
    });
    return {
      abort: function() {
        runner.abort();
      },
      forceMinPriority: function(p) {
        minPriority = p;
        if (runner) {
          runner.forceMinPriority(p);
        }
      }
    };
  };
  function getTransportCacheKey(encrypted) {
    return "pusherTransport" + (encrypted ? "Encrypted" : "Unencrypted");
  }
  function fetchTransportCache(encrypted) {
    var storage = Pusher.Util.getLocalStorage();
    if (storage) {
      try {
        var serializedCache = storage[getTransportCacheKey(encrypted)];
        if (serializedCache) {
          return JSON.parse(serializedCache);
        }
      } catch (e) {
        flushTransportCache(encrypted);
      }
    }
    return null;
  }
  function storeTransportCache(encrypted, transport, latency) {
    var storage = Pusher.Util.getLocalStorage();
    if (storage) {
      try {
        storage[getTransportCacheKey(encrypted)] = JSON.stringify({
          timestamp: Pusher.Util.now(),
          transport: transport,
          latency: latency
        });
      } catch (e) {}
    }
  }
  function flushTransportCache(encrypted) {
    var storage = Pusher.Util.getLocalStorage();
    if (storage) {
      try {
        delete storage[getTransportCacheKey(encrypted)];
      } catch (e) {}
    }
  }
  Pusher.CachedStrategy = CachedStrategy;
}).call(this);

(function() {
  function DelayedStrategy(strategy, options) {
    this.strategy = strategy;
    this.options = {
      delay: options.delay
    };
  }
  var prototype = DelayedStrategy.prototype;
  prototype.isSupported = function() {
    return this.strategy.isSupported();
  };
  prototype.connect = function(minPriority, callback) {
    var strategy = this.strategy;
    var runner;
    var timer = new Pusher.Timer(this.options.delay, function() {
      runner = strategy.connect(minPriority, callback);
    });
    return {
      abort: function() {
        timer.ensureAborted();
        if (runner) {
          runner.abort();
        }
      },
      forceMinPriority: function(p) {
        minPriority = p;
        if (runner) {
          runner.forceMinPriority(p);
        }
      }
    };
  };
  Pusher.DelayedStrategy = DelayedStrategy;
}).call(this);

(function() {
  function FirstConnectedStrategy(strategy) {
    this.strategy = strategy;
  }
  var prototype = FirstConnectedStrategy.prototype;
  prototype.isSupported = function() {
    return this.strategy.isSupported();
  };
  prototype.connect = function(minPriority, callback) {
    var runner = this.strategy.connect(minPriority, function(error, handshake) {
      if (handshake) {
        runner.abort();
      }
      callback(error, handshake);
    });
    return runner;
  };
  Pusher.FirstConnectedStrategy = FirstConnectedStrategy;
}).call(this);

(function() {
  function IfStrategy(test, trueBranch, falseBranch) {
    this.test = test;
    this.trueBranch = trueBranch;
    this.falseBranch = falseBranch;
  }
  var prototype = IfStrategy.prototype;
  prototype.isSupported = function() {
    var branch = this.test() ? this.trueBranch : this.falseBranch;
    return branch.isSupported();
  };
  prototype.connect = function(minPriority, callback) {
    var branch = this.test() ? this.trueBranch : this.falseBranch;
    return branch.connect(minPriority, callback);
  };
  Pusher.IfStrategy = IfStrategy;
}).call(this);

(function() {
  function SequentialStrategy(strategies, options) {
    this.strategies = strategies;
    this.loop = Boolean(options.loop);
    this.failFast = Boolean(options.failFast);
    this.timeout = options.timeout;
    this.timeoutLimit = options.timeoutLimit;
  }
  var prototype = SequentialStrategy.prototype;
  prototype.isSupported = function() {
    return Pusher.Util.any(this.strategies, Pusher.Util.method("isSupported"));
  };
  prototype.connect = function(minPriority, callback) {
    var self = this;
    var strategies = this.strategies;
    var current = 0;
    var timeout = this.timeout;
    var runner = null;
    var tryNextStrategy = function(error, handshake) {
      if (handshake) {
        callback(null, handshake);
      } else {
        current = current + 1;
        if (self.loop) {
          current = current % strategies.length;
        }
        if (current < strategies.length) {
          if (timeout) {
            timeout = timeout * 2;
            if (self.timeoutLimit) {
              timeout = Math.min(timeout, self.timeoutLimit);
            }
          }
          runner = self.tryStrategy(strategies[current], minPriority, {
            timeout: timeout,
            failFast: self.failFast
          }, tryNextStrategy);
        } else {
          callback(true);
        }
      }
    };
    runner = this.tryStrategy(strategies[current], minPriority, {
      timeout: timeout,
      failFast: this.failFast
    }, tryNextStrategy);
    return {
      abort: function() {
        runner.abort();
      },
      forceMinPriority: function(p) {
        minPriority = p;
        if (runner) {
          runner.forceMinPriority(p);
        }
      }
    };
  };
  prototype.tryStrategy = function(strategy, minPriority, options, callback) {
    var timer = null;
    var runner = null;
    if (options.timeout > 0) {
      timer = new Pusher.Timer(options.timeout, function() {
        runner.abort();
        callback(true);
      });
    }
    runner = strategy.connect(minPriority, function(error, handshake) {
      if (error && timer && timer.isRunning() && !options.failFast) {
        return;
      }
      if (timer) {
        timer.ensureAborted();
      }
      callback(error, handshake);
    });
    return {
      abort: function() {
        if (timer) {
          timer.ensureAborted();
        }
        runner.abort();
      },
      forceMinPriority: function(p) {
        runner.forceMinPriority(p);
      }
    };
  };
  Pusher.SequentialStrategy = SequentialStrategy;
}).call(this);

(function() {
  function TransportStrategy(name, priority, transport, options) {
    this.name = name;
    this.priority = priority;
    this.transport = transport;
    this.options = options || {};
  }
  var prototype = TransportStrategy.prototype;
  prototype.isSupported = function() {
    return this.transport.isSupported({
      encrypted: this.options.encrypted
    });
  };
  prototype.connect = function(minPriority, callback) {
    if (!this.isSupported()) {
      return failAttempt(new Pusher.Errors.UnsupportedStrategy(), callback);
    } else if (this.priority < minPriority) {
      return failAttempt(new Pusher.Errors.TransportPriorityTooLow(), callback);
    }
    var self = this;
    var connected = false;
    var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);
    var handshake = null;
    var onInitialized = function() {
      transport.unbind("initialized", onInitialized);
      transport.connect();
    };
    var onOpen = function() {
      handshake = new Pusher.Handshake(transport, function(result) {
        connected = true;
        unbindListeners();
        callback(null, result);
      });
    };
    var onError = function(error) {
      unbindListeners();
      callback(error);
    };
    var onClosed = function() {
      unbindListeners();
      callback(new Pusher.Errors.TransportClosed(transport));
    };
    var unbindListeners = function() {
      transport.unbind("initialized", onInitialized);
      transport.unbind("open", onOpen);
      transport.unbind("error", onError);
      transport.unbind("closed", onClosed);
    };
    transport.bind("initialized", onInitialized);
    transport.bind("open", onOpen);
    transport.bind("error", onError);
    transport.bind("closed", onClosed);
    transport.initialize();
    return {
      abort: function() {
        if (connected) {
          return;
        }
        unbindListeners();
        if (handshake) {
          handshake.close();
        } else {
          transport.close();
        }
      },
      forceMinPriority: function(p) {
        if (connected) {
          return;
        }
        if (self.priority < p) {
          if (handshake) {
            handshake.close();
          } else {
            transport.close();
          }
        }
      }
    };
  };
  function failAttempt(error, callback) {
    Pusher.Util.defer(function() {
      callback(error);
    });
    return {
      abort: function() {},
      forceMinPriority: function() {}
    };
  }
  Pusher.TransportStrategy = TransportStrategy;
}).call(this);

(function() {
  function getGenericURL(baseScheme, params, path) {
    var scheme = baseScheme + (params.encrypted ? "s" : "");
    var host = params.encrypted ? params.hostEncrypted : params.hostUnencrypted;
    return scheme + "://" + host + path;
  }
  function getGenericPath(key, queryString) {
    var path = "/app/" + key;
    var query = "?protocol=" + Pusher.PROTOCOL + "&client=js" + "&version=" + Pusher.VERSION + (queryString ? "&" + queryString : "");
    return path + query;
  }
  Pusher.URLSchemes = {
    ws: {
      getInitial: function(key, params) {
        return getGenericURL("ws", params, getGenericPath(key, "flash=false"));
      }
    },
    flash: {
      getInitial: function(key, params) {
        return getGenericURL("ws", params, getGenericPath(key, "flash=true"));
      }
    },
    sockjs: {
      getInitial: function(key, params) {
        return getGenericURL("http", params, params.httpPath || "/pusher", "");
      },
      getPath: function(key, params) {
        return getGenericPath(key);
      }
    },
    http: {
      getInitial: function(key, params) {
        var path = (params.httpPath || "/pusher") + getGenericPath(key);
        return getGenericURL("http", params, path);
      }
    }
  };
}).call(this);

(function() {
  function TransportConnection(hooks, name, priority, key, options) {
    Pusher.EventsDispatcher.call(this);
    this.hooks = hooks;
    this.name = name;
    this.priority = priority;
    this.key = key;
    this.options = options;
    this.state = "new";
    this.timeline = options.timeline;
    this.activityTimeout = options.activityTimeout;
    this.id = this.timeline.generateUniqueID();
  }
  var prototype = TransportConnection.prototype;
  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);
  prototype.handlesActivityChecks = function() {
    return Boolean(this.hooks.handlesActivityChecks);
  };
  prototype.supportsPing = function() {
    return Boolean(this.hooks.supportsPing);
  };
  prototype.initialize = function() {
    var self = this;
    self.timeline.info(self.buildTimelineMessage({
      transport: self.name + (self.options.encrypted ? "s" : "")
    }));
    if (self.hooks.beforeInitialize) {
      self.hooks.beforeInitialize();
    }
    if (self.hooks.isInitialized()) {
      self.changeState("initialized");
    } else if (self.hooks.file) {
      self.changeState("initializing");
      Pusher.Dependencies.load(self.hooks.file, function(error, callback) {
        if (self.hooks.isInitialized()) {
          self.changeState("initialized");
          callback(true);
        } else {
          if (error) {
            self.onError(error);
          }
          self.onClose();
          callback(false);
        }
      });
    } else {
      self.onClose();
    }
  };
  prototype.connect = function() {
    var self = this;
    if (self.socket || self.state !== "initialized") {
      return false;
    }
    var url = self.hooks.urls.getInitial(self.key, self.options);
    try {
      self.socket = self.hooks.getSocket(url, self.options);
    } catch (e) {
      Pusher.Util.defer(function() {
        self.onError(e);
        self.changeState("closed");
      });
      return false;
    }
    self.bindListeners();
    Pusher.debug("Connecting", {
      transport: self.name,
      url: url
    });
    self.changeState("connecting");
    return true;
  };
  prototype.close = function() {
    if (this.socket) {
      this.socket.close();
      return true;
    } else {
      return false;
    }
  };
  prototype.send = function(data) {
    var self = this;
    if (self.state === "open") {
      Pusher.Util.defer(function() {
        if (self.socket) {
          self.socket.send(data);
        }
      });
      return true;
    } else {
      return false;
    }
  };
  prototype.ping = function() {
    if (this.state === "open" && this.supportsPing()) {
      this.socket.ping();
    }
  };
  prototype.onOpen = function() {
    if (this.hooks.beforeOpen) {
      this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));
    }
    this.changeState("open");
    this.socket.onopen = undefined;
  };
  prototype.onError = function(error) {
    this.emit("error", {
      type: "WebSocketError",
      error: error
    });
    this.timeline.error(this.buildTimelineMessage({
      error: error.toString()
    }));
  };
  prototype.onClose = function(closeEvent) {
    if (closeEvent) {
      this.changeState("closed", {
        code: closeEvent.code,
        reason: closeEvent.reason,
        wasClean: closeEvent.wasClean
      });
    } else {
      this.changeState("closed");
    }
    this.unbindListeners();
    this.socket = undefined;
  };
  prototype.onMessage = function(message) {
    this.emit("message", message);
  };
  prototype.onActivity = function() {
    this.emit("activity");
  };
  prototype.bindListeners = function() {
    var self = this;
    self.socket.onopen = function() {
      self.onOpen();
    };
    self.socket.onerror = function(error) {
      self.onError(error);
    };
    self.socket.onclose = function(closeEvent) {
      self.onClose(closeEvent);
    };
    self.socket.onmessage = function(message) {
      self.onMessage(message);
    };
    if (self.supportsPing()) {
      self.socket.onactivity = function() {
        self.onActivity();
      };
    }
  };
  prototype.unbindListeners = function() {
    if (this.socket) {
      this.socket.onopen = undefined;
      this.socket.onerror = undefined;
      this.socket.onclose = undefined;
      this.socket.onmessage = undefined;
      if (this.supportsPing()) {
        this.socket.onactivity = undefined;
      }
    }
  };
  prototype.changeState = function(state, params) {
    this.state = state;
    this.timeline.info(this.buildTimelineMessage({
      state: state,
      params: params
    }));
    this.emit(state, params);
  };
  prototype.buildTimelineMessage = function(message) {
    return Pusher.Util.extend({
      cid: this.id
    }, message);
  };
  Pusher.TransportConnection = TransportConnection;
}).call(this);

(function() {
  function Transport(hooks) {
    this.hooks = hooks;
  }
  var prototype = Transport.prototype;
  prototype.isSupported = function(environment) {
    return this.hooks.isSupported(environment);
  };
  prototype.createConnection = function(name, priority, key, options) {
    return new Pusher.TransportConnection(this.hooks, name, priority, key, options);
  };
  Pusher.Transport = Transport;
}).call(this);

(function() {
  Pusher.WSTransport = new Pusher.Transport({
    urls: Pusher.URLSchemes.ws,
    handlesActivityChecks: false,
    supportsPing: false,
    isInitialized: function() {
      return Boolean(window.WebSocket || window.MozWebSocket);
    },
    isSupported: function() {
      return Boolean(window.WebSocket || window.MozWebSocket);
    },
    getSocket: function(url) {
      var Constructor = window.WebSocket || window.MozWebSocket;
      return new Constructor(url);
    }
  });
  Pusher.FlashTransport = new Pusher.Transport({
    file: "flashfallback",
    urls: Pusher.URLSchemes.flash,
    handlesActivityChecks: false,
    supportsPing: false,
    isSupported: function() {
      try {
        return Boolean(new ActiveXObject("ShockwaveFlash.ShockwaveFlash"));
      } catch (e1) {
        try {
          var nav = Pusher.Util.getNavigator();
          return Boolean(nav && nav.mimeTypes && nav.mimeTypes["application/x-shockwave-flash"] !== undefined);
        } catch (e2) {
          return false;
        }
      }
    },
    beforeInitialize: function() {
      if (window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR === undefined) {
        window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR = true;
      }
      window.WEB_SOCKET_SWF_LOCATION = Pusher.Dependencies.getRoot() + "/WebSocketMain.swf";
    },
    isInitialized: function() {
      return window.FlashWebSocket !== undefined;
    },
    getSocket: function(url) {
      return new FlashWebSocket(url);
    }
  });
  Pusher.SockJSTransport = new Pusher.Transport({
    file: "sockjs",
    urls: Pusher.URLSchemes.sockjs,
    handlesActivityChecks: true,
    supportsPing: false,
    isSupported: function() {
      return true;
    },
    isInitialized: function() {
      return window.SockJS !== undefined;
    },
    getSocket: function(url, options) {
      return new SockJS(url, null, {
        js_path: Pusher.Dependencies.getPath("sockjs", {
          encrypted: options.encrypted
        }),
        ignore_null_origin: options.ignoreNullOrigin
      });
    },
    beforeOpen: function(socket, path) {
      socket.send(JSON.stringify({
        path: path
      }));
    }
  });
  var httpConfiguration = {
    urls: Pusher.URLSchemes.http,
    handlesActivityChecks: false,
    supportsPing: true,
    isInitialized: function() {
      return Boolean(Pusher.HTTP.Socket);
    }
  };
  var streamingConfiguration = Pusher.Util.extend({
    getSocket: function(url) {
      return Pusher.HTTP.getStreamingSocket(url);
    }
  }, httpConfiguration);
  var pollingConfiguration = Pusher.Util.extend({
    getSocket: function(url) {
      return Pusher.HTTP.getPollingSocket(url);
    }
  }, httpConfiguration);
  var xhrConfiguration = {
    file: "xhr",
    isSupported: Pusher.Util.isXHRSupported
  };
  var xdrConfiguration = {
    file: "xdr",
    isSupported: function(environment) {
      return Pusher.Util.isXDRSupported(environment.encrypted);
    }
  };
  Pusher.XHRStreamingTransport = new Pusher.Transport(Pusher.Util.extend({}, streamingConfiguration, xhrConfiguration));
  Pusher.XDRStreamingTransport = new Pusher.Transport(Pusher.Util.extend({}, streamingConfiguration, xdrConfiguration));
  Pusher.XHRPollingTransport = new Pusher.Transport(Pusher.Util.extend({}, pollingConfiguration, xhrConfiguration));
  Pusher.XDRPollingTransport = new Pusher.Transport(Pusher.Util.extend({}, pollingConfiguration, xdrConfiguration));
}).call(this);

(function() {
  function AssistantToTheTransportManager(manager, transport, options) {
    this.manager = manager;
    this.transport = transport;
    this.minPingDelay = options.minPingDelay;
    this.maxPingDelay = options.maxPingDelay;
    this.pingDelay = undefined;
  }
  var prototype = AssistantToTheTransportManager.prototype;
  prototype.createConnection = function(name, priority, key, options) {
    var self = this;
    options = Pusher.Util.extend({}, options, {
      activityTimeout: self.pingDelay
    });
    var connection = self.transport.createConnection(name, priority, key, options);
    var openTimestamp = null;
    var onOpen = function() {
      connection.unbind("open", onOpen);
      connection.bind("closed", onClosed);
      openTimestamp = Pusher.Util.now();
    };
    var onClosed = function(closeEvent) {
      connection.unbind("closed", onClosed);
      if (closeEvent.code === 1002 || closeEvent.code === 1003) {
        self.manager.reportDeath();
      } else if (!closeEvent.wasClean && openTimestamp) {
        var lifespan = Pusher.Util.now() - openTimestamp;
        if (lifespan < 2 * self.maxPingDelay) {
          self.manager.reportDeath();
          self.pingDelay = Math.max(lifespan / 2, self.minPingDelay);
        }
      }
    };
    connection.bind("open", onOpen);
    return connection;
  };
  prototype.isSupported = function(environment) {
    return this.manager.isAlive() && this.transport.isSupported(environment);
  };
  Pusher.AssistantToTheTransportManager = AssistantToTheTransportManager;
}).call(this);

(function() {
  function TransportManager(options) {
    this.options = options || {};
    this.livesLeft = this.options.lives || Infinity;
  }
  var prototype = TransportManager.prototype;
  prototype.getAssistant = function(transport) {
    return new Pusher.AssistantToTheTransportManager(this, transport, {
      minPingDelay: this.options.minPingDelay,
      maxPingDelay: this.options.maxPingDelay
    });
  };
  prototype.isAlive = function() {
    return this.livesLeft > 0;
  };
  prototype.reportDeath = function() {
    this.livesLeft -= 1;
  };
  Pusher.TransportManager = TransportManager;
}).call(this);

(function() {
  var StrategyBuilder = {
    build: function(scheme, options) {
      var context = Pusher.Util.extend({}, globalContext, options);
      return evaluate(scheme, context)[1].strategy;
    }
  };
  var transports = {
    ws: Pusher.WSTransport,
    flash: Pusher.FlashTransport,
    sockjs: Pusher.SockJSTransport,
    xhr_streaming: Pusher.XHRStreamingTransport,
    xdr_streaming: Pusher.XDRStreamingTransport,
    xhr_polling: Pusher.XHRPollingTransport,
    xdr_polling: Pusher.XDRPollingTransport
  };
  var UnsupportedStrategy = {
    isSupported: function() {
      return false;
    },
    connect: function(_, callback) {
      var deferred = Pusher.Util.defer(function() {
        callback(new Pusher.Errors.UnsupportedStrategy());
      });
      return {
        abort: function() {
          deferred.ensureAborted();
        },
        forceMinPriority: function() {}
      };
    }
  };
  function returnWithOriginalContext(f) {
    return function(context) {
      return [ f.apply(this, arguments), context ];
    };
  }
  var globalContext = {
    extend: function(context, first, second) {
      return [ Pusher.Util.extend({}, first, second), context ];
    },
    def: function(context, name, value) {
      if (context[name] !== undefined) {
        throw "Redefining symbol " + name;
      }
      context[name] = value;
      return [ undefined, context ];
    },
    def_transport: function(context, name, type, priority, options, manager) {
      var transportClass = transports[type];
      if (!transportClass) {
        throw new Pusher.Errors.UnsupportedTransport(type);
      }
      var enabled = (!context.enabledTransports || Pusher.Util.arrayIndexOf(context.enabledTransports, name) !== -1) && (!context.disabledTransports || Pusher.Util.arrayIndexOf(context.disabledTransports, name) === -1) && (name !== "flash" || context.disableFlash !== true);
      var transport;
      if (enabled) {
        transport = new Pusher.TransportStrategy(name, priority, manager ? manager.getAssistant(transportClass) : transportClass, Pusher.Util.extend({
          key: context.key,
          encrypted: context.encrypted,
          timeline: context.timeline,
          ignoreNullOrigin: context.ignoreNullOrigin
        }, options));
      } else {
        transport = UnsupportedStrategy;
      }
      var newContext = context.def(context, name, transport)[1];
      newContext.transports = context.transports || {};
      newContext.transports[name] = transport;
      return [ undefined, newContext ];
    },
    transport_manager: returnWithOriginalContext(function(_, options) {
      return new Pusher.TransportManager(options);
    }),
    sequential: returnWithOriginalContext(function(_, options) {
      var strategies = Array.prototype.slice.call(arguments, 2);
      return new Pusher.SequentialStrategy(strategies, options);
    }),
    cached: returnWithOriginalContext(function(context, ttl, strategy) {
      return new Pusher.CachedStrategy(strategy, context.transports, {
        ttl: ttl,
        timeline: context.timeline,
        encrypted: context.encrypted
      });
    }),
    first_connected: returnWithOriginalContext(function(_, strategy) {
      return new Pusher.FirstConnectedStrategy(strategy);
    }),
    best_connected_ever: returnWithOriginalContext(function() {
      var strategies = Array.prototype.slice.call(arguments, 1);
      return new Pusher.BestConnectedEverStrategy(strategies);
    }),
    delayed: returnWithOriginalContext(function(_, delay, strategy) {
      return new Pusher.DelayedStrategy(strategy, {
        delay: delay
      });
    }),
    "if": returnWithOriginalContext(function(_, test, trueBranch, falseBranch) {
      return new Pusher.IfStrategy(test, trueBranch, falseBranch);
    }),
    is_supported: returnWithOriginalContext(function(_, strategy) {
      return function() {
        return strategy.isSupported();
      };
    })
  };
  function isSymbol(expression) {
    return typeof expression === "string" && expression.charAt(0) === ":";
  }
  function getSymbolValue(expression, context) {
    return context[expression.slice(1)];
  }
  function evaluateListOfExpressions(expressions, context) {
    if (expressions.length === 0) {
      return [ [], context ];
    }
    var head = evaluate(expressions[0], context);
    var tail = evaluateListOfExpressions(expressions.slice(1), head[1]);
    return [ [ head[0] ].concat(tail[0]), tail[1] ];
  }
  function evaluateString(expression, context) {
    if (!isSymbol(expression)) {
      return [ expression, context ];
    }
    var value = getSymbolValue(expression, context);
    if (value === undefined) {
      throw "Undefined symbol " + expression;
    }
    return [ value, context ];
  }
  function evaluateArray(expression, context) {
    if (isSymbol(expression[0])) {
      var f = getSymbolValue(expression[0], context);
      if (expression.length > 1) {
        if (typeof f !== "function") {
          throw "Calling non-function " + expression[0];
        }
        var args = [ Pusher.Util.extend({}, context) ].concat(Pusher.Util.map(expression.slice(1), function(arg) {
          return evaluate(arg, Pusher.Util.extend({}, context))[0];
        }));
        return f.apply(this, args);
      } else {
        return [ f, context ];
      }
    } else {
      return evaluateListOfExpressions(expression, context);
    }
  }
  function evaluate(expression, context) {
    var expressionType = typeof expression;
    if (typeof expression === "string") {
      return evaluateString(expression, context);
    } else if (typeof expression === "object") {
      if (expression instanceof Array && expression.length > 0) {
        return evaluateArray(expression, context);
      }
    }
    return [ expression, context ];
  }
  Pusher.StrategyBuilder = StrategyBuilder;
}).call(this);

(function() {
  var Protocol = {};
  Protocol.decodeMessage = function(message) {
    try {
      var params = JSON.parse(message.data);
      if (typeof params.data === "string") {
        try {
          params.data = JSON.parse(params.data);
        } catch (e) {
          if (!(e instanceof SyntaxError)) {
            throw e;
          }
        }
      }
      return params;
    } catch (e) {
      throw {
        type: "MessageParseError",
        error: e,
        data: message.data
      };
    }
  };
  Protocol.encodeMessage = function(message) {
    return JSON.stringify(message);
  };
  Protocol.processHandshake = function(message) {
    message = this.decodeMessage(message);
    if (message.event === "pusher:connection_established") {
      if (!message.data.activity_timeout) {
        throw "No activity timeout specified in handshake";
      }
      return {
        action: "connected",
        id: message.data.socket_id,
        activityTimeout: message.data.activity_timeout * 1e3
      };
    } else if (message.event === "pusher:error") {
      return {
        action: this.getCloseAction(message.data),
        error: this.getCloseError(message.data)
      };
    } else {
      throw "Invalid handshake";
    }
  };
  Protocol.getCloseAction = function(closeEvent) {
    if (closeEvent.code < 4e3) {
      if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {
        return "backoff";
      } else {
        return null;
      }
    } else if (closeEvent.code === 4e3) {
      return "ssl_only";
    } else if (closeEvent.code < 4100) {
      return "refused";
    } else if (closeEvent.code < 4200) {
      return "backoff";
    } else if (closeEvent.code < 4300) {
      return "retry";
    } else {
      return "refused";
    }
  };
  Protocol.getCloseError = function(closeEvent) {
    if (closeEvent.code !== 1e3 && closeEvent.code !== 1001) {
      return {
        type: "PusherError",
        data: {
          code: closeEvent.code,
          message: closeEvent.reason || closeEvent.message
        }
      };
    } else {
      return null;
    }
  };
  Pusher.Protocol = Protocol;
}).call(this);

(function() {
  function Connection(id, transport) {
    Pusher.EventsDispatcher.call(this);
    this.id = id;
    this.transport = transport;
    this.activityTimeout = transport.activityTimeout;
    this.bindListeners();
  }
  var prototype = Connection.prototype;
  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);
  prototype.handlesActivityChecks = function() {
    return this.transport.handlesActivityChecks();
  };
  prototype.send = function(data) {
    return this.transport.send(data);
  };
  prototype.send_event = function(name, data, channel) {
    var message = {
      event: name,
      data: data
    };
    if (channel) {
      message.channel = channel;
    }
    Pusher.debug("Event sent", message);
    return this.send(Pusher.Protocol.encodeMessage(message));
  };
  prototype.ping = function() {
    if (this.transport.supportsPing()) {
      this.transport.ping();
    } else {
      this.send_event("pusher:ping", {});
    }
  };
  prototype.close = function() {
    this.transport.close();
  };
  prototype.bindListeners = function() {
    var self = this;
    var listeners = {
      message: function(m) {
        var message;
        try {
          message = Pusher.Protocol.decodeMessage(m);
        } catch (e) {
          self.emit("error", {
            type: "MessageParseError",
            error: e,
            data: m.data
          });
        }
        if (message !== undefined) {
          Pusher.debug("Event recd", message);
          switch (message.event) {
           case "pusher:error":
            self.emit("error", {
              type: "PusherError",
              data: message.data
            });
            break;

           case "pusher:ping":
            self.emit("ping");
            break;

           case "pusher:pong":
            self.emit("pong");
            break;
          }
          self.emit("message", message);
        }
      },
      activity: function() {
        self.emit("activity");
      },
      error: function(error) {
        self.emit("error", {
          type: "WebSocketError",
          error: error
        });
      },
      closed: function(closeEvent) {
        unbindListeners();
        if (closeEvent && closeEvent.code) {
          self.handleCloseEvent(closeEvent);
        }
        self.transport = null;
        self.emit("closed");
      }
    };
    var unbindListeners = function() {
      Pusher.Util.objectApply(listeners, function(listener, event) {
        self.transport.unbind(event, listener);
      });
    };
    Pusher.Util.objectApply(listeners, function(listener, event) {
      self.transport.bind(event, listener);
    });
  };
  prototype.handleCloseEvent = function(closeEvent) {
    var action = Pusher.Protocol.getCloseAction(closeEvent);
    var error = Pusher.Protocol.getCloseError(closeEvent);
    if (error) {
      this.emit("error", error);
    }
    if (action) {
      this.emit(action);
    }
  };
  Pusher.Connection = Connection;
}).call(this);

(function() {
  function Handshake(transport, callback) {
    this.transport = transport;
    this.callback = callback;
    this.bindListeners();
  }
  var prototype = Handshake.prototype;
  prototype.close = function() {
    this.unbindListeners();
    this.transport.close();
  };
  prototype.bindListeners = function() {
    var self = this;
    self.onMessage = function(m) {
      self.unbindListeners();
      try {
        var result = Pusher.Protocol.processHandshake(m);
        if (result.action === "connected") {
          self.finish("connected", {
            connection: new Pusher.Connection(result.id, self.transport),
            activityTimeout: result.activityTimeout
          });
        } else {
          self.finish(result.action, {
            error: result.error
          });
          self.transport.close();
        }
      } catch (e) {
        self.finish("error", {
          error: e
        });
        self.transport.close();
      }
    };
    self.onClosed = function(closeEvent) {
      self.unbindListeners();
      var action = Pusher.Protocol.getCloseAction(closeEvent) || "backoff";
      var error = Pusher.Protocol.getCloseError(closeEvent);
      self.finish(action, {
        error: error
      });
    };
    self.transport.bind("message", self.onMessage);
    self.transport.bind("closed", self.onClosed);
  };
  prototype.unbindListeners = function() {
    this.transport.unbind("message", this.onMessage);
    this.transport.unbind("closed", this.onClosed);
  };
  prototype.finish = function(action, params) {
    this.callback(Pusher.Util.extend({
      transport: this.transport,
      action: action
    }, params));
  };
  Pusher.Handshake = Handshake;
}).call(this);

(function() {
  function ConnectionManager(key, options) {
    Pusher.EventsDispatcher.call(this);
    this.key = key;
    this.options = options || {};
    this.state = "initialized";
    this.connection = null;
    this.encrypted = !!options.encrypted;
    this.timeline = this.options.timeline;
    this.connectionCallbacks = this.buildConnectionCallbacks();
    this.errorCallbacks = this.buildErrorCallbacks();
    this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);
    var self = this;
    Pusher.Network.bind("online", function() {
      self.timeline.info({
        netinfo: "online"
      });
      if (self.state === "connecting" || self.state === "unavailable") {
        self.retryIn(0);
      }
    });
    Pusher.Network.bind("offline", function() {
      self.timeline.info({
        netinfo: "offline"
      });
      if (self.connection) {
        self.sendActivityCheck();
      }
    });
    this.updateStrategy();
  }
  var prototype = ConnectionManager.prototype;
  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);
  prototype.connect = function() {
    if (this.connection || this.runner) {
      return;
    }
    if (!this.strategy.isSupported()) {
      this.updateState("failed");
      return;
    }
    this.updateState("connecting");
    this.startConnecting();
    this.setUnavailableTimer();
  };
  prototype.send = function(data) {
    if (this.connection) {
      return this.connection.send(data);
    } else {
      return false;
    }
  };
  prototype.send_event = function(name, data, channel) {
    if (this.connection) {
      return this.connection.send_event(name, data, channel);
    } else {
      return false;
    }
  };
  prototype.disconnect = function() {
    this.disconnectInternally();
    this.updateState("disconnected");
  };
  prototype.isEncrypted = function() {
    return this.encrypted;
  };
  prototype.startConnecting = function() {
    var self = this;
    var callback = function(error, handshake) {
      if (error) {
        self.runner = self.strategy.connect(0, callback);
      } else {
        if (handshake.action === "error") {
          self.emit("error", {
            type: "HandshakeError",
            error: handshake.error
          });
          self.timeline.error({
            handshakeError: handshake.error
          });
        } else {
          self.abortConnecting();
          self.handshakeCallbacks[handshake.action](handshake);
        }
      }
    };
    self.runner = self.strategy.connect(0, callback);
  };
  prototype.abortConnecting = function() {
    if (this.runner) {
      this.runner.abort();
      this.runner = null;
    }
  };
  prototype.disconnectInternally = function() {
    this.abortConnecting();
    this.clearRetryTimer();
    this.clearUnavailableTimer();
    if (this.connection) {
      var connection = this.abandonConnection();
      connection.close();
    }
  };
  prototype.updateStrategy = function() {
    this.strategy = this.options.getStrategy({
      key: this.key,
      timeline: this.timeline,
      encrypted: this.encrypted
    });
  };
  prototype.retryIn = function(delay) {
    var self = this;
    self.timeline.info({
      action: "retry",
      delay: delay
    });
    if (delay > 0) {
      self.emit("connecting_in", Math.round(delay / 1e3));
    }
    self.retryTimer = new Pusher.Timer(delay || 0, function() {
      self.disconnectInternally();
      self.connect();
    });
  };
  prototype.clearRetryTimer = function() {
    if (this.retryTimer) {
      this.retryTimer.ensureAborted();
      this.retryTimer = null;
    }
  };
  prototype.setUnavailableTimer = function() {
    var self = this;
    self.unavailableTimer = new Pusher.Timer(self.options.unavailableTimeout, function() {
      self.updateState("unavailable");
    });
  };
  prototype.clearUnavailableTimer = function() {
    if (this.unavailableTimer) {
      this.unavailableTimer.ensureAborted();
    }
  };
  prototype.sendActivityCheck = function() {
    var self = this;
    self.stopActivityCheck();
    self.connection.ping();
    self.activityTimer = new Pusher.Timer(self.options.pongTimeout, function() {
      self.timeline.error({
        pong_timed_out: self.options.pongTimeout
      });
      self.retryIn(0);
    });
  };
  prototype.resetActivityCheck = function() {
    var self = this;
    self.stopActivityCheck();
    if (!self.connection.handlesActivityChecks()) {
      self.activityTimer = new Pusher.Timer(self.activityTimeout, function() {
        self.sendActivityCheck();
      });
    }
  };
  prototype.stopActivityCheck = function() {
    if (this.activityTimer) {
      this.activityTimer.ensureAborted();
    }
  };
  prototype.buildConnectionCallbacks = function() {
    var self = this;
    return {
      message: function(message) {
        self.resetActivityCheck();
        self.emit("message", message);
      },
      ping: function() {
        self.send_event("pusher:pong", {});
      },
      activity: function() {
        self.resetActivityCheck();
      },
      error: function(error) {
        self.emit("error", {
          type: "WebSocketError",
          error: error
        });
      },
      closed: function() {
        self.abandonConnection();
        if (self.shouldRetry()) {
          self.retryIn(1e3);
        }
      }
    };
  };
  prototype.buildHandshakeCallbacks = function(errorCallbacks) {
    var self = this;
    return Pusher.Util.extend({}, errorCallbacks, {
      connected: function(handshake) {
        self.activityTimeout = Math.min(self.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);
        self.clearUnavailableTimer();
        self.setConnection(handshake.connection);
        self.socket_id = self.connection.id;
        self.updateState("connected", {
          socket_id: self.socket_id
        });
      }
    });
  };
  prototype.buildErrorCallbacks = function() {
    var self = this;
    function withErrorEmitted(callback) {
      return function(result) {
        if (result.error) {
          self.emit("error", {
            type: "WebSocketError",
            error: result.error
          });
        }
        callback(result);
      };
    }
    return {
      ssl_only: withErrorEmitted(function() {
        self.encrypted = true;
        self.updateStrategy();
        self.retryIn(0);
      }),
      refused: withErrorEmitted(function() {
        self.disconnect();
      }),
      backoff: withErrorEmitted(function() {
        self.retryIn(1e3);
      }),
      retry: withErrorEmitted(function() {
        self.retryIn(0);
      })
    };
  };
  prototype.setConnection = function(connection) {
    this.connection = connection;
    for (var event in this.connectionCallbacks) {
      this.connection.bind(event, this.connectionCallbacks[event]);
    }
    this.resetActivityCheck();
  };
  prototype.abandonConnection = function() {
    if (!this.connection) {
      return;
    }
    this.stopActivityCheck();
    for (var event in this.connectionCallbacks) {
      this.connection.unbind(event, this.connectionCallbacks[event]);
    }
    var connection = this.connection;
    this.connection = null;
    return connection;
  };
  prototype.updateState = function(newState, data) {
    var previousState = this.state;
    this.state = newState;
    if (previousState !== newState) {
      Pusher.debug("State changed", previousState + " -> " + newState);
      this.timeline.info({
        state: newState,
        params: data
      });
      this.emit("state_change", {
        previous: previousState,
        current: newState
      });
      this.emit(newState, data);
    }
  };
  prototype.shouldRetry = function() {
    return this.state === "connecting" || this.state === "connected";
  };
  Pusher.ConnectionManager = ConnectionManager;
}).call(this);

(function() {
  function NetInfo() {
    Pusher.EventsDispatcher.call(this);
    var self = this;
    if (window.addEventListener !== undefined) {
      window.addEventListener("online", function() {
        self.emit("online");
      }, false);
      window.addEventListener("offline", function() {
        self.emit("offline");
      }, false);
    }
  }
  Pusher.Util.extend(NetInfo.prototype, Pusher.EventsDispatcher.prototype);
  var prototype = NetInfo.prototype;
  prototype.isOnline = function() {
    if (window.navigator.onLine === undefined) {
      return true;
    } else {
      return window.navigator.onLine;
    }
  };
  Pusher.NetInfo = NetInfo;
  Pusher.Network = new NetInfo();
}).call(this);

(function() {
  function Members() {
    this.reset();
  }
  var prototype = Members.prototype;
  prototype.get = function(id) {
    if (Object.prototype.hasOwnProperty.call(this.members, id)) {
      return {
        id: id,
        info: this.members[id]
      };
    } else {
      return null;
    }
  };
  prototype.each = function(callback) {
    var self = this;
    Pusher.Util.objectApply(self.members, function(member, id) {
      callback(self.get(id));
    });
  };
  prototype.setMyID = function(id) {
    this.myID = id;
  };
  prototype.onSubscription = function(subscriptionData) {
    this.members = subscriptionData.presence.hash;
    this.count = subscriptionData.presence.count;
    this.me = this.get(this.myID);
  };
  prototype.addMember = function(memberData) {
    if (this.get(memberData.user_id) === null) {
      this.count++;
    }
    this.members[memberData.user_id] = memberData.user_info;
    return this.get(memberData.user_id);
  };
  prototype.removeMember = function(memberData) {
    var member = this.get(memberData.user_id);
    if (member) {
      delete this.members[memberData.user_id];
      this.count--;
    }
    return member;
  };
  prototype.reset = function() {
    this.members = {};
    this.count = 0;
    this.myID = null;
    this.me = null;
  };
  Pusher.Members = Members;
}).call(this);

(function() {
  function Channel(name, pusher) {
    Pusher.EventsDispatcher.call(this, function(event, data) {
      Pusher.debug("No callbacks on " + name + " for " + event);
    });
    this.name = name;
    this.pusher = pusher;
    this.subscribed = false;
  }
  var prototype = Channel.prototype;
  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);
  prototype.authorize = function(socketId, callback) {
    return callback(false, {});
  };
  prototype.trigger = function(event, data) {
    if (event.indexOf("client-") !== 0) {
      throw new Pusher.Errors.BadEventName("Event '" + event + "' does not start with 'client-'");
    }
    return this.pusher.send_event(event, data, this.name);
  };
  prototype.disconnect = function() {
    this.subscribed = false;
  };
  prototype.handleEvent = function(event, data) {
    if (event.indexOf("pusher_internal:") === 0) {
      if (event === "pusher_internal:subscription_succeeded") {
        this.subscribed = true;
        this.emit("pusher:subscription_succeeded", data);
      }
    } else {
      this.emit(event, data);
    }
  };
  prototype.subscribe = function() {
    var self = this;
    self.authorize(self.pusher.connection.socket_id, function(error, data) {
      if (error) {
        self.handleEvent("pusher:subscription_error", data);
      } else {
        self.pusher.send_event("pusher:subscribe", {
          auth: data.auth,
          channel_data: data.channel_data,
          channel: self.name
        });
      }
    });
  };
  prototype.unsubscribe = function() {
    this.pusher.send_event("pusher:unsubscribe", {
      channel: this.name
    });
  };
  Pusher.Channel = Channel;
}).call(this);

(function() {
  function PrivateChannel(name, pusher) {
    Pusher.Channel.call(this, name, pusher);
  }
  var prototype = PrivateChannel.prototype;
  Pusher.Util.extend(prototype, Pusher.Channel.prototype);
  prototype.authorize = function(socketId, callback) {
    var authorizer = new Pusher.Channel.Authorizer(this, this.pusher.config);
    return authorizer.authorize(socketId, callback);
  };
  Pusher.PrivateChannel = PrivateChannel;
}).call(this);

(function() {
  function PresenceChannel(name, pusher) {
    Pusher.PrivateChannel.call(this, name, pusher);
    this.members = new Pusher.Members();
  }
  var prototype = PresenceChannel.prototype;
  Pusher.Util.extend(prototype, Pusher.PrivateChannel.prototype);
  prototype.authorize = function(socketId, callback) {
    var _super = Pusher.PrivateChannel.prototype.authorize;
    var self = this;
    _super.call(self, socketId, function(error, authData) {
      if (!error) {
        if (authData.channel_data === undefined) {
          Pusher.warn("Invalid auth response for channel '" + self.name + "', expected 'channel_data' field");
          callback("Invalid auth response");
          return;
        }
        var channelData = JSON.parse(authData.channel_data);
        self.members.setMyID(channelData.user_id);
      }
      callback(error, authData);
    });
  };
  prototype.handleEvent = function(event, data) {
    switch (event) {
     case "pusher_internal:subscription_succeeded":
      this.members.onSubscription(data);
      this.subscribed = true;
      this.emit("pusher:subscription_succeeded", this.members);
      break;

     case "pusher_internal:member_added":
      var addedMember = this.members.addMember(data);
      this.emit("pusher:member_added", addedMember);
      break;

     case "pusher_internal:member_removed":
      var removedMember = this.members.removeMember(data);
      if (removedMember) {
        this.emit("pusher:member_removed", removedMember);
      }
      break;

     default:
      Pusher.PrivateChannel.prototype.handleEvent.call(this, event, data);
    }
  };
  prototype.disconnect = function() {
    this.members.reset();
    Pusher.PrivateChannel.prototype.disconnect.call(this);
  };
  Pusher.PresenceChannel = PresenceChannel;
}).call(this);

(function() {
  function Channels() {
    this.channels = {};
  }
  var prototype = Channels.prototype;
  prototype.add = function(name, pusher) {
    if (!this.channels[name]) {
      this.channels[name] = createChannel(name, pusher);
    }
    return this.channels[name];
  };
  prototype.all = function(name) {
    return Pusher.Util.values(this.channels);
  };
  prototype.find = function(name) {
    return this.channels[name];
  };
  prototype.remove = function(name) {
    var channel = this.channels[name];
    delete this.channels[name];
    return channel;
  };
  prototype.disconnect = function() {
    Pusher.Util.objectApply(this.channels, function(channel) {
      channel.disconnect();
    });
  };
  function createChannel(name, pusher) {
    if (name.indexOf("private-") === 0) {
      return new Pusher.PrivateChannel(name, pusher);
    } else if (name.indexOf("presence-") === 0) {
      return new Pusher.PresenceChannel(name, pusher);
    } else {
      return new Pusher.Channel(name, pusher);
    }
  }
  Pusher.Channels = Channels;
}).call(this);

(function() {
  Pusher.Channel.Authorizer = function(channel, options) {
    this.channel = channel;
    this.type = options.authTransport;
    this.options = options;
    this.authOptions = (options || {}).auth || {};
  };
  Pusher.Channel.Authorizer.prototype = {
    composeQuery: function(socketId) {
      var query = "socket_id=" + encodeURIComponent(socketId) + "&channel_name=" + encodeURIComponent(this.channel.name);
      for (var i in this.authOptions.params) {
        query += "&" + encodeURIComponent(i) + "=" + encodeURIComponent(this.authOptions.params[i]);
      }
      return query;
    },
    authorize: function(socketId, callback) {
      return Pusher.authorizers[this.type].call(this, socketId, callback);
    }
  };
  var nextAuthCallbackID = 1;
  Pusher.auth_callbacks = {};
  Pusher.authorizers = {
    ajax: function(socketId, callback) {
      var self = this, xhr;
      if (Pusher.XHR) {
        xhr = new Pusher.XHR();
      } else {
        xhr = window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
      }
      xhr.open("POST", self.options.authEndpoint, true);
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      for (var headerName in this.authOptions.headers) {
        xhr.setRequestHeader(headerName, this.authOptions.headers[headerName]);
      }
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            var data, parsed = false;
            try {
              data = JSON.parse(xhr.responseText);
              parsed = true;
            } catch (e) {
              callback(true, "JSON returned from webapp was invalid, yet status code was 200. Data was: " + xhr.responseText);
            }
            if (parsed) {
              callback(false, data);
            }
          } else {
            Pusher.warn("Couldn't get auth info from your webapp", xhr.status);
            callback(true, xhr.status);
          }
        }
      };
      xhr.send(this.composeQuery(socketId));
      return xhr;
    },
    jsonp: function(socketId, callback) {
      if (this.authOptions.headers !== undefined) {
        Pusher.warn("Warn", "To send headers with the auth request, you must use AJAX, rather than JSONP.");
      }
      var callbackName = nextAuthCallbackID.toString();
      nextAuthCallbackID++;
      var document = Pusher.Util.getDocument();
      var script = document.createElement("script");
      Pusher.auth_callbacks[callbackName] = function(data) {
        callback(false, data);
      };
      var callback_name = "Pusher.auth_callbacks['" + callbackName + "']";
      script.src = this.options.authEndpoint + "?callback=" + encodeURIComponent(callback_name) + "&" + this.composeQuery(socketId);
      var head = document.getElementsByTagName("head")[0] || document.documentElement;
      head.insertBefore(script, head.firstChild);
    }
  };
}).call(this);
(function(window, angular, undefined) {
  "use strict";
  angular.module("ngAnimate", [ "ng" ]).directive("ngAnimateChildren", function() {
    var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
    return function(scope, element, attrs) {
      var val = attrs.ngAnimateChildren;
      if (angular.isString(val) && val.length === 0) {
        element.data(NG_ANIMATE_CHILDREN, true);
      } else {
        scope.$watch(val, function(value) {
          element.data(NG_ANIMATE_CHILDREN, !!value);
        });
      }
    };
  }).factory("$$animateReflow", [ "$$rAF", "$document", function($$rAF, $document) {
    var bod = $document[0].body;
    return function(fn) {
      return $$rAF(function() {
        var a = bod.offsetWidth + 1;
        fn();
      });
    };
  } ]).config([ "$provide", "$animateProvider", function($provide, $animateProvider) {
    var noop = angular.noop;
    var forEach = angular.forEach;
    var selectors = $animateProvider.$$selectors;
    var ELEMENT_NODE = 1;
    var NG_ANIMATE_STATE = "$$ngAnimateState";
    var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
    var NG_ANIMATE_CLASS_NAME = "ng-animate";
    var rootAnimateState = {
      running: true
    };
    function extractElementNode(element) {
      for (var i = 0; i < element.length; i++) {
        var elm = element[i];
        if (elm.nodeType == ELEMENT_NODE) {
          return elm;
        }
      }
    }
    function prepareElement(element) {
      return element && angular.element(element);
    }
    function stripCommentsFromElement(element) {
      return angular.element(extractElementNode(element));
    }
    function isMatchingElement(elm1, elm2) {
      return extractElementNode(elm1) == extractElementNode(elm2);
    }
    $provide.decorator("$animate", [ "$delegate", "$injector", "$sniffer", "$rootElement", "$$asyncCallback", "$rootScope", "$document", function($delegate, $injector, $sniffer, $rootElement, $$asyncCallback, $rootScope, $document) {
      var globalAnimationCounter = 0;
      $rootElement.data(NG_ANIMATE_STATE, rootAnimateState);
      $rootScope.$$postDigest(function() {
        $rootScope.$$postDigest(function() {
          rootAnimateState.running = false;
        });
      });
      var classNameFilter = $animateProvider.classNameFilter();
      var isAnimatableClassName = !classNameFilter ? function() {
        return true;
      } : function(className) {
        return classNameFilter.test(className);
      };
      function blockElementAnimations(element) {
        var data = element.data(NG_ANIMATE_STATE) || {};
        data.running = true;
        element.data(NG_ANIMATE_STATE, data);
      }
      function lookup(name) {
        if (name) {
          var matches = [], flagMap = {}, classes = name.substr(1).split(".");
          if ($sniffer.transitions || $sniffer.animations) {
            matches.push($injector.get(selectors[""]));
          }
          for (var i = 0; i < classes.length; i++) {
            var klass = classes[i], selectorFactoryName = selectors[klass];
            if (selectorFactoryName && !flagMap[klass]) {
              matches.push($injector.get(selectorFactoryName));
              flagMap[klass] = true;
            }
          }
          return matches;
        }
      }
      function animationRunner(element, animationEvent, className) {
        var node = element[0];
        if (!node) {
          return;
        }
        var isSetClassOperation = animationEvent == "setClass";
        var isClassBased = isSetClassOperation || animationEvent == "addClass" || animationEvent == "removeClass";
        var classNameAdd, classNameRemove;
        if (angular.isArray(className)) {
          classNameAdd = className[0];
          classNameRemove = className[1];
          className = classNameAdd + " " + classNameRemove;
        }
        var currentClassName = element.attr("class");
        var classes = currentClassName + " " + className;
        if (!isAnimatableClassName(classes)) {
          return;
        }
        var beforeComplete = noop, beforeCancel = [], before = [], afterComplete = noop, afterCancel = [], after = [];
        var animationLookup = (" " + classes).replace(/\s+/g, ".");
        forEach(lookup(animationLookup), function(animationFactory) {
          var created = registerAnimation(animationFactory, animationEvent);
          if (!created && isSetClassOperation) {
            registerAnimation(animationFactory, "addClass");
            registerAnimation(animationFactory, "removeClass");
          }
        });
        function registerAnimation(animationFactory, event) {
          var afterFn = animationFactory[event];
          var beforeFn = animationFactory["before" + event.charAt(0).toUpperCase() + event.substr(1)];
          if (afterFn || beforeFn) {
            if (event == "leave") {
              beforeFn = afterFn;
              afterFn = null;
            }
            after.push({
              event: event,
              fn: afterFn
            });
            before.push({
              event: event,
              fn: beforeFn
            });
            return true;
          }
        }
        function run(fns, cancellations, allCompleteFn) {
          var animations = [];
          forEach(fns, function(animation) {
            animation.fn && animations.push(animation);
          });
          var count = 0;
          function afterAnimationComplete(index) {
            if (cancellations) {
              (cancellations[index] || noop)();
              if (++count < animations.length) return;
              cancellations = null;
            }
            allCompleteFn();
          }
          forEach(animations, function(animation, index) {
            var progress = function() {
              afterAnimationComplete(index);
            };
            switch (animation.event) {
             case "setClass":
              cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress));
              break;

             case "addClass":
              cancellations.push(animation.fn(element, classNameAdd || className, progress));
              break;

             case "removeClass":
              cancellations.push(animation.fn(element, classNameRemove || className, progress));
              break;

             default:
              cancellations.push(animation.fn(element, progress));
              break;
            }
          });
          if (cancellations && cancellations.length === 0) {
            allCompleteFn();
          }
        }
        return {
          node: node,
          event: animationEvent,
          className: className,
          isClassBased: isClassBased,
          isSetClassOperation: isSetClassOperation,
          before: function(allCompleteFn) {
            beforeComplete = allCompleteFn;
            run(before, beforeCancel, function() {
              beforeComplete = noop;
              allCompleteFn();
            });
          },
          after: function(allCompleteFn) {
            afterComplete = allCompleteFn;
            run(after, afterCancel, function() {
              afterComplete = noop;
              allCompleteFn();
            });
          },
          cancel: function() {
            if (beforeCancel) {
              forEach(beforeCancel, function(cancelFn) {
                (cancelFn || noop)(true);
              });
              beforeComplete(true);
            }
            if (afterCancel) {
              forEach(afterCancel, function(cancelFn) {
                (cancelFn || noop)(true);
              });
              afterComplete(true);
            }
          }
        };
      }
      return {
        enter: function(element, parentElement, afterElement, doneCallback) {
          element = angular.element(element);
          parentElement = prepareElement(parentElement);
          afterElement = prepareElement(afterElement);
          blockElementAnimations(element);
          $delegate.enter(element, parentElement, afterElement);
          $rootScope.$$postDigest(function() {
            element = stripCommentsFromElement(element);
            performAnimation("enter", "ng-enter", element, parentElement, afterElement, noop, doneCallback);
          });
        },
        leave: function(element, doneCallback) {
          element = angular.element(element);
          cancelChildAnimations(element);
          blockElementAnimations(element);
          $rootScope.$$postDigest(function() {
            performAnimation("leave", "ng-leave", stripCommentsFromElement(element), null, null, function() {
              $delegate.leave(element);
            }, doneCallback);
          });
        },
        move: function(element, parentElement, afterElement, doneCallback) {
          element = angular.element(element);
          parentElement = prepareElement(parentElement);
          afterElement = prepareElement(afterElement);
          cancelChildAnimations(element);
          blockElementAnimations(element);
          $delegate.move(element, parentElement, afterElement);
          $rootScope.$$postDigest(function() {
            element = stripCommentsFromElement(element);
            performAnimation("move", "ng-move", element, parentElement, afterElement, noop, doneCallback);
          });
        },
        addClass: function(element, className, doneCallback) {
          element = angular.element(element);
          element = stripCommentsFromElement(element);
          performAnimation("addClass", className, element, null, null, function() {
            $delegate.addClass(element, className);
          }, doneCallback);
        },
        removeClass: function(element, className, doneCallback) {
          element = angular.element(element);
          element = stripCommentsFromElement(element);
          performAnimation("removeClass", className, element, null, null, function() {
            $delegate.removeClass(element, className);
          }, doneCallback);
        },
        setClass: function(element, add, remove, doneCallback) {
          element = angular.element(element);
          element = stripCommentsFromElement(element);
          performAnimation("setClass", [ add, remove ], element, null, null, function() {
            $delegate.setClass(element, add, remove);
          }, doneCallback);
        },
        enabled: function(value, element) {
          switch (arguments.length) {
           case 2:
            if (value) {
              cleanup(element);
            } else {
              var data = element.data(NG_ANIMATE_STATE) || {};
              data.disabled = true;
              element.data(NG_ANIMATE_STATE, data);
            }
            break;

           case 1:
            rootAnimateState.disabled = !value;
            break;

           default:
            value = !rootAnimateState.disabled;
            break;
          }
          return !!value;
        }
      };
      function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, doneCallback) {
        var runner = animationRunner(element, animationEvent, className);
        if (!runner) {
          fireDOMOperation();
          fireBeforeCallbackAsync();
          fireAfterCallbackAsync();
          closeAnimation();
          return;
        }
        className = runner.className;
        var elementEvents = angular.element._data(runner.node);
        elementEvents = elementEvents && elementEvents.events;
        if (!parentElement) {
          parentElement = afterElement ? afterElement.parent() : element.parent();
        }
        var ngAnimateState = element.data(NG_ANIMATE_STATE) || {};
        var runningAnimations = ngAnimateState.active || {};
        var totalActiveAnimations = ngAnimateState.totalActive || 0;
        var lastAnimation = ngAnimateState.last;
        var skipAnimations;
        if (runner.isClassBased) {
          skipAnimations = ngAnimateState.running || ngAnimateState.disabled || lastAnimation && !lastAnimation.isClassBased;
        }
        if (skipAnimations || animationsDisabled(element, parentElement)) {
          fireDOMOperation();
          fireBeforeCallbackAsync();
          fireAfterCallbackAsync();
          closeAnimation();
          return;
        }
        var skipAnimation = false;
        if (totalActiveAnimations > 0) {
          var animationsToCancel = [];
          if (!runner.isClassBased) {
            if (animationEvent == "leave" && runningAnimations["ng-leave"]) {
              skipAnimation = true;
            } else {
              for (var klass in runningAnimations) {
                animationsToCancel.push(runningAnimations[klass]);
                cleanup(element, klass);
              }
              runningAnimations = {};
              totalActiveAnimations = 0;
            }
          } else if (lastAnimation.event == "setClass") {
            animationsToCancel.push(lastAnimation);
            cleanup(element, className);
          } else if (runningAnimations[className]) {
            var current = runningAnimations[className];
            if (current.event == animationEvent) {
              skipAnimation = true;
            } else {
              animationsToCancel.push(current);
              cleanup(element, className);
            }
          }
          if (animationsToCancel.length > 0) {
            forEach(animationsToCancel, function(operation) {
              operation.cancel();
            });
          }
        }
        if (runner.isClassBased && !runner.isSetClassOperation && !skipAnimation) {
          skipAnimation = animationEvent == "addClass" == element.hasClass(className);
        }
        if (skipAnimation) {
          fireDOMOperation();
          fireBeforeCallbackAsync();
          fireAfterCallbackAsync();
          fireDoneCallbackAsync();
          return;
        }
        if (animationEvent == "leave") {
          element.one("$destroy", function(e) {
            var element = angular.element(this);
            var state = element.data(NG_ANIMATE_STATE);
            if (state) {
              var activeLeaveAnimation = state.active["ng-leave"];
              if (activeLeaveAnimation) {
                activeLeaveAnimation.cancel();
                cleanup(element, "ng-leave");
              }
            }
          });
        }
        element.addClass(NG_ANIMATE_CLASS_NAME);
        var localAnimationCount = globalAnimationCounter++;
        totalActiveAnimations++;
        runningAnimations[className] = runner;
        element.data(NG_ANIMATE_STATE, {
          last: runner,
          active: runningAnimations,
          index: localAnimationCount,
          totalActive: totalActiveAnimations
        });
        fireBeforeCallbackAsync();
        runner.before(function(cancelled) {
          var data = element.data(NG_ANIMATE_STATE);
          cancelled = cancelled || !data || !data.active[className] || runner.isClassBased && data.active[className].event != animationEvent;
          fireDOMOperation();
          if (cancelled === true) {
            closeAnimation();
          } else {
            fireAfterCallbackAsync();
            runner.after(closeAnimation);
          }
        });
        function fireDOMCallback(animationPhase) {
          var eventName = "$animate:" + animationPhase;
          if (elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0) {
            $$asyncCallback(function() {
              element.triggerHandler(eventName, {
                event: animationEvent,
                className: className
              });
            });
          }
        }
        function fireBeforeCallbackAsync() {
          fireDOMCallback("before");
        }
        function fireAfterCallbackAsync() {
          fireDOMCallback("after");
        }
        function fireDoneCallbackAsync() {
          fireDOMCallback("close");
          if (doneCallback) {
            $$asyncCallback(function() {
              doneCallback();
            });
          }
        }
        function fireDOMOperation() {
          if (!fireDOMOperation.hasBeenRun) {
            fireDOMOperation.hasBeenRun = true;
            domOperation();
          }
        }
        function closeAnimation() {
          if (!closeAnimation.hasBeenRun) {
            closeAnimation.hasBeenRun = true;
            var data = element.data(NG_ANIMATE_STATE);
            if (data) {
              if (runner && runner.isClassBased) {
                cleanup(element, className);
              } else {
                $$asyncCallback(function() {
                  var data = element.data(NG_ANIMATE_STATE) || {};
                  if (localAnimationCount == data.index) {
                    cleanup(element, className, animationEvent);
                  }
                });
                element.data(NG_ANIMATE_STATE, data);
              }
            }
            fireDoneCallbackAsync();
          }
        }
      }
      function cancelChildAnimations(element) {
        var node = extractElementNode(element);
        if (node) {
          var nodes = angular.isFunction(node.getElementsByClassName) ? node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) : node.querySelectorAll("." + NG_ANIMATE_CLASS_NAME);
          forEach(nodes, function(element) {
            element = angular.element(element);
            var data = element.data(NG_ANIMATE_STATE);
            if (data && data.active) {
              forEach(data.active, function(runner) {
                runner.cancel();
              });
            }
          });
        }
      }
      function cleanup(element, className) {
        if (isMatchingElement(element, $rootElement)) {
          if (!rootAnimateState.disabled) {
            rootAnimateState.running = false;
            rootAnimateState.structural = false;
          }
        } else if (className) {
          var data = element.data(NG_ANIMATE_STATE) || {};
          var removeAnimations = className === true;
          if (!removeAnimations && data.active && data.active[className]) {
            data.totalActive--;
            delete data.active[className];
          }
          if (removeAnimations || !data.totalActive) {
            element.removeClass(NG_ANIMATE_CLASS_NAME);
            element.removeData(NG_ANIMATE_STATE);
          }
        }
      }
      function animationsDisabled(element, parentElement) {
        if (rootAnimateState.disabled) {
          return true;
        }
        if (isMatchingElement(element, $rootElement)) {
          return rootAnimateState.running;
        }
        var allowChildAnimations, parentRunningAnimation, hasParent;
        do {
          if (parentElement.length === 0) break;
          var isRoot = isMatchingElement(parentElement, $rootElement);
          var state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE) || {};
          if (state.disabled) {
            return true;
          }
          if (isRoot) {
            hasParent = true;
          }
          if (allowChildAnimations !== false) {
            var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN);
            if (angular.isDefined(animateChildrenFlag)) {
              allowChildAnimations = animateChildrenFlag;
            }
          }
          parentRunningAnimation = parentRunningAnimation || state.running || state.last && !state.last.isClassBased;
        } while (parentElement = parentElement.parent());
        return !hasParent || !allowChildAnimations && parentRunningAnimation;
      }
    } ]);
    $animateProvider.register("", [ "$window", "$sniffer", "$timeout", "$$animateReflow", function($window, $sniffer, $timeout, $$animateReflow) {
      var CSS_PREFIX = "", TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
      if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
        CSS_PREFIX = "-webkit-";
        TRANSITION_PROP = "WebkitTransition";
        TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
      } else {
        TRANSITION_PROP = "transition";
        TRANSITIONEND_EVENT = "transitionend";
      }
      if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
        CSS_PREFIX = "-webkit-";
        ANIMATION_PROP = "WebkitAnimation";
        ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
      } else {
        ANIMATION_PROP = "animation";
        ANIMATIONEND_EVENT = "animationend";
      }
      var DURATION_KEY = "Duration";
      var PROPERTY_KEY = "Property";
      var DELAY_KEY = "Delay";
      var ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
      var NG_ANIMATE_PARENT_KEY = "$$ngAnimateKey";
      var NG_ANIMATE_CSS_DATA_KEY = "$$ngAnimateCSS3Data";
      var NG_ANIMATE_BLOCK_CLASS_NAME = "ng-animate-block-transitions";
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var ONE_SECOND = 1e3;
      var lookupCache = {};
      var parentCounter = 0;
      var animationReflowQueue = [];
      var cancelAnimationReflow;
      function afterReflow(element, callback) {
        if (cancelAnimationReflow) {
          cancelAnimationReflow();
        }
        animationReflowQueue.push(callback);
        cancelAnimationReflow = $$animateReflow(function() {
          forEach(animationReflowQueue, function(fn) {
            fn();
          });
          animationReflowQueue = [];
          cancelAnimationReflow = null;
          lookupCache = {};
        });
      }
      var closingTimer = null;
      var closingTimestamp = 0;
      var animationElementQueue = [];
      function animationCloseHandler(element, totalTime) {
        var node = extractElementNode(element);
        element = angular.element(node);
        animationElementQueue.push(element);
        var futureTimestamp = Date.now() + totalTime;
        if (futureTimestamp <= closingTimestamp) {
          return;
        }
        $timeout.cancel(closingTimer);
        closingTimestamp = futureTimestamp;
        closingTimer = $timeout(function() {
          closeAllAnimations(animationElementQueue);
          animationElementQueue = [];
        }, totalTime, false);
      }
      function closeAllAnimations(elements) {
        forEach(elements, function(element) {
          var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
          if (elementData) {
            (elementData.closeAnimationFn || noop)();
          }
        });
      }
      function getElementAnimationDetails(element, cacheKey) {
        var data = cacheKey ? lookupCache[cacheKey] : null;
        if (!data) {
          var transitionDuration = 0;
          var transitionDelay = 0;
          var animationDuration = 0;
          var animationDelay = 0;
          var transitionDelayStyle;
          var animationDelayStyle;
          var transitionDurationStyle;
          var transitionPropertyStyle;
          forEach(element, function(element) {
            if (element.nodeType == ELEMENT_NODE) {
              var elementStyles = $window.getComputedStyle(element) || {};
              transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY];
              transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration);
              transitionPropertyStyle = elementStyles[TRANSITION_PROP + PROPERTY_KEY];
              transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY];
              transitionDelay = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay);
              animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY];
              animationDelay = Math.max(parseMaxTime(animationDelayStyle), animationDelay);
              var aDuration = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);
              if (aDuration > 0) {
                aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1;
              }
              animationDuration = Math.max(aDuration, animationDuration);
            }
          });
          data = {
            total: 0,
            transitionPropertyStyle: transitionPropertyStyle,
            transitionDurationStyle: transitionDurationStyle,
            transitionDelayStyle: transitionDelayStyle,
            transitionDelay: transitionDelay,
            transitionDuration: transitionDuration,
            animationDelayStyle: animationDelayStyle,
            animationDelay: animationDelay,
            animationDuration: animationDuration
          };
          if (cacheKey) {
            lookupCache[cacheKey] = data;
          }
        }
        return data;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = angular.isString(str) ? str.split(/\s*,\s*/) : [];
        forEach(values, function(value) {
          maxValue = Math.max(parseFloat(value) || 0, maxValue);
        });
        return maxValue;
      }
      function getCacheKey(element) {
        var parentElement = element.parent();
        var parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
        if (!parentID) {
          parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter);
          parentID = parentCounter;
        }
        return parentID + "-" + extractElementNode(element).getAttribute("class");
      }
      function animateSetup(animationEvent, element, className, calculationDecorator) {
        var cacheKey = getCacheKey(element);
        var eventCacheKey = cacheKey + " " + className;
        var itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0;
        var stagger = {};
        if (itemIndex > 0) {
          var staggerClassName = className + "-stagger";
          var staggerCacheKey = cacheKey + " " + staggerClassName;
          var applyClasses = !lookupCache[staggerCacheKey];
          applyClasses && element.addClass(staggerClassName);
          stagger = getElementAnimationDetails(element, staggerCacheKey);
          applyClasses && element.removeClass(staggerClassName);
        }
        calculationDecorator = calculationDecorator || function(fn) {
          return fn();
        };
        element.addClass(className);
        var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {};
        var timings = calculationDecorator(function() {
          return getElementAnimationDetails(element, eventCacheKey);
        });
        var transitionDuration = timings.transitionDuration;
        var animationDuration = timings.animationDuration;
        if (transitionDuration === 0 && animationDuration === 0) {
          element.removeClass(className);
          return false;
        }
        element.data(NG_ANIMATE_CSS_DATA_KEY, {
          running: formerData.running || 0,
          itemIndex: itemIndex,
          stagger: stagger,
          timings: timings,
          closeAnimationFn: noop
        });
        var isCurrentlyAnimating = formerData.running > 0 || animationEvent == "setClass";
        if (transitionDuration > 0) {
          blockTransitions(element, className, isCurrentlyAnimating);
        }
        if (animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0) {
          blockKeyframeAnimations(element);
        }
        return true;
      }
      function isStructuralAnimation(className) {
        return className == "ng-enter" || className == "ng-move" || className == "ng-leave";
      }
      function blockTransitions(element, className, isAnimating) {
        if (isStructuralAnimation(className) || !isAnimating) {
          extractElementNode(element).style[TRANSITION_PROP + PROPERTY_KEY] = "none";
        } else {
          element.addClass(NG_ANIMATE_BLOCK_CLASS_NAME);
        }
      }
      function blockKeyframeAnimations(element) {
        extractElementNode(element).style[ANIMATION_PROP] = "none 0s";
      }
      function unblockTransitions(element, className) {
        var prop = TRANSITION_PROP + PROPERTY_KEY;
        var node = extractElementNode(element);
        if (node.style[prop] && node.style[prop].length > 0) {
          node.style[prop] = "";
        }
        element.removeClass(NG_ANIMATE_BLOCK_CLASS_NAME);
      }
      function unblockKeyframeAnimations(element) {
        var prop = ANIMATION_PROP;
        var node = extractElementNode(element);
        if (node.style[prop] && node.style[prop].length > 0) {
          node.style[prop] = "";
        }
      }
      function animateRun(animationEvent, element, className, activeAnimationComplete) {
        var node = extractElementNode(element);
        var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
        if (node.getAttribute("class").indexOf(className) == -1 || !elementData) {
          activeAnimationComplete();
          return;
        }
        var activeClassName = "";
        forEach(className.split(" "), function(klass, i) {
          activeClassName += (i > 0 ? " " : "") + klass + "-active";
        });
        var stagger = elementData.stagger;
        var timings = elementData.timings;
        var itemIndex = elementData.itemIndex;
        var maxDuration = Math.max(timings.transitionDuration, timings.animationDuration);
        var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay);
        var maxDelayTime = maxDelay * ONE_SECOND;
        var startTime = Date.now();
        var css3AnimationEvents = ANIMATIONEND_EVENT + " " + TRANSITIONEND_EVENT;
        var style = "", appliedStyles = [];
        if (timings.transitionDuration > 0) {
          var propertyStyle = timings.transitionPropertyStyle;
          if (propertyStyle.indexOf("all") == -1) {
            style += CSS_PREFIX + "transition-property: " + propertyStyle + ";";
            style += CSS_PREFIX + "transition-duration: " + timings.transitionDurationStyle + ";";
            appliedStyles.push(CSS_PREFIX + "transition-property");
            appliedStyles.push(CSS_PREFIX + "transition-duration");
          }
        }
        if (itemIndex > 0) {
          if (stagger.transitionDelay > 0 && stagger.transitionDuration === 0) {
            var delayStyle = timings.transitionDelayStyle;
            style += CSS_PREFIX + "transition-delay: " + prepareStaggerDelay(delayStyle, stagger.transitionDelay, itemIndex) + "; ";
            appliedStyles.push(CSS_PREFIX + "transition-delay");
          }
          if (stagger.animationDelay > 0 && stagger.animationDuration === 0) {
            style += CSS_PREFIX + "animation-delay: " + prepareStaggerDelay(timings.animationDelayStyle, stagger.animationDelay, itemIndex) + "; ";
            appliedStyles.push(CSS_PREFIX + "animation-delay");
          }
        }
        if (appliedStyles.length > 0) {
          var oldStyle = node.getAttribute("style") || "";
          node.setAttribute("style", oldStyle + "; " + style);
        }
        element.on(css3AnimationEvents, onAnimationProgress);
        element.addClass(activeClassName);
        elementData.closeAnimationFn = function() {
          onEnd();
          activeAnimationComplete();
        };
        var staggerTime = itemIndex * (Math.max(stagger.animationDelay, stagger.transitionDelay) || 0);
        var animationTime = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER;
        var totalTime = (staggerTime + animationTime) * ONE_SECOND;
        elementData.running++;
        animationCloseHandler(element, totalTime);
        return onEnd;
        function onEnd(cancelled) {
          element.off(css3AnimationEvents, onAnimationProgress);
          element.removeClass(activeClassName);
          animateClose(element, className);
          var node = extractElementNode(element);
          for (var i in appliedStyles) {
            node.style.removeProperty(appliedStyles[i]);
          }
        }
        function onAnimationProgress(event) {
          event.stopPropagation();
          var ev = event.originalEvent || event;
          var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
          var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
          if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
            activeAnimationComplete();
          }
        }
      }
      function prepareStaggerDelay(delayStyle, staggerDelay, index) {
        var style = "";
        forEach(delayStyle.split(","), function(val, i) {
          style += (i > 0 ? "," : "") + (index * staggerDelay + parseInt(val, 10)) + "s";
        });
        return style;
      }
      function animateBefore(animationEvent, element, className, calculationDecorator) {
        if (animateSetup(animationEvent, element, className, calculationDecorator)) {
          return function(cancelled) {
            cancelled && animateClose(element, className);
          };
        }
      }
      function animateAfter(animationEvent, element, className, afterAnimationComplete) {
        if (element.data(NG_ANIMATE_CSS_DATA_KEY)) {
          return animateRun(animationEvent, element, className, afterAnimationComplete);
        } else {
          animateClose(element, className);
          afterAnimationComplete();
        }
      }
      function animate(animationEvent, element, className, animationComplete) {
        var preReflowCancellation = animateBefore(animationEvent, element, className);
        if (!preReflowCancellation) {
          animationComplete();
          return;
        }
        var cancel = preReflowCancellation;
        afterReflow(element, function() {
          unblockTransitions(element, className);
          unblockKeyframeAnimations(element);
          cancel = animateAfter(animationEvent, element, className, animationComplete);
        });
        return function(cancelled) {
          (cancel || noop)(cancelled);
        };
      }
      function animateClose(element, className) {
        element.removeClass(className);
        var data = element.data(NG_ANIMATE_CSS_DATA_KEY);
        if (data) {
          if (data.running) {
            data.running--;
          }
          if (!data.running || data.running === 0) {
            element.removeData(NG_ANIMATE_CSS_DATA_KEY);
          }
        }
      }
      return {
        enter: function(element, animationCompleted) {
          return animate("enter", element, "ng-enter", animationCompleted);
        },
        leave: function(element, animationCompleted) {
          return animate("leave", element, "ng-leave", animationCompleted);
        },
        move: function(element, animationCompleted) {
          return animate("move", element, "ng-move", animationCompleted);
        },
        beforeSetClass: function(element, add, remove, animationCompleted) {
          var className = suffixClasses(remove, "-remove") + " " + suffixClasses(add, "-add");
          var cancellationMethod = animateBefore("setClass", element, className, function(fn) {
            var klass = element.attr("class");
            element.removeClass(remove);
            element.addClass(add);
            var timings = fn();
            element.attr("class", klass);
            return timings;
          });
          if (cancellationMethod) {
            afterReflow(element, function() {
              unblockTransitions(element, className);
              unblockKeyframeAnimations(element);
              animationCompleted();
            });
            return cancellationMethod;
          }
          animationCompleted();
        },
        beforeAddClass: function(element, className, animationCompleted) {
          var cancellationMethod = animateBefore("addClass", element, suffixClasses(className, "-add"), function(fn) {
            element.addClass(className);
            var timings = fn();
            element.removeClass(className);
            return timings;
          });
          if (cancellationMethod) {
            afterReflow(element, function() {
              unblockTransitions(element, className);
              unblockKeyframeAnimations(element);
              animationCompleted();
            });
            return cancellationMethod;
          }
          animationCompleted();
        },
        setClass: function(element, add, remove, animationCompleted) {
          remove = suffixClasses(remove, "-remove");
          add = suffixClasses(add, "-add");
          var className = remove + " " + add;
          return animateAfter("setClass", element, className, animationCompleted);
        },
        addClass: function(element, className, animationCompleted) {
          return animateAfter("addClass", element, suffixClasses(className, "-add"), animationCompleted);
        },
        beforeRemoveClass: function(element, className, animationCompleted) {
          var cancellationMethod = animateBefore("removeClass", element, suffixClasses(className, "-remove"), function(fn) {
            var klass = element.attr("class");
            element.removeClass(className);
            var timings = fn();
            element.attr("class", klass);
            return timings;
          });
          if (cancellationMethod) {
            afterReflow(element, function() {
              unblockTransitions(element, className);
              unblockKeyframeAnimations(element);
              animationCompleted();
            });
            return cancellationMethod;
          }
          animationCompleted();
        },
        removeClass: function(element, className, animationCompleted) {
          return animateAfter("removeClass", element, suffixClasses(className, "-remove"), animationCompleted);
        }
      };
      function suffixClasses(classes, suffix) {
        var className = "";
        classes = angular.isArray(classes) ? classes : classes.split(/\s+/);
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0 ? " " : "") + klass + suffix;
          }
        });
        return className;
      }
    } ]);
  } ]);
})(window, window.angular);
(function(window, angular, undefined) {
  "use strict";
  var $sanitizeMinErr = angular.$$minErr("$sanitize");
  function $SanitizeProvider() {
    this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
      return function(html) {
        var buf = [];
        htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
          return !/^unsafe/.test($$sanitizeUri(uri, isImage));
        }));
        return buf.join("");
      };
    } ];
  }
  function sanitizeText(chars) {
    var buf = [];
    var writer = htmlSanitizeWriter(buf, angular.noop);
    writer.chars(chars);
    return buf.join("");
  }
  var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/, END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/, ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, BEGIN_TAG_REGEXP = /^</, BEGING_END_TAGE_REGEXP = /^<\//, COMMENT_REGEXP = /<!--(.*?)-->/g, DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i, CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g, SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
  var voidElements = makeMap("area,br,col,hr,img,wbr");
  var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = makeMap("rp,rt"), optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
  var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
  var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
  var specialElements = makeMap("script,style");
  var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements);
  var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap");
  var validAttrs = angular.extend({}, uriAttrs, makeMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear," + "color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace," + "ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules," + "scope,scrolling,shape,size,span,start,summary,target,title,type," + "valign,value,vspace,width"));
  function makeMap(str) {
    var obj = {}, items = str.split(","), i;
    for (i = 0; i < items.length; i++) obj[items[i]] = true;
    return obj;
  }
  function htmlParser(html, handler) {
    if (typeof html !== "string") {
      if (html === null || typeof html === "undefined") {
        html = "";
      } else {
        html = "" + html;
      }
    }
    var index, chars, match, stack = [], last = html, text;
    stack.last = function() {
      return stack[stack.length - 1];
    };
    while (html) {
      text = "";
      chars = true;
      if (!stack.last() || !specialElements[stack.last()]) {
        if (html.indexOf("<!--") === 0) {
          index = html.indexOf("--", 4);
          if (index >= 0 && html.lastIndexOf("-->", index) === index) {
            if (handler.comment) handler.comment(html.substring(4, index));
            html = html.substring(index + 3);
            chars = false;
          }
        } else if (DOCTYPE_REGEXP.test(html)) {
          match = html.match(DOCTYPE_REGEXP);
          if (match) {
            html = html.replace(match[0], "");
            chars = false;
          }
        } else if (BEGING_END_TAGE_REGEXP.test(html)) {
          match = html.match(END_TAG_REGEXP);
          if (match) {
            html = html.substring(match[0].length);
            match[0].replace(END_TAG_REGEXP, parseEndTag);
            chars = false;
          }
        } else if (BEGIN_TAG_REGEXP.test(html)) {
          match = html.match(START_TAG_REGEXP);
          if (match) {
            if (match[4]) {
              html = html.substring(match[0].length);
              match[0].replace(START_TAG_REGEXP, parseStartTag);
            }
            chars = false;
          } else {
            text += "<";
            html = html.substring(1);
          }
        }
        if (chars) {
          index = html.indexOf("<");
          text += index < 0 ? html : html.substring(0, index);
          html = index < 0 ? "" : html.substring(index);
          if (handler.chars) handler.chars(decodeEntities(text));
        }
      } else {
        html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", "i"), function(all, text) {
          text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
          if (handler.chars) handler.chars(decodeEntities(text));
          return "";
        });
        parseEndTag("", stack.last());
      }
      if (html == last) {
        throw $sanitizeMinErr("badparse", "The sanitizer was unable to parse the following block " + "of html: {0}", html);
      }
      last = html;
    }
    parseEndTag();
    function parseStartTag(tag, tagName, rest, unary) {
      tagName = angular.lowercase(tagName);
      if (blockElements[tagName]) {
        while (stack.last() && inlineElements[stack.last()]) {
          parseEndTag("", stack.last());
        }
      }
      if (optionalEndTagElements[tagName] && stack.last() == tagName) {
        parseEndTag("", tagName);
      }
      unary = voidElements[tagName] || !!unary;
      if (!unary) stack.push(tagName);
      var attrs = {};
      rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
        var value = doubleQuotedValue || singleQuotedValue || unquotedValue || "";
        attrs[name] = decodeEntities(value);
      });
      if (handler.start) handler.start(tagName, attrs, unary);
    }
    function parseEndTag(tag, tagName) {
      var pos = 0, i;
      tagName = angular.lowercase(tagName);
      if (tagName) for (pos = stack.length - 1; pos >= 0; pos--) if (stack[pos] == tagName) break;
      if (pos >= 0) {
        for (i = stack.length - 1; i >= pos; i--) if (handler.end) handler.end(stack[i]);
        stack.length = pos;
      }
    }
  }
  var hiddenPre = document.createElement("pre");
  var spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;
  function decodeEntities(value) {
    if (!value) {
      return "";
    }
    var parts = spaceRe.exec(value);
    var spaceBefore = parts[1];
    var spaceAfter = parts[3];
    var content = parts[2];
    if (content) {
      hiddenPre.innerHTML = content.replace(/</g, "&lt;");
      content = "textContent" in hiddenPre ? hiddenPre.textContent : hiddenPre.innerText;
    }
    return spaceBefore + content + spaceAfter;
  }
  function encodeEntities(value) {
    return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
      var hi = value.charCodeAt(0);
      var low = value.charCodeAt(1);
      return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
    }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
      return "&#" + value.charCodeAt(0) + ";";
    }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function htmlSanitizeWriter(buf, uriValidator) {
    var ignore = false;
    var out = angular.bind(buf, buf.push);
    return {
      start: function(tag, attrs, unary) {
        tag = angular.lowercase(tag);
        if (!ignore && specialElements[tag]) {
          ignore = tag;
        }
        if (!ignore && validElements[tag] === true) {
          out("<");
          out(tag);
          angular.forEach(attrs, function(value, key) {
            var lkey = angular.lowercase(key);
            var isImage = tag === "img" && lkey === "src" || lkey === "background";
            if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
              out(" ");
              out(key);
              out('="');
              out(encodeEntities(value));
              out('"');
            }
          });
          out(unary ? "/>" : ">");
        }
      },
      end: function(tag) {
        tag = angular.lowercase(tag);
        if (!ignore && validElements[tag] === true) {
          out("</");
          out(tag);
          out(">");
        }
        if (tag == ignore) {
          ignore = false;
        }
      },
      chars: function(chars) {
        if (!ignore) {
          out(encodeEntities(chars));
        }
      }
    };
  }
  angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider);
  angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
    var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"]/, MAILTO_REGEXP = /^mailto:/;
    return function(text, target) {
      if (!text) return text;
      var match;
      var raw = text;
      var html = [];
      var url;
      var i;
      while (match = raw.match(LINKY_URL_REGEXP)) {
        url = match[0];
        if (match[2] == match[3]) url = "mailto:" + url;
        i = match.index;
        addText(raw.substr(0, i));
        addLink(url, match[0].replace(MAILTO_REGEXP, ""));
        raw = raw.substring(i + match[0].length);
      }
      addText(raw);
      return $sanitize(html.join(""));
      function addText(text) {
        if (!text) {
          return;
        }
        html.push(sanitizeText(text));
      }
      function addLink(url, text) {
        html.push("<a ");
        if (angular.isDefined(target)) {
          html.push('target="');
          html.push(target);
          html.push('" ');
        }
        html.push('href="');
        html.push(url);
        html.push('">');
        addText(text);
        html.push("</a>");
      }
    };
  } ]);
})(window, window.angular);
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
  module.exports = "ui.router";
}

(function(window, angular, undefined) {
  "use strict";
  var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy;
  function inherit(parent, extra) {
    return extend(new (extend(function() {}, {
      prototype: parent
    }))(), extra);
  }
  function merge(dst) {
    forEach(arguments, function(obj) {
      if (obj !== dst) {
        forEach(obj, function(value, key) {
          if (!dst.hasOwnProperty(key)) dst[key] = value;
        });
      }
    });
    return dst;
  }
  function ancestors(first, second) {
    var path = [];
    for (var n in first.path) {
      if (first.path[n] !== second.path[n]) break;
      path.push(first.path[n]);
    }
    return path;
  }
  function keys(object) {
    if (Object.keys) {
      return Object.keys(object);
    }
    var result = [];
    angular.forEach(object, function(val, key) {
      result.push(key);
    });
    return result;
  }
  function arraySearch(array, value) {
    if (Array.prototype.indexOf) {
      return array.indexOf(value, Number(arguments[2]) || 0);
    }
    var len = array.length >>> 0, from = Number(arguments[2]) || 0;
    from = from < 0 ? Math.ceil(from) : Math.floor(from);
    if (from < 0) from += len;
    for (;from < len; from++) {
      if (from in array && array[from] === value) return from;
    }
    return -1;
  }
  function inheritParams(currentParams, newParams, $current, $to) {
    var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
    for (var i in parents) {
      if (!parents[i].params || !parents[i].params.length) continue;
      parentParams = parents[i].params;
      for (var j in parentParams) {
        if (arraySearch(inheritList, parentParams[j]) >= 0) continue;
        inheritList.push(parentParams[j]);
        inherited[parentParams[j]] = currentParams[parentParams[j]];
      }
    }
    return extend({}, inherited, newParams);
  }
  function normalize(keys, values) {
    var normalized = {};
    forEach(keys, function(name) {
      var value = values[name];
      normalized[name] = value != null ? String(value) : null;
    });
    return normalized;
  }
  function equalForKeys(a, b, keys) {
    if (!keys) {
      keys = [];
      for (var n in a) keys.push(n);
    }
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      if (a[k] != b[k]) return false;
    }
    return true;
  }
  function filterByKeys(keys, values) {
    var filtered = {};
    forEach(keys, function(name) {
      filtered[name] = values[name];
    });
    return filtered;
  }
  angular.module("ui.router.util", [ "ng" ]);
  angular.module("ui.router.router", [ "ui.router.util" ]);
  angular.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]);
  angular.module("ui.router", [ "ui.router.state" ]);
  angular.module("ui.router.compat", [ "ui.router" ]);
  $Resolve.$inject = [ "$q", "$injector" ];
  function $Resolve($q, $injector) {
    var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
      $$promises: NOTHING,
      $$values: NOTHING
    });
    this.study = function(invocables) {
      if (!isObject(invocables)) throw new Error("'invocables' must be an object");
      var plan = [], cycle = [], visited = {};
      function visit(value, key) {
        if (visited[key] === VISIT_DONE) return;
        cycle.push(key);
        if (visited[key] === VISIT_IN_PROGRESS) {
          cycle.splice(0, cycle.indexOf(key));
          throw new Error("Cyclic dependency: " + cycle.join(" -> "));
        }
        visited[key] = VISIT_IN_PROGRESS;
        if (isString(value)) {
          plan.push(key, [ function() {
            return $injector.get(value);
          } ], NO_DEPENDENCIES);
        } else {
          var params = $injector.annotate(value);
          forEach(params, function(param) {
            if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
          });
          plan.push(key, value, params);
        }
        cycle.pop();
        visited[key] = VISIT_DONE;
      }
      forEach(invocables, visit);
      invocables = cycle = visited = null;
      function isResolve(value) {
        return isObject(value) && value.then && value.$$promises;
      }
      return function(locals, parent, self) {
        if (isResolve(locals) && self === undefined) {
          self = parent;
          parent = locals;
          locals = null;
        }
        if (!locals) locals = NO_LOCALS; else if (!isObject(locals)) {
          throw new Error("'locals' must be an object");
        }
        if (!parent) parent = NO_PARENT; else if (!isResolve(parent)) {
          throw new Error("'parent' must be a promise returned by $resolve.resolve()");
        }
        var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = false;
        function done() {
          if (!--wait) {
            if (!merged) merge(values, parent.$$values);
            result.$$values = values;
            result.$$promises = true;
            resolution.resolve(values);
          }
        }
        function fail(reason) {
          result.$$failure = reason;
          resolution.reject(reason);
        }
        if (isDefined(parent.$$failure)) {
          fail(parent.$$failure);
          return result;
        }
        if (parent.$$values) {
          merged = merge(values, parent.$$values);
          done();
        } else {
          extend(promises, parent.$$promises);
          parent.then(done, fail);
        }
        for (var i = 0, ii = plan.length; i < ii; i += 3) {
          if (locals.hasOwnProperty(plan[i])) done(); else invoke(plan[i], plan[i + 1], plan[i + 2]);
        }
        function invoke(key, invocable, params) {
          var invocation = $q.defer(), waitParams = 0;
          function onfailure(reason) {
            invocation.reject(reason);
            fail(reason);
          }
          forEach(params, function(dep) {
            if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
              waitParams++;
              promises[dep].then(function(result) {
                values[dep] = result;
                if (!--waitParams) proceed();
              }, onfailure);
            }
          });
          if (!waitParams) proceed();
          function proceed() {
            if (isDefined(result.$$failure)) return;
            try {
              invocation.resolve($injector.invoke(invocable, self, values));
              invocation.promise.then(function(result) {
                values[key] = result;
                done();
              }, onfailure);
            } catch (e) {
              onfailure(e);
            }
          }
          promises[key] = invocation.promise;
        }
        return result;
      };
    };
    this.resolve = function(invocables, locals, parent, self) {
      return this.study(invocables)(locals, parent, self);
    };
  }
  angular.module("ui.router.util").service("$resolve", $Resolve);
  $TemplateFactory.$inject = [ "$http", "$templateCache", "$injector" ];
  function $TemplateFactory($http, $templateCache, $injector) {
    this.fromConfig = function(config, params, locals) {
      return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
    };
    this.fromString = function(template, params) {
      return isFunction(template) ? template(params) : template;
    };
    this.fromUrl = function(url, params) {
      if (isFunction(url)) url = url(params);
      if (url == null) return null; else return $http.get(url, {
        cache: $templateCache
      }).then(function(response) {
        return response.data;
      });
    };
    this.fromProvider = function(provider, params, locals) {
      return $injector.invoke(provider, null, locals || {
        params: params
      });
    };
  }
  angular.module("ui.router.util").service("$templateFactory", $TemplateFactory);
  function UrlMatcher(pattern) {
    var placeholder = /([:*])(\w+)|\{(\w+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, names = {}, compiled = "^", last = 0, m, segments = this.segments = [], params = this.params = [];
    function addParameter(id) {
      if (!/^\w+(-+\w+)*$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
      if (names[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
      names[id] = true;
      params.push(id);
    }
    function quoteRegExp(string) {
      return string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
    }
    this.source = pattern;
    var id, regexp, segment;
    while (m = placeholder.exec(pattern)) {
      id = m[2] || m[3];
      regexp = m[4] || (m[1] == "*" ? ".*" : "[^/]*");
      segment = pattern.substring(last, m.index);
      if (segment.indexOf("?") >= 0) break;
      compiled += quoteRegExp(segment) + "(" + regexp + ")";
      addParameter(id);
      segments.push(segment);
      last = placeholder.lastIndex;
    }
    segment = pattern.substring(last);
    var i = segment.indexOf("?");
    if (i >= 0) {
      var search = this.sourceSearch = segment.substring(i);
      segment = segment.substring(0, i);
      this.sourcePath = pattern.substring(0, last + i);
      forEach(search.substring(1).split(/[&?]/), addParameter);
    } else {
      this.sourcePath = pattern;
      this.sourceSearch = "";
    }
    compiled += quoteRegExp(segment) + "$";
    segments.push(segment);
    this.regexp = new RegExp(compiled);
    this.prefix = segments[0];
  }
  UrlMatcher.prototype.concat = function(pattern) {
    return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch);
  };
  UrlMatcher.prototype.toString = function() {
    return this.source;
  };
  UrlMatcher.prototype.exec = function(path, searchParams) {
    var m = this.regexp.exec(path);
    if (!m) return null;
    var params = this.params, nTotal = params.length, nPath = this.segments.length - 1, values = {}, i;
    if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
    for (i = 0; i < nPath; i++) values[params[i]] = m[i + 1];
    for (;i < nTotal; i++) values[params[i]] = searchParams[params[i]];
    return values;
  };
  UrlMatcher.prototype.parameters = function() {
    return this.params;
  };
  UrlMatcher.prototype.format = function(values) {
    var segments = this.segments, params = this.params;
    if (!values) return segments.join("");
    var nPath = segments.length - 1, nTotal = params.length, result = segments[0], i, search, value;
    for (i = 0; i < nPath; i++) {
      value = values[params[i]];
      if (value != null) result += encodeURIComponent(value);
      result += segments[i + 1];
    }
    for (;i < nTotal; i++) {
      value = values[params[i]];
      if (value != null) {
        result += (search ? "&" : "?") + params[i] + "=" + encodeURIComponent(value);
        search = true;
      }
    }
    return result;
  };
  function $UrlMatcherFactory() {
    this.compile = function(pattern) {
      return new UrlMatcher(pattern);
    };
    this.isMatcher = function(o) {
      return isObject(o) && isFunction(o.exec) && isFunction(o.format) && isFunction(o.concat);
    };
    this.$get = function() {
      return this;
    };
  }
  angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory);
  $UrlRouterProvider.$inject = [ "$urlMatcherFactoryProvider" ];
  function $UrlRouterProvider($urlMatcherFactory) {
    var rules = [], otherwise = null;
    function regExpPrefix(re) {
      var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
      return prefix != null ? prefix[1].replace(/\\(.)/g, "$1") : "";
    }
    function interpolate(pattern, match) {
      return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
        return match[what === "$" ? 0 : Number(what)];
      });
    }
    this.rule = function(rule) {
      if (!isFunction(rule)) throw new Error("'rule' must be a function");
      rules.push(rule);
      return this;
    };
    this.otherwise = function(rule) {
      if (isString(rule)) {
        var redirect = rule;
        rule = function() {
          return redirect;
        };
      } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
      otherwise = rule;
      return this;
    };
    function handleIfMatch($injector, handler, match) {
      if (!match) return false;
      var result = $injector.invoke(handler, handler, {
        $match: match
      });
      return isDefined(result) ? result : true;
    }
    this.when = function(what, handler) {
      var redirect, handlerIsString = isString(handler);
      if (isString(what)) what = $urlMatcherFactory.compile(what);
      if (!handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
      var strategies = {
        matcher: function(what, handler) {
          if (handlerIsString) {
            redirect = $urlMatcherFactory.compile(handler);
            handler = [ "$match", function($match) {
              return redirect.format($match);
            } ];
          }
          return extend(function($injector, $location) {
            return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
          }, {
            prefix: isString(what.prefix) ? what.prefix : ""
          });
        },
        regex: function(what, handler) {
          if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
          if (handlerIsString) {
            redirect = handler;
            handler = [ "$match", function($match) {
              return interpolate(redirect, $match);
            } ];
          }
          return extend(function($injector, $location) {
            return handleIfMatch($injector, handler, what.exec($location.path()));
          }, {
            prefix: regExpPrefix(what)
          });
        }
      };
      var check = {
        matcher: $urlMatcherFactory.isMatcher(what),
        regex: what instanceof RegExp
      };
      for (var n in check) {
        if (check[n]) {
          return this.rule(strategies[n](what, handler));
        }
      }
      throw new Error("invalid 'what' in when()");
    };
    this.$get = [ "$location", "$rootScope", "$injector", function($location, $rootScope, $injector) {
      function update(evt) {
        if (evt && evt.defaultPrevented) return;
        function check(rule) {
          var handled = rule($injector, $location);
          if (handled) {
            if (isString(handled)) $location.replace().url(handled);
            return true;
          }
          return false;
        }
        var n = rules.length, i;
        for (i = 0; i < n; i++) {
          if (check(rules[i])) return;
        }
        if (otherwise) check(otherwise);
      }
      $rootScope.$on("$locationChangeSuccess", update);
      return {
        sync: function() {
          update();
        }
      };
    } ];
  }
  angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider);
  $StateProvider.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider", "$locationProvider" ];
  function $StateProvider($urlRouterProvider, $urlMatcherFactory, $locationProvider) {
    var root, states = {}, $state, queue = {}, abstractKey = "abstract";
    var stateBuilder = {
      parent: function(state) {
        if (isDefined(state.parent) && state.parent) return findState(state.parent);
        var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
        return compositeName ? findState(compositeName[1]) : root;
      },
      data: function(state) {
        if (state.parent && state.parent.data) {
          state.data = state.self.data = extend({}, state.parent.data, state.data);
        }
        return state.data;
      },
      url: function(state) {
        var url = state.url;
        if (isString(url)) {
          if (url.charAt(0) == "^") {
            return $urlMatcherFactory.compile(url.substring(1));
          }
          return (state.parent.navigable || root).url.concat(url);
        }
        if ($urlMatcherFactory.isMatcher(url) || url == null) {
          return url;
        }
        throw new Error("Invalid url '" + url + "' in state '" + state + "'");
      },
      navigable: function(state) {
        return state.url ? state : state.parent ? state.parent.navigable : null;
      },
      params: function(state) {
        if (!state.params) {
          return state.url ? state.url.parameters() : state.parent.params;
        }
        if (!isArray(state.params)) throw new Error("Invalid params in state '" + state + "'");
        if (state.url) throw new Error("Both params and url specicified in state '" + state + "'");
        return state.params;
      },
      views: function(state) {
        var views = {};
        forEach(isDefined(state.views) ? state.views : {
          "": state
        }, function(view, name) {
          if (name.indexOf("@") < 0) name += "@" + state.parent.name;
          views[name] = view;
        });
        return views;
      },
      ownParams: function(state) {
        if (!state.parent) {
          return state.params;
        }
        var paramNames = {};
        forEach(state.params, function(p) {
          paramNames[p] = true;
        });
        forEach(state.parent.params, function(p) {
          if (!paramNames[p]) {
            throw new Error("Missing required parameter '" + p + "' in state '" + state.name + "'");
          }
          paramNames[p] = false;
        });
        var ownParams = [];
        forEach(paramNames, function(own, p) {
          if (own) ownParams.push(p);
        });
        return ownParams;
      },
      path: function(state) {
        return state.parent ? state.parent.path.concat(state) : [];
      },
      includes: function(state) {
        var includes = state.parent ? extend({}, state.parent.includes) : {};
        includes[state.name] = true;
        return includes;
      },
      $delegates: {}
    };
    function isRelative(stateName) {
      return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
    }
    function findState(stateOrName, base) {
      var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
      if (path) {
        if (!base) throw new Error("No reference point given for path '" + name + "'");
        var rel = name.split("."), i = 0, pathLength = rel.length, current = base;
        for (;i < pathLength; i++) {
          if (rel[i] === "" && i === 0) {
            current = base;
            continue;
          }
          if (rel[i] === "^") {
            if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
            current = current.parent;
            continue;
          }
          break;
        }
        rel = rel.slice(i).join(".");
        name = current.name + (current.name && rel ? "." : "") + rel;
      }
      var state = states[name];
      if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
        return state;
      }
      return undefined;
    }
    function queueState(parentName, state) {
      if (!queue[parentName]) {
        queue[parentName] = [];
      }
      queue[parentName].push(state);
    }
    function registerState(state) {
      state = inherit(state, {
        self: state,
        resolve: state.resolve || {},
        toString: function() {
          return this.name;
        }
      });
      var name = state.name;
      if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
      if (states.hasOwnProperty(name)) throw new Error("State '" + name + "'' is already defined");
      var parentName = name.indexOf(".") !== -1 ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : "";
      if (parentName && !states[parentName]) {
        return queueState(parentName, state.self);
      }
      for (var key in stateBuilder) {
        if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
      }
      states[name] = state;
      if (!state[abstractKey] && state.url) {
        $urlRouterProvider.when(state.url, [ "$match", "$stateParams", function($match, $stateParams) {
          if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
            $state.transitionTo(state, $match, {
              location: false
            });
          }
        } ]);
      }
      if (queue[name]) {
        for (var i = 0; i < queue[name].length; i++) {
          registerState(queue[name][i]);
        }
      }
      return state;
    }
    function isGlob(text) {
      return text.indexOf("*") > -1;
    }
    function doesStateMatchGlob(glob) {
      var globSegments = glob.split("."), segments = $state.$current.name.split(".");
      if (globSegments[0] === "**") {
        segments = segments.slice(segments.indexOf(globSegments[1]));
        segments.unshift("**");
      }
      if (globSegments[globSegments.length - 1] === "**") {
        segments.splice(segments.indexOf(globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
        segments.push("**");
      }
      if (globSegments.length != segments.length) {
        return false;
      }
      for (var i = 0, l = globSegments.length; i < l; i++) {
        if (globSegments[i] === "*") {
          segments[i] = "*";
        }
      }
      return segments.join("") === globSegments.join("");
    }
    root = registerState({
      name: "",
      url: "^",
      views: null,
      "abstract": true
    });
    root.navigable = null;
    this.decorator = decorator;
    function decorator(name, func) {
      if (isString(name) && !isDefined(func)) {
        return stateBuilder[name];
      }
      if (!isFunction(func) || !isString(name)) {
        return this;
      }
      if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
        stateBuilder.$delegates[name] = stateBuilder[name];
      }
      stateBuilder[name] = func;
      return this;
    }
    this.state = state;
    function state(name, definition) {
      if (isObject(name)) definition = name; else definition.name = name;
      registerState(definition);
      return this;
    }
    this.$get = $get;
    $get.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$location", "$urlRouter", "$browser" ];
    function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $location, $urlRouter, $browser) {
      var TransitionSuperseded = $q.reject(new Error("transition superseded"));
      var TransitionPrevented = $q.reject(new Error("transition prevented"));
      var TransitionAborted = $q.reject(new Error("transition aborted"));
      var TransitionFailed = $q.reject(new Error("transition failed"));
      var currentLocation = $location.url();
      var baseHref = $browser.baseHref();
      function syncUrl() {
        if ($location.url() !== currentLocation) {
          $location.url(currentLocation);
          $location.replace();
        }
      }
      root.locals = {
        resolve: null,
        globals: {
          $stateParams: {}
        }
      };
      $state = {
        params: {},
        current: root.self,
        $current: root,
        transition: null
      };
      $state.reload = function reload() {
        $state.transitionTo($state.current, $stateParams, {
          reload: true,
          inherit: false,
          notify: false
        });
      };
      $state.go = function go(to, params, options) {
        return this.transitionTo(to, params, extend({
          inherit: true,
          relative: $state.$current
        }, options));
      };
      $state.transitionTo = function transitionTo(to, toParams, options) {
        toParams = toParams || {};
        options = extend({
          location: true,
          inherit: false,
          relative: null,
          notify: true,
          reload: false,
          $retry: false
        }, options || {});
        var from = $state.$current, fromParams = $state.params, fromPath = from.path;
        var evt, toState = findState(to, options.relative);
        if (!isDefined(toState)) {
          var redirect = {
            to: to,
            toParams: toParams,
            options: options
          };
          evt = $rootScope.$broadcast("$stateNotFound", redirect, from.self, fromParams);
          if (evt.defaultPrevented) {
            syncUrl();
            return TransitionAborted;
          }
          if (evt.retry) {
            if (options.$retry) {
              syncUrl();
              return TransitionFailed;
            }
            var retryTransition = $state.transition = $q.when(evt.retry);
            retryTransition.then(function() {
              if (retryTransition !== $state.transition) return TransitionSuperseded;
              redirect.options.$retry = true;
              return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
            }, function() {
              return TransitionAborted;
            });
            syncUrl();
            return retryTransition;
          }
          to = redirect.to;
          toParams = redirect.toParams;
          options = redirect.options;
          toState = findState(to, options.relative);
          if (!isDefined(toState)) {
            if (options.relative) throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
            throw new Error("No such state '" + to + "'");
          }
        }
        if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
        if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
        to = toState;
        var toPath = to.path;
        var keep, state, locals = root.locals, toLocals = [];
        for (keep = 0, state = toPath[keep]; state && state === fromPath[keep] && equalForKeys(toParams, fromParams, state.ownParams) && !options.reload; keep++, 
        state = toPath[keep]) {
          locals = toLocals[keep] = state.locals;
        }
        if (shouldTriggerReload(to, from, locals, options)) {
          if (to.self.reloadOnSearch !== false) syncUrl();
          $state.transition = null;
          return $q.when($state.current);
        }
        toParams = normalize(to.params, toParams || {});
        if (options.notify) {
          evt = $rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams);
          if (evt.defaultPrevented) {
            syncUrl();
            return TransitionPrevented;
          }
        }
        var resolved = $q.when(locals);
        for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
          locals = toLocals[l] = inherit(locals);
          resolved = resolveState(state, toParams, state === to, resolved, locals);
        }
        var transition = $state.transition = resolved.then(function() {
          var l, entering, exiting;
          if ($state.transition !== transition) return TransitionSuperseded;
          for (l = fromPath.length - 1; l >= keep; l--) {
            exiting = fromPath[l];
            if (exiting.self.onExit) {
              $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
            }
            exiting.locals = null;
          }
          for (l = keep; l < toPath.length; l++) {
            entering = toPath[l];
            entering.locals = toLocals[l];
            if (entering.self.onEnter) {
              $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
            }
          }
          if ($state.transition !== transition) return TransitionSuperseded;
          $state.$current = to;
          $state.current = to.self;
          $state.params = toParams;
          copy($state.params, $stateParams);
          $state.transition = null;
          var toNav = to.navigable;
          if (options.location && toNav) {
            $location.url(toNav.url.format(toNav.locals.globals.$stateParams));
            if (options.location === "replace") {
              $location.replace();
            }
          }
          if (options.notify) {
            $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams);
          }
          currentLocation = $location.url();
          return $state.current;
        }, function(error) {
          if ($state.transition !== transition) return TransitionSuperseded;
          $state.transition = null;
          $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error);
          syncUrl();
          return $q.reject(error);
        });
        return transition;
      };
      $state.is = function is(stateOrName, params) {
        var state = findState(stateOrName);
        if (!isDefined(state)) {
          return undefined;
        }
        if ($state.$current !== state) {
          return false;
        }
        return isDefined(params) && params !== null ? angular.equals($stateParams, params) : true;
      };
      $state.includes = function includes(stateOrName, params) {
        if (isString(stateOrName) && isGlob(stateOrName)) {
          if (doesStateMatchGlob(stateOrName)) {
            stateOrName = $state.$current.name;
          } else {
            return false;
          }
        }
        var state = findState(stateOrName);
        if (!isDefined(state)) {
          return undefined;
        }
        if (!isDefined($state.$current.includes[state.name])) {
          return false;
        }
        var validParams = true;
        angular.forEach(params, function(value, key) {
          if (!isDefined($stateParams[key]) || $stateParams[key] !== value) {
            validParams = false;
          }
        });
        return validParams;
      };
      $state.href = function href(stateOrName, params, options) {
        options = extend({
          lossy: true,
          inherit: false,
          absolute: false,
          relative: $state.$current
        }, options || {});
        var state = findState(stateOrName, options.relative);
        if (!isDefined(state)) return null;
        params = inheritParams($stateParams, params || {}, $state.$current, state);
        var nav = state && options.lossy ? state.navigable : state;
        var url = nav && nav.url ? nav.url.format(normalize(state.params, params || {})) : null;
        if (!$locationProvider.html5Mode() && url) {
          url = "#" + $locationProvider.hashPrefix() + url;
        }
        if (baseHref !== "/") {
          if ($locationProvider.html5Mode()) {
            url = baseHref.slice(0, -1) + url;
          } else if (options.absolute) {
            url = baseHref.slice(1) + url;
          }
        }
        if (options.absolute && url) {
          url = $location.protocol() + "://" + $location.host() + ($location.port() == 80 || $location.port() == 443 ? "" : ":" + $location.port()) + (!$locationProvider.html5Mode() && url ? "/" : "") + url;
        }
        return url;
      };
      $state.get = function(stateOrName, context) {
        if (!isDefined(stateOrName)) {
          var list = [];
          forEach(states, function(state) {
            list.push(state.self);
          });
          return list;
        }
        var state = findState(stateOrName, context);
        return state && state.self ? state.self : null;
      };
      function resolveState(state, params, paramsAreFiltered, inherited, dst) {
        var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params, params);
        var locals = {
          $stateParams: $stateParams
        };
        dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
        var promises = [ dst.resolve.then(function(globals) {
          dst.globals = globals;
        }) ];
        if (inherited) promises.push(inherited);
        forEach(state.views, function(view, name) {
          var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
          injectables.$template = [ function() {
            return $view.load(name, {
              view: view,
              locals: locals,
              params: $stateParams,
              notify: false
            }) || "";
          } ];
          promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function(result) {
            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
              var injectLocals = angular.extend({}, injectables, locals);
              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
            } else {
              result.$$controller = view.controller;
            }
            result.$$state = state;
            result.$$controllerAs = view.controllerAs;
            dst[name] = result;
          }));
        });
        return $q.all(promises).then(function(values) {
          return dst;
        });
      }
      return $state;
    }
    function shouldTriggerReload(to, from, locals, options) {
      if (to === from && (locals === from.locals && !options.reload || to.self.reloadOnSearch === false)) {
        return true;
      }
    }
  }
  angular.module("ui.router.state").value("$stateParams", {}).provider("$state", $StateProvider);
  $ViewProvider.$inject = [];
  function $ViewProvider() {
    this.$get = $get;
    $get.$inject = [ "$rootScope", "$templateFactory" ];
    function $get($rootScope, $templateFactory) {
      return {
        load: function load(name, options) {
          var result, defaults = {
            template: null,
            controller: null,
            view: null,
            locals: null,
            notify: true,
            async: true,
            params: {}
          };
          options = extend(defaults, options);
          if (options.view) {
            result = $templateFactory.fromConfig(options.view, options.params, options.locals);
          }
          if (result && options.notify) {
            $rootScope.$broadcast("$viewContentLoading", options);
          }
          return result;
        }
      };
    }
  }
  angular.module("ui.router.state").provider("$view", $ViewProvider);
  function $ViewScrollProvider() {
    var useAnchorScroll = false;
    this.useAnchorScroll = function() {
      useAnchorScroll = true;
    };
    this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
      if (useAnchorScroll) {
        return $anchorScroll;
      }
      return function($element) {
        $timeout(function() {
          $element[0].scrollIntoView();
        }, 0, false);
      };
    } ];
  }
  angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider);
  $ViewDirective.$inject = [ "$state", "$injector", "$uiViewScroll" ];
  function $ViewDirective($state, $injector, $uiViewScroll) {
    function getService() {
      return $injector.has ? function(service) {
        return $injector.has(service) ? $injector.get(service) : null;
      } : function(service) {
        try {
          return $injector.get(service);
        } catch (e) {
          return null;
        }
      };
    }
    var service = getService(), $animator = service("$animator"), $animate = service("$animate");
    function getRenderer(attrs, scope) {
      var statics = function() {
        return {
          enter: function(element, target, cb) {
            target.after(element);
            cb();
          },
          leave: function(element, cb) {
            element.remove();
            cb();
          }
        };
      };
      if ($animate) {
        return {
          enter: function(element, target, cb) {
            $animate.enter(element, null, target, cb);
          },
          leave: function(element, cb) {
            $animate.leave(element, cb);
          }
        };
      }
      if ($animator) {
        var animate = $animator && $animator(scope, attrs);
        return {
          enter: function(element, target, cb) {
            animate.enter(element, null, target);
            cb();
          },
          leave: function(element, cb) {
            animate.leave(element);
            cb();
          }
        };
      }
      return statics();
    }
    var directive = {
      restrict: "ECA",
      terminal: true,
      priority: 400,
      transclude: "element",
      compile: function(tElement, tAttrs, $transclude) {
        return function(scope, $element, attrs) {
          var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope);
          scope.$on("$stateChangeSuccess", function() {
            updateView(false);
          });
          scope.$on("$viewContentLoading", function() {
            updateView(false);
          });
          updateView(true);
          function cleanupLastView() {
            if (previousEl) {
              previousEl.remove();
              previousEl = null;
            }
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentEl) {
              renderer.leave(currentEl, function() {
                previousEl = null;
              });
              previousEl = currentEl;
              currentEl = null;
            }
          }
          function updateView(firstTime) {
            var newScope = scope.$new(), name = currentEl && currentEl.data("$uiViewName"), previousLocals = name && $state.$current && $state.$current.locals[name];
            if (!firstTime && previousLocals === latestLocals) return;
            var clone = $transclude(newScope, function(clone) {
              renderer.enter(clone, $element, function onUiViewEnter() {
                if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                  $uiViewScroll(clone);
                }
              });
              cleanupLastView();
            });
            latestLocals = $state.$current.locals[clone.data("$uiViewName")];
            currentEl = clone;
            currentScope = newScope;
            currentScope.$emit("$viewContentLoaded");
            currentScope.$eval(onloadExp);
          }
        };
      }
    };
    return directive;
  }
  $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$state" ];
  function $ViewDirectiveFill($compile, $controller, $state) {
    return {
      restrict: "ECA",
      priority: -400,
      compile: function(tElement) {
        var initial = tElement.html();
        return function(scope, $element, attrs) {
          var name = attrs.uiView || attrs.name || "", inherited = $element.inheritedData("$uiView");
          if (name.indexOf("@") < 0) {
            name = name + "@" + (inherited ? inherited.state.name : "");
          }
          $element.data("$uiViewName", name);
          var current = $state.$current, locals = current && current.locals[name];
          if (!locals) {
            return;
          }
          $element.data("$uiView", {
            name: name,
            state: locals.$$state
          });
          $element.html(locals.$template ? locals.$template : initial);
          var link = $compile($element.contents());
          if (locals.$$controller) {
            locals.$scope = scope;
            var controller = $controller(locals.$$controller, locals);
            if (locals.$$controllerAs) {
              scope[locals.$$controllerAs] = controller;
            }
            $element.data("$ngControllerController", controller);
            $element.children().data("$ngControllerController", controller);
          }
          link(scope);
        };
      }
    };
  }
  angular.module("ui.router.state").directive("uiView", $ViewDirective);
  angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill);
  function parseStateRef(ref) {
    var parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
    if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
    return {
      state: parsed[1],
      paramExpr: parsed[3] || null
    };
  }
  function stateContext(el) {
    var stateData = el.parent().inheritedData("$uiView");
    if (stateData && stateData.state && stateData.state.name) {
      return stateData.state;
    }
  }
  $StateRefDirective.$inject = [ "$state", "$timeout" ];
  function $StateRefDirective($state, $timeout) {
    var allowedOptions = [ "location", "inherit", "reload" ];
    return {
      restrict: "A",
      require: "?^uiSrefActive",
      link: function(scope, element, attrs, uiSrefActive) {
        var ref = parseStateRef(attrs.uiSref);
        var params = null, url = null, base = stateContext(element) || $state.$current;
        var isForm = element[0].nodeName === "FORM";
        var attr = isForm ? "action" : "href", nav = true;
        var options = {
          relative: base
        };
        var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
        angular.forEach(allowedOptions, function(option) {
          if (option in optionsOverride) {
            options[option] = optionsOverride[option];
          }
        });
        var update = function(newVal) {
          if (newVal) params = newVal;
          if (!nav) return;
          var newHref = $state.href(ref.state, params, options);
          if (uiSrefActive) {
            uiSrefActive.$$setStateInfo(ref.state, params);
          }
          if (!newHref) {
            nav = false;
            return false;
          }
          element[0][attr] = newHref;
        };
        if (ref.paramExpr) {
          scope.$watch(ref.paramExpr, function(newVal, oldVal) {
            if (newVal !== params) update(newVal);
          }, true);
          params = scope.$eval(ref.paramExpr);
        }
        update();
        if (isForm) return;
        element.bind("click", function(e) {
          var button = e.which || e.button;
          if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr("target"))) {
            $timeout(function() {
              $state.go(ref.state, params, options);
            });
            e.preventDefault();
          }
        });
      }
    };
  }
  $StateActiveDirective.$inject = [ "$state", "$stateParams", "$interpolate" ];
  function $StateActiveDirective($state, $stateParams, $interpolate) {
    return {
      restrict: "A",
      controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
        var state, params, activeClass;
        activeClass = $interpolate($attrs.uiSrefActive || "", false)($scope);
        this.$$setStateInfo = function(newState, newParams) {
          state = $state.get(newState, stateContext($element));
          params = newParams;
          update();
        };
        $scope.$on("$stateChangeSuccess", update);
        function update() {
          if ($state.$current.self === state && matchesParams()) {
            $element.addClass(activeClass);
          } else {
            $element.removeClass(activeClass);
          }
        }
        function matchesParams() {
          return !params || equalForKeys(params, $stateParams);
        }
      } ]
    };
  }
  angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateActiveDirective);
  $IsStateFilter.$inject = [ "$state" ];
  function $IsStateFilter($state) {
    return function(state) {
      return $state.is(state);
    };
  }
  $IncludedByStateFilter.$inject = [ "$state" ];
  function $IncludedByStateFilter($state) {
    return function(state) {
      return $state.includes(state);
    };
  }
  angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
  $RouteProvider.$inject = [ "$stateProvider", "$urlRouterProvider" ];
  function $RouteProvider($stateProvider, $urlRouterProvider) {
    var routes = [];
    onEnterRoute.$inject = [ "$$state" ];
    function onEnterRoute($$state) {
      this.locals = $$state.locals.globals;
      this.params = this.locals.$stateParams;
    }
    function onExitRoute() {
      this.locals = null;
      this.params = null;
    }
    this.when = when;
    function when(url, route) {
      if (route.redirectTo != null) {
        var redirect = route.redirectTo, handler;
        if (isString(redirect)) {
          handler = redirect;
        } else if (isFunction(redirect)) {
          handler = function(params, $location) {
            return redirect(params, $location.path(), $location.search());
          };
        } else {
          throw new Error("Invalid 'redirectTo' in when()");
        }
        $urlRouterProvider.when(url, handler);
      } else {
        $stateProvider.state(inherit(route, {
          parent: null,
          name: "route:" + encodeURIComponent(url),
          url: url,
          onEnter: onEnterRoute,
          onExit: onExitRoute
        }));
      }
      routes.push(route);
      return this;
    }
    this.$get = $get;
    $get.$inject = [ "$state", "$rootScope", "$routeParams" ];
    function $get($state, $rootScope, $routeParams) {
      var $route = {
        routes: routes,
        params: $routeParams,
        current: undefined
      };
      function stateAsRoute(state) {
        return state.name !== "" ? state : undefined;
      }
      $rootScope.$on("$stateChangeStart", function(ev, to, toParams, from, fromParams) {
        $rootScope.$broadcast("$routeChangeStart", stateAsRoute(to), stateAsRoute(from));
      });
      $rootScope.$on("$stateChangeSuccess", function(ev, to, toParams, from, fromParams) {
        $route.current = stateAsRoute(to);
        $rootScope.$broadcast("$routeChangeSuccess", stateAsRoute(to), stateAsRoute(from));
        copy(toParams, $route.params);
      });
      $rootScope.$on("$stateChangeError", function(ev, to, toParams, from, fromParams, error) {
        $rootScope.$broadcast("$routeChangeError", stateAsRoute(to), stateAsRoute(from), error);
      });
      return $route;
    }
  }
  angular.module("ui.router.compat").provider("$route", $RouteProvider).directive("ngView", $ViewDirective);
})(window, window.angular);
!function(e) {
  if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else {
    var f;
    "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), 
    f.collide = e();
  }
}(function() {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          throw new Error("Cannot find module '" + o + "'");
        }
        var f = n[o] = {
          exports: {}
        };
        t[o][0].call(f.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, f, f.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
  }({
    1: [ function(_dereq_, module, exports) {
      (function(process) {
        (function() {
          var getNanoSeconds, hrtime, loadTime;
          if (typeof performance !== "undefined" && performance !== null && performance.now) {
            module.exports = function() {
              return performance.now();
            };
          } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
            module.exports = function() {
              return (getNanoSeconds() - loadTime) / 1e6;
            };
            hrtime = process.hrtime;
            getNanoSeconds = function() {
              var hr;
              hr = hrtime();
              return hr[0] * 1e9 + hr[1];
            };
            loadTime = getNanoSeconds();
          } else if (Date.now) {
            module.exports = function() {
              return Date.now() - loadTime;
            };
            loadTime = Date.now();
          } else {
            module.exports = function() {
              return new Date().getTime() - loadTime;
            };
            loadTime = new Date().getTime();
          }
        }).call(this);
      }).call(this, _dereq_("qhDIRT"));
    }, {
      qhDIRT: 13
    } ],
    2: [ function(_dereq_, module, exports) {
      var now = _dereq_("performance-now"), global = typeof window === "undefined" ? {} : window, vendors = [ "moz", "webkit" ], suffix = "AnimationFrame", raf = global["request" + suffix], caf = global["cancel" + suffix] || global["cancelRequest" + suffix];
      for (var i = 0; i < vendors.length && !raf; i++) {
        raf = global[vendors[i] + "Request" + suffix];
        caf = global[vendors[i] + "Cancel" + suffix] || global[vendors[i] + "CancelRequest" + suffix];
      }
      if (!raf || !caf) {
        var last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
        raf = function(callback) {
          if (queue.length === 0) {
            var _now = now(), next = Math.max(0, frameDuration - (_now - last));
            last = next + _now;
            setTimeout(function() {
              var cp = queue.slice(0);
              queue.length = 0;
              for (var i = 0; i < cp.length; i++) {
                if (!cp[i].cancelled) {
                  cp[i].callback(last);
                }
              }
            }, next);
          }
          queue.push({
            handle: ++id,
            callback: callback,
            cancelled: false
          });
          return id;
        };
        caf = function(handle) {
          for (var i = 0; i < queue.length; i++) {
            if (queue[i].handle === handle) {
              queue[i].cancelled = true;
            }
          }
        };
      }
      module.exports = function() {
        return raf.apply(global, arguments);
      };
      module.exports.cancel = function() {
        caf.apply(global, arguments);
      };
    }, {
      "performance-now": 3
    } ],
    3: [ function(_dereq_, module, exports) {
      module.exports = _dereq_(1);
    }, {
      qhDIRT: 13
    } ],
    4: [ function(_dereq_, module, exports) {
      var timeline = _dereq_("./core/timeline");
      var dynamics = _dereq_("./core/dynamics");
      var easingFunctions = _dereq_("./core/easing-functions");
      var uid = _dereq_("./util/uid");
      var EventEmitter = _dereq_("./util/simple-emitter");
      function clamp(min, n, max) {
        return Math.max(min, Math.min(n, max));
      }
      var VELOCITY_MIN = .0075;
      module.exports = Animation;
      function Animation(opts) {
        if (!(this instanceof Animation)) {
          return new Animation(opts);
        }
        var self = this;
        opts = opts || {};
        this._ = {
          id: uid(),
          percent: 0,
          duration: 500,
          reverse: false,
          distance: 100,
          deceleration: .998
        };
        var emitter = this._.emitter = new EventEmitter();
        this._.onDestroy = function() {
          emitter.emit("destroy");
        };
        this._.onStop = function(wasCompleted) {
          emitter.emit("stop", wasCompleted);
          wasCompleted && emitter.emit("complete");
        };
        this._.onStart = function() {
          emitter.emit("start");
        };
        var precision = 1e4;
        this._.onStep = function(v) {
          emitter.emit("step", Math.round(v * precision) / precision);
        };
        opts.duration && this.duration(opts.duration);
        opts.percent && this.percent(opts.percent);
        opts.easing && this.easing(opts.easing);
        opts.reverse && this.reverse(opts.reverse);
        opts.distance && this.distance(opts.distance);
        self._tick = function(deltaT) {
          var state = self._;
          state.onStep(animStepValue(self, state.percent));
          if (Math.abs(state.velocity) < VELOCITY_MIN) {
            state.velocity = 0;
            return self.stop();
          }
          if (state.percent === animEndPercent(self)) {
            return self.stop();
          }
          if (!deltaT) {} else if (state.velocity) {
            var velocity = decayVelocity(state.velocity, deltaT, state.deceleration);
            var currentDistance = state.percent * state.distance;
            state.percent = (currentDistance - velocity) / state.distance;
            if (state.percent > 1 || state.percent < 0) {
              state.percent = clamp(0, state.percent, 1);
              state.velocity = 0;
            }
            state.velocity = velocity;
          } else {
            if (state.reverse) {
              state.percent = state.percent - deltaT / state.duration;
            } else {
              state.percent = state.percent + deltaT / state.duration;
            }
          }
          state.percent = clamp(0, state.percent, 1);
        };
      }
      Animation.prototype = {
        reverse: function(reverse) {
          if (arguments.length) {
            this._.reverse = !!reverse;
            return this;
          }
          return this._.reverse;
        },
        easing: function(easing) {
          var type = typeof easing;
          if (arguments.length) {
            if (type === "function" || type === "string" || type === "object") {
              this._.easing = figureOutEasing(easing);
            }
            return this;
          }
          return this._.easing;
        },
        percent: function(percent, immediate) {
          var self = this;
          if (arguments.length) {
            if (typeof percent === "number") {
              this._.percent = clamp(0, percent, 1);
            }
            if (!this.isRunning()) {
              if (immediate) {
                this._tick();
              } else {
                timeline.tickAction(this._.id, function() {
                  self._tick();
                  timeline.untickAction(self._.id);
                });
              }
            }
            return this;
          }
          return this._.percent;
        },
        distance: function(distance) {
          if (arguments.length) {
            if (typeof distance === "number" && distance > 0) {
              this._.distance = distance;
            }
            return this;
          }
          return this._.distance;
        },
        deceleration: function(deceleration) {
          if (arguments.length) {
            if (typeof deceleration === "number" && deceleration > 0 && deceleration < 1) {
              this._.deceleration = deceleration;
            }
            return this;
          }
          return this._.deceleration;
        },
        duration: function(duration) {
          if (arguments.length) {
            if (typeof duration === "number" && duration > 0) {
              this._.duration = duration;
            }
            return this;
          }
          return this._.duration;
        },
        isRunning: function() {
          return !!this._.isRunning;
        },
        promise: function() {
          var self = this;
          return {
            then: function(cb) {
              self.once("stop", cb);
            }
          };
        },
        on: function(eventType, listener) {
          this._.emitter.on(eventType, listener);
          return this;
        },
        once: function(eventType, listener) {
          this._.emitter.once(eventType, listener);
          return this;
        },
        off: function(eventType, listener) {
          this._.emitter.off(eventType, listener);
          return this;
        },
        destroy: function() {
          this.stop();
          this._.onDestroy();
          this.off();
          return this;
        },
        stop: function() {
          if (!this._.isRunning) return;
          this._.isRunning = false;
          timeline.untickAction(this._.id);
          this._.onStop(animIsComplete(this));
          return this;
        },
        restart: function(immediate) {
          if (this._.isRunning) return;
          this._.percent = animStartPercent(this);
          return this.start(!!immediate);
        },
        start: function(immediate) {
          return animBegin(this, immediate);
        },
        velocity: function(velocity, immediate) {
          this._.velocity = velocity;
          return animBegin(this, immediate);
        }
      };
      function animBegin(animation, immediate) {
        if (immediate) {
          animation._tick();
        }
        animation._.isRunning = true;
        timeline.tickAction(animation._.id, animation._tick);
        animation._.onStart();
        return animation;
      }
      function animIsComplete(animation) {
        return !animation._.isRunning && animation._.percent === animEndPercent(animation);
      }
      function animEndPercent(animation) {
        return animation._.reverse ? 0 : 1;
      }
      function animStartPercent(animation) {
        return animation._.reverse ? 1 : 0;
      }
      function animStepValue(animation, value) {
        if (animation._.easing) {
          return animation._.easing(value, animation._.duration);
        }
        return value;
      }
      function decayVelocity(velocity, dt, deceleration) {
        var kv = Math.pow(deceleration, dt);
        return velocity * kv;
      }
      function figureOutEasing(easing) {
        if (typeof easing === "object") {
          var dynamicType = typeof easing.type === "string" && easing.type.toLowerCase().trim();
          if (!dynamics[dynamicType]) {
            throw new Error('Invalid easing dynamics object type "' + easing.type + '". ' + "Available dynamics types: " + Object.keys(dynamics).join(", ") + ".");
          }
          return dynamics[dynamicType](easing);
        } else if (typeof easing === "string") {
          easing = easing.toLowerCase().trim();
          if (easing.indexOf("cubic-bezier(") === 0) {
            var parts = easing.replace("cubic-bezier(", "").replace(")", "").split(",").map(function(v) {
              return v.trim();
            });
            return easingFunctions["cubic-bezier"](parts[0], parts[1], parts[2], parts[3]);
          } else {
            var fn = easingFunctions[easing];
            if (!fn) {
              throw new Error('Invalid easing function "' + easing + '". ' + "Available easing functions: " + Object.keys(easingFunctions).join(", ") + ".");
            }
            return easingFunctions[easing]();
          }
        } else if (typeof easing === "function") {
          return easing;
        }
      }
    }, {
      "./core/dynamics": 6,
      "./core/easing-functions": 7,
      "./core/timeline": 8,
      "./util/simple-emitter": 11,
      "./util/uid": 12
    } ],
    5: [ function(_dereq_, module, exports) {
      module.exports = {
        linear: unitBezier(0, 0, 1, 1),
        ease: unitBezier(.25, .1, .25, 1),
        easeIn: unitBezier(.42, 0, 1, 1),
        easeOut: unitBezier(0, 0, .58, 1),
        easeInOut: unitBezier(.42, 0, .58, 1),
        cubicBezier: function(p1x, p1y, p2x, p2y) {
          return unitBezier(p1x, p1y, p2x, p2y);
        }
      };
      function B1(t) {
        return t * t * t;
      }
      function B2(t) {
        return 3 * t * t * (1 - t);
      }
      function B3(t) {
        return 3 * t * (1 - t) * (1 - t);
      }
      function B4(t) {
        return (1 - t) * (1 - t) * (1 - t);
      }
      var DEFAULT_DURATION = 400;
      function solveEpsilon(duration) {
        return 1 / (200 * duration);
      }
      function unitBezier(p1x, p1y, p2x, p2y) {
        var cx = 3 * p1x;
        var bx = 3 * (p2x - p1x) - cx;
        var ax = 1 - cx - bx;
        var cy = 3 * p1y;
        var by = 3 * (p2y - p1y) - cy;
        var ay = 1 - cy - by;
        var sampleCurveX = function(t) {
          return ((ax * t + bx) * t + cx) * t;
        };
        var sampleCurveY = function(t) {
          return ((ay * t + by) * t + cy) * t;
        };
        var sampleCurveDerivativeX = function(t) {
          return (3 * ax * t + 2 * bx) * t + cx;
        };
        var solveCurveX = function(x, epsilon) {
          var t0;
          var t1;
          var t2;
          var x2;
          var d2;
          var i;
          for (t2 = x, i = 0; i < 8; i++) {
            x2 = sampleCurveX(t2) - x;
            if (Math.abs(x2) < epsilon) {
              return t2;
            }
            d2 = sampleCurveDerivativeX(t2);
            if (Math.abs(d2) < 1e-6) {
              break;
            }
            t2 = t2 - x2 / d2;
          }
          t0 = 0;
          t1 = 1;
          t2 = x;
          if (t2 < t0) {
            return t0;
          }
          if (t2 > t1) {
            return t1;
          }
          while (t0 < t1) {
            x2 = sampleCurveX(t2);
            if (Math.abs(x2 - x) < epsilon) {
              return t2;
            }
            if (x > x2) {
              t0 = t2;
            } else {
              t1 = t2;
            }
            t2 = (t1 - t0) * .5 + t0;
          }
          return t2;
        };
        var solve = function(x, epsilon) {
          return sampleCurveY(solveCurveX(x, epsilon));
        };
        return function(x, duration) {
          return solve(x, solveEpsilon(+duration || DEFAULT_DURATION));
        };
      }
    }, {} ],
    6: [ function(_dereq_, module, exports) {
      var extend = _dereq_("../util/extend");
      module.exports = {
        spring: dynamicsSpring,
        gravity: dynamicsGravity
      };
      var springDefaults = {
        frequency: 15,
        friction: 200,
        anticipationStrength: 0,
        anticipationSize: 0
      };
      function dynamicsSpring(opts) {
        opts = extend({}, springDefaults, opts || {});
        return function at(t, duration) {
          var A, At, a, angle, b, decal, frequency, friction, frictionT, s, v, y0, yS, _opts = opts;
          frequency = Math.max(1, opts.frequency);
          friction = Math.pow(20, opts.friction / 100);
          s = opts.anticipationSize / 100;
          decal = Math.max(0, s);
          frictionT = t / (1 - s) - s / (1 - s);
          if (t < s) {
            A = function(t) {
              var M, a, b, x0, x1;
              M = .8;
              x0 = s / (1 - s);
              x1 = 0;
              b = (x0 - M * x1) / (x0 - x1);
              a = (M - b) / x0;
              return a * t * _opts.anticipationStrength / 100 + b;
            };
            yS = s / (1 - s) - s / (1 - s);
            y0 = 0 / (1 - s) - s / (1 - s);
            b = Math.acos(1 / A(yS));
            a = (Math.acos(1 / A(y0)) - b) / (frequency * -s);
          } else {
            A = function(t) {
              return Math.pow(friction / 10, -t) * (1 - t);
            };
            b = 0;
            a = 1;
          }
          At = A(frictionT);
          angle = frequency * (t - s) * a + b;
          v = 1 - At * Math.cos(angle);
          return v;
        };
      }
      var gravityDefaults = {
        bounce: 40,
        gravity: 1e3,
        initialForce: false
      };
      function dynamicsGravity(opts) {
        opts = extend({}, gravityDefaults, opts || {});
        var curves = [];
        init();
        return at;
        function length() {
          var L, b, bounce, curve, gravity;
          bounce = Math.min(opts.bounce / 100, 80);
          gravity = opts.gravity / 100;
          b = Math.sqrt(2 / gravity);
          curve = {
            a: -b,
            b: b,
            H: 1
          };
          if (opts.initialForce) {
            curve.a = 0;
            curve.b = curve.b * 2;
          }
          while (curve.H > .001) {
            L = curve.b - curve.a;
            curve = {
              a: curve.b,
              b: curve.b + L * bounce,
              H: curve.H * bounce * bounce
            };
          }
          return curve.b;
        }
        function init() {
          var L, b, bounce, curve, gravity, _results;
          L = length();
          gravity = opts.gravity / 100 * L * L;
          bounce = Math.min(opts.bounce / 100, 80);
          b = Math.sqrt(2 / gravity);
          curves = [];
          curve = {
            a: -b,
            b: b,
            H: 1
          };
          if (opts.initialForce) {
            curve.a = 0;
            curve.b = curve.b * 2;
          }
          curves.push(curve);
          _results = [];
          while (curve.b < 1 && curve.H > .001) {
            L = curve.b - curve.a;
            curve = {
              a: curve.b,
              b: curve.b + L * bounce,
              H: curve.H * bounce * bounce
            };
            _results.push(curves.push(curve));
          }
          return _results;
        }
        function calculateCurve(a, b, H, t) {
          var L, c, t2;
          L = b - a;
          t2 = 2 / L * t - 1 - a * 2 / L;
          c = t2 * t2 * H - H + 1;
          if (opts.initialForce) {
            c = 1 - c;
          }
          return c;
        }
        function at(t, duration) {
          var bounce, curve, gravity, i, v;
          bounce = opts.bounce / 100;
          gravity = opts.gravity;
          i = 0;
          curve = curves[i];
          while (!(t >= curve.a && t <= curve.b)) {
            i += 1;
            curve = curves[i];
            if (!curve) {
              break;
            }
          }
          if (!curve) {
            v = opts.initialForce ? 0 : 1;
          } else {
            v = calculateCurve(curve.a, curve.b, curve.H, t);
          }
          return v;
        }
      }
    }, {
      "../util/extend": 10
    } ],
    7: [ function(_dereq_, module, exports) {
      var dynamics = _dereq_("./dynamics");
      var bezier = _dereq_("./bezier");
      module.exports = {
        linear: function() {
          return function(t, duration) {
            return bezier.linear(t, duration);
          };
        },
        ease: function() {
          return function(t, duration) {
            return bezier.ease(t, duration);
          };
        },
        "ease-in": function() {
          return function(t, duration) {
            return bezier.easeIn(t, duration);
          };
        },
        "ease-out": function() {
          return function(t, duration) {
            return bezier.easeOut(t, duration);
          };
        },
        "ease-in-out": function() {
          return function(t, duration) {
            return bezier.easeInOut(t, duration);
          };
        },
        "cubic-bezier": function(x1, y1, x2, y2, duration) {
          var bz = bezier.cubicBezier(x1, y1, x2, y2);
          return function(t, duration) {
            return bz(t, duration);
          };
        }
      };
    }, {
      "./bezier": 5,
      "./dynamics": 6
    } ],
    8: [ function(_dereq_, module, exports) {
      var raf = _dereq_("raf");
      var time = _dereq_("performance-now");
      var self = module.exports = {
        _actions: {},
        isTicking: false,
        tickAction: function(id, action) {
          self._actions[id] = action;
          if (!self.isTicking) {
            self.tick();
          }
        },
        untickAction: function(id) {
          delete self._actions[id];
          self.maybeStopTicking();
        },
        tick: function() {
          var lastFrame = time();
          self.isTicking = true;
          self._rafId = raf(step);
          function step() {
            self._rafId = raf(step);
            var now = time();
            var deltaT = now - lastFrame;
            for (var id in self._actions) {
              self._actions[id](deltaT);
            }
            lastFrame = now;
          }
        },
        maybeStopTicking: function() {
          if (self.isTicking && !Object.keys(self._actions).length) {
            raf.cancel(self._rafId);
            self.isTicking = false;
          }
        }
      };
    }, {
      "performance-now": 1,
      raf: 2
    } ],
    9: [ function(_dereq_, module, exports) {
      module.exports = {
        animation: _dereq_("./animation")
      };
    }, {
      "./animation": 4
    } ],
    10: [ function(_dereq_, module, exports) {
      module.exports = function extend(obj) {
        var args = Array.prototype.slice.call(arguments, 1);
        for (var i = 0; i < args.length; i++) {
          var source = args[i];
          if (source) {
            for (var prop in source) {
              obj[prop] = source[prop];
            }
          }
        }
        return obj;
      };
    }, {} ],
    11: [ function(_dereq_, module, exports) {
      module.exports = SimpleEventEmitter;
      function SimpleEventEmitter() {
        this.listeners = [];
      }
      SimpleEventEmitter.prototype = {
        on: function(eventType, fn) {
          if (typeof fn !== "function") return;
          this.listeners[eventType] || (this.listeners[eventType] = []);
          this.listeners[eventType].push(fn);
        },
        once: function(eventType, fn) {
          var self = this;
          function onceFn() {
            self.off(eventType, fn);
            self.off(eventType, onceFn);
          }
          this.on(eventType, fn);
          this.on(eventType, onceFn);
        },
        emit: function(eventType, eventArg) {
          var listeners = this.listeners[eventType] || [];
          var i = 0;
          var len = listeners.length;
          if (arguments.length === 2) {
            for (i; i < len; i++) listeners[i] && listeners[i](eventArg);
          } else {
            for (i; i < len; i++) listeners[i] && listeners[i]();
          }
        },
        off: function(eventType, fnToRemove) {
          if (!eventType) {
            for (var type in this.listeners) {
              this.off(type);
            }
          } else {
            var listeners = this.listeners[eventType];
            if (listeners) {
              if (!fnToRemove) {
                listeners.length = 0;
              } else {
                var index = listeners.indexOf(fnToRemove);
                listeners.splice(index, 1);
              }
            }
          }
        }
      };
    }, {} ],
    12: [ function(_dereq_, module, exports) {
      var uid = [];
      module.exports = function nextUid() {
        var index = uid.length;
        var digit;
        while (index) {
          index--;
          digit = uid[index].charCodeAt(0);
          if (digit == 57) {
            uid[index] = "A";
            return uid.join("");
          }
          if (digit == 90) {
            uid[index] = "0";
          } else {
            uid[index] = String.fromCharCode(digit + 1);
            return uid.join("");
          }
        }
        uid.unshift("0");
        return uid.join("");
      };
    }, {} ],
    13: [ function(_dereq_, module, exports) {
      var process = module.exports = {};
      process.nextTick = function() {
        var canSetImmediate = typeof window !== "undefined" && window.setImmediate;
        var canPost = typeof window !== "undefined" && window.postMessage && window.addEventListener;
        if (canSetImmediate) {
          return function(f) {
            return window.setImmediate(f);
          };
        }
        if (canPost) {
          var queue = [];
          window.addEventListener("message", function(ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === "process-tick") {
              ev.stopPropagation();
              if (queue.length > 0) {
                var fn = queue.shift();
                fn();
              }
            }
          }, true);
          return function nextTick(fn) {
            queue.push(fn);
            window.postMessage("process-tick", "*");
          };
        }
        return function nextTick(fn) {
          setTimeout(fn, 0);
        };
      }();
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      function noop() {}
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
    }, {} ]
  }, {}, [ 9 ])(9);
});
(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;
        if (!u && a) return a(o, !0);
        if (i) return i(o, !0);
        throw new Error("Cannot find module '" + o + "'");
      }
      var f = n[o] = {
        exports: {}
      };
      t[o][0].call(f.exports, function(e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, f, f.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var i = typeof require == "function" && require;
  for (var o = 0; o < r.length; o++) s(r[o]);
  return s;
})({
  1: [ function(require, module, exports) {
    var json_parse = require("./json-parse");
    module.exports = LoginError;
    function LoginError(status, details) {
      var obj;
      if (typeof details == "string") {
        try {
          obj = json_parse(details);
        } catch (er) {
          obj = {
            message: details
          };
        }
      } else {
        obj = details || {
          description: "server error"
        };
      }
      if (obj && !obj.code) {
        obj.code = obj.error;
      }
      var err = Error.call(this, obj.description || obj.message || obj.error);
      err.status = status;
      err.name = obj.code;
      err.code = obj.code;
      err.details = obj;
      if (status === 0) {
        err.code = "Unknown";
        err.message = "Unknown error.";
      }
      return err;
    }
    if (Object && Object.create) {
      LoginError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: LoginError
        }
      });
    }
  }, {
    "./json-parse": 6
  } ],
  2: [ function(require, module, exports) {
    module.exports = required;
    function required(obj, prop) {
      if (!obj[prop]) {
        throw new Error(prop + " is required.");
      }
    }
  }, {} ],
  3: [ function(require, module, exports) {
    var Base64 = require("Base64");
    module.exports = base64_url_decode;
    function base64_url_decode(str) {
      var output = str.replace("-", "+").replace("_", "/");
      switch (output.length % 4) {
       case 0:
        break;

       case 2:
        output += "==";
        break;

       case 3:
        output += "=";
        break;

       default:
        throw "Illegal base64url string!";
      }
      return decodeURIComponent(escape(Base64.atob(output)));
    }
  }, {
    Base64: 8
  } ],
  4: [ function(require, module, exports) {
    var global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    var assert_required = require("./assert_required");
    var base64_url_decode = require("./base64_url_decode");
    var is_array = require("./is-array");
    var qs = require("qs");
    var xtend = require("xtend");
    var trim = require("trim");
    var reqwest = require("reqwest");
    var WinChan = require("winchan");
    var jsonp = require("jsonp");
    var jsonpOpts = {
      param: "cbx",
      timeout: 8e3,
      prefix: "__auth0jp"
    };
    var use_jsonp = require("./use_jsonp");
    var LoginError = require("./LoginError");
    var json_parse = require("./json-parse");
    function Auth0(options) {
      if (!(this instanceof Auth0)) {
        return new Auth0(options);
      }
      assert_required(options, "clientID");
      assert_required(options, "domain");
      this._useJSONP = options.forceJSONP || use_jsonp();
      this._clientID = options.clientID;
      this._callbackURL = options.callbackURL || document.location.href;
      this._domain = options.domain;
      this._callbackOnLocationHash = false || options.callbackOnLocationHash;
    }
    Auth0.version = "4.3.0";
    Auth0.prototype._redirect = function(url) {
      global.window.location = url;
    };
    Auth0.prototype._renderAndSubmitWSFedForm = function(options, formHtml) {
      var div = document.createElement("div");
      div.innerHTML = formHtml;
      var form = document.body.appendChild(div).children[0];
      if (options.popup && !this._callbackOnLocationHash) {
        form.target = "auth0_signup_popup";
      }
      form.submit();
    };
    Auth0.prototype._getMode = function() {
      return {
        scope: "openid",
        response_type: this._callbackOnLocationHash ? "token" : "code"
      };
    };
    Auth0.prototype._addOfflineMode = function(options) {
      if (options.offline_mode) {
        if (!options.scope) {
          throw new Error("When adding offline mode, scope should exist in options");
        }
        options.device = options.device || "Browser";
        if (options.scope.indexOf("offline_access") < 0) {
          options.scope += " offline_access";
        }
      }
    };
    Auth0.prototype._getUserInfo = function(profile, id_token, callback) {
      if (profile && !profile.user_id) {
        var self = this;
        var url = "https://" + self._domain + "/tokeninfo?";
        function fail(status, description) {
          var error = new Error(status + ": " + (description || ""));
          error.error = status;
          error.error_description = description;
          callback(error);
        }
        if (this._useJSONP) {
          return jsonp(url + qs.stringify({
            id_token: id_token
          }), jsonpOpts, function(err, resp) {
            if (err) {
              return fail(0, err.toString());
            }
            return resp.status === 200 ? callback(null, resp.user) : fail(resp.status, resp.error);
          });
        }
        return reqwest({
          url: url,
          method: "post",
          type: "json",
          crossOrigin: true,
          data: {
            id_token: id_token
          }
        }).fail(function(err) {
          fail(err.status, err.responseText);
        }).then(function(userinfo) {
          callback(null, userinfo);
        });
      }
      callback(null, profile);
    };
    Auth0.prototype.getProfile = function(id_token, callback) {
      if (!id_token || typeof id_token !== "string") {
        return callback(new Error("Invalid token"));
      }
      this._getUserInfo(this.decodeJwt(id_token), id_token, callback);
    };
    Auth0.prototype.validateUser = function(options, callback) {
      var endpoint = "https://" + this._domain + "/public/api/users/validate_userpassword";
      var query = xtend(options, {
        client_id: this._clientID,
        username: trim(options.username || options.email || "")
      });
      if (this._useJSONP) {
        return jsonp(endpoint + "?" + qs.stringify(query), jsonpOpts, function(err, resp) {
          if (err) {
            return callback(err);
          }
          if ("error" in resp && resp.status !== 404) {
            return callback(new Error(resp.error));
          }
          callback(null, resp.status === 200);
        });
      }
      reqwest({
        url: endpoint,
        method: "post",
        type: "text",
        data: query,
        crossOrigin: true,
        error: function(err) {
          if (err.status !== 404) {
            return callback(new Error(err.responseText));
          }
          callback(null, false);
        },
        success: function(resp) {
          callback(null, resp.status === 200);
        }
      });
    };
    Auth0.prototype.decodeJwt = function(jwt) {
      var encoded = jwt && jwt.split(".")[1];
      return json_parse(base64_url_decode(encoded));
    };
    Auth0.prototype.parseHash = function(hash) {
      hash = hash || window.location.hash;
      if (hash.match(/error/)) {
        hash = hash.substr(1).replace(/^\//, "");
        var parsed_qs = qs.parse(hash);
        var err = {
          error: parsed_qs.error,
          error_description: parsed_qs.error_description
        };
        return err;
      }
      if (!hash.match(/access_token/)) {
        return null;
      }
      hash = hash.substr(1).replace(/^\//, "");
      var parsed_qs = qs.parse(hash);
      var id_token = parsed_qs.id_token;
      var refresh_token = parsed_qs.refresh_token;
      var prof = this.decodeJwt(id_token);
      var invalidJwt = function(error) {
        var err = {
          error: "invalid_token",
          error_description: error
        };
        return err;
      };
      if (prof.aud !== this._clientID) {
        return invalidJwt("The clientID configured (" + this._clientID + ") does not match with the clientID set in the token (" + prof.aud + ").");
      }
      if (prof.iss && prof.iss !== "https://" + this._domain + "/") {
        return invalidJwt("The domain configured (https://" + this._domain + "/) does not match with the domain set in the token (" + prof.iss + ").");
      }
      return {
        profile: prof,
        id_token: id_token,
        access_token: parsed_qs.access_token,
        state: parsed_qs.state,
        refresh_token: refresh_token
      };
    };
    Auth0.prototype.signup = function(options, callback) {
      var self = this;
      var query = xtend(this._getMode(), options, {
        client_id: this._clientID,
        redirect_uri: this._callbackURL,
        email: trim(options.username || options.email || ""),
        tenant: this._domain.split(".")[0]
      });
      this._addOfflineMode(query);
      var popup;
      if (options.popup && !this._callbackOnLocationHash) {
        popup = this._buildPopupWindow(options);
      }
      function success() {
        if ("auto_login" in options && !options.auto_login) {
          if (callback) {
            callback();
          }
          return;
        }
        self.login(options, callback);
      }
      function fail(status, resp) {
        var error = new LoginError(status, resp);
        if (popup) {
          popup.kill();
        }
        if (callback) {
          return callback(error);
        }
        throw error;
      }
      if (this._useJSONP) {
        return jsonp("https://" + this._domain + "/dbconnections/signup?" + qs.stringify(query), jsonpOpts, function(err, resp) {
          if (err) {
            return fail(0, err);
          }
          return resp.status == 200 ? success() : fail(resp.status, resp.err);
        });
      }
      reqwest({
        url: "https://" + this._domain + "/dbconnections/signup",
        method: "post",
        type: "html",
        data: query,
        success: success,
        crossOrigin: true,
        error: function(err) {
          fail(err.status, err.responseText);
        }
      });
    };
    Auth0.prototype.changePassword = function(options, callback) {
      var self = this;
      var query = {
        tenant: this._domain.split(".")[0],
        client_id: this._clientID,
        connection: options.connection,
        email: trim(options.username || options.email || ""),
        password: options.password
      };
      function fail(status, resp) {
        var error = new LoginError(status, resp);
        if (callback) return callback(error);
      }
      if (this._useJSONP) {
        return jsonp("https://" + this._domain + "/dbconnections/change_password?" + qs.stringify(query), jsonpOpts, function(err, resp) {
          if (err) {
            return fail(0, err);
          }
          return resp.status == 200 ? callback(null, resp.message) : fail(resp.status, resp.err);
        });
      }
      reqwest({
        url: "https://" + this._domain + "/dbconnections/change_password",
        method: "post",
        type: "html",
        data: query,
        crossOrigin: true,
        error: function(err) {
          fail(err.status, err.responseText);
        },
        success: function(r) {
          callback(null, r);
        }
      });
    };
    Auth0.prototype._buildAuthorizeQueryString = function(args, blacklist) {
      var query = xtend.apply(null, args);
      this._addOfflineMode(query);
      blacklist = blacklist || [ "popup", "popupOptions" ];
      blacklist.push("offline_mode");
      var i, key;
      for (i = 0; i < blacklist.length; i++) {
        key = blacklist[i];
        delete query[key];
      }
      if (query.connection_scope && is_array(query.connection_scope)) {
        query.connection_scope = query.connection_scope.join(",");
      }
      return qs.stringify(query);
    };
    Auth0.prototype.login = Auth0.prototype.signin = function(options, callback) {
      if (typeof options.username !== "undefined" || typeof options.email !== "undefined") {
        return this.loginWithUsernamePassword(options, callback);
      }
      if (!!window.cordova) {
        return this.loginPhonegap(options, callback);
      }
      if (!!options.popup && this._callbackOnLocationHash) {
        return this.loginWithPopup(options, callback);
      }
      var query = this._buildAuthorizeQueryString([ this._getMode(), options, {
        client_id: this._clientID,
        redirect_uri: this._callbackURL
      } ]);
      var url = "https://" + this._domain + "/authorize?" + query;
      if (options.popup) {
        this._buildPopupWindow(options, url);
      } else {
        this._redirect(url);
      }
    };
    Auth0.prototype._computePopupPosition = function(options) {
      var width = options.width;
      var height = options.height;
      var screenX = typeof window.screenX !== "undefined" ? window.screenX : window.screenLeft;
      var screenY = typeof window.screenY !== "undefined" ? window.screenY : window.screenTop;
      var outerWidth = typeof window.outerWidth !== "undefined" ? window.outerWidth : document.body.clientWidth;
      var outerHeight = typeof window.outerHeight !== "undefined" ? window.outerHeight : document.body.clientHeight - 22;
      var left = screenX + (outerWidth - width) / 2;
      var top = screenY + (outerHeight - height) / 2;
      return {
        width: width,
        height: height,
        left: left,
        top: top
      };
    };
    Auth0.prototype.loginPhonegap = function(options, callback) {
      var mobileCallbackURL = "https://" + this._domain + "/mobile";
      var self = this;
      var query = this._buildAuthorizeQueryString([ this._getMode(), options, {
        client_id: this._clientID,
        redirect_uri: mobileCallbackURL
      } ]);
      var popupUrl = "https://" + this._domain + "/authorize?" + query;
      var popupOptions = xtend({
        location: "yes"
      }, options.popupOptions);
      delete popupOptions.width;
      delete popupOptions.height;
      var ref = window.open(popupUrl, "_blank", stringifyPopupSettings(popupOptions));
      var answered = false;
      function errorHandler(event) {
        if (answered) {
          return;
        }
        callback(new Error(event.message), null, null, null, null);
        answered = true;
        return ref.close();
      }
      function startHandler(event) {
        if (answered) {
          return;
        }
        if (event.url && !(event.url.indexOf(mobileCallbackURL + "#") === 0 || event.url.indexOf(mobileCallbackURL + "?") === 0)) {
          return;
        }
        var result = self.parseHash(event.url.slice(mobileCallbackURL.length));
        if (!result) {
          callback(new Error("Error parsing hash"), null, null, null, null);
          answered = true;
          return ref.close();
        }
        if (result.id_token) {
          self.getProfile(result.id_token, function(err, profile) {
            callback(err, profile, result.id_token, result.access_token, result.state, result.refresh_token);
          });
          answered = true;
          return ref.close();
        }
        callback(new Error(result.err || result.error || "Something went wrong"), null, null, null, null);
        answered = true;
        return ref.close();
      }
      function exitHandler() {
        if (answered) {
          return;
        }
        callback(new Error("Browser window closed"), null, null, null, null);
        ref.removeEventListener("loaderror", errorHandler);
        ref.removeEventListener("loadstart", startHandler);
        ref.removeEventListener("exit", exitHandler);
      }
      ref.addEventListener("loaderror", errorHandler);
      ref.addEventListener("loadstart", startHandler);
      ref.addEventListener("exit", exitHandler);
    };
    Auth0.prototype.loginWithPopup = function(options, callback) {
      var self = this;
      if (!callback) {
        throw new Error("popup mode should receive a mandatory callback");
      }
      var query = this._buildAuthorizeQueryString([ this._getMode(), options, {
        client_id: this._clientID,
        owp: true
      } ]);
      var popupUrl = "https://" + this._domain + "/authorize?" + query;
      var popupOptions = xtend(self._computePopupPosition({
        width: options.popupOptions && options.popupOptions.width || 500,
        height: options.popupOptions && options.popupOptions.height || 600
      }), options.popupOptions);
      var popup = WinChan.open({
        url: popupUrl,
        relay_url: "https://" + this._domain + "/relay.html",
        window_features: stringifyPopupSettings(popupOptions)
      }, function(err, result) {
        if (err) {
          return callback(new Error(err), null, null, null, null, null);
        }
        if (result && result.id_token) {
          return self.getProfile(result.id_token, function(err, profile) {
            callback(err, profile, result.id_token, result.access_token, result.state, result.refresh_token);
          });
        }
        return callback(new Error(result ? result.err : "Something went wrong"), null, null, null, null, null);
      });
      popup.focus();
    };
    function stringifyPopupSettings(popupOptions) {
      var settings = "";
      for (var key in popupOptions) {
        settings += key + "=" + popupOptions[key] + ",";
      }
      return settings.slice(0, -1);
    }
    Auth0.prototype.loginWithResourceOwner = function(options, callback) {
      var self = this;
      var query = xtend(this._getMode(), options, {
        client_id: this._clientID,
        username: trim(options.username || options.email || ""),
        grant_type: "password"
      });
      this._addOfflineMode(query);
      var endpoint = "/oauth/ro";
      function enrichGetProfile(resp, callback) {
        self.getProfile(resp.id_token, function(err, profile) {
          callback(err, profile, resp.id_token, resp.access_token, resp.state, resp.refresh_token);
        });
      }
      if (this._useJSONP) {
        return jsonp("https://" + this._domain + endpoint + "?" + qs.stringify(query), jsonpOpts, function(err, resp) {
          if (err) {
            return callback(err);
          }
          if ("error" in resp) {
            var error = new LoginError(resp.status, resp.error);
            return callback(error);
          }
          enrichGetProfile(resp, callback);
        });
      }
      reqwest({
        url: "https://" + this._domain + endpoint,
        method: "post",
        type: "json",
        data: query,
        crossOrigin: true,
        success: function(resp) {
          enrichGetProfile(resp, callback);
        },
        error: function(err) {
          var er = err;
          if (!er.status || er.status === 0) {
            er = {};
            er.status = 401;
            er.responseText = {
              code: "invalid_user_password"
            };
          } else {
            er.responseText = err;
          }
          var error = new LoginError(er.status, er.responseText);
          callback(error);
        }
      });
    };
    Auth0.prototype._buildPopupWindow = function(options, url) {
      if (this._current_popup) {
        return this._current_popup;
      }
      var popupOptions = stringifyPopupSettings(xtend({
        width: 500,
        height: 600
      }, options.popupOptions || {}));
      this._current_popup = window.open(url || "about:blank", "auth0_signup_popup", popupOptions);
      var self = this;
      this._current_popup.kill = function() {
        this.close();
        delete self._current_popup;
      };
      return this._current_popup;
    };
    Auth0.prototype.loginWithUsernamePassword = function(options, callback) {
      if (callback && callback.length > 1) {
        return this.loginWithResourceOwner(options, callback);
      }
      var self = this;
      var popup;
      if (options.popup && !this._callbackOnLocationHash) {
        popup = this._buildPopupWindow(options);
      }
      var query = xtend(this._getMode(), options, {
        client_id: this._clientID,
        redirect_uri: this._callbackURL,
        username: trim(options.username || options.email || ""),
        tenant: this._domain.split(".")[0]
      });
      this._addOfflineMode(query);
      var endpoint = "/usernamepassword/login";
      if (this._useJSONP) {
        return jsonp("https://" + this._domain + endpoint + "?" + qs.stringify(query), jsonpOpts, function(err, resp) {
          if (err) {
            if (popup) {
              popup.kill();
            }
            return callback(err);
          }
          if ("error" in resp) {
            if (popup) {
              popup.kill();
            }
            var error = new LoginError(resp.status, resp.error);
            return callback(error);
          }
          self._renderAndSubmitWSFedForm(options, resp.form);
        });
      }
      function return_error(error) {
        if (callback) {
          return callback(error);
        }
        throw error;
      }
      reqwest({
        url: "https://" + this._domain + endpoint,
        method: "post",
        type: "html",
        data: query,
        crossOrigin: true,
        success: function(resp) {
          self._renderAndSubmitWSFedForm(options, resp);
        },
        error: function(err) {
          var er = err;
          if (popup) {
            popup.kill();
          }
          if (!er.status || er.status === 0) {
            er = {};
            er.status = 401;
            er.responseText = {
              code: "invalid_user_password"
            };
          }
          var error = new LoginError(er.status, er.responseText);
          return return_error(error);
        }
      });
    };
    Auth0.prototype.renewIdToken = function(id_token, callback) {
      this.getDelegationToken({
        id_token: id_token,
        scope: "passthrough",
        api: "auth0"
      }, callback);
    };
    Auth0.prototype.refreshToken = function(refresh_token, callback) {
      this.getDelegationToken({
        refresh_token: refresh_token,
        api: "auth0"
      }, callback);
    };
    Auth0.prototype.getDelegationToken = function(options, callback) {
      options = options || {};
      if (!options.id_token && !options.refresh_token) {
        throw new Error("You must send either an id_token or a refresh_token to do this call");
      }
      var query = xtend({
        grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
        client_id: this._clientID,
        target: options.targetClientId || this._clientID,
        api_type: options.api
      }, options);
      delete query.hasOwnProperty;
      delete query.targetClientId;
      delete query.api;
      var endpoint = "/delegation";
      if (this._useJSONP) {
        return jsonp("https://" + this._domain + endpoint + "?" + qs.stringify(query), jsonpOpts, function(err, resp) {
          if (err) {
            return callback(err);
          }
          if ("error" in resp) {
            var error = new LoginError(resp.status, resp.error_description || resp.error);
            return callback(error);
          }
          callback(null, resp);
        });
      }
      reqwest({
        url: "https://" + this._domain + endpoint,
        method: "post",
        type: "json",
        data: query,
        crossOrigin: true,
        success: function(resp) {
          callback(null, resp);
        },
        error: function(err) {
          try {
            callback(JSON.parse(err.responseText));
          } catch (e) {
            var er = err;
            if (!er.status || er.status === 0) {
              er = {};
              er.status = 401;
              er.responseText = {
                code: "invalid_operation"
              };
            }
            callback(new LoginError(er.status, er.responseText));
          }
        }
      });
    };
    Auth0.prototype.logout = function(query) {
      var url = "https://" + this._domain + "/logout";
      if (query) {
        url += "?" + qs.stringify(query);
      }
      this._redirect(url);
    };
    Auth0.prototype.getSSOData = function(withActiveDirectories, callback) {
      if (typeof withActiveDirectories === "function") {
        callback = withActiveDirectories;
        withActiveDirectories = false;
      }
      var url = "https://" + this._domain + "/user/ssodata";
      if (withActiveDirectories) {
        url += "?" + qs.stringify({
          ldaps: 1,
          client_id: this._clientID
        });
      }
      var jsonpOptions = xtend({}, jsonpOpts, {
        timeout: 3e3
      });
      return jsonp(url, jsonpOptions, function(err, resp) {
        callback(null, err ? {
          sso: false
        } : resp);
      });
    };
    Auth0.prototype.getConnections = function(callback) {
      return jsonp("https://" + this._domain + "/public/api/" + this._clientID + "/connections", jsonpOpts, callback);
    };
    module.exports = Auth0;
  }, {
    "./LoginError": 1,
    "./assert_required": 2,
    "./base64_url_decode": 3,
    "./is-array": 5,
    "./json-parse": 6,
    "./use_jsonp": 7,
    jsonp: 13,
    qs: 14,
    reqwest: 15,
    trim: 16,
    winchan: 17,
    xtend: 19
  } ],
  5: [ function(require, module, exports) {
    var toString = Object.prototype.toString;
    module.exports = null != Array.isArray ? Array.isArray : isArray;
    function isArray(array) {
      return toString.call(array) === "[object Array]";
    }
  }, {} ],
  6: [ function(require, module, exports) {
    module.exports = "undefined" === typeof window.JSON ? require("json-fallback").parse : window.JSON.parse;
  }, {
    "json-fallback": 12
  } ],
  7: [ function(require, module, exports) {
    module.exports = use_jsonp;
    function use_jsonp() {
      var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : null;
      if (xhr && "withCredentials" in xhr) {
        return false;
      }
      return true;
    }
  }, {} ],
  8: [ function(require, module, exports) {
    (function() {
      var object = typeof exports != "undefined" ? exports : this, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", INVALID_CHARACTER_ERR = function() {
        try {
          document.createElement("$");
        } catch (error) {
          return error;
        }
      }();
      object.btoa || (object.btoa = function(input) {
        for (var block, charCode, idx = 0, map = chars, output = ""; input.charAt(idx | 0) || (map = "=", 
        idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
          charCode = input.charCodeAt(idx += 3 / 4);
          if (charCode > 255) throw INVALID_CHARACTER_ERR;
          block = block << 8 | charCode;
        }
        return output;
      });
      object.atob || (object.atob = function(input) {
        input = input.replace(/=+$/, "");
        if (input.length % 4 == 1) throw INVALID_CHARACTER_ERR;
        for (var bc = 0, bs, buffer, idx = 0, output = ""; buffer = input.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, 
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
          buffer = chars.indexOf(buffer);
        }
        return output;
      });
    })();
  }, {} ],
  9: [ function(require, module, exports) {
    exports = module.exports = require("./debug");
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [ "lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson" ];
    function useColors() {
      return "WebkitAppearance" in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
    }
    exports.formatters.j = function(v) {
      return JSON.stringify(v);
    };
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors) return args;
      var c = "color: " + this.color;
      args = [ args[0], c, "color: inherit" ].concat(Array.prototype.slice.call(args, 1));
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-z%]/g, function(match) {
        if ("%%" === match) return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
      return args;
    }
    function log() {
      return "object" == typeof console && "function" == typeof console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          localStorage.removeItem("debug");
        } else {
          localStorage.debug = namespaces;
        }
      } catch (e) {}
    }
    function load() {
      var r;
      try {
        r = localStorage.debug;
      } catch (e) {}
      return r;
    }
    exports.enable(load());
  }, {
    "./debug": 10
  } ],
  10: [ function(require, module, exports) {
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require("ms");
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevColor = 0;
    var prevTime;
    function selectColor() {
      return exports.colors[prevColor++ % exports.colors.length];
    }
    function debug(namespace) {
      function disabled() {}
      disabled.enabled = false;
      function enabled() {
        var self = enabled;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        if (null == self.useColors) self.useColors = exports.useColors();
        if (null == self.color && self.useColors) self.color = selectColor();
        var args = Array.prototype.slice.call(arguments);
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args = [ "%o" ].concat(args);
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
          if (match === "%%") return match;
          index++;
          var formatter = exports.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        if ("function" === typeof exports.formatArgs) {
          args = exports.formatArgs.apply(self, args);
        }
        var logFn = enabled.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      enabled.enabled = true;
      var fn = exports.enabled(namespace) ? enabled : disabled;
      fn.namespace = namespace;
      return fn;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      var split = (namespaces || "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  }, {
    ms: 11
  } ],
  11: [ function(require, module, exports) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      if ("string" == typeof val) return parse(val);
      return options.long ? long(val) : short(val);
    };
    function parse(str) {
      var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
       case "years":
       case "year":
       case "y":
        return n * y;

       case "days":
       case "day":
       case "d":
        return n * d;

       case "hours":
       case "hour":
       case "h":
        return n * h;

       case "minutes":
       case "minute":
       case "m":
        return n * m;

       case "seconds":
       case "second":
       case "s":
        return n * s;

       case "ms":
        return n;
      }
    }
    function short(ms) {
      if (ms >= d) return Math.round(ms / d) + "d";
      if (ms >= h) return Math.round(ms / h) + "h";
      if (ms >= m) return Math.round(ms / m) + "m";
      if (ms >= s) return Math.round(ms / s) + "s";
      return ms + "ms";
    }
    function long(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < n * 1.5) return Math.floor(ms / n) + " " + name;
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }, {} ],
  12: [ function(require, module, exports) {
    var JSON = {};
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      if (typeof Date.prototype.toJSON !== "function") {
        Date.prototype.toJSON = function(key) {
          return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
        };
        String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function(key) {
          return this.valueOf();
        };
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key];
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
         case "string":
          return quote(value);

         case "number":
          return isFinite(value) ? String(value) : "null";

         case "boolean":
         case "null":
          return String(value);

         case "object":
          if (!value) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i = 0; i < length; i += 1) {
              partial[i] = str(i, value) || "null";
            }
            v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i = 0; i < length; i += 1) {
              if (typeof rep[i] === "string") {
                k = rep[i];
                v = str(k, value);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          } else {
            for (k in value) {
              if (Object.prototype.hasOwnProperty.call(value, k)) {
                v = str(k, value);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          }
          v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v;
        }
      }
      if (typeof JSON.stringify !== "function") {
        JSON.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", {
            "": value
          });
        };
      }
      if (typeof JSON.parse !== "function") {
        JSON.parse = function(text, reviver) {
          var j;
          function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && typeof value === "object") {
              for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                  v = walk(value, k);
                  if (v !== undefined) {
                    value[k] = v;
                  } else {
                    delete value[k];
                  }
                }
              }
            }
            return reviver.call(holder, key, value);
          }
          text = String(text);
          cx.lastIndex = 0;
          if (cx.test(text)) {
            text = text.replace(cx, function(a) {
              return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            });
          }
          if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) {
            j = eval("(" + text + ")");
            return typeof reviver === "function" ? walk({
              "": j
            }, "") : j;
          }
          throw new SyntaxError("JSON.parse");
        };
      }
    })();
    module.exports = JSON;
  }, {} ],
  13: [ function(require, module, exports) {
    var debug = require("debug")("jsonp");
    module.exports = jsonp;
    var count = 0;
    function noop() {}
    function jsonp(url, opts, fn) {
      if ("function" == typeof opts) {
        fn = opts;
        opts = {};
      }
      if (!opts) opts = {};
      var prefix = opts.prefix || "__jp";
      var param = opts.param || "callback";
      var timeout = null != opts.timeout ? opts.timeout : 6e4;
      var enc = encodeURIComponent;
      var target = document.getElementsByTagName("script")[0] || document.head;
      var script;
      var timer;
      var id = prefix + count++;
      if (timeout) {
        timer = setTimeout(function() {
          cleanup();
          if (fn) fn(new Error("Timeout"));
        }, timeout);
      }
      function cleanup() {
        script.parentNode.removeChild(script);
        window[id] = noop;
      }
      window[id] = function(data) {
        debug("jsonp got", data);
        if (timer) clearTimeout(timer);
        cleanup();
        if (fn) fn(null, data);
      };
      url += (~url.indexOf("?") ? "&" : "?") + param + "=" + enc(id);
      url = url.replace("?&", "?");
      debug('jsonp req "%s"', url);
      script = document.createElement("script");
      script.src = url;
      target.parentNode.insertBefore(script, target);
    }
  }, {
    debug: 9
  } ],
  14: [ function(require, module, exports) {
    var toString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var indexOf = typeof Array.prototype.indexOf === "function" ? function(arr, el) {
      return arr.indexOf(el);
    } : function(arr, el) {
      if (typeof arr == "string" && typeof "a"[0] == "undefined") {
        arr = arr.split("");
      }
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };
    var isArray = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    var objectKeys = Object.keys || function(obj) {
      var ret = [];
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          ret.push(key);
        }
      }
      return ret;
    };
    var forEach = typeof Array.prototype.forEach === "function" ? function(arr, fn) {
      return arr.forEach(fn);
    } : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };
    var reduce = function(arr, fn, initial) {
      if (typeof arr.reduce === "function") return arr.reduce(fn, initial);
      var res = initial;
      for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
      return res;
    };
    var isint = /^[0-9]+$/;
    function promote(parent, key) {
      if (parent[key].length == 0) return parent[key] = {};
      var t = {};
      for (var i in parent[key]) {
        if (hasOwnProperty.call(parent[key], i)) {
          t[i] = parent[key][i];
        }
      }
      parent[key] = t;
      return t;
    }
    function parse(parts, parent, key, val) {
      var part = parts.shift();
      if (hasOwnProperty.call(Object.prototype, key)) return;
      if (!part) {
        if (isArray(parent[key])) {
          parent[key].push(val);
        } else if ("object" == typeof parent[key]) {
          parent[key] = val;
        } else if ("undefined" == typeof parent[key]) {
          parent[key] = val;
        } else {
          parent[key] = [ parent[key], val ];
        }
      } else {
        var obj = parent[key] = parent[key] || [];
        if ("]" == part) {
          if (isArray(obj)) {
            if ("" != val) obj.push(val);
          } else if ("object" == typeof obj) {
            obj[objectKeys(obj).length] = val;
          } else {
            obj = parent[key] = [ parent[key], val ];
          }
        } else if (~indexOf(part, "]")) {
          part = part.substr(0, part.length - 1);
          if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
          parse(parts, obj, part, val);
        } else {
          if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
          parse(parts, obj, part, val);
        }
      }
    }
    function merge(parent, key, val) {
      if (~indexOf(key, "]")) {
        var parts = key.split("["), len = parts.length, last = len - 1;
        parse(parts, parent, "base", val);
      } else {
        if (!isint.test(key) && isArray(parent.base)) {
          var t = {};
          for (var k in parent.base) t[k] = parent.base[k];
          parent.base = t;
        }
        set(parent.base, key, val);
      }
      return parent;
    }
    function compact(obj) {
      if ("object" != typeof obj) return obj;
      if (isArray(obj)) {
        var ret = [];
        for (var i in obj) {
          if (hasOwnProperty.call(obj, i)) {
            ret.push(obj[i]);
          }
        }
        return ret;
      }
      for (var key in obj) {
        obj[key] = compact(obj[key]);
      }
      return obj;
    }
    function parseObject(obj) {
      var ret = {
        base: {}
      };
      forEach(objectKeys(obj), function(name) {
        merge(ret, name, obj[name]);
      });
      return compact(ret.base);
    }
    function parseString(str, options) {
      var ret = reduce(String(str).split(options.separator), function(ret, pair) {
        var eql = indexOf(pair, "="), brace = lastBraceInKey(pair), key = pair.substr(0, brace || eql), val = pair.substr(brace || eql, pair.length), val = val.substr(indexOf(val, "=") + 1, val.length);
        if ("" == key) key = pair, val = "";
        if ("" == key) return ret;
        return merge(ret, decode(key), decode(val));
      }, {
        base: {}
      }).base;
      return compact(ret);
    }
    exports.parse = function(str, options) {
      if (null == str || "" == str) return {};
      options = options || {};
      options.separator = options.separator || "&";
      return "object" == typeof str ? parseObject(str) : parseString(str, options);
    };
    var stringify = exports.stringify = function(obj, prefix) {
      if (isArray(obj)) {
        return stringifyArray(obj, prefix);
      } else if ("[object Object]" == toString.call(obj)) {
        return stringifyObject(obj, prefix);
      } else if ("string" == typeof obj) {
        return stringifyString(obj, prefix);
      } else {
        return prefix + "=" + encodeURIComponent(String(obj));
      }
    };
    function stringifyString(str, prefix) {
      if (!prefix) throw new TypeError("stringify expects an object");
      return prefix + "=" + encodeURIComponent(str);
    }
    function stringifyArray(arr, prefix) {
      var ret = [];
      if (!prefix) throw new TypeError("stringify expects an object");
      for (var i = 0; i < arr.length; i++) {
        ret.push(stringify(arr[i], prefix + "[" + i + "]"));
      }
      return ret.join("&");
    }
    function stringifyObject(obj, prefix) {
      var ret = [], keys = objectKeys(obj), key;
      for (var i = 0, len = keys.length; i < len; ++i) {
        key = keys[i];
        if ("" == key) continue;
        if (null == obj[key]) {
          ret.push(encodeURIComponent(key) + "=");
        } else {
          ret.push(stringify(obj[key], prefix ? prefix + "[" + encodeURIComponent(key) + "]" : encodeURIComponent(key)));
        }
      }
      return ret.join("&");
    }
    function set(obj, key, val) {
      var v = obj[key];
      if (hasOwnProperty.call(Object.prototype, key)) return;
      if (undefined === v) {
        obj[key] = val;
      } else if (isArray(v)) {
        v.push(val);
      } else {
        obj[key] = [ v, val ];
      }
    }
    function lastBraceInKey(str) {
      var len = str.length, brace, c;
      for (var i = 0; i < len; ++i) {
        c = str[i];
        if ("]" == c) brace = false;
        if ("[" == c) brace = true;
        if ("=" == c && !brace) return i;
      }
    }
    function decode(str) {
      try {
        return decodeURIComponent(str.replace(/\+/g, " "));
      } catch (err) {
        return str;
      }
    }
  }, {} ],
  15: [ function(require, module, exports) {
    !function(name, context, definition) {
      if (typeof module != "undefined" && module.exports) module.exports = definition(); else if (typeof define == "function" && define.amd) define(definition); else context[name] = definition();
    }("reqwest", this, function() {
      var win = window, doc = document, httpsRe = /^http/, protocolRe = /(^\w+):\/\//, twoHundo = /^(20\d|1223)$/, byTag = "getElementsByTagName", readyState = "readyState", contentType = "Content-Type", requestedWith = "X-Requested-With", head = doc[byTag]("head")[0], uniqid = 0, callbackPrefix = "reqwest_" + +new Date(), lastValue, xmlHttpRequest = "XMLHttpRequest", xDomainRequest = "XDomainRequest", noop = function() {}, isArray = typeof Array.isArray == "function" ? Array.isArray : function(a) {
        return a instanceof Array;
      }, defaultHeaders = {
        contentType: "application/x-www-form-urlencoded",
        requestedWith: xmlHttpRequest,
        accept: {
          "*": "text/javascript, text/html, application/xml, text/xml, */*",
          xml: "application/xml, text/xml",
          html: "text/html",
          text: "text/plain",
          json: "application/json, text/javascript",
          js: "application/javascript, text/javascript"
        }
      }, xhr = function(o) {
        if (o["crossOrigin"] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;
          if (xhr && "withCredentials" in xhr) {
            return xhr;
          } else if (win[xDomainRequest]) {
            return new XDomainRequest();
          } else {
            throw new Error("Browser does not support cross-origin requests");
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest();
        } else {
          return new ActiveXObject("Microsoft.XMLHTTP");
        }
      }, globalSetupOptions = {
        dataFilter: function(data) {
          return data;
        }
      };
      function succeed(r) {
        var protocol = protocolRe.exec(r.url);
        protocol = protocol && protocol[1] || window.location.protocol;
        return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response;
      }
      function handleReadyState(r, success, error) {
        return function() {
          if (r._aborted) return error(r.request);
          if (r.request && r.request[readyState] == 4) {
            r.request.onreadystatechange = noop;
            if (succeed(r)) success(r.request); else error(r.request);
          }
        };
      }
      function setHeaders(http, o) {
        var headers = o["headers"] || {}, h;
        headers["Accept"] = headers["Accept"] || defaultHeaders["accept"][o["type"]] || defaultHeaders["accept"]["*"];
        var isAFormData = typeof FormData === "function" && o["data"] instanceof FormData;
        if (!o["crossOrigin"] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders["requestedWith"];
        if (!headers[contentType] && !isAFormData) headers[contentType] = o["contentType"] || defaultHeaders["contentType"];
        for (h in headers) headers.hasOwnProperty(h) && "setRequestHeader" in http && http.setRequestHeader(h, headers[h]);
      }
      function setCredentials(http, o) {
        if (typeof o["withCredentials"] !== "undefined" && typeof http.withCredentials !== "undefined") {
          http.withCredentials = !!o["withCredentials"];
        }
      }
      function generalCallback(data) {
        lastValue = data;
      }
      function urlappend(url, s) {
        return url + (/\?/.test(url) ? "&" : "?") + s;
      }
      function handleJsonp(o, fn, err, url) {
        var reqId = uniqid++, cbkey = o["jsonpCallback"] || "callback", cbval = o["jsonpCallbackName"] || reqwest.getcallbackPrefix(reqId), cbreg = new RegExp("((^|\\?|&)" + cbkey + ")=([^&]+)"), match = url.match(cbreg), script = doc.createElement("script"), loaded = 0, isIE10 = navigator.userAgent.indexOf("MSIE 10.0") !== -1;
        if (match) {
          if (match[3] === "?") {
            url = url.replace(cbreg, "$1=" + cbval);
          } else {
            cbval = match[3];
          }
        } else {
          url = urlappend(url, cbkey + "=" + cbval);
        }
        win[cbval] = generalCallback;
        script.type = "text/javascript";
        script.src = url;
        script.async = true;
        if (typeof script.onreadystatechange !== "undefined" && !isIE10) {
          script.htmlFor = script.id = "_reqwest_" + reqId;
        }
        script.onload = script.onreadystatechange = function() {
          if (script[readyState] && script[readyState] !== "complete" && script[readyState] !== "loaded" || loaded) {
            return false;
          }
          script.onload = script.onreadystatechange = null;
          script.onclick && script.onclick();
          fn(lastValue);
          lastValue = undefined;
          head.removeChild(script);
          loaded = 1;
        };
        head.appendChild(script);
        return {
          abort: function() {
            script.onload = script.onreadystatechange = null;
            err({}, "Request is aborted: timeout", {});
            lastValue = undefined;
            head.removeChild(script);
            loaded = 1;
          }
        };
      }
      function getRequest(fn, err) {
        var o = this.o, method = (o["method"] || "GET").toUpperCase(), url = typeof o === "string" ? o : o["url"], data = o["processData"] !== false && o["data"] && typeof o["data"] !== "string" ? reqwest.toQueryString(o["data"]) : o["data"] || null, http, sendWait = false;
        if ((o["type"] == "jsonp" || method == "GET") && data) {
          url = urlappend(url, data);
          data = null;
        }
        if (o["type"] == "jsonp") return handleJsonp(o, fn, err, url);
        http = o.xhr && o.xhr(o) || xhr(o);
        http.open(method, url, o["async"] === false ? false : true);
        setHeaders(http, o);
        setCredentials(http, o);
        if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
          http.onload = fn;
          http.onerror = err;
          http.onprogress = function() {};
          sendWait = true;
        } else {
          http.onreadystatechange = handleReadyState(this, fn, err);
        }
        o["before"] && o["before"](http);
        if (sendWait) {
          setTimeout(function() {
            http.send(data);
          }, 200);
        } else {
          http.send(data);
        }
        return http;
      }
      function Reqwest(o, fn) {
        this.o = o;
        this.fn = fn;
        init.apply(this, arguments);
      }
      function setType(header) {
        if (header.match("json")) return "json";
        if (header.match("javascript")) return "js";
        if (header.match("text")) return "html";
        if (header.match("xml")) return "xml";
      }
      function init(o, fn) {
        this.url = typeof o == "string" ? o : o["url"];
        this.timeout = null;
        this._fulfilled = false;
        this._successHandler = function() {};
        this._fulfillmentHandlers = [];
        this._errorHandlers = [];
        this._completeHandlers = [];
        this._erred = false;
        this._responseArgs = {};
        var self = this;
        fn = fn || function() {};
        if (o["timeout"]) {
          this.timeout = setTimeout(function() {
            self.abort();
          }, o["timeout"]);
        }
        if (o["success"]) {
          this._successHandler = function() {
            o["success"].apply(o, arguments);
          };
        }
        if (o["error"]) {
          this._errorHandlers.push(function() {
            o["error"].apply(o, arguments);
          });
        }
        if (o["complete"]) {
          this._completeHandlers.push(function() {
            o["complete"].apply(o, arguments);
          });
        }
        function complete(resp) {
          o["timeout"] && clearTimeout(self.timeout);
          self.timeout = null;
          while (self._completeHandlers.length > 0) {
            self._completeHandlers.shift()(resp);
          }
        }
        function success(resp) {
          var type = o["type"] || resp && setType(resp.getResponseHeader("Content-Type"));
          resp = type !== "jsonp" ? self.request : resp;
          var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type), r = filteredResponse;
          try {
            resp.responseText = r;
          } catch (e) {}
          if (r) {
            switch (type) {
             case "json":
              try {
                resp = win.JSON ? win.JSON.parse(r) : eval("(" + r + ")");
              } catch (err) {
                return error(resp, "Could not parse JSON in response", err);
              }
              break;

             case "js":
              resp = eval(r);
              break;

             case "html":
              resp = r;
              break;

             case "xml":
              resp = resp.responseXML && resp.responseXML.parseError && resp.responseXML.parseError.errorCode && resp.responseXML.parseError.reason ? null : resp.responseXML;
              break;
            }
          }
          self._responseArgs.resp = resp;
          self._fulfilled = true;
          fn(resp);
          self._successHandler(resp);
          while (self._fulfillmentHandlers.length > 0) {
            resp = self._fulfillmentHandlers.shift()(resp);
          }
          complete(resp);
        }
        function error(resp, msg, t) {
          resp = self.request;
          self._responseArgs.resp = resp;
          self._responseArgs.msg = msg;
          self._responseArgs.t = t;
          self._erred = true;
          while (self._errorHandlers.length > 0) {
            self._errorHandlers.shift()(resp, msg, t);
          }
          complete(resp);
        }
        this.request = getRequest.call(this, success, error);
      }
      Reqwest.prototype = {
        abort: function() {
          this._aborted = true;
          this.request.abort();
        },
        retry: function() {
          init.call(this, this.o, this.fn);
        },
        then: function(success, fail) {
          success = success || function() {};
          fail = fail || function() {};
          if (this._fulfilled) {
            this._responseArgs.resp = success(this._responseArgs.resp);
          } else if (this._erred) {
            fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
          } else {
            this._fulfillmentHandlers.push(success);
            this._errorHandlers.push(fail);
          }
          return this;
        },
        always: function(fn) {
          if (this._fulfilled || this._erred) {
            fn(this._responseArgs.resp);
          } else {
            this._completeHandlers.push(fn);
          }
          return this;
        },
        fail: function(fn) {
          if (this._erred) {
            fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
          } else {
            this._errorHandlers.push(fn);
          }
          return this;
        },
        "catch": function(fn) {
          return this.fail(fn);
        }
      };
      function reqwest(o, fn) {
        return new Reqwest(o, fn);
      }
      function normalize(s) {
        return s ? s.replace(/\r?\n/g, "\r\n") : "";
      }
      function serial(el, cb) {
        var n = el.name, t = el.tagName.toLowerCase(), optCb = function(o) {
          if (o && !o["disabled"]) cb(n, normalize(o["attributes"]["value"] && o["attributes"]["value"]["specified"] ? o["value"] : o["text"]));
        }, ch, ra, val, i;
        if (el.disabled || !n) return;
        switch (t) {
         case "input":
          if (!/reset|button|image|file/i.test(el.type)) {
            ch = /checkbox/i.test(el.type);
            ra = /radio/i.test(el.type);
            val = el.value;
            (!(ch || ra) || el.checked) && cb(n, normalize(ch && val === "" ? "on" : val));
          }
          break;

         case "textarea":
          cb(n, normalize(el.value));
          break;

         case "select":
          if (el.type.toLowerCase() === "select-one") {
            optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null);
          } else {
            for (i = 0; el.length && i < el.length; i++) {
              el.options[i].selected && optCb(el.options[i]);
            }
          }
          break;
        }
      }
      function eachFormElement() {
        var cb = this, e, i, serializeSubtags = function(e, tags) {
          var i, j, fa;
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i]);
            for (j = 0; j < fa.length; j++) serial(fa[j], cb);
          }
        };
        for (i = 0; i < arguments.length; i++) {
          e = arguments[i];
          if (/input|select|textarea/i.test(e.tagName)) serial(e, cb);
          serializeSubtags(e, [ "input", "select", "textarea" ]);
        }
      }
      function serializeQueryString() {
        return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments));
      }
      function serializeHash() {
        var hash = {};
        eachFormElement.apply(function(name, value) {
          if (name in hash) {
            hash[name] && !isArray(hash[name]) && (hash[name] = [ hash[name] ]);
            hash[name].push(value);
          } else hash[name] = value;
        }, arguments);
        return hash;
      }
      reqwest.serializeArray = function() {
        var arr = [];
        eachFormElement.apply(function(name, value) {
          arr.push({
            name: name,
            value: value
          });
        }, arguments);
        return arr;
      };
      reqwest.serialize = function() {
        if (arguments.length === 0) return "";
        var opt, fn, args = Array.prototype.slice.call(arguments, 0);
        opt = args.pop();
        opt && opt.nodeType && args.push(opt) && (opt = null);
        opt && (opt = opt.type);
        if (opt == "map") fn = serializeHash; else if (opt == "array") fn = reqwest.serializeArray; else fn = serializeQueryString;
        return fn.apply(null, args);
      };
      reqwest.toQueryString = function(o, trad) {
        var prefix, i, traditional = trad || false, s = [], enc = encodeURIComponent, add = function(key, value) {
          value = "function" === typeof value ? value() : value == null ? "" : value;
          s[s.length] = enc(key) + "=" + enc(value);
        };
        if (isArray(o)) {
          for (i = 0; o && i < o.length; i++) add(o[i]["name"], o[i]["value"]);
        } else {
          for (prefix in o) {
            if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add);
          }
        }
        return s.join("&").replace(/%20/g, "+");
      };
      function buildParams(prefix, obj, traditional, add) {
        var name, i, v, rbracket = /\[\]$/;
        if (isArray(obj)) {
          for (i = 0; obj && i < obj.length; i++) {
            v = obj[i];
            if (traditional || rbracket.test(prefix)) {
              add(prefix, v);
            } else {
              buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
            }
          }
        } else if (obj && obj.toString() === "[object Object]") {
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
          }
        } else {
          add(prefix, obj);
        }
      }
      reqwest.getcallbackPrefix = function() {
        return callbackPrefix;
      };
      reqwest.compat = function(o, fn) {
        if (o) {
          o["type"] && (o["method"] = o["type"]) && delete o["type"];
          o["dataType"] && (o["type"] = o["dataType"]);
          o["jsonpCallback"] && (o["jsonpCallbackName"] = o["jsonpCallback"]) && delete o["jsonpCallback"];
          o["jsonp"] && (o["jsonpCallback"] = o["jsonp"]);
        }
        return new Reqwest(o, fn);
      };
      reqwest.ajaxSetup = function(options) {
        options = options || {};
        for (var k in options) {
          globalSetupOptions[k] = options[k];
        }
      };
      return reqwest;
    });
  }, {} ],
  16: [ function(require, module, exports) {
    exports = module.exports = trim;
    function trim(str) {
      return str.replace(/^\s*|\s*$/g, "");
    }
    exports.left = function(str) {
      return str.replace(/^\s*/, "");
    };
    exports.right = function(str) {
      return str.replace(/\s*$/, "");
    };
  }, {} ],
  17: [ function(require, module, exports) {
    var WinChan = function() {
      var RELAY_FRAME_NAME = "__winchan_relay_frame";
      var CLOSE_CMD = "die";
      function addListener(w, event, cb) {
        if (w.attachEvent) w.attachEvent("on" + event, cb); else if (w.addEventListener) w.addEventListener(event, cb, false);
      }
      function removeListener(w, event, cb) {
        if (w.detachEvent) w.detachEvent("on" + event, cb); else if (w.removeEventListener) w.removeEventListener(event, cb, false);
      }
      function isInternetExplorer() {
        var rv = -1;
        var ua = navigator.userAgent;
        if (navigator.appName === "Microsoft Internet Explorer") {
          var re = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
          if (re.exec(ua) != null) rv = parseFloat(RegExp.$1);
        } else if (ua.indexOf("Trident") > -1) {
          var re = new RegExp("rv:([0-9]{2,2}[.0-9]{0,})");
          if (re.exec(ua) !== null) {
            rv = parseFloat(RegExp.$1);
          }
        }
        return rv >= 8;
      }
      function isFennec() {
        try {
          var userAgent = navigator.userAgent;
          return userAgent.indexOf("Fennec/") != -1 || userAgent.indexOf("Firefox/") != -1 && userAgent.indexOf("Android") != -1;
        } catch (e) {}
        return false;
      }
      function isSupported() {
        return window.JSON && window.JSON.stringify && window.JSON.parse && window.postMessage;
      }
      function extractOrigin(url) {
        if (!/^https?:\/\//.test(url)) url = window.location.href;
        var m = /^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(url);
        if (m) return m[1];
        return url;
      }
      function findRelay() {
        var loc = window.location;
        var frames = window.opener.frames;
        for (var i = frames.length - 1; i >= 0; i--) {
          try {
            if (frames[i].location.protocol === window.location.protocol && frames[i].location.host === window.location.host && frames[i].name === RELAY_FRAME_NAME) {
              return frames[i];
            }
          } catch (e) {}
        }
        return;
      }
      var isIE = isInternetExplorer();
      if (isSupported()) {
        return {
          open: function(opts, cb) {
            if (!cb) throw "missing required callback argument";
            var err;
            if (!opts.url) err = "missing required 'url' parameter";
            if (!opts.relay_url) err = "missing required 'relay_url' parameter";
            if (err) setTimeout(function() {
              cb(err);
            }, 0);
            if (!opts.window_name) opts.window_name = null;
            if (!opts.window_features || isFennec()) opts.window_features = undefined;
            var iframe;
            var origin = extractOrigin(opts.url);
            if (origin !== extractOrigin(opts.relay_url)) {
              return setTimeout(function() {
                cb("invalid arguments: origin of url and relay_url must match");
              }, 0);
            }
            var messageTarget;
            if (isIE) {
              iframe = document.createElement("iframe");
              iframe.setAttribute("src", opts.relay_url);
              iframe.style.display = "none";
              iframe.setAttribute("name", RELAY_FRAME_NAME);
              document.body.appendChild(iframe);
              messageTarget = iframe.contentWindow;
            }
            var w = window.open(opts.url, opts.window_name, opts.window_features);
            if (!messageTarget) messageTarget = w;
            var closeInterval = setInterval(function() {
              if (w && w.closed) {
                cleanup();
                if (cb) {
                  cb("User closed the popup window");
                  cb = null;
                }
              }
            }, 500);
            var req = JSON.stringify({
              a: "request",
              d: opts.params
            });
            function cleanup() {
              if (iframe) document.body.removeChild(iframe);
              iframe = undefined;
              if (closeInterval) closeInterval = clearInterval(closeInterval);
              removeListener(window, "message", onMessage);
              removeListener(window, "unload", cleanup);
              if (w) {
                try {
                  w.close();
                } catch (securityViolation) {
                  messageTarget.postMessage(CLOSE_CMD, origin);
                }
              }
              w = messageTarget = undefined;
            }
            addListener(window, "unload", cleanup);
            function onMessage(e) {
              if (e.origin !== origin) {
                return;
              }
              try {
                var d = JSON.parse(e.data);
                if (d.a === "ready") messageTarget.postMessage(req, origin); else if (d.a === "error") {
                  cleanup();
                  if (cb) {
                    cb(d.d);
                    cb = null;
                  }
                } else if (d.a === "response") {
                  cleanup();
                  if (cb) {
                    cb(null, d.d);
                    cb = null;
                  }
                }
              } catch (err) {}
            }
            addListener(window, "message", onMessage);
            return {
              close: cleanup,
              focus: function() {
                if (w) {
                  try {
                    w.focus();
                  } catch (e) {}
                }
              }
            };
          },
          onOpen: function(cb) {
            var o = "*";
            var msgTarget = isIE ? findRelay() : window.opener;
            if (!msgTarget) throw "can't find relay frame";
            function doPost(msg) {
              msg = JSON.stringify(msg);
              if (isIE) msgTarget.doPost(msg, o); else msgTarget.postMessage(msg, o);
            }
            function onMessage(e) {
              var d;
              try {
                d = JSON.parse(e.data);
              } catch (err) {}
              if (!d || d.a !== "request") return;
              removeListener(window, "message", onMessage);
              o = e.origin;
              if (cb) {
                setTimeout(function() {
                  cb(o, d.d, function(r) {
                    cb = undefined;
                    doPost({
                      a: "response",
                      d: r
                    });
                  });
                }, 0);
              }
            }
            function onDie(e) {
              if (e.data === CLOSE_CMD) {
                try {
                  window.close();
                } catch (o_O) {}
              }
            }
            addListener(isIE ? msgTarget : window, "message", onMessage);
            addListener(isIE ? msgTarget : window, "message", onDie);
            try {
              doPost({
                a: "ready"
              });
            } catch (e) {
              addListener(msgTarget, "load", function(e) {
                doPost({
                  a: "ready"
                });
              });
            }
            var onUnload = function() {
              try {
                removeListener(isIE ? msgTarget : window, "message", onDie);
              } catch (ohWell) {}
              if (cb) doPost({
                a: "error",
                d: "client closed window"
              });
              cb = undefined;
              try {
                window.close();
              } catch (e) {}
            };
            addListener(window, "unload", onUnload);
            return {
              detach: function() {
                removeListener(window, "unload", onUnload);
              }
            };
          }
        };
      } else {
        return {
          open: function(url, winopts, arg, cb) {
            setTimeout(function() {
              cb("unsupported browser");
            }, 0);
          },
          onOpen: function(cb) {
            setTimeout(function() {
              cb("unsupported browser");
            }, 0);
          }
        };
      }
    }();
    if (typeof module !== "undefined" && module.exports) {
      module.exports = WinChan;
    }
  }, {} ],
  18: [ function(require, module, exports) {
    module.exports = hasKeys;
    function hasKeys(source) {
      return source !== null && (typeof source === "object" || typeof source === "function");
    }
  }, {} ],
  19: [ function(require, module, exports) {
    var Keys = require("object-keys");
    var hasKeys = require("./has-keys");
    module.exports = extend;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        if (!hasKeys(source)) {
          continue;
        }
        var keys = Keys(source);
        for (var j = 0; j < keys.length; j++) {
          var name = keys[j];
          target[name] = source[name];
        }
      }
      return target;
    }
  }, {
    "./has-keys": 18,
    "object-keys": 21
  } ],
  20: [ function(require, module, exports) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    var isFunction = function(fn) {
      var isFunc = typeof fn === "function" && !(fn instanceof RegExp) || toString.call(fn) === "[object Function]";
      if (!isFunc && typeof window !== "undefined") {
        isFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;
      }
      return isFunc;
    };
    module.exports = function forEach(obj, fn) {
      if (!isFunction(fn)) {
        throw new TypeError("iterator must be a function");
      }
      var i, k, isString = typeof obj === "string", l = obj.length, context = arguments.length > 2 ? arguments[2] : null;
      if (l === +l) {
        for (i = 0; i < l; i++) {
          if (context === null) {
            fn(isString ? obj.charAt(i) : obj[i], i, obj);
          } else {
            fn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);
          }
        }
      } else {
        for (k in obj) {
          if (hasOwn.call(obj, k)) {
            if (context === null) {
              fn(obj[k], k, obj);
            } else {
              fn.call(context, obj[k], k, obj);
            }
          }
        }
      }
    };
  }, {} ],
  21: [ function(require, module, exports) {
    module.exports = Object.keys || require("./shim");
  }, {
    "./shim": 23
  } ],
  22: [ function(require, module, exports) {
    var toString = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toString.call(value);
      var isArguments = str === "[object Arguments]";
      if (!isArguments) {
        isArguments = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toString.call(value.callee) === "[object Function]";
      }
      return isArguments;
    };
  }, {} ],
  23: [ function(require, module, exports) {
    (function() {
      "use strict";
      var has = Object.prototype.hasOwnProperty, toString = Object.prototype.toString, forEach = require("./foreach"), isArgs = require("./isArguments"), hasDontEnumBug = !{
        toString: null
      }.propertyIsEnumerable("toString"), hasProtoEnumBug = function() {}.propertyIsEnumerable("prototype"), dontEnums = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor" ], keysShim;
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object", isFunction = toString.call(object) === "[object Function]", isArguments = isArgs(object), theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        if (isArguments) {
          forEach(object, function(value) {
            theKeys.push(value);
          });
        } else {
          var name, skipProto = hasProtoEnumBug && isFunction;
          for (name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(name);
            }
          }
        }
        if (hasDontEnumBug) {
          var ctor = object.constructor, skipConstructor = ctor && ctor.prototype === object;
          forEach(dontEnums, function(dontEnum) {
            if (!(skipConstructor && dontEnum === "constructor") && has.call(object, dontEnum)) {
              theKeys.push(dontEnum);
            }
          });
        }
        return theKeys;
      };
      module.exports = keysShim;
    })();
  }, {
    "./foreach": 20,
    "./isArguments": 22
  } ],
  24: [ function(require, module, exports) {
    var global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    var Auth0 = require("./lib/index");
    if (typeof global.window.define == "function" && global.window.define.amd) {
      global.window.define("auth0", function() {
        return Auth0;
      });
    } else if (global.window) {
      global.window.Auth0 = Auth0;
    }
  }, {
    "./lib/index": 4
  } ]
}, {}, [ 24 ]);
(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;
        if (!u && a) return a(o, !0);
        if (i) return i(o, !0);
        throw new Error("Cannot find module '" + o + "'");
      }
      var f = n[o] = {
        exports: {}
      };
      t[o][0].call(f.exports, function(e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, f, f.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var i = typeof require == "function" && require;
  for (var o = 0; o < r.length; o++) s(r[o]);
  return s;
})({
  1: [ function(require, module, exports) {
    module.exports = {
      "//": "This is an automatic translation. Help us to improve it.",
      loadingTitle: "الرجاء الانتظار...",
      close: "قم بإغلاق",
      signin: {
        title: "تسجيل الدخول",
        action: "تسجيل الدخول",
        all: "إظهار الكل",
        strategyEmailEmpty: "رسالة البريد الإلكتروني فارغاً.",
        strategyEmailInvalid: "البريد الإلكتروني غير صالح.",
        strategyDomainInvalid: "{المجال} لم يكن الإعداد.",
        signupText: "التسجيل",
        forgotText: "هل نسيت كلمة المرور الخاصة بك؟",
        emailPlaceholder: "البريد الإلكتروني",
        usernamePlaceholder: "اسم المستخدم",
        passwordPlaceholder: "كلمة المرور",
        separatorText: "أو",
        serverErrorText: "حدث خطأ أثناء معالجة تسجيل الدخول.",
        returnUserLabel: "آخر مرة قمت بتسجيل الدخول باستخدام...",
        wrongEmailPasswordErrorText: "البريد الإلكتروني غير صحيح أو كلمة المرور.",
        or: ".. أو قم بتسجيل الدخول باستخدام",
        loadingMessage: "التوقيع في مع {connection}..."
      },
      signup: {
        description: "",
        title: "التسجيل",
        action: "التسجيل",
        emailPlaceholder: "البريد الإلكتروني",
        passwordPlaceholder: "إنشاء كلمة مرور",
        cancelAction: "إلغاء الأمر",
        headerText: "الرجاء إدخال البريد الإلكتروني وكلمة المرور الخاصة بك",
        footerText: "",
        enterpriseEmailWarningText: "هذا المجال {المجال} قد تم تكوينه لتسجيل الدخول، ولا يمكن أن تقوم بإنشاء حساب. حاول تسجيل الدخول بدلاً من ذلك.",
        serverErrorText: "حدث خطأ أثناء معالجة العلامة التسجيل."
      },
      reset: {
        title: "إعادة تعيين كلمة المرور",
        action: "إرسال",
        emailPlaceholder: "البريد الإلكتروني",
        passwordPlaceholder: "كلمة المرور الجديدة",
        repeatPasswordPlaceholder: "تأكيد كلمة المرور الجديدة",
        cancelAction: "إلغاء الأمر",
        successText: "لقد أرسلنا فقط لك رسالة بريد إلكتروني إعادة تعيين كلمة المرور الخاصة بك.",
        enterSamePasswordText: "الرجاء إدخال كلمة المرور نفسها.",
        headerText: "الرجاء إدخال البريد الإلكتروني الخاص بك وكلمة المرور الجديدة. وسوف نرسل لك رسالة بالبريد إلكتروني لتأكيد تغيير كلمة المرور.",
        serverErrorText: "حدث خطأ أثناء معالجة إعادة تعيين كلمة المرور."
      }
    };
  }, {} ],
  2: [ function(require, module, exports) {
    module.exports = {
      "//": "This is an automatic translation. Help us to improve it.",
      loadingTitle: "Bitte warten...",
      close: "Schließen",
      signin: {
        title: "Anmelden",
        action: "Anmelden",
        all: "Alle anzeigen",
        strategyEmailEmpty: "Die e-Mail ist leer.",
        strategyEmailInvalid: "Die e-Mail ist ungültig.",
        strategyDomainInvalid: "{domain} wurde nicht eingerichtet.",
        signupText: "Anmelden",
        forgotText: "Passwort vergessen?",
        emailPlaceholder: "E-Mail",
        usernamePlaceholder: "Benutzername",
        passwordPlaceholder: "Passwort",
        separatorText: "oder",
        serverErrorText: "Gab es Fehler beim Verarbeiten der anmelden.",
        returnUserLabel: "Letzte Mal unterschrieben Sie bei der Verwendung...",
        wrongEmailPasswordErrorText: "Falsche e-Mail oder Passwort.",
        or: "... oder melden Sie sich mit",
        loadingMessage: "Bei der Anmeldung mit {connection}..."
      },
      signup: {
        description: "",
        title: "Anmelden",
        action: "Anmelden",
        emailPlaceholder: "E-Mail",
        passwordPlaceholder: "Erstellen Sie ein Kennwort",
        cancelAction: "Abbrechen",
        headerText: "Bitte geben Sie Ihre e-Mail und Passwort",
        footerText: 'Durch Klicken auf "Anmelden", stimmen Sie unseren Nutzungsbedingungen oder Datenschutzrichtlinien.',
        enterpriseEmailWarningText: "Diese Domäne {domain} für Single Sign On konfiguriert wurde und Sie können ein Konto erstellen. Versuchen Sie stattdessen sich anzumelden.",
        serverErrorText: "Gab es Fehler beim Verarbeiten der Zeichens auf."
      },
      reset: {
        title: "Passwort zurücksetzen",
        action: "Senden",
        emailPlaceholder: "E-Mail",
        passwordPlaceholder: "Neues Passwort",
        repeatPasswordPlaceholder: "Neues Kennwort bestätigen",
        cancelAction: "Abbrechen",
        successText: "Wir haben Sie nur eine e-Mail zum Zurücksetzen Ihres Passworts geschickt.",
        enterSamePasswordText: "Bitte geben Sie das gleiche Kennwort.",
        headerText: "Bitte geben Sie Ihre e-Mail und das neue Kennwort. Wir senden Ihnen eine e-Mail zur Bestätigung der Passwortänderung.",
        serverErrorText: "Gab es Fehler beim Verarbeiten des Kennworts zurücksetzen."
      }
    };
  }, {} ],
  3: [ function(require, module, exports) {
    module.exports = {
      loadingTitle: "Please wait...",
      close: "Close",
      windowsAuthTitle: "Windows Authentication",
      invalid: "Invalid",
      mustMatch: "Must match",
      loginSocialButton: "Login with {connection:title}",
      signupSocialButton: "Signup with {connection:title}",
      networkError: "We could not reach the server.<br/>Please try again.",
      signin: {
        title: "Log in",
        action: "Access",
        actionDomain: "Log in to {domain}",
        all: "Show all",
        strategyEmailEmpty: "The email is empty.",
        strategyEmailInvalid: "The email is invalid.",
        strategyDomainInvalid: "The domain {domain} has not been set up.",
        signupText: "Sign Up",
        forgotText: "Reset password",
        cancelAction: "Cancel",
        emailPlaceholder: "Email",
        usernamePlaceholder: "Username",
        passwordPlaceholder: "Password",
        separatorText: "or",
        serverErrorText: "There was an error processing the login.",
        returnUserLabel: "Last time you signed in using...",
        domainUserLabel: "You are connected from your corporate network...",
        wrongEmailPasswordErrorText: "Wrong email or password.",
        or: "... or log in using",
        loadingMessage: "Logging In with {connection}...",
        popupCredentials: "Enter your credentials in the pop-up window",
        userClosedPopup: "Popup window closed. Try again.",
        userConsentFailed: "Permissions were not granted. Try again."
      },
      signup: {
        description: "",
        title: "Sign Up",
        action: "Sign Up",
        emailPlaceholder: "Email",
        passwordPlaceholder: "Create a Password",
        cancelAction: "Cancel",
        headerText: "Please enter your email and password",
        footerText: "",
        enterpriseEmailWarningText: "This domain {domain} has been configured for Single Sign On and you can't create an account. Try logging in instead.",
        serverErrorText: "There was an error processing the signup.",
        userExistsErrorText: "The user already exists.",
        invalidPassword: "Password is too weak."
      },
      reset: {
        title: "Reset Password",
        action: "Send",
        emailPlaceholder: "Email",
        passwordPlaceholder: "New Password",
        repeatPasswordPlaceholder: "Confirm New Password",
        cancelAction: "Cancel",
        successText: "We've just sent you an email to reset your password.",
        enterSamePasswordText: "Please enter the same password.",
        headerText: "Please enter your email and the new password. We will send you an email to confirm the password change.",
        serverErrorText: "There was an error processing the password reset.",
        userDoesNotExistErrorText: "User does not exist."
      }
    };
  }, {} ],
  4: [ function(require, module, exports) {
    module.exports = {
      loadingTitle: "Por favor espere...",
      close: "Cerrar",
      invalid: "Inválido",
      mustMatch: "Debe coincidir",
      loginSocialButton: "Ingresar con {connection:title}",
      signupSocialButton: "Registrarse con {connection:title}",
      signin: {
        title: "Iniciar sesión",
        action: "Ingresar",
        all: "Mostrar todas",
        strategyEmailEmpty: "El email esta vacío.",
        strategyEmailInvalid: "El email no es válido.",
        strategyDomainInvalid: "El dominio {domain} no esta configurado.",
        signupText: "Registrarse",
        forgotText: "Resetear contraseña",
        emailPlaceholder: "Email",
        usernamePlaceholder: "Nombre de usuario",
        passwordPlaceholder: "Contraseña",
        separatorText: "o",
        serverErrorText: "Hubo un error al iniciar sesión.",
        returnUserLabel: "La última vez inició sesión con...",
        domainUserLabel: "Usted se encuentra conectado desde su red corporativa...",
        wrongEmailPasswordErrorText: "Email o clave incorrecta.",
        or: "... o inicie sesión usando",
        loadingMessage: "Iniciando sesión con {connection}...",
        popupCredentials: "Ingrese sus credenciales en la ventana emergente"
      },
      signup: {
        description: "",
        title: "Registrarse",
        action: "Registrar",
        emailPlaceholder: "Email",
        passwordPlaceholder: "Contraseña",
        cancelAction: "Cancelar",
        headerText: "Por favor ingrese email y contraseña",
        footerText: "",
        enterpriseEmailWarningText: "El dominio {domain} ha sido configurado para Single Sign On y no puede crear una cuenta. Intente iniciar sesión directamente.",
        serverErrorText: "Hubo un error al procesar su registro.",
        userExistsErrorText: "El usuario ya existe."
      },
      reset: {
        title: "Resetear Contraseña",
        action: "Enviar",
        emailPlaceholder: "Email",
        passwordPlaceholder: "Nueva Contraseña",
        repeatPasswordPlaceholder: "Confirme nueva contraseña",
        cancelAction: "Cancelar",
        successText: "Hemos enviado un email para completar el reseteo de su contraseña.",
        enterSamePasswordText: "Por favor ingrese la misma contraseña.",
        headerText: "Por favor ingrese su email y la nueva contraseña. Enviaremos un email para confirmar el cambio.",
        serverErrorText: "Hubo un error al resetear su contraseña.",
        userDoesNotExistErrorText: "Usuario inválido."
      }
    };
  }, {} ],
  5: [ function(require, module, exports) {
    module.exports = {
      loadingTitle: "Veuillez patienter...",
      close: "Fermer",
      windowsAuthTitle: "Connexion Windows",
      signin: {
        title: "Connexion",
        action: "Connexion",
        all: "Afficher tout",
        strategyEmailEmpty: "Le courriel est vide.",
        strategyEmailInvalid: "Le courriel n'est pas valide.",
        strategyDomainInvalid: "Le domaine {domain} n'a pas été configuré.",
        signupText: "Inscrivez-vous",
        forgotText: "Vous avez oublié votre mot de passe ?",
        emailPlaceholder: "Courriel",
        usernamePlaceholder: "Nom d'utilisateur",
        passwordPlaceholder: "Mot de passe",
        separatorText: "ou",
        serverErrorText: "Erreur lors de la connexion.",
        returnUserLabel: "Lors de votre dernière connexion vous avez utilisé...",
        domainUserLabel: "Vous êtes connecté depuis le réseau de votre entreprise...",
        wrongEmailPasswordErrorText: "Courriel ou mot de passe incorrect.",
        or: "... ou connectez-vous à l'aide de",
        loadingMessage: "Connexion à l'aide de {connection}..."
      },
      signup: {
        description: "",
        title: "Inscrivez-vous",
        action: "Inscrivez-vous",
        emailPlaceholder: "Courriel",
        passwordPlaceholder: "Créer un mot de passe",
        cancelAction: "Annuler",
        headerText: "Veuillez entrer votre courriel et mot de passe",
        footerText: "",
        enterpriseEmailWarningText: "Ce domaine {domain} a été configuré pour le Single Sign On et vous ne pouvez pas créer de compte. Essayez de vous connecter à un compte existant.",
        serverErrorText: "Erreur lors de l'inscription.",
        userExistsErrorText: "Cet utilisateur existe déjà."
      },
      reset: {
        title: "Réinitialiser votre mot de passe",
        action: "Envoyer",
        emailPlaceholder: "Courriel",
        passwordPlaceholder: "Nouveau mot de passe",
        repeatPasswordPlaceholder: "Confirmer le nouveau mot de passe",
        cancelAction: "Annuler",
        successText: "Vous allez recevoir sous quelques minutes un courriel vous indiquant comment réinitialiser votre mot de passe.",
        enterSamePasswordText: "S'il vous plaît entrez le même mot de passe.",
        headerText: "Veuillez saisir votre courriel et mot de passe. Nous vous enverrons un courriel pour confirmer le changement de mot de passe.",
        serverErrorText: "Erreur de traitement los de réinitialisation du mot de passe.",
        userDoesNotExistErrorText: "Utilisateur introuvable."
      }
    };
  }, {} ],
  6: [ function(require, module, exports) {
    module.exports = {
      "//": "This is an automatic translation. Help us to improve it.",
      loadingTitle: "חכה בבקשה...",
      close: "סגור",
      signin: {
        title: "הירשם",
        action: "הירשם",
        all: "הצג הכל",
        strategyEmailEmpty: "הדוא ל הוא ריק.",
        strategyEmailInvalid: "הדוא ל אינו חוקי.",
        strategyDomainInvalid: "התחום {domain} לא היתה תוכנית ההתקנה.",
        signupText: "הירשם",
        forgotText: "שכחת הסיסמא?",
        emailPlaceholder: "דוא",
        usernamePlaceholder: "שם משתמש",
        passwordPlaceholder: "סיסמה",
        separatorText: "או",
        serverErrorText: "אירעה שגיאה בעיבוד הכניסה.",
        returnUserLabel: "בפעם האחרונה נכנסת באמצעות...",
        wrongEmailPasswordErrorText: 'הדוא"ל טועה או סיסמה.',
        or: ". או כניסה באמצעות",
        loadingMessage: "כניסה עם {connection}..."
      },
      signup: {
        description: "",
        title: "הירשם",
        action: "הירשם",
        emailPlaceholder: "דוא",
        passwordPlaceholder: "צור סיסמה",
        cancelAction: "ביטול",
        headerText: "הזינו את כתובת המייל והסיסמא",
        footerText: "",
        enterpriseEmailWarningText: "תחום זה, {domain} נקבעה עבור כניסה יחידה, אין באפשרותך ליצור חשבון. נסה להיכנס במקום.",
        serverErrorText: "אירעה שגיאה בעיבוד את השלט למעלה."
      },
      reset: {
        title: "איפוס סיסמה",
        action: "שלח",
        emailPlaceholder: "דוא",
        passwordPlaceholder: "סיסמה חדשה",
        repeatPasswordPlaceholder: "אשר סיסמה חדשה",
        cancelAction: "ביטול",
        successText: "אנחנו פשוט לשלוח לך דואר אלקטרוני כדי לאפס את הסיסמה שלך.",
        enterSamePasswordText: "הזינו בבקשה את אותה סיסמה.",
        headerText: "אנא הזן את הדואר האלקטרוני שלך ואת הסיסמה החדשה. אנו נשלח לך הודעת דואר אלקטרוני כדי לאשר שינוי הסיסמה.",
        serverErrorText: "אירעה שגיאה בעיבוד איפוס הסיסמה."
      }
    };
  }, {} ],
  7: [ function(require, module, exports) {
    module.exports = {
      "//": "This is an automatic translation. Help us to improve it.",
      loadingTitle: "Attendere prego...",
      close: "Chiudere",
      signin: {
        title: "Accedi",
        action: "Accedi",
        all: "Visualizza tutti",
        strategyEmailEmpty: "L'email è vuota.",
        strategyEmailInvalid: "L'email non è valido.",
        strategyDomainInvalid: "Il dominio {domain} non è stata l'installazione.",
        signupText: "Registrati",
        forgotText: "Hai dimenticato la password?",
        emailPlaceholder: "Posta elettronica",
        usernamePlaceholder: "Nome utente",
        passwordPlaceholder: "Password",
        separatorText: "o",
        serverErrorText: "C'è stato un errore durante l'elaborazione il segno in.",
        returnUserLabel: "Ultima volta che hai eseguito utilizzando...",
        wrongEmailPasswordErrorText: "Email errato o password.",
        or: "... oppure accedi usando",
        loadingMessage: "Accedi con {connection}..."
      },
      signup: {
        description: "",
        title: "Registrati",
        action: "Registrati",
        emailPlaceholder: "Posta elettronica",
        passwordPlaceholder: "Creare una Password",
        cancelAction: "Annulla",
        headerText: "Inserisci la tua email e la password",
        footerText: "",
        enterpriseEmailWarningText: "Questo dominio {domain} è stato configurato per il Single Sign On e non è possibile creare un account. Prova ad accedere invece.",
        serverErrorText: "C'è stato un errore durante l'elaborazione il segno fino."
      },
      reset: {
        title: "Reimpostare la Password",
        action: "Invia",
        emailPlaceholder: "Posta elettronica",
        passwordPlaceholder: "Nuova Password",
        repeatPasswordPlaceholder: "Conferma nuova Password",
        cancelAction: "Annulla",
        successText: "Noi abbiamo appena inviato un'e-mail per reimpostare la password.",
        enterSamePasswordText: "Inserisci la stessa password.",
        headerText: "Inserisci il tuo indirizzo email e la password nuova. Ti invieremo un'email per confermare la modifica della password.",
        serverErrorText: "C'è stato un errore durante l'elaborazione il password reset."
      }
    };
  }, {} ],
  8: [ function(require, module, exports) {
    module.exports = {
      "//": "This is an automatic translation. Help us to improve it.",
      loadingTitle: "お待ちください。。。",
      close: "閉じる",
      signin: {
        title: "サインイン",
        action: "サインイン",
        all: "すべて表示します。",
        strategyEmailEmpty: "電子メールが空です。",
        strategyEmailInvalid: "電子メールは有効です。",
        strategyDomainInvalid: "{ドメイン} セットアップされていません。",
        signupText: "サインアップ",
        forgotText: "パスワードをお忘れですか？",
        emailPlaceholder: "電子メール",
        usernamePlaceholder: "ユーザ名",
        passwordPlaceholder: "パスワード",
        separatorText: "または",
        serverErrorText: "サインインを処理中にエラーがありました。",
        returnUserLabel: "最後の時間を使用してをサインインして.",
        wrongEmailPasswordErrorText: "間違ったメール アドレスまたはパスワードです。",
        or: "... またはを使用してサインイン",
        loadingMessage: "でサインイン {connection}..."
      },
      signup: {
        description: "",
        title: "サインアップ",
        action: "サインアップ",
        emailPlaceholder: "電子メール",
        passwordPlaceholder: "パスワードを作成します。",
        cancelAction: "キャンセル",
        headerText: "あなたのメール アドレスとパスワードを入力してください。",
        footerText: "",
        enterpriseEmailWarningText: "このドメイン {} が構成されているシングル サインオン ・ アカウントを作成することはできません。代わりにサインインしてください。",
        serverErrorText: "符号を処理中にエラーがありました。"
      },
      reset: {
        title: "パスワードのリセット",
        action: "送信",
        emailPlaceholder: "電子メール",
        passwordPlaceholder: "新しいパスワード",
        repeatPasswordPlaceholder: "新しいパスワードを確認します。",
        cancelAction: "キャンセル",
        successText: "我々 はちょうどあなたのパスワードをリセットするメールを送信しました。",
        enterSamePasswordText: "同じパスワードを入力してください。",
        headerText: "あなたのメール アドレスと新しいパスワードを入力してください。我々 は、パスワードの変更を確認するためにメールが送信されます。",
        serverErrorText: "パスワードのリセットを処理中にエラーがありました。"
      }
    };
  }, {} ],
  9: [ function(require, module, exports) {
    module.exports = {
      "//": "This is an automatic translation. Help us to improve it.",
      loadingTitle: "Een ogenblik geduld...",
      close: "Sluiten",
      signin: {
        title: "Aanmelden",
        action: "Aanmelden",
        all: "Toon alles",
        strategyEmailEmpty: "Het veld e-mail is leeg.",
        strategyEmailInvalid: "Het veld e-mail is ongeldig.",
        strategyDomainInvalid: "Het domein {domain} is niet geactiveerd.",
        signupText: "Aanmelden",
        forgotText: "Wachtwoord vergeten?",
        emailPlaceholder: "E-mail",
        usernamePlaceholder: "Usernamea",
        passwordPlaceholder: "Wachtwoord",
        separatorText: "of",
        serverErrorText: "Er is een fout opgetreden tijdens het inloggen.",
        returnUserLabel: "De laatste keer logde je in met...",
        wrongEmailPasswordErrorText: "Verkeerd e-mail of wachtwoord.",
        or: "... of meld u aan met",
        loadingMessage: "Aanmelden met {connection}..."
      },
      signup: {
        description: "",
        title: "Aanmelden",
        action: "Aanmelden",
        emailPlaceholder: "E-mail",
        passwordPlaceholder: "Een wachtwoord maken",
        cancelAction: "Annuleren",
        headerText: "Voer je email en wachtwoord in",
        footerText: "",
        enterpriseEmailWarningText: "Dit domein {domain} is geconfigureerd voor eenmalige aanmelding en u kunt geen account aanmaken. Probeer u aan te melden in plaats daarvan.",
        serverErrorText: "Er is een fout opgetreden bij de verwerking van uw aanmelding."
      },
      reset: {
        title: "Wachtwoord resetten",
        action: "Verzenden",
        emailPlaceholder: "E-mail",
        passwordPlaceholder: "Nieuw wachtwoord",
        repeatPasswordPlaceholder: "Bevestig het nieuwe wachtwoord",
        cancelAction: "Annuleren",
        successText: "We hebben u zojuist een e-mail gestuurd om uw wachtwoord te resetten.",
        enterSamePasswordText: "Voer hetzelfde wachtwoord in.",
        headerText: "Voer uw e-mailadres en het nieuwe wachtwoord in. Wij sturen u een e-mail ter bevestiging van de wachtwoordswijziging.",
        serverErrorText: "Er is een fout opgetreden bij de verwerking van het nieuwe wachtwoord."
      }
    };
  }, {} ],
  10: [ function(require, module, exports) {
    module.exports = {
      loadingTitle: "Carregando...",
      close: "Fechar",
      signin: {
        title: "Entrar",
        action: "Entrar",
        all: "Mostrar todos",
        strategyEmailEmpty: "O e-mail deve ser preenchido.",
        strategyEmailInvalid: "O email é inválido.",
        strategyDomainInvalid: "O domínio {domain} não foi informado.",
        signupText: "Registre-se",
        forgotText: "Esqueceu sua senha?",
        emailPlaceholder: "E-mail",
        usernamePlaceholder: "Nome de Usuário",
        passwordPlaceholder: "Senha",
        separatorText: "ou",
        serverErrorText: "Houve um erro ao efetuar o login.",
        returnUserLabel: "Da última vez que você fez login usando...",
        wrongEmailPasswordErrorText: "E-mail ou senha inválidos.",
        or: "... ou entre usando",
        loadingMessage: "Entrar com {connection}..."
      },
      signup: {
        description: "",
        title: "Cadastre-se",
        action: "Cadastre-se",
        emailPlaceholder: "E-mail",
        passwordPlaceholder: "Crie uma senha",
        cancelAction: "Cancelar",
        headerText: "Por favor, digite seu e-mail e senha",
        footerText: "",
        enterpriseEmailWarningText: "Este domínio {domain} foi configurado para Sign-On único e você não pode criar uma conta. Tente fazer o login em vez disso.",
        serverErrorText: "Houve um erro ao efetuar o login."
      },
      reset: {
        title: "Redefinir senha",
        action: "Enviar",
        emailPlaceholder: "E-mail",
        passwordPlaceholder: "Nova senha",
        repeatPasswordPlaceholder: "Confirmar nova senha",
        cancelAction: "Cancelar",
        successText: "Já enviamos um e-mail para redefinir sua senha.",
        enterSamePasswordText: "Por favor digite a mesma senha.",
        headerText: "Por favor, digite seu e-mail e a senha nova. Nós lhe enviaremos um e-mail para confirmar a alteração de senha.",
        serverErrorText: "Houve um erro ao redefinir a senha."
      }
    };
  }, {} ],
  11: [ function(require, module, exports) {
    module.exports = {
      "//": "This is an automatic translation. Help us to improve it.",
      loadingTitle: "Aguarde...",
      close: "Fechar",
      signin: {
        title: "Entrar",
        action: "Entrar",
        all: "Mostrar todos",
        strategyEmailEmpty: "O e-mail é vazio.",
        strategyEmailInvalid: "O email é inválido.",
        strategyDomainInvalid: "O domínio {domain} não foi a instalação.",
        signupText: "Inscrição",
        forgotText: "Esqueceu sua senha?",
        emailPlaceholder: "Email",
        usernamePlaceholder: "Nome de Usuário",
        passwordPlaceholder: "Senha",
        separatorText: "ou",
        serverErrorText: "Houve um erro ao processar o sinal em.",
        returnUserLabel: "Da última vez que você assinou usando...",
        wrongEmailPasswordErrorText: "Senha ou e-mail errado.",
        or: "... ou Cadastre-se no uso de",
        loadingMessage: "Entrar com {connection}..."
      },
      signup: {
        description: "",
        title: "Inscrição",
        action: "Inscrição",
        emailPlaceholder: "Email",
        passwordPlaceholder: "Crie uma senha",
        cancelAction: "Cancelar",
        headerText: "Por favor, digite seu e-mail e senha",
        footerText: "",
        enterpriseEmailWarningText: "Este domínio {domain} tiver sido configurado para Sign-On único e você não pode criar uma conta. Tente entrar em vez disso.",
        serverErrorText: "Houve um erro ao processar o sinal de cima."
      },
      reset: {
        title: "Redefinir senha",
        action: "Enviar",
        emailPlaceholder: "Email",
        passwordPlaceholder: "Nova senha",
        repeatPasswordPlaceholder: "Confirmar nova senha",
        cancelAction: "Cancelar",
        successText: "Só te enviamos um e-mail para redefinir sua senha.",
        enterSamePasswordText: "Por favor digite a mesma senha.",
        headerText: "Por favor, digite seu e-mail e a senha nova. Nós lhe enviaremos um e-mail para confirmar a alteração de senha.",
        serverErrorText: "Houve um erro ao processar a redefinir a senha."
      }
    };
  }, {} ],
  12: [ function(require, module, exports) {
    module.exports = {
      "//": "This is an automatic translation. Help us to improve it.",
      "//": "Some improvements by human :)",
      loadingTitle: "Подождите...",
      close: "Закрыть",
      windowsAuthTitle: "Windows аутентификация",
      invalid: "Неверный",
      mustMatch: "Должны совпадать",
      loginSocialButton: "Вход через {connection:title}",
      signupSocialButton: "Регистрация через {connection:title}",
      signin: {
        title: "Войти",
        action: "Войти",
        all: "Показать все",
        strategyEmailEmpty: "Email пустой.",
        strategyEmailInvalid: "Email недействителен.",
        strategyDomainInvalid: "Домен {domain} не был установлен.",
        signupText: "Регистрация",
        forgotText: "Забыли ваш пароль?",
        emailPlaceholder: "Email",
        usernamePlaceholder: "Имя пользователя",
        passwordPlaceholder: "Пароль",
        separatorText: "или",
        serverErrorText: "Произошла ошибка при обработке входа.",
        returnUserLabel: "Последний раз вы заходили через...",
        wrongEmailPasswordErrorText: "Неправильный email или пароль.",
        or: "... или войдите с помощью",
        loadingMessage: "Вход через {connection}..."
      },
      signup: {
        description: "",
        title: "Регистрация",
        action: "Регистрация",
        emailPlaceholder: "Email",
        passwordPlaceholder: "Создайте пароль",
        cancelAction: "Отмена",
        headerText: "Пожалуйста, введите свой email и пароль",
        footerText: "",
        enterpriseEmailWarningText: "Этот домен {domain} был настроен для единого входа и нельзя создать учетную запись, попробуйте войти.",
        serverErrorText: "Произошла ошибка при обработке регистрации.",
        userExistsErrorText: "Пользователь существует."
      },
      reset: {
        title: "Сброс пароля",
        action: "Отправить",
        emailPlaceholder: "Email",
        passwordPlaceholder: "Новый пароль",
        repeatPasswordPlaceholder: "Подтвердите новый пароль",
        cancelAction: "Отмена",
        successText: "Мы отправили вам email для сброса пароля.",
        enterSamePasswordText: "Пожалуйста, введите тот же пароль.",
        headerText: "Пожалуйста, введите ваш email и новый пароль. Мы вышлем email для подтверждения изменения пароля.",
        serverErrorText: "Произошла ошибка при обработке сброса пароля.",
        userDoesNotExistErrorText: "Пользователь не существует."
      }
    };
  }, {} ],
  13: [ function(require, module, exports) {
    module.exports = {
      "//": "This is an automatic translation. Help us to improve it.",
      loadingTitle: "DubelmoHchugh loS.",
      close: "SoQmoH",
      signin: {
        title: "qI'",
        action: "qI'",
        all: "cha' Hoch",
        strategyEmailEmpty: "chIm email.",
        strategyEmailInvalid: "email invalid.",
        strategyDomainInvalid: "{domain} yer wej setup.",
        signupText: "qI'",
        forgotText: "mu'wIj lIj?",
        emailPlaceholder: "email",
        usernamePlaceholder: "tus neeg siv lub npe",
        passwordPlaceholder: "mu'wIj",
        separatorText: "ghap",
        serverErrorText: "Qagh qaStaHvIS qI' mIw tu'lu'.",
        returnUserLabel: "Qav poH qI' SoH qaStaHvIS lo'.",
        wrongEmailPasswordErrorText: "QIH email pagh mu'wIj.",
        or: "... pagh qI' qaStaHvIS yIlo'",
        loadingMessage: "Ukubhalisela In nge {connection}..."
      },
      signup: {
        description: "",
        title: "qI'",
        action: "qI'",
        emailPlaceholder: "email",
        passwordPlaceholder: "mu'wIj chenmoH",
        cancelAction: "qIl",
        headerText: "nuqneH email mu'wIj je",
        footerText: "",
        enterpriseEmailWarningText: "configured {domain} yer Vas qI' 'ej account pagh chenmoH SoH. nID, qI' instead.",
        serverErrorText: "Qagh qI' mIw Ha' tu'lu'."
      },
      reset: {
        title: "mu'wIj reset",
        action: "ngeH",
        emailPlaceholder: "email",
        passwordPlaceholder: "mu'wIj chu'",
        repeatPasswordPlaceholder: "mu'wIj chu' confirm",
        cancelAction: "qIl",
        successText: "jIboQqang reset mu'wIj neH ngeH SoH maH.",
        enterSamePasswordText: "DubelmoHchugh mu'wIj rap 'el.",
        headerText: "nuqneH email chu' mu'wIj je. jIboQqang mu'wIj choH confirm ngeH SoH maH.",
        serverErrorText: "Qagh reset mu'wIj mIw tu'lu'."
      }
    };
  }, {} ],
  14: [ function(require, module, exports) {
    module.exports = {
      loadingTitle: "Lütfen bekleyiniz...",
      close: "Kapat",
      windowsAuthTitle: "Windows Doğrulama",
      invalid: "Geçersiz",
      mustMatch: "Eşleşmeli",
      loginSocialButton: "{connection:title} ile Giriş Yap",
      signupSocialButton: "{connection:title} lie Kayıt Ol",
      signin: {
        title: "Giriş",
        action: "Erişim",
        all: "Hepsini Göster",
        strategyEmailEmpty: "Bu e-posta boş",
        strategyEmailInvalid: "Bu e-posts geçersiz",
        strategyDomainInvalid: "{domain} Bu alan henüz kurulmadı",
        signupText: "Kayıt Ol",
        forgotText: "Şifremi unuttum",
        emailPlaceholder: "E-posta",
        usernamePlaceholder: "Kullanıcı Adı",
        passwordPlaceholder: "Şifre",
        separatorText: "veya",
        serverErrorText: "Kayıt işlemi sırasında bir hatayla karşılaşıldı",
        returnUserLabel: "... ile en son girişiniz ",
        domainUserLabel: "Şirketinize ait ... ağından bağlandınız",
        wrongEmailPasswordErrorText: "Hatalı e-posta veya şifre.",
        or: "veya bunlardan biriyle Giriş Yap",
        loadingMessage: "{connection} ile Giriş Yap",
        popupCredentials: "Lütfen açılır pencereye kimlik belgelerinizi giriniz",
        userClosedPopup: "Açılır pencere kapandı. Lütfen tekrar deneyiniz.",
        userConsentFailed: "İzin verilmedi. Lütfen tekrar deneyiniz."
      },
      signup: {
        description: "",
        title: "Kayıt Ol",
        action: "Kayıt Ol",
        emailPlaceholder: "E-posta",
        passwordPlaceholder: "Şifre Oluşturun",
        cancelAction: "İptal",
        headerText: "Lütfen e-postanızı ve şifrenizi giriniz",
        footerText: "",
        enterpriseEmailWarningText: "Bu alan {domain} üzerindeki tek oturum için yapılandırılmıştır, bu yüzden hesap oluşturamazsınız. Bunun yerine, lütfen giriş yapmayı deneyiniz.",
        serverErrorText: "Kayıt olurken bir hata ile karşılaşıldı.",
        userExistsErrorText: "Bu kullanıcı adı zaten alınmış.",
        invalidPassword: "Bu şifre çok zayıf."
      },
      reset: {
        title: "Şifreyi Sıfırla",
        action: "Yolla",
        emailPlaceholder: "E-posta",
        passwordPlaceholder: "Yeni Şifre",
        repeatPasswordPlaceholder: "Yeni Şifreyi Onayla",
        cancelAction: "İptal",
        successText: "Size şifrenizi sıfırlamanız için bir e-posta yolladık.",
        enterSamePasswordText: "Lütfen aynı şifreyi tekrar giriniz.",
        headerText: "Lütfen e-posta adresinizi ve yeni şifrenizi giriniz. Size şifre değişikliğini onaylamak için bir e-posta yollayacağız.",
        serverErrorText: "Şifre sıfırlama işlemi sırasında bir hatayla karşılaşıldı.",
        userDoesNotExistErrorText: "Böyle bir kullanıcı bulunamadı."
      }
    };
  }, {} ],
  15: [ function(require, module, exports) {
    module.exports = {
      "//": "This is an automatic translation. Help us to improve it.",
      loadingTitle: "请稍候。。。",
      close: "关闭",
      signin: {
        title: "登录",
        action: "登录",
        all: "全部显示",
        strategyEmailEmpty: "电子邮件是空的。",
        strategyEmailInvalid: "电子邮件是无效的。",
        strategyDomainInvalid: "指定域 {domain} 尚未安装。",
        signupText: "登记",
        forgotText: "忘记了您的密码吗？",
        emailPlaceholder: "电子邮件",
        usernamePlaceholder: "用户名",
        passwordPlaceholder: "密码",
        separatorText: "或",
        serverErrorText: "处理所示的标志时出错。",
        returnUserLabel: "最后一次你在使用签署...",
        wrongEmailPasswordErrorText: "错误的电子邮件或密码。",
        or: "...或使用登录",
        loadingMessage: "签约与 {connection}..."
      },
      signup: {
        description: "",
        title: "登记",
        action: "登记",
        emailPlaceholder: "电子邮件",
        passwordPlaceholder: "创建一个密码",
        cancelAction: "取消",
        headerText: "请输入您的电子邮件和密码",
        footerText: "",
        enterpriseEmailWarningText: "指定此域 {domain} 已配置为单一登录和您不能创建一个帐户。请尝试登录相反。",
        serverErrorText: "处理标志向上时出错。"
      },
      reset: {
        title: "重置密码",
        action: "发送",
        emailPlaceholder: "电子邮件",
        passwordPlaceholder: "新密码",
        repeatPasswordPlaceholder: "确认新密码",
        cancelAction: "取消",
        successText: "我们刚刚已经向您发送一封电子邮件，重置您的密码。",
        enterSamePasswordText: "请输入相同的密码。",
        headerText: "请输入您的电子邮件和新的密码。我们将向您发送邮件以确认密码更改。",
        serverErrorText: "处理重置密码时出错。"
      }
    };
  }, {} ],
  16: [ function(require, module, exports) {
    (function(global) {
      require("./lib/insert-css");
      var bonzo = require("bonzo");
      var _ = require("underscore");
      var Auth0 = require("auth0-js");
      var $ = require("./lib/bonzo-augmented");
      var EventEmitter = require("events").EventEmitter;
      var strategies = require("./lib/strategies");
      var template = require("./lib/html/main.ejs");
      var HeaderView = require("./lib/header");
      var SigninPanel = require("./lib/mode-signin");
      var SignupPanel = require("./lib/mode-signup");
      var ResetPanel = require("./lib/mode-reset");
      var LoggedinPanel = require("./lib/mode-loggedin");
      var KerberosPanel = require("./lib/mode-kerberos");
      var LoadingPanel = require("./lib/mode-loading");
      var OptionsManager = require("./lib/options-manager");
      var placeholderSupported = require("./lib/supports-placeholder");
      var has_animations = require("./lib/supports-animation");
      var ocreate = require("./lib/object-create");
      var stop = require("./lib/stop-event");
      var utils = require("./lib/utils");
      var bind = require("./lib/bind");
      module.exports = Auth0Lock;
      function Auth0Lock(clientID, domain, options) {
        if (!(this instanceof Auth0Lock)) {
          return new Auth0Lock(clientID, domain, options);
        }
        if ("string" !== typeof clientID) throw new Error("`ClientID` required as first parameter.");
        if ("string" !== typeof domain) throw new Error("`domain` required as second parameter.");
        EventEmitter.call(this);
        this.$options = _.extend({}, options);
        this.$options.clientID = clientID;
        this.$options.domain = domain;
        this.$strategies = strategies;
        this.$auth0 = new Auth0({
          clientID: this.$options.clientID,
          domain: this.$options.domain
        });
        this.$options.assetsUrl = this.$options.assetsUrl || (this.isAuth0Domain() ? "https://s3.amazonaws.com/assets.auth0.com/" : "https://" + this.$options.domain + "/");
        this.$options.cdn = this.$options.cdn || (this.isAuth0Domain() ? "https://d19p4zemcycm7a.cloudfront.net/w2/" : "https://" + this.$options.domain + "/w2/");
        this.$ssoData = null;
        this.$container = null;
        this.$client = {};
        this.getClientConfiguration(bind(this.setClientConfiguration, this));
      }
      Auth0Lock.version = "6.3.4";
      Auth0Lock.prototype = ocreate(EventEmitter.prototype);
      Auth0Lock.prototype.getClientConfiguration = function(done) {
        var self = this;
        if ("function" === typeof done) {
          this.once("client loaded", function(client) {
            done(client);
          });
        }
        global.window.Auth0 = global.window.Auth0 || {
          clients: {},
          script_tags: {}
        };
        if (!global.window.Auth0.clients) {
          global.window.Auth0.clients = {};
          global.window.Auth0.script_tags = {};
        }
        var clients = global.window.Auth0.clients;
        var client = clients[this.$options.clientID];
        if (client) return this.emit("client loaded", client);
        if (this.loadState) return;
        this.loadState = true;
        var setClient = global.window.Auth0.setClient || function setClient() {};
        global.window.Auth0.setClient = function(client) {
          setClient.apply(window.Auth0, arguments);
          if (self.$options.clientID !== client.id) return;
          clients[self.$options.clientID] = client;
          self.emit("client loaded", client);
        };
        var script = global.window.Auth0.script_tags[this.$options.clientID];
        if (!script) {
          var script = document.createElement("script");
          script.src = this.$options.assetsUrl + "client/" + this.$options.clientID + ".js" + "?t" + +new Date();
          global.window.Auth0.script_tags[this.$options.clientID] = script;
          var firstScript = document.getElementsByTagName("script")[0];
          firstScript.parentNode.insertBefore(script, firstScript);
        }
        script.addEventListener("load", bind(this.onclientloadsuccess, this));
        script.addEventListener("error", bind(this.onclientloaderror, this));
        this.timeout = setTimeout(bind(this.onclientloaderror, this), 3e3);
      };
      Auth0Lock.prototype.onclientloadsuccess = function() {
        clearTimeout(this.timeout);
        if (console && console.log) {
          console.log("Client configuration loaded");
        }
      };
      Auth0Lock.prototype.onclientloaderror = function(err) {
        clearTimeout(this.timeout);
        if (this.options) {
          this.exhibit();
          this._loadingPanel(this.options);
          this.query(".a0-spinner").addClass("a0-hide");
          this._showError(this.options.i18n.t("networkError"));
        }
        this.loadState = false;
        global.window.Auth0.script_tags[this.$options.clientID] = null;
        if (console && console.log) {
          console.log(new Error("Failed to load client configuration for " + this.$options.clientID));
        }
      };
      Auth0Lock.prototype.setClientConfiguration = function(client) {
        this.$client = _.clone(client);
        this.emit("client initialized");
        return this;
      };
      Auth0Lock.prototype.query = function(selector, context) {
        if ("string" === typeof selector) {
          return $(selector, context || this.$container);
        }
        return $("#a0-lock", selector || this.$container);
      };
      Auth0Lock.prototype.render = function(tmpl, locals) {
        var _locals = _.extend({}, this.options, locals);
        return tmpl(_locals);
      };
      Auth0Lock.prototype.insert = function() {
        if (this.$container) return this;
        var options = this.options;
        var cid = options.container;
        var locals = {
          options: options,
          alt_spinner: !has_animations() ? this.$options.cdn + "img/ajax-loader.gif" : null
        };
        if (cid) {
          this.$container = document.getElementById(cid);
          if (!this.$container) throw new Error("Not found element with 'id' " + cid);
          this.$container.innerHTML = this.render(template, locals);
        } else {
          this.$container = document.createElement("div");
          bonzo(this.$container).addClass("a0-lock-container");
          this.$container.innerHTML = this.render(template, locals);
          document.body.appendChild(this.$container);
        }
        return this;
      };
      Auth0Lock.prototype.exhibit = function() {
        var options = this.options;
        this.header = new HeaderView(this, this.query(".a0-header").get(0), options);
        this.query("div.a0-panel").removeClass("a0-active");
        this.query("div.a0-overlay").addClass("a0-active");
        this.query(".a0-panel.a0-onestep").addClass("a0-active");
        if (!options.container) {
          bonzo(document.body).addClass("a0-lock-open");
        } else {
          this.query(".a0-active").removeClass("a0-overlay");
        }
        this.query(".a0-popup .a0-invalid").removeClass("a0-invalid");
        this.query(".a0-overlay").toggleClass("a0-no-placeholder-support", !placeholderSupported);
        this.query(".a0-onestep a.a0-close").a0_on("click", bind(this.oncloseclick, this));
        if (options.closable) {
          this.query("").a0_on("keyup", bind(this.onescpressed, this));
        }
        this.emit("shown");
      };
      Auth0Lock.prototype.show = function(options, callback) {
        var params = getShowParams(options, callback);
        var opts = _.extend({
          mode: "signin"
        }, params.options);
        return this.display(opts, params.callback);
      };
      Auth0Lock.prototype.showSignin = function(options, callback) {
        var params = getShowParams(options, callback);
        var optional = {
          disableSignupAction: true,
          disableResetAction: true
        };
        var required = {
          mode: "signin"
        };
        var opts = _.extend(optional, params.options, required);
        return this.show.call(this, opts, params.callback);
      };
      Auth0Lock.prototype.showSignup = function(options, callback) {
        var params = getShowParams(options, callback);
        var optional = {
          disableSignupAction: true,
          disableResetAction: true
        };
        var required = {
          mode: "signup"
        };
        var opts = _.extend(optional, params.options, required);
        return this.show.call(this, opts, params.callback);
      };
      Auth0Lock.prototype.showReset = function(options, callback) {
        var params = getShowParams(options, callback);
        var optional = {
          disableSignupAction: true,
          disableResetAction: true
        };
        var required = {
          mode: "reset"
        };
        var opts = _.extend(optional, params.options, required);
        return this.show.call(this, opts, params.callback);
      };
      Auth0Lock.prototype.hide = function(callback) {
        bonzo(document.body).removeClass("a0-lock-open");
        if (this.$container && this.options.container) {
          this.query().remove();
        } else if (this.$container) {
          this.query().parent(".a0-lock-container").remove();
        }
        this.$container = null;
        if ("function" === typeof callback) callback();
        this.emit("hidden");
        return this;
      };
      Auth0Lock.prototype.logout = function(query) {
        this.$auth0.logout(query);
        return this;
      };
      Auth0Lock.prototype.display = function(options, callback) {
        var opts = _.extend({
          popupCallback: callback
        }, options);
        this.options = new OptionsManager(this, opts);
        this.insert();
        this.options.ready(bind(onoptionsready, this));
        function onoptionsready() {
          this.initialize(bind(oninitialized, this));
        }
        function oninitialized() {
          this.once(this.options.mode + " ready", bind(this.focusInput, this));
          if ("signin" === this.options.mode) {
            if (this.$ssoData && this.$ssoData.connection) {
              return this._kerberosPanel(this.options, callback);
            }
            if (this.options._shouldShowLastLogin()) {
              return this._loggedinPanel(this.options, callback);
            }
            this._signinPanel(this.options, callback);
          }
          if ("signup" === this.options.mode) {
            this._signupPanel(this.options, callback);
          }
          if ("reset" === this.options.mode) {
            this._resetPanel(this.options, callback);
          }
        }
        return this;
      };
      Auth0Lock.prototype.initialize = function(done) {
        var self = this;
        var options = this.options;
        if (_.isEmpty(this.$client)) {
          var args = arguments;
          return this.getClientConfiguration(function() {
            self.initialize.apply(self, args);
          });
        }
        if (options._isFreeSubscription()) {
          this.query(".a0-footer").toggleClass("a0-hide", true);
          this.query(".a0-free-subscription").removeClass("a0-free-subscription");
        }
        this.exhibit();
        function finish(err, ssoData) {
          self.$ssoData = ssoData;
          done();
          self.emit("ready");
        }
        var notSigninMode = ~[ "reset", "signup" ].indexOf(options.mode);
        if (notSigninMode) {
          return finish(null, {}), this;
        }
        var disabledReturnUserExperience = false === options.rememberLastLogin && (!options._isThereAnyADConnection() || false === options.integratedWindowsLogin);
        if (disabledReturnUserExperience) {
          return finish(null, {}), this;
        }
        this._loadingPanel(options);
        this.$auth0.getSSOData(options._isThereAnyADConnection(), finish);
        return this;
      };
      Auth0Lock.prototype._signinPanel = function(options) {
        var panel = SigninPanel(this, {
          options: options || {}
        });
        this._setTitle(this.options.i18n.t("signin:title"));
        this.setPanel(panel);
        return this;
      };
      Auth0Lock.prototype._signupPanel = function(options) {
        var panel = SignupPanel(this, {
          options: options || {}
        });
        this._setTitle(this.options.i18n.t("signup:title"));
        this.setPanel(panel);
        return this;
      };
      Auth0Lock.prototype._resetPanel = function(options) {
        var panel = ResetPanel(this, {
          options: options || {}
        });
        this._setTitle(this.options.i18n.t("reset:title"));
        this.setPanel(panel);
        return this;
      };
      Auth0Lock.prototype._loadingPanel = function(options) {
        var panel = LoadingPanel(this, {
          options: options
        });
        if (options.title) {
          this._setTitle(this.options.i18n.t(options.title + ":title"));
        } else {
          this._setTitle(this.options.i18n.t((options.mode || "signin") + ":title"));
        }
        this.setPanel(panel);
        if (options.message) {
          panel.query("").addClass("a0-with-message");
          panel.query(".a0-spin-message span").html(options.message.replace("-", " "));
        }
        return this;
      };
      Auth0Lock.prototype._loggedinPanel = function(options) {
        var panel = LoggedinPanel(this, {
          options: options || {}
        });
        this._setTitle(this.options.i18n.t("signin:title"));
        this.setPanel(panel);
        return this;
      };
      Auth0Lock.prototype._kerberosPanel = function(options) {
        var panel = KerberosPanel(this, {
          options: options || {}
        });
        this._setTitle(this.options.i18n.t("signin:title"));
        this.setPanel(panel);
        return this;
      };
      Auth0Lock.prototype.setPanel = function(panel, name) {
        var el = "function" === typeof panel.render ? panel.render() : panel;
        var pname = "function" === typeof panel.render ? panel.name : name || "signin";
        this.query(".a0-mode-container").html(el);
        this.emit("%s ready".replace("%s", pname));
      };
      Auth0Lock.prototype.isAuth0Domain = function() {
        var domainUrl = utils.parseUrl("https://" + this.$options.domain);
        return utils.endsWith(domainUrl.hostname, ".auth0.com");
      };
      Auth0Lock.prototype._ignoreEmailValidations = function(input) {
        return input.attr("type") !== "email";
      };
      Auth0Lock.prototype._showError = function(message) {
        if (!message) {
          this.query(".a0-error").html("").addClass("a0-hide");
          this.query(".a0-errors").removeClass("a0-errors");
          return animation_shake_reset(this.$container);
        }
        setTimeout(animation_shake, 0, this.$container);
        this.query(".a0-success").addClass("a0-hide");
        this.query(".a0-error").html(message).removeClass("a0-hide");
        this.emit("_error", message);
      };
      Auth0Lock.prototype._showSuccess = function(message) {
        if (!message) return this.query(".a0-success").html("").addClass("a0-hide");
        this.query(".a0-error").addClass("a0-hide");
        this.query(".a0-success").html(message).removeClass("a0-hide");
      };
      Auth0Lock.prototype._focusError = function(input, message) {
        if (!arguments.length) {
          this.query(".a0-errors").removeClass("a0-errors");
          this.query(".a0-error-input").removeClass("a0-error-input");
          this.query(".a0-error-message").remove();
          return animation_shake_reset(this.$container);
        }
        setTimeout(animation_shake, 0, this.$container);
        input.parent().addClass("a0-error-input");
        if (!message) return;
        input.parent().append($.create('<span class="a0-error-message">' + message + "</span>"));
      };
      Auth0Lock.prototype._setTitle = function(title) {
        this.header.setTitle(title);
      };
      Auth0Lock.prototype.restoreImage = function(title) {
        this.header.restoreImage(title);
      };
      Auth0Lock.prototype.setImage = function(title) {
        this.header.setImage(title);
      };
      Auth0Lock.prototype._signin = function(panel) {
        var valid = true;
        var message;
        var emailD = panel.query(".a0-email");
        var email_input = panel.query("input[name=email]");
        var email = null, domain, connection;
        var input_email_domain = this.options._extractEmailDomain(email_input.val().toLowerCase());
        var conn_obj = this.options._findConnectionByDomain(input_email_domain, this.$client.strategies);
        if (!conn_obj) {
          if (this.options.auth0Strategies.length > 0) {
            return this._signinWithAuth0(panel);
          }
          if (input_email_domain === "gmail.com") {
            return this._signinSocial("google-oauth2", null, null, panel);
          }
          message = this.options.i18n.t("signin:strategyDomainInvalid");
          message = message.replace("{domain}", input_email_domain);
          this._showError(message);
          this._focusError(email_input);
          return;
        }
        domain = conn_obj.domain;
        email = email_input.val();
        connection = conn_obj.name;
        valid &= !domain && !emailD.addClass("a0-invalid") || !!domain && !!emailD.removeClass("a0-invalid");
        if (!valid) {
          return;
        }
        if (this.options.popup && "token" === this.options.responseType) {
          return this._signinPopupNoRedirect(connection, this.options.popupCallback, undefined, panel);
        }
        message = this.options.i18n.t("signin:loadingMessage").replace("{connection}", connection);
        this._loadingPanel({
          mode: "signin",
          message: message
        });
        var loginOptions = _.extend({}, {
          connection: connection,
          popup: this.options.popup,
          popupOptions: this.options.popupOptions
        }, this.options.authParams);
        this.$auth0.login(loginOptions);
      };
      Auth0Lock.prototype._signinWithAuth0 = function(panel, connection) {
        var self = this;
        var options = this.options;
        var email_input = panel.query("input[name=email]");
        var password_input = panel.query("input[name=password]");
        var username = email_input.val();
        var password = password_input.val();
        connection = connection || options._getAuth0Connection(username);
        var loginOptions = {
          connection: connection.name,
          username: connection.domain ? username.replace("@" + connection.domain, "") : username,
          password: password,
          popup: self.options.popup,
          popupOptions: self.options.popupOptions
        };
        loginOptions = _.extend({}, loginOptions, this.options.authParams);
        var strategy = options._getClientStrategyByConnectionName(connection.name) || {};
        this._showError();
        this._focusError();
        if (this.options.popup && this.options.sso && "token" === this.options.responseType) {
          return this._signinPopupNoRedirect(connection.name, this.options.popupCallback, loginOptions, panel);
        }
        var message = strategy.name !== "auth0" ? this.options.i18n.t("signin:loadingMessage").replace("{connection}", connection.name) : "";
        this._loadingPanel({
          mode: "signin",
          message: message
        });
        this.$auth0.login(loginOptions, function(err) {
          if (!err) return;
          self.setPanel(panel);
          self._focusError(email_input);
          self._focusError(password_input);
          if (err.status !== 401) {
            self._showError(err.message || self.options.i18n.t("signin:serverErrorText"));
          } else {
            self._showError(self.options.i18n.t("signin:wrongEmailPasswordErrorText"));
          }
        });
      };
      Auth0Lock.prototype._signinSocial = function(e, connection, extraParams, panel) {
        var target = e.currentTarget || e.delegateTarget || e.target || e;
        var self = this;
        var options = panel.options;
        var strategyName = typeof target === "string" ? target : target.getAttribute("data-strategy");
        var strategy = options._getClientStrategyByName(strategyName);
        var connectionName = connection || strategy.connections[0].name;
        var extra = self.options.authParams;
        if (extra.connection_scopes) {
          extra.connection_scope = extra.connection_scopes[connectionName];
        }
        if (strategy) {
          if (this.options.popup && "token" === this.options.responseType) {
            this._signinPopupNoRedirect(connectionName, self.options.popupCallback, extraParams, panel);
          } else {
            var loginOptions = _.extend({}, {
              connection: connectionName,
              popup: self.options.popup,
              popupOptions: self.options.popupOptions
            }, self.options.authParams, extraParams);
            this.$auth0.login(loginOptions);
          }
        }
      };
      Auth0Lock.prototype._signinPopupNoRedirect = function(connectionName, popupCallback, extraParams, panel) {
        var self = this;
        var email_input = panel.query("input[name=email]");
        var password_input = panel.query("input[name=password]");
        var options = this.options;
        var callback = popupCallback || options.popupCallback;
        extraParams = extraParams || {};
        var loginOptions = _.extend({}, {
          connection: connectionName,
          popup: self.options.popup,
          popupOptions: self.options.popupOptions
        }, options.authParams, extraParams);
        if ("function" !== typeof callback) {
          throw new Error("Popup mode needs a callback function to be executed after authentication success or failure.");
        }
        this._showError();
        this._focusError();
        var message = null == loginOptions.username ? this.options.i18n.t("signin:popupCredentials") : null;
        this._loadingPanel({
          mode: "signin",
          message: message
        });
        this.$auth0.login(loginOptions, function(err, profile, id_token, access_token, state) {
          var args = Array.prototype.slice.call(arguments, 0);
          if (!err) return callback.apply(self, args), self.hide();
          self.setPanel(panel);
          if (err.message === "User closed the popup window") {
            self._showError(self.options.i18n.t("signin:userClosedPopup"));
          } else if (err.message === "access_denied") {
            self._showError(self.options.i18n.t("signin:userConsentFailed"));
          } else if (err.status !== 401) {
            self._showError(self.options.i18n.t("signin:serverErrorText"));
          } else {
            self._showError(self.options.i18n.t("signin:wrongEmailPasswordErrorText"));
            self._focusError(email_input);
            self._focusError(password_input);
          }
          return callback.apply(null, args);
        });
      };
      Auth0Lock.prototype.getClient = function() {
        return this.$auth0;
      };
      Auth0Lock.prototype.parseHash = function(hash) {
        return this.$auth0.parseHash(hash);
      };
      Auth0Lock.prototype.getProfile = function(token, callback) {
        this.$auth0.getProfile(token, callback);
        return this;
      };
      Auth0Lock.prototype.oncloseclick = function(e) {
        stop(e);
        this.hide();
      };
      Auth0Lock.prototype.onescpressed = function(e) {
        if (e.which == 27 || e.keycode == 27) this.hide();
      };
      Auth0Lock.prototype.focusInput = function() {
        if (this.options._focusDisabled()) return this;
        var el = this.query("input").first();
        try {
          el.focus();
        } catch (err) {}
        return this;
      };
      function animation_shake(context) {
        $(".a0-panel", context).addClass("a0-errors").addClass("a0-animated a0-shake");
      }
      function animation_shake_reset(context) {
        $(".a0-animated", context).removeClass("a0-errors").removeClass("a0-animated a0-shake");
      }
      function getShowParams(options, callback) {
        var realOptions = options;
        var realCallback = callback;
        if (_.isFunction(options)) {
          realCallback = options;
          realOptions = {};
        }
        return {
          callback: realCallback,
          options: realOptions
        };
      }
    }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {
    "./lib/bind": 17,
    "./lib/bonzo-augmented": 18,
    "./lib/header": 21,
    "./lib/html/main.ejs": 22,
    "./lib/insert-css": 25,
    "./lib/mode-kerberos": 27,
    "./lib/mode-loading": 29,
    "./lib/mode-loggedin": 31,
    "./lib/mode-reset": 34,
    "./lib/mode-signin": 36,
    "./lib/mode-signup": 39,
    "./lib/object-create": 41,
    "./lib/options-manager": 42,
    "./lib/stop-event": 44,
    "./lib/strategies": 45,
    "./lib/supports-animation": 46,
    "./lib/supports-placeholder": 47,
    "./lib/utils": 48,
    "auth0-js": 52,
    bonzo: 73,
    events: 75,
    underscore: 78
  } ],
  17: [ function(require, module, exports) {
    module.exports = bind;
    function bind(fn, obj) {
      return function binded() {
        return fn.apply(obj, arguments);
      };
    }
  }, {} ],
  18: [ function(require, module, exports) {
    var sizzle = require("sizzle");
    var bonzo = require("bonzo");
    var bean = require("bean");
    function generate(name) {
      return function(event, handler) {
        return this.each(function(el) {
          bean[name](el, event, handler);
        });
      };
    }
    bonzo.aug({
      a0_on: generate("on"),
      a0_off: generate("off"),
      a0_one: generate("one"),
      a0_once: generate("one")
    });
    module.exports = function(selector, root) {
      if ("string" === typeof selector) {
        return bonzo(sizzle(selector || "", root));
      }
      return bonzo(selector);
    };
    module.exports.create = function(html) {
      return bonzo.create(html);
    };
  }, {
    bean: 71,
    bonzo: 73,
    sizzle: 76
  } ],
  19: [ function(require, module, exports) {
    var md5 = require("blueimp-md5").md5;
    var regex = require("../regex");
    var trim = require("trim");
    function createURL(parsedEmail) {
      parsedEmail = trim(parsedEmail);
      parsedEmail = parsedEmail.toLowerCase();
      return "https://www.gravatar.com/avatar/" + md5(parsedEmail) + "?d=404";
    }
    module.exports = function(widget, mail) {
      var parseResult = regex.email_parser.exec(mail.toLowerCase());
      if (parseResult) {
        var parsedEmail = parseResult[0];
        widget.setImage(createURL(parsedEmail));
      } else {
        widget.restoreImage();
      }
    };
  }, {
    "../regex": 43,
    "blueimp-md5": 72,
    trim: 77
  } ],
  20: [ function(require, module, exports) {
    var EventEmitter = require("events").EventEmitter;
    var whichAnimationEvent = require("../supports-animation");
    var ocreate = require("../object-create");
    var ANIMATION_TIMEOUT_MS = 300;
    module.exports = IconContainerView;
    function IconContainerView(header, options) {
      this.header = header;
      this.options = options;
      this.animationEnd = whichAnimationEvent();
      this.queue = [];
    }
    IconContainerView.prototype = ocreate(EventEmitter.prototype);
    IconContainerView.prototype.query = function(selector) {
      return this.header.query(selector);
    };
    IconContainerView.prototype.avatar = function() {
      return this.query(".a0-avatar");
    };
    IconContainerView.prototype.img = function() {
      return this.query(".a0-image img");
    };
    IconContainerView.prototype.imgContainer = function() {
      return this.query(".a0-image");
    };
    IconContainerView.prototype._show = function(el, cb) {
      var self = this;
      if (!el.hasClass("a0-hide")) {
        return cb();
      }
      if (!self.animationEnd) {
        el.removeClass("a0-hide");
        return cb();
      }
      el.removeClass("a0-animated a0-fast a0-flipInX a0-flipOutX");
      el.a0_once(self.animationEnd, function() {
        el.removeClass("a0-animated a0-fast a0-flipInX a0-flipOutX");
        cb();
      });
      el.addClass("a0-animated a0-fast a0-flipInX");
      el.removeClass("a0-hide");
    };
    IconContainerView.prototype._hide = function(el, cb) {
      var self = this;
      if (el.hasClass("a0-hide")) {
        return cb();
      }
      if (!self.animationEnd) {
        el.addClass("a0-hide");
        return cb();
      }
      el.removeClass("a0-animated a0-fast a0-flipInX a0-flipOutX");
      el.a0_once(self.animationEnd, function() {
        el.removeClass("a0-animated a0-fast a0-flipOutX a0-flipInX");
        el.addClass("a0-hide");
        cb();
      });
      el.addClass("a0-animated a0-fast a0-flipOutX");
    };
    IconContainerView.prototype._showIcon = function(cb) {
      var self = this;
      return this._show(this.imgContainer(), function() {
        self.emit("icon shown");
        cb();
      });
    };
    IconContainerView.prototype._showAvatar = function(cb) {
      var self = this;
      return this._show(this.avatar(), function() {
        self.emit("avatar shown");
        cb();
      });
    };
    IconContainerView.prototype._hideIcon = function(cb) {
      var self = this;
      return this._hide(this.imgContainer(), function() {
        self.emit("icon hidden");
        cb();
      });
    };
    IconContainerView.prototype._hideAvatar = function(cb) {
      var self = this;
      return this._hide(this.avatar(), function() {
        self.emit("avatar hidden");
        cb();
      });
    };
    IconContainerView.prototype._onError = callbackify(function(cb, self) {
      clearTimeout(self.timer);
      self.img().a0_off("load");
      self.img().a0_off("error");
      self.imgContainer().removeClass("a0-gravatar");
      self._hideIcon(function() {
        if (self.options.icon) {
          self.img().attr("src", self.options.icon);
          self._showIcon(cb);
        } else {
          self._showAvatar(cb);
        }
      });
    });
    IconContainerView.prototype._onLoad = callbackify(function(cb, self) {
      clearTimeout(self.timer);
      self.img().a0_off("error");
      self.img().a0_off("load");
      self.query(".a0-image").addClass("a0-gravatar");
      self._hideAvatar(function() {
        self._showIcon(cb);
      });
    });
    IconContainerView.prototype._processQueue = function() {
      var self = this;
      if (!this.queue.length || this.processing) {
        return;
      }
      var element = this.queue.pop();
      self.processing = true;
      element(function() {
        self.processing = false;
        self._processQueue();
      });
    };
    IconContainerView.prototype.set = function(url) {
      var self = this;
      this.queue.push(function(cb) {
        if (self.img().attr("src") === url) {
          return cb();
        }
        self.timer = setTimeout(cb, ANIMATION_TIMEOUT_MS);
        self.img().a0_once("error", self._onError(cb, self));
        self.img().a0_once("load", self._onLoad(cb, self));
        self._hideIcon(function() {
          self.img().attr("src", url);
        });
      });
      this._processQueue();
    };
    IconContainerView.prototype.reset = function() {
      var self = this;
      if (this.options.icon) {
        this.queue.push(function(cb) {
          if (self.img().attr("src") !== self.options.icon) {
            self._hideIcon(function() {
              self.imgContainer().removeClass("a0-gravatar");
              self.img().attr("src", self.options.icon);
              self._showIcon(cb);
            });
            return;
          }
          self.imgContainer().removeClass("a0-gravatar");
          cb();
        });
      } else {
        this.queue.push(function(cb) {
          self._hideIcon(function() {
            self.imgContainer().removeClass("a0-gravatar");
            self._showAvatar(cb);
          });
        });
      }
      this._processQueue();
    };
    function callbackify(fn) {
      return function(cb, self) {
        return function() {
          fn.apply(self, [ cb, self ]);
        };
      };
    }
  }, {
    "../object-create": 41,
    "../supports-animation": 46,
    events: 75
  } ],
  21: [ function(require, module, exports) {
    var _ = require("underscore");
    var $ = require("../bonzo-augmented");
    var IconContainerView = require("./icon-container");
    module.exports = HeaderView;
    var validOptionsProperties = [ "icon" ];
    function HeaderView(widget, el, options) {
      var self = this;
      this.el = el;
      this.widget = widget;
      this.options = _.filter(options, function(option) {
        return !!~validOptionsProperties.indexOf(option);
      });
      this.image = new IconContainerView(this, options);
      function redirectEvent(s) {
        return function() {
          widget.emit(s);
        };
      }
      var events = [ "icon shown", "icon hidden", "avatar shown", "avatar hidden" ];
      events.forEach(function(eventName) {
        self.image.on(eventName, redirectEvent(eventName));
      });
    }
    HeaderView.prototype.setTitle = function(title) {
      var h1 = this.query("h1");
      h1.html(title);
      h1.css("display", "");
    };
    HeaderView.prototype.query = function(selector) {
      if (!this.el) {
        throw new Error("Can't get element since no `el` is set to local context");
      }
      return $(selector, this.el);
    };
    HeaderView.prototype.setImage = function(url) {
      this.image.set(url);
    };
    HeaderView.prototype.restoreImage = function() {
      this.image.reset();
    };
  }, {
    "../bonzo-augmented": 18,
    "./icon-container": 20,
    underscore: 78
  } ],
  22: [ function(require, module, exports) {
    module.exports = function anonymous(locals, filters, escape, rethrow) {
      escape = escape || function(html) {
        return String(html).replace(/&(?!#?[a-zA-Z0-9]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;");
      };
      var buf = [];
      with (locals || {}) {
        (function() {
          buf.push('<div id="a0-lock" class="a0-lock" dir="auto">\n    <div class="a0-signin">\n        <div class="a0-popup">\n            <div class="a0-overlay">\n                <div class="', escape((5, 
          locals && locals.options.container ? "" : "a0-centrix")), '">\n                    ' + function() {
            var buf = [];
            buf.push('<div id="a0-onestep" class="a0-panel a0-onestep a0-free-subscription">\n    ' + function() {
              var buf = [];
              buf.push('<div class="a0-header a0-top-header ', escape((1, locals.embedded ? "a0-hide" : "")), '">\n\n    <div class="a0-bg-gradient"></div>\n\n    <div class="a0-icon-container">\n      <div class="a0-image ', escape((6, 
              options.icon ? "" : "a0-hide")), '">\n          <img src="', escape((7, options.icon || "")), '">\n      </div>\n\n      <div class="a0-avatar ', escape((10, 
              !options.icon ? "" : "a0-hide")), '">\n          <i class="a0-avatar-guest a0-icon-budicon-2"></i>\n      </div>\n    </div>\n\n    <h1>', escape((15, 
              options.i18n.t("signin:title"))), '</h1>\n    <h2 class="a0-error a0-hide">&nbsp;</h2>\n    <h2 class="a0-success a0-hide">&nbsp;</h2>\n\n    <!-- if standalone, you shouldn\'t be able to close the widget -->\n    <a class="a0-close a0-icon-budicon-3 ', escape((20, 
              options.closable ? "" : "a0-hide")), '" href="#"></a>\n</div>\n');
              return buf.join("");
            }() + '\n\n    <div class="a0-mode-container"></div>\n\n    ' + function() {
              var buf = [];
              buf.push('<div class=\'a0-footer\'>\n    <a href="http://auth0.com" target="_new" class="a0-logo">\n        <i class="a0-icon-badge"></i>\n    </a>\n</div>\n');
              return buf.join("");
            }() + "\n</div>\n");
            return buf.join("");
          }() + "\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n");
        })();
      }
      return buf.join("");
    };
  }, {} ],
  23: [ function(require, module, exports) {
    module.exports = function anonymous(locals, filters, escape, rethrow) {
      escape = escape || function(html) {
        return String(html).replace(/&(?!#?[a-zA-Z0-9]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;");
      };
      var buf = [];
      with (locals || {}) {
        (function() {
          buf.push("");
          1;
          var icon_class = !use_big_buttons ? "a0-icon" : "a0-block";
          buf.push('\n<div tabindex="0"\n		data-strategy="', escape((3, name)), '"\n		title="', escape((4, 
          title)), '"\n		class="a0-zocial ', escape((5, icon_class)), " a0-", escape((5, css)), " ", escape((5, 
          locals.imageicon ? "a0-image-icon" : "")), '" dir="ltr">\n\n\n	<span>', escape((8, 
          title)), "</span>\n</div>");
        })();
      }
      return buf.join("");
    };
  }, {} ],
  24: [ function(require, module, exports) {
    var dics_data = {
      ar: require("../../i18n/ar.json"),
      de: require("../../i18n/de.json"),
      en: require("../../i18n/en.json"),
      es: require("../../i18n/es.json"),
      fr: require("../../i18n/fr-FR.json"),
      "fr-FR": require("../../i18n/fr-FR.json"),
      he: require("../../i18n/he.json"),
      it: require("../../i18n/it.json"),
      ja: require("../../i18n/ja.json"),
      nl: require("../../i18n/nl-NL.json"),
      "nl-NL": require("../../i18n/nl-NL.json"),
      pt: require("../../i18n/pt.json"),
      "pt-BR": require("../../i18n/pt-BR.json"),
      ru: require("../../i18n/ru.json"),
      tlh: require("../../i18n/tlh.json"),
      tr: require("../../i18n/tr.json"),
      zh: require("../../i18n/zh.json")
    };
    var default_dict = dics_data["en"];
    function findProp(o, s) {
      s = s.replace(/\[(\w+)\]/g, ":$1");
      s = s.replace(/^\:/, "");
      var a = s.split(":");
      while (a.length) {
        var n = a.shift();
        if (n in o) {
          o = o[n];
        } else {
          return;
        }
      }
      return o;
    }
    function Dictionary(data) {
      this._data = data;
    }
    Dictionary.prototype.t = function(key) {
      return findProp(this._data, key) || findProp(default_dict, key);
    };
    module.exports.getDict = function(langOrDict) {
      if (!langOrDict) {
        return new Dictionary(default_dict);
      }
      if (typeof langOrDict === "string") {
        var dict = dics_data[langOrDict] || dics_data[langOrDict.split("-")[0]];
        return new Dictionary(dict);
      } else {
        return new Dictionary(langOrDict);
      }
    };
  }, {
    "../../i18n/ar.json": 1,
    "../../i18n/de.json": 2,
    "../../i18n/en.json": 3,
    "../../i18n/es.json": 4,
    "../../i18n/fr-FR.json": 5,
    "../../i18n/he.json": 6,
    "../../i18n/it.json": 7,
    "../../i18n/ja.json": 8,
    "../../i18n/nl-NL.json": 9,
    "../../i18n/pt-BR.json": 10,
    "../../i18n/pt.json": 11,
    "../../i18n/ru.json": 12,
    "../../i18n/tlh.json": 13,
    "../../i18n/tr.json": 14,
    "../../i18n/zh.json": 15
  } ],
  25: [ function(require, module, exports) {
    var fs = require("fs");
    var style = '#a0-lock article,#a0-lock aside,#a0-lock details,#a0-lock figcaption,#a0-lock figure,#a0-lock footer,#a0-lock header,#a0-lock hgroup,#a0-lock nav,#a0-lock section,#a0-lock summary{display:block}#a0-lock audio,#a0-lock canvas,#a0-lock video{display:inline-block;*display:inline;*zoom:1}#a0-lock audio:not([controls]){display:none;height:0}#a0-lock [hidden]{display:none}#a0-lock html{font-size:100%;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}#a0-lock a,#a0-lock button,#a0-lock div,#a0-lock h1,#a0-lock h2,#a0-lock html,#a0-lock input,#a0-lock select,#a0-lock span,#a0-lock textarea{font-family:sans-serif}#a0-lock body{margin:0}#a0-lock a:focus{outline:thin dotted}#a0-lock a:active,#a0-lock a:hover{outline:0}#a0-lock h4{font-size:1em;margin:1.33em 0}#a0-lock h5{font-size:.83em;margin:1.67em 0}#a0-lock h6{font-size:.75em;margin:2.33em 0}#a0-lock abbr[title]{border-bottom:1px dotted}#a0-lock b,#a0-lock strong{font-weight:700}#a0-lock blockquote{margin:1em 40px}#a0-lock dfn{font-style:italic}#a0-lock mark{background:#ff0;color:#000}#a0-lock p,#a0-lock pre{margin:1em 0}#a0-lock code,#a0-lock kbd,#a0-lock pre,#a0-lock samp{font-family:monospace,serif;_font-family:\'courier new\',monospace;font-size:1em}#a0-lock pre{white-space:pre;white-space:pre-wrap;word-wrap:break-word}#a0-lock q{quotes:none}#a0-lock q:after,#a0-lock q:before{content:\'\';content:none}#a0-lock small{font-size:80%}#a0-lock sub,#a0-lock sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}#a0-lock sup{top:-.5em}#a0-lock sub{bottom:-.25em}#a0-lock dl,#a0-lock menu,#a0-lock ol,#a0-lock ul{margin:1em 0}#a0-lock dd{margin:0 0 0 40px}#a0-lock menu,#a0-lock ol,#a0-lock ul{padding:0 0 0 40px}#a0-lock nav ol,#a0-lock nav ul{list-style:none;list-style-image:none}#a0-lock img{border:0;-ms-interpolation-mode:bicubic}#a0-lock svg:not(:root){overflow:hidden}#a0-lock figure,#a0-lock form{margin:0}#a0-lock fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}#a0-lock legend{border:0;padding:0;white-space:normal;*margin-left:-7px}#a0-lock button,#a0-lock input,#a0-lock select,#a0-lock textarea{font-size:100%;margin:0;vertical-align:baseline;*vertical-align:middle}#a0-lock button,#a0-lock input{line-height:normal}#a0-lock button,#a0-lock html input[type=button],#a0-lock input[type=reset],#a0-lock input[type=submit]{-webkit-appearance:button;cursor:pointer;*overflow:visible}#a0-lock button[disabled],#a0-lock input[disabled]{cursor:default}#a0-lock input[type=checkbox],#a0-lock input[type=radio]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0;*height:13px;*width:13px}#a0-lock input[type=search]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}#a0-lock input[type=search]::-webkit-search-cancel-button,#a0-lock input[type=search]::-webkit-search-decoration{-webkit-appearance:none}#a0-lock button::-moz-focus-inner,#a0-lock input::-moz-focus-inner{border:0;padding:0}#a0-lock textarea{overflow:auto;vertical-align:top}#a0-lock table{border-collapse:collapse;border-spacing:0}#a0-lock a,#a0-lock button,#a0-lock footer,#a0-lock form,#a0-lock form label,#a0-lock h1,#a0-lock h2,#a0-lock h3,#a0-lock header,#a0-lock input[type=button],#a0-lock input[type=email],#a0-lock input[type=password],#a0-lock input[type=text],#a0-lock span{font-smooth:never;-webkit-font-smoothing:auto;alignment-baseline:baseline;-webkit-animation:none 0 ease 0 1 normal;-moz-animation:none 0 ease 0 1 normal;animation:none 0 ease 0 1 normal;-webkit-animation-play-state:running;-moz-animation-play-state:running;animation-play-state:running;appearance:normal;-webkit-backface-visibility:visible;-moz-backface-visibility:visible;-ms-backface-visibility:visible;backface-visibility:visible;background:none 0 0 auto repeat scroll padding-box transparent;background-color:transparent;background-image:none;baseline-shift:baseline;binding:none;bleed:6pt;bookmark-label:content();bookmark-level:none;bookmark-state:open;bookmark-target:none;border:0 none transparent;border-radius:0;bottom:auto;-webkit-box-align:stretch;-webkit-align-items:stretch;-moz-box-align:stretch;-ms-flex-align:stretch;box-align:stretch;box-decoration-break:slice;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:normal;-moz-box-orient:vertical;-moz-box-direction:normal;-ms-flex-direction:normal;box-direction:normal;-webkit-box-flex:0;-webkit-flex:0;-moz-box-flex:0;-ms-flex:0;box-flex:0;box-flex-group:1;box-lines:single;-webkit-box-ordinal-group:2;-webkit-order:1;-moz-box-ordinal-group:2;-ms-flex-order:1;box-ordinal-group:1;box-orient:inline-axis;-webkit-box-pack:start;-webkit-justify-content:start;-moz-box-pack:start;-ms-flex-pack:start;box-pack:start;-webkit-box-shadow:none;box-shadow:none;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-break-after:auto;-moz-break-after:auto;break-after:auto;-webkit-break-before:auto;-moz-break-before:auto;break-before:auto;-webkit-break-inside:auto;-moz-break-inside:auto;break-inside:auto;caption-side:top;clear:none;clip:auto;color:inherit;color-profile:auto;-webkit-column-count:auto;-moz-column-count:auto;column-count:auto;-webkit-column-fill:balance;-moz-column-fill:balance;column-fill:balance;-webkit-column-gap:normal;-moz-column-gap:normal;column-gap:normal;-webkit-column-rule:medium medium #1f1f1f;-moz-column-rule:medium medium #1f1f1f;column-rule:medium medium #1f1f1f;-webkit-column-span:1;-moz-column-span:1;column-span:1;-webkit-column-width:auto;-moz-column-width:auto;column-width:auto;-webkit-columns:auto auto;-moz-columns:auto auto;columns:auto auto;content:normal;counter-increment:none;counter-reset:none;crop:auto;cursor:auto;direction:auto;display:auto;dominant-baseline:auto;drop-initial-after-adjust:text-after-edge;drop-initial-after-align:baseline;drop-initial-before-adjust:text-before-edge;drop-initial-before-align:caps-height;drop-initial-size:auto;drop-initial-value:initial;elevation:level;empty-cells:show;fit:fill;fit-position:0 0;float:none;float-offset:0 0;font-size-adjust:none;font-stretch:normal;font:normal normal 100% "Helvetica Neue",Arial,sans-serif;grid-columns:none;grid-rows:none;hanging-punctuation:none;height:auto;hyphenate-after:auto;hyphenate-before:auto;hyphenate-character:auto;hyphenate-lines:no-limit;hyphenate-resource:none;-webkit-hyphens:manual;-moz-hyphens:manual;-ms-hyphens:manual;hyphens:manual;icon:auto;image-orientation:auto;image-rendering:auto;image-resolution:normal;inline-box-align:last;left:auto;letter-spacing:normal;line-height:normal;line-stacking:inline-line-height exclude-ruby consider-shifts;list-style:disc outside none;margin:0;marks:none;marquee-direction:forward;marquee-loop:1;marquee-play-count:1;marquee-speed:normal;marquee-style:scroll;max-height:none;max-width:none;min-height:0;min-width:0;move-to:normal;nav-down:auto;nav-index:auto;nav-left:auto;nav-right:auto;nav-up:auto;opacity:1;orphans:2;outline:invert none medium!important;outline-offset:0;overflow:visible;overflow-style:auto;padding:0;page:auto;page-break-after:auto;page-break-before:auto;page-break-inside:auto;page-policy:start;-webkit-perspective:none;-moz-perspective:none;-ms-perspective:none;perspective:none;-webkit-perspective-origin:50% 50%;-moz-perspective-origin:50% 50%;-ms-perspective-origin:50% 50%;perspective-origin:50% 50%;position:static;presentation-level:0;punctuation-trim:none;quotes:none;rendering-intent:auto;resize:none;right:auto;rotation:0;rotation-point:50% 50%;ruby-align:auto;ruby-overhang:none;ruby-position:before;ruby-span:none;size:auto;string-set:none;table-layout:auto;text-align:auto;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal;top:auto;-webkit-transform:none;-moz-transform:none;-ms-transform:none;transform:none;-webkit-transform-origin:50% 50% 0;-moz-transform-origin:50% 50% 0;-ms-transform-origin:50% 50% 0;transform-origin:50% 50% 0;-webkit-transform-style:flat;-moz-transform-style:flat;-ms-transform-style:flat;transform-style:flat;-webkit-transition:all 0 ease 0;-moz-transition:all 0 ease 0;transition:all 0 ease 0;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;white-space-collapse:collapse;widows:2;width:auto;word-break:normal;word-spacing:normal;word-wrap:normal;z-index:auto;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}@-webkit-keyframes appear{from{opacity:0}to{opacity:1}}@-webkit-keyframes fadein{from{opacity:.3}to{opacity:1}}@-moz-keyframes showPanel{0%{opacity:0;-webkit-transform:scale(0.95) translate3d(0,0,0)}100%{opacity:1;-webkit-transform:scale(1) translate3d(0,0,0)}}@-webkit-keyframes showPanel{0%{opacity:0;-webkit-transform:scale(0.95) translate3d(0,0,0)}100%{opacity:1;-webkit-transform:scale(1) translate3d(0,0,0)}}@-ms-keyframes showPanel{0%{opacity:0;-webkit-transform:scale(0.95) translate3d(0,0,0)}100%{opacity:1;-webkit-transform:scale(1) translate3d(0,0,0)}}@keyframes showPanel{0%{opacity:0;-webkit-transform:scale(0.95) translate3d(0,0,0)}100%{opacity:1;-webkit-transform:scale(1) translate3d(0,0,0)}}@-moz-keyframes hidePanel{0%{-webkit-transform:scale(1) translate3d(0,0,0)}100%{-webkit-transform:scale(0.98) translate3d(0,0,0)}}@-webkit-keyframes hidePanel{0%{-webkit-transform:scale(1) translate3d(0,0,0)}100%{-webkit-transform:scale(0.98) translate3d(0,0,0)}}@-ms-keyframes hidePanel{0%{-webkit-transform:scale(1) translate3d(0,0,0)}100%{-webkit-transform:scale(0.98) translate3d(0,0,0)}}@keyframes hidePanel{0%{-webkit-transform:scale(1) translate3d(0,0,0)}100%{-webkit-transform:scale(0.98) translate3d(0,0,0)}}#a0-lock .a0-zocial,#a0-lock a.a0-zocial{color:#fff;text-align:left;text-decoration:none;white-space:nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:block;border-radius:3px;padding:0;margin-bottom:6px;cursor:pointer;overflow:hidden;-webkit-transition:opacity .2s ease;-moz-transition:opacity .2s ease;transition:opacity .2s ease}#a0-lock .a0-zocial:hover{opacity:1}#a0-lock .a0-zocial span,#a0-lock a.a0-zocial span{text-transform:uppercase;font-weight:400;font-size:11px;line-height:40px;display:inline-block;padding-left:4%;width:86%;cursor:pointer;-webkit-transition:all .2s ease;-moz-transition:all .2s ease;transition:all .2s ease}#a0-lock .a0-strategy div.a0-zocial span{text-transform:lowercase;font-size:12px}#a0-lock .a0-zocial:hover span,#a0-lock a.a0-zocial,#a0-lock a.a0-zocial:hover span{background:rgba(0,0,0,.2)}#a0-lock .a0-zocial:before{font:14px zocial;font-weight:400;float:left;display:inline-block;line-height:40px;width:16%;cursor:pointer;text-align:center;background:rgba(0,0,0,.3);-webkit-transition:all .2s ease;-moz-transition:all .2s ease;transition:all .2s ease}#a0-lock .a0-zocial:active,#a0-lock .a0-zocial:focus{outline:0;opacity:.4}#a0-lock .a0-zocial.a0-icon{overflow:hidden;white-space:nowrap}#a0-lock .a0-zocial.a0-icon:before{-webkit-box-shadow:none;box-shadow:none;border:0}#a0-lock .a0-strategy{margin:10px 0}#a0-lock .a0-zocial.a0-amazon:before{content:"a"}#a0-lock .a0-zocial.a0-dropbox:before{content:"d";color:#1f75cc}#a0-lock .a0-zocial.a0-facebook:before{content:"f"}#a0-lock .a0-zocial.a0-github:before{content:"\\00E8"}#a0-lock .a0-zocial.a0-gmail:before{content:"m";color:red}#a0-lock .a0-zocial.a0-google:before{content:"G"}#a0-lock .a0-zocial.a0-googleplus:before{content:"+"}#a0-lock .a0-zocial.a0-guest:before{content:"?"}#a0-lock .a0-zocial.a0-ie:before{content:"6"}#a0-lock .a0-zocial.a0-linkedin:before{content:"L"}#a0-lock .a0-zocial.a0-openid:before{content:"o";color:#ff921d}#a0-lock .a0-zocial.a0-paypal:before{content:"$"}#a0-lock .a0-zocial.a0-stackoverflow:before{content:"\\00EC";color:#ff7a15}#a0-lock .a0-zocial.a0-twitter:before{content:"T"}#a0-lock .a0-zocial.a0-vk:before{content:"N"}#a0-lock .a0-zocial.a0-windows:before{content:"W"}#a0-lock .a0-zocial.a0-yahoo:before{content:"Y"}#a0-lock .a0-zocial.a0-office365:before{content:"W"}#a0-lock .a0-zocial.a0-thirtysevensignals:before{content:"b"}#a0-lock .a0-zocial.a0-salesforce:before{content:"*"}#a0-lock .a0-zocial.a0-waad:before{content:"W"}#a0-lock .a0-zocial.a0-box:before{content:"x"}#a0-lock .a0-zocial.a0-aol:before{content:"l"}#a0-lock .a0-zocial.a0-renren:before{content:"r"}#a0-lock .a0-zocial.a0-baidu:before{content:"u"}#a0-lock .a0-zocial.a0-fitbit:before{content:"#"}#a0-lock .a0-zocial.a0-yandex:before{content:"&"}#a0-lock .a0-zocial.a0-wordpress:before{content:"w"}#a0-lock .a0-zocial.a0-dwolla:before{content:"D"}#a0-lock .a0-zocial.a0-shopify:before{content:"s"}#a0-lock .a0-zocial.a0-yammer:before{content:"!"}#a0-lock .a0-zocial.a0-miicard:before{content:"m"}#a0-lock .a0-zocial.a0-soundcloud:before{content:"t"}#a0-lock .a0-zocial.a0-evernote:before{content:"n"}#a0-lock .a0-zocial.a0-ebay:before{content:"e"}#a0-lock .a0-zocial.a0-sharepoint:before{content:"p"}#a0-lock .a0-zocial.a0-weibo:before{content:"S"}#a0-lock .a0-zocial.a0-instagram:before{content:"i"}#a0-lock .a0-zocial.a0-thecity:before{content:"c"}#a0-lock .a0-zocial.a0-planningcenter:before{content:"y"}#a0-lock .a0-zocial.a0-amazon{background-color:#ffad1d;color:#030037}#a0-lock .a0-zocial.a0-dropbox{background-color:#007ee5;color:#fff}#a0-lock .a0-zocial.a0-facebook{background-color:#4863ae}#a0-lock .a0-zocial.a0-github{background-color:#eee;color:#050505}#a0-lock .a0-zocial.a0-wordpress{background-color:#1e8cbe;color:#fff}#a0-lock .a0-zocial.a0-dwolla{background-color:#F5891F;color:#fbfbfb}#a0-lock .a0-zocial.a0-gmail{background-color:#efefef;color:#222}#a0-lock .a0-zocial.a0-google{background-color:#4e6cf7}#a0-lock .a0-zocial.a0-googleplus{background-color:#dd4b39}#a0-lock .a0-zocial.a0-guest{background-color:#1b4d6d}#a0-lock .a0-zocial.a0-ie{background-color:#00a1d9}#a0-lock .a0-zocial.a0-linkedin{background-color:#0083a8}#a0-lock .a0-zocial.a0-openid{background-color:#f5f5f5;color:#333}#a0-lock .a0-zocial.a0-paypal{background-color:#eee;color:#32689a}#a0-lock .a0-zocial.a0-twitter{background-color:#46c0fb}#a0-lock .a0-zocial.a0-vk{background-color:#45688E}#a0-lock .a0-zocial.a0-office365{background-color:#00ACED;color:#fff}#a0-lock .a0-zocial.a0-waad{background-color:#00ADEF;color:#fff}#a0-lock .a0-zocial.a0-thirtysevensignals{background-color:#6AC071;color:#fff}#a0-lock .a0-zocial.a0-box{background-color:#267bb6;color:#fff}#a0-lock .a0-zocial.a0-salesforce{background-color:#eee;color:red}#a0-lock .a0-zocial.a0-windows{background-color:#2672EC;color:#fff}#a0-lock .a0-zocial.a0-yahoo{background-color:#a200c2;color:#fff}#a0-lock .a0-zocial.a0-aol{background-color:#0861A8;color:#fff}#a0-lock .a0-zocial.a0-renren{background-color:#0056B5;color:#fff}#a0-lock .a0-zocial.a0-baidu{background-color:#2832E1;color:#fff}#a0-lock .a0-zocial.a0-fitbit{background-color:#45C2C5;color:#fff}#a0-lock .a0-zocial.a0-yandex{background-color:red;color:#fff}#a0-lock .a0-zocial.a0-shopify{background-color:#9CC24C;color:#fbfbfb}#a0-lock .a0-zocial.a0-yammer{background-color:#0072c6;color:#fdfdfd}#a0-lock .a0-zocial.a0-miicard{background-color:#C7EAFF;color:#303030}#a0-lock .a0-zocial.a0-soundcloud{background-color:#ff4500}#a0-lock .a0-zocial.a0-evernote{background-color:#6bb130;color:#fff}#a0-lock .a0-zocial.a0-ebay{background-color:#000098;color:#fff}#a0-lock .a0-zocial.a0-sharepoint{background-color:#0072C6;color:#fff}#a0-lock .a0-zocial.a0-weibo{background-color:#faf6f1;color:#e6162d}#a0-lock .a0-zocial.a0-instagram{background-color:#25537B;color:#fff}#a0-lock .a0-zocial.a0-thecity{background-color:#767571;color:#d1d1d1}#a0-lock .a0-zocial.a0-planningcenter{background-color:#4e4e4e;color:#d1d1d1}#a0-lock button:-moz-focus-inner{border:0;padding:0}@font-face{font-family:zocial;src:url(https://cdn.auth0.com/w2/font/zocial-regular-webfont.eot)}@font-face{font-family:zocial;src:url(data:application/font-woff;charset=utf-8;base64,d09GRk9UVE8AADtIAAoAAAAAOwAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABDRkYgAAAA9AAANq4AADaug3fsOE9TLzIAADekAAAAYAAAAGAOkw4WY21hcAAAOAQAAADUAAAA1AS6BUxnYXNwAAA42AAAAAgAAAAIAAAAEGhlYWQAADjgAAAANgAAADYED4nAaGhlYQAAORgAAAAkAAAAJAl7BahobXR4AAA5PAAAALQAAAC0rHQDzG1heHAAADnwAAAABgAAAAYALVAAbmFtZQAAOfgAAAEwAAABMOrQjR1wb3N0AAA7KAAAACAAAAAgAAMAAAEABAQAAQEBB3pvY2lhbAABAgABADv4HAL4GwP4GAQeCgAJd/+Lix4KAAl3/4uLDAd+MBwF5/pcBR0AAAESDx0AAAEXER0AAAAJHQAANqUSAC4BAQcNDxEUFxodICMmKSwvMjU4Oz5BREdKTVBTVllcX2JlaGtucXR3en2Ag4aJjI96b2NpYWx6b2NpYWx1MHUxdTIwdTIxdTIydTIzdTI0dTI2dTJBdTJCdTMwdTNGdTQ0dTQ1dTQ3dTRDdTRFdTUzdTU0dTU2dTU3dTU5dTYxdTYydTYzdTY0dTY1dTY2dTY3dTY5dTZDdTZEdTZFdTZGdTcwdTcydTczdTc0dTc1dTc3dTc4dTc5dUU4dUVDAAACAYkAKwAtAgABAAQABwAKAA0BYAJcA9wEmwUOBhUHaQgbCMAJtAvHDQ4NuBAjExcT0xTnFjYXYhl1GvkcJhyOH5gf5SGjItIjdCUHJxooDClmKgMrAy1LMB8xizJ+M6I0wjUw/pQO/pQO/pQO/JQOo/m5FY+jop6ki6CMoH6Ud8X7J8X7J8X7J42NjY2LjsL3I8P3JMD3JJaiqZejgaODmW2Dcjz7VT77Vj37Vgh8ZXpjcWp4c3F4boJlf2KLZJBzj3qkj6OOnJianJCYj5mHmIukiqWRnpuhnZellaQIj5iSl5CXipGIkImQRPdARPc/Rfc/h5aJlo2XCPm1TxWhkqZ/lXaVdoVvd35bcVlyWHVvgHCAboJ+iH2Hfo2IjIaMi46LkpCQjpCcn5+bn5sIrqivpbCloZmfm6KXCOj7pBWajJmOmoqkhpxxh3OJc3V3c4xXjFeMVpBsjmyPbZJ/joCOgJGHjYiPiI+Qk5SNk44IopOjkKOPwpXCksOQCPvb+0EVko2SipOKpIejgqKCyHPGbsVtnIOVd4p5ind9eXmFfoZ8i4CTZaNmpWelaqRqpG2oCIOTg5KGlYiOi5KQjQgO+mj52BVN3SOj+wBpaIBih2eS+6zH+377I0P7qoh9gX6Efotmi2aLZpN4lXiQd8X7hPdn+yX3lKT3daH3Q/ddlPeACIy4nbuis8LpjOxM3gj8Iv2uFfs+WvtQ0yj3LCf3L5b3UfcJ9yP3AfcY90q/9ylNiFp+dE2U+1Gk+y/7FHH7V3b7L/cc+z73NnX3T3L3L/cMqfdTlMaLi9iKCIn7avsC+yz7TlUI91b4RRX7BYsu5ov3A4r27fD1jfcAjvUhiPsBifsDLTH7BIwIc/f7FSx5YlOKO4s2uFPneIv0i++L9wEIvfvIFeuju8WF3IXaWL06kIsoiyiLKAgO+Rr3gRWLs6qpsouzjKxqi2WKZWtsZItji2ypi7II9+73XBWLZGxsY4xli2urirGLsayrs4qzi6hui2II++73XRWLs6uqs4qxi6xqi2aKZmtrZIpki2uqi7II/Pr7XBWLs6iotIuyi6ttjGWLZWtqY4tli2uqi7II+PqLFYuzqai0i7KLq22MZYtlampki2SLa6uLsQj7oIoVimVsbGWLZItprIuwjLOrqbSKs4uobYtjCPcZ0RW0i6ttimOLZWtsZItki2uqi7KKsauqsosIjPebFWWLa6qKsIuxrKuxi7CMrGuMZotkbGxjiwiL/bYVZIxrqYuxi7CsrLGKsourbItmi2RrbGSLCNL3ohWLZWtsZYpki2qsi7CMsKyrsIuyi6tri2YI++2KFYuzqKm0i7GLqmuLZYtlbGxki2SLbamLsgj3pvhqFbKLqm2MZYtkbG1ii2SLbKqLsYyxqaizjAj7YPsdFWSLa6mKsYqwrKuzi7OKqG+LZItjbm5jiwgOb4u9Ffdb+iT4VIsFrYushat/q36oeKVypHGda5VklWSLXYFWdy5fQkdWR1U8cS+LCPtPi0r7w/ubiwXx+wQV95yLy/fC91CLBeeL26bOwM/At9Sf6J7nfdZaxKJZj1F8SXguX0JHVkdWO3Awiwj7UItL+8L7cYsF95D4rxXgi7b3T/cUiwWMi5GKlYmGn4Cbe5d7l3iRdYsI+xSLBdP7jRWrjKqYp6Ooo5ynk62LjIuNjI6MjouNi4wI+wmLBQ75PPonFfsfiwX7HYv7ByCL+2OL+xDDMO9eCPtP++4FhYCRgpWLCOKLBZKLkI6NkQj3PffnyIuL++cFi4ePhpCLCNaLBZKLjo+LkQiL+ikFi5SGj4OLCDr8kxVYiwU7iz3Hi/cqi/cx1MrViwjJi4v8QgUOi/ljFYuckJuWmZaZmZScjwj3XrsFYFp2UotJi/sS4Sr3QUiehJ2DnYGdgp2An32efZt7l3mXeZF4i3iLbX90c3tze3CCbIsIY4tik2CaYJtnn2+lCDr7SwWxdrx2x3eEiYGIfId8hn6If4mAiICKgYt6i3uRfZV9loKZh5wI+zz5VAWKk4qRi48I+EFcFYull5+jmaOZpZKni6yLsYW0f7V/qXudeAjK90IFTatMoUmVjYuaj6mTqJSjkZ+Pno+ajZSLnIubhpmAmYCUfY96CPc8/VQFjIOMhYuHi3qGe4B9gH19gnqHCPspaAWru5u/i8OL13PJW7xbvEywPaX7CbJRu4vDCA73UIv3DhWLx6nAyLnIutSi4YsIw4sFbqZ9qIuri5+QnpafhIqBi36LRItRoV64Xrd1wovMi8mnwcO5w7rKotOLCPfSi0RYJosFrH+kc51pnWmUZYtii0ttVE9ccnd6e4SAg3+HfYt6i36Vep13nXieep19tW6obZtsCJtsk2WLXItOb1VTXlNeP3QsizCLPpxMrUytbLiLwwj3B60Vi1yfY7Nqs2q8eseL3IvGmq+psKmds4u9i5iKloiUiZKIkomSiJGHkoWRhpKGkIeQCIePhJGCkoKRhJCGj4aOg5F/lH6TgpGGj3CTcY9xi06MVXtdal1qdGSLXgjO+NEVk1WfXK1krWSweLSKtIqrnKOwo7CTuITBhMF3uWmxabBmn2KMYoxrenNnc2eCXpJWCPjNchWLvvdgi4v3Yb+Li/th92GLi1j7YYuL+2JXi4v3YvtgiwUO+Of3yRX7O4t0Pfsqi/dH+G73NIv3Rvxu+y2Lc9kFbPIVV/c+V/s+84sF+GObFYv7svt8+337s4v7sov7ffd9i/eyi/ez9333fPeyi/ezi/d8+3yL+7MI/Jb4FxX7a4v7QvtCi/tri/tr90L7Qvdri/dri/dC90KL92uL92v7QvdC+2uLCIpmFftWi/sy+zGL+1aL+1f3Mvsx91aL91aL9zL3MYv3V4v3Vvsy9zH7VosIDvuEjfcrFYuaj6GTqJvGqcG2u7a8vq7EoVW2cMKLzovFoL22tLa0vaDGi8aLvna1YrZioFmLUQiLSHFVVmDUccdgvE67TqNHi0GLTHJnWoKIhIeChICHgIOBf4N/gnuEdYZ2hXqHf4gIfol4iHGHcYh+iYqLiouIi4iKh4qJi4qLCPsPiwVoi1+RVpZVlm2ahJ9/loKZhp16jn2Sf5ZxlX6oi7oIDvwci+gVi7+esbKkn5ielZyS2Ky1npGOfKB5onSlaLR3o4WSQOVr4JbZj7GaqqOjk5Walp+XCKSampORjo6Mk46XkZeQlY+Tjgi7odKqBbKcqZielpiSlImOf4uEgoJ5gmFwdWSJWIt3jHiPd494kHuPfpB+k3yYeJh4lH6RhQiQhJd9nXeddpZ/joeQhpSAm3mbepZ+koOSg5R+mHmXeZR8kH2RfZB7kHeQeI53i3YIi3KGc4J3g3WCeX9+gH57fXZ+c3x5gX6FfIN2gnGAgId/hn6FfYWEh4mLCC9jZ3gFdYB6hH6IUX1ek2qpaqp7tYvACA77PIv5GxWLppCflZeSlZOSl5CXkZuOn4sI64sFlouTj5OSk5OOk4uWi5mLmoqbCIvHBYucj5qUmJWanJWjkpKPnY2oiwieiwW0iqyFpoGlgJp2kGudjJuLmouvi6qJo4jNg7eDoYOogp10k2aRZZJEkCGOTo1Zi2MIi22Kc4l5gPsKfDV5U4FugnOBeYJ5gX2CgIKAfoN8hnuHfYh9in6Kd4pwi0KLWZRxnAhynX6vi8KLqo6jkp2RnpaXm5OckpqQm4yVjJmLnIsIqIsFjYuNi4yKjIqMiYqJioiKiYqIioiKh4qHioaLhouHi4WLhY2EjIWLh4uJiomJioeLCHaLBYuLiIuEi4SLiIqLiouLiIqFioWKiImMiouJiYmHiYeIioiMh4yIi4eJh4uBjIOOhQiOhY2GjoiNh5GJlYqViZOLkIsIrIsFsoukj5aUlpWQoIuti7+Frn6df513lnGPT5FjknWSZ5l5s4vPi4yKjIqLiYuKiouKCItdhWJ/ZwiCcgWEen6DeooIhIsFe4t5jnaQNJZIm1qge5N+mIOff6N/t37Lf8uDuIemiKKKnIuYCJH3DhWLjfdQ90wFi4yLi4yLCIeFBYR9h3uLeIt8jGeLVIuEiIiEiwgsiwV0i3aHeoSIiYiJiIoI+Nr7vRWZjZuMnIuqiqaFpH+LxXapYYwIiIsFd4t8hIF+gXyFeoh2CA78AIv3DhWLx6nAyLnIutSi4YsIw4sFbqZ9qIuri5+QnpafhIqBi36LRItRoV64Xrd1wovMi8mnwcO5w7rKotOLCPfSi0RYJosFrH+kc51pnWmUZYtii0ttVE9ccnd6e4SAg3+HfYt6i36Vep13nXieep19tW6obZtsCJtsk2WLXItOb1VTXlNeP3QsizCLPpxMrUytbLiLwwj3B60Vi1yfY7Nqs2q8eseL3IvGmq+psKmds4u9i5iKloiUiZKIkomSiJGHkoWRhpKGkIeQCIePhJGCkoKRhJCGj4aOg5F/lH6TgpGGj3CTcY9xiwiHiwVQi1Z7XmtdanRki14IzvjRFZNVn1ytZK1ksHi0igiPiwWyi6mdo66dqJSti7KLlYuXiZeEwXe5abFpsGafYowIh4sFZItsenRoeG+CaYtki4CMgIyACA6zhvnbFYutl6ejoqOhqpaxi7CLqoCidaN1l22LZ4tqf3B0dXN1bH9kiwiKiwVli22XdKFzooCni60ImP4UFYv5QPd4i4v9QPt4iwX39YsV93iLi/gSBYujjp2QmJWjmZ6fm56bo5Opi9eLsViLJAiL/AL3eIuL+BwFi/Bz2Fu/W79Mpj2LM4tGZVo/CIuJiouMjYvs+3iLBY11jEeL+waL+waK+zSJ+2IIDvdugvl0FZKQk4+VjpWOk4yTiwiUiwWSi5OLlYqaipaLkouPi5iMoIyWjJWLlIuUipOLkouYipaIk4eQiY+GkIWQhI6Ej4UIjoWPgo+AkICPg42IpVOrU7FUjImOh46GjoWOh46IjYiOh4+Gj4eOh4+IjoiPiI6ICI+Ij4mPi4+Kj4uPjJ+OlbON14yYi5eLlou+hq6BnoeShpGEkIWPgo+Bj4GPg46FjwiVnpyXo5KjkayOtYsIwYsFi4uUi52KnYuUiouJCKKGBYuLkoiYhJiFkIaGiJF/j3yMe4uGi4eMhot9inmJdYhvinmLhIl8inuLe4t/i36NfQiObZV2nYCRi5CNkI2RjZCPkJCRkY+PjY2NjY+RkZSSlI6PjIyrtavDq9AIlaIFi4uPlJKdk52PkoyGi4aQkJaZlZCYjZqLCJWLBZiLm4qdiqGKm4qVi5GLlIuYjJiMlouUjJWLlYuWipWKlImSiJGIkIaOho2HjIaLhgiLeH9tc2OAd396f3t/ent4eHN4dH97hIOKiYaFg4CDgIWDh4WHhoeDh4GHgoqCi4IIi4aMho2GjYaPho+GkIWOh42IjomPhpKFkoWPh4yKvF6xY6dopmeZcot7i3V6fWiFCHmIeYp5i3yLfYx8jX2MfoyAi3mLfIl+iAiEiwVek1yrWcOIjoaSgpaCl4OThZGFkoOQgpGBkIKNgop7iIGBhnqGeoh3inOJdIh6hoIIgnpwg16LeIt0jHGOVpFbmF+hYKFponGjcqRwqm2yROZH9wJM9xWJj4eShpeFloeUiJEIiZGHk4iVh5WIlImVipSKlIuUCA73hIv3oRWL9wLK9wr3EfcT29rcw9yqsZusk6eLqoukgZ15nXmUc4tri3aHcoJviYKMhZCJj4iRi5GNCJWPBc2mxZm9i76Lr32hbpV8kHmLd4t2hnKAcIaEioWOh46GjoiNio6JkImSibZ+r3apbgipbppmi1+LY31ib2FvYWVlW2hbaE5uQXVCdD2AOIsyizeYO6U7pkmyV79Wv3HHi84I9xRaFZJGtVTaYspp0nvbi5+Ln4ygjfSV4qzRw8m+q8SLyIuRipGLkYTQYME9tEutRJs7iwh3i3eKdolGhU15U29Tb2BpbWJxZ35li2WLhYuFjIUI9zhLFYKfh5+LoIuikaOXo6C3r6y8oaqYqpKri52Lnomdhr99sG+iYZZ1kXWLc4t1hnWBdQh1WmZoVnRtfm2FbYt0i3SPdJJZm2moeLcIxJ8Vj3qWf5uElIeUiZWLk4uTjJOOnpGalpWckpWOlouWi5CKkImRh5uBl3uRgo+CjYKLCIOLgomCiHmFfYCBfISAh4CLf4uGjIeMhwj3JdwVjYSPh5KIjoqPio6LjouOjI6Mk46Qj4+SjpGMkYmRiZGHkISNhY2Fi4SJg4iGh4iFCImHioeLhwiLhQX33PkPFYuPio6Lj4uUjpOQk5KWlZKYj6KQo42ii66LrYasgcR4vGu0XrRepVeXUJBzjnSLdAiLaIVqgGsIi4oFh36DgoCFg4iEiYOLhouGjIaMfo+Ck4WWiJOJkouSi5CMkYyPCIuMBZOjjqKLpIubipuInIK2eLBuq26raKFimHSSc49zi3qLe4l6iIeKiIuHi4KLgo2DkQiAkoSViJgItPs0FYuOio6Lj4uSjZKPkpGVlJGXjpiOmIyXi7mLsnmsZ550mHKSbo1/jICLgIt7iHqFewiIgISDgYaFiIWJhYuGi4aMh4yAj4OShpWIkYqRi5GLkIuPjZCNlI2Ui5OLnoOcfZoIfJ15lHWLhIuEioSKiIqIi4iLhIuDjYWQgZGFlIiWCA73fouxFZ+JoIqfi/cNi/aw6dVTjFmcXqxfrW21er+ZiJuKnYuji6KOoZFPl1moZLtkunfCi8kIi44Fr3ezgLWKZ6NvqXaxd7GAtIu4i7mXtqO0yzvaS+dc6FvucfWFhqKIn4uci9Klx72+CL69yKXSi9aLym++VcaXwqC9qXhNZVtTar2RvJm8oGpYYF5XZQiLaQWLRoBGd0Z3RWxJYkxiTFpTUVlSWkZkO247bjR9L4v7Iov7GLH7DtgIDvcoi/lBFbG3sLOxrbCurKamnaedpJmhl6GWm5KWjwicjwWTjJSMk4uYi5eJloechJp/lnqWe5V4lHaTdpNzkW6Rb5Bxj3KPcpBwkG6QbZBzkHgIoTacTplomGeZeZqLnIuhnqixqLGrvq7NnayUqouoi5SKk4qShK56oW6UhI6DjIKLCHOLb4JqeprjudPXwcW0xp/Ii5OLlIuTitCGu2ykU5dxkm2LaYt3iHaHdX9Gc0RoQghoQ2RLYVNhVF5WW1laWGFjZ25nbW10cXpuenCDcotyi3SSdJp1mXebfJ57nX6fgZ8If6Vp8VX3RlX3Rmrqf5mLjImNiYyJjIaNhI2EjIOLgoqBiX+Ge4N8hHp/eH0IDveCi7wV9wD4EAWimKmWrZKuk6ePoo0IrYwFrouuh7CE0H68dqhvCCH8DwVynnCbbZdul3OSeo0IcY8Fc411jHaLgIt9inmKeYpuh2SCZINtgHd9CPcV+HwV9wD4EAWimamVrpOtk6iPoowIrIwFrouviK+E0H28dqhvCCH8EAVyn3CabZdul3OSeo0IcY8Fc411jHeLgIt9i3mKeYpuhmSDY4Ruf3Z9CPhN/KEV9vgQBaR4p3uof6l/ooSciQilhwWiiaGKoYuWi5mLnYydjKiQspOyk6mWn5kIIPwQBXN9boFog2iEb4d0ighpiQVpi2eOZ5JGmVmgbacI9w/4ehX2+A8FpHime6l/qYCihJyICKWHBaKJoYqgi5aLmoydjJ2MqI+yk7GTqZagmQgg/A4Fc31ugGiDaINuh3SKCGmJBWiLaI9ok0aYWaBtpwgO+BiL+dYVkXgFjoaNiI6IjYmNiYyKCI6JnoH3Bov3uvv0BZKCj4OLggiL+1kFi4aKh4mIioiJiomKCIiLBT6LW4p2iYSLiIiLhQiLUviki4vGBYuNio2KjImMiYyKiwj7KYsFhIuIkIuVCIv3YwWLjYuOjY2NjoyNjo4Ijo4FkpLl4PdB9zcI9xyLBZGLkY2SkAicngWPkI2Ri5MIi5kFio2KjYqMioyKi4qLCPxVi4SFBYuHi4eNho2HjIiNiAiOh6J0nYT3Cov7aPtc+333vrWLBZSKko2RjgjRoQWMi4yLjIyMi42NjY6MjYyOi48Ii5kFi42LjYmMio2Ji4qLCPyMiwWGi4eIiocIi4MFHATD9wQV91GDNvzYTY4FbvtZFY/3BfcFh4f7BQUO74z3PBWOkZGLkob3Pyj3Tlr3XIv3Gov3GKT3F72OjJCNko6RjpCNjYyWj5OJkIORg4mDgoR/gnuBeIAIUGhKcEJ4Q3hEgUaLIYsmniywLLA2v0DPh46Jj4uOi42MjYyNCPfI97gVi7qXtKKsoq2rpLOcsJu5lsCSno2pjbWPCIucBYu3hqiBmn2gdJVtiwiCiwV1iXiEen97foB6hnWJfoSDgIkI+wqZBYCOhZGLlYuNi42MjpbIqLi4qLmowJzHjgiliwXZi8h3tmOShJKDkISRg5CEjoWPhY6CjX+Of42DjIeNh4yBjHyLfYyCi4gIi/uMBYt6jXqQfZB8kICQhZCEk4GWfY+FjYWLhouGiIaGh1JabHCGh4OFgYqAkIGTg5OEkwiEkoWRiI6IjoaShJWFlYaSiI5lYWVxZoF0hG+IaItXi2Cbaaxpq3q5i8YI90SgFYtwknaYe5l7nYOhi42LjouPjI+LjYyMi6iSoZ6bqJOYkJmPm4+ajZeLlYuUjJuLoQiLpQVji22IdoVPem1li1EI+EL73hWNjo2Ojo2cl5uTm4+lkqSOpIyRjJKKkYqqiJ2GkYSOh4yEi4MIi4QFi3OFb35rfmp5cXR3h4mIiYiLiouKi4mMh42Kj42QpceXtIuii5OKkIiPhJN4j2yLCH+LfYp8inqJe4l9iYeLiIyJjIqMi42LjIuMjIyLjAgOs/dfFZOBkoCUgZx4nXmge7ZpvXO/esh3yoHJhdWF1YvTk8+SzpnKpMOiv6q4tJeVlpaUmAiTlpGWjJmNmoibiJuInIach5uJkoqRiZF71HLSaM1uw2fAYrtkt16yV6dvmm6XbZQIe5B7j3qPh4uGjYeLhouFi4aLgIuAi4GLhouGi4aKh4uGioeKg4qCiYOJeod7hnuFCGx/bXpveFVlW1tjV2FTaUxxSnBGeEN/QYmBiYKLgYuGi4aLhouIi4qMiYyJjIqMiQjPuRWMkIyQjI+NlI2UjpSXrZ2qnaqVmpSalZqUmpWalpmdoqKkp5W0mKlgo3GYfZl7noMIk4eUiZWLmIyXlZWTp6KhqKGno6uhq6anlpeXmpuQko6TipKIj4mOiY6IjoePiY+ICKh1pnKkcaF1oHOfc55znnObcJ9rm2mea5ttnGh7aYqJioqKiW1ZVmxWd0xyR39IhwhFhkSLRpJMkUyWT6JanlunarWDlYWWhZaKjIqNi4yKjYqMjI0IDlfY+ioVV2KF+6wFiPsujfsRjouQi6uXr5nls9149xsyrnWZiZWakpiKl4KOUKD7Fe5wumHPiO+y3eD3R/ecjub7Rwi9LIAqRPsHYkaEeKCCmoSio6jFuujg28OPn4ysjZ+NqoyOmIvvjfcfesZRuGKsbY376IsI+/2LhotXYQiLiwX32Ps8FVx6TzmLWos8rF/3CET3CEaxf2K7e56So67IvemJ1FDJY7dBnFN4CIuLBfhs+7EVZ3xmY2VJbFV1Xo6Jumz3Mkeji66LiYOP90aO9zt6ojBkCIuLBf1++1sVV3hQOYtZi/sO9ww79wW6zqn3DvdiWIt8i2WbbZxJtU2XWnoIi4sF+Jr7ERX3pyScOfwrj/cQ904F+8/7RxX3H/dX5YT7Evtc+wmOBQ6Xf/g0Ffdv9zv7b/c699L3ZPdk+0b3afdG98n7Wvte+z33XvtC+877Uftk9zT7ZPs0BSdHFYvG61L3ZPczjIqL/AAF+8D5ChX3wftR98P3XPvB90IFiP3DFYz4AI2M92P7M/HJi0oFDvg1i/fGFYugjZ2Omo+bkpuWm5abm5mglJ+VqJSvkbCSt46+i8eLvYa0gqaGn4WYhAiL+zn7wIsFi32Lf42DjIKOgZB/kH6UgpiFmIWciKCLxYuooIu0CPcQi4swBXiCeIV3h12AWIZTi0yLV5Bjk2OUbZh4nXidfp6Fn4SgiKSLqgj3X60V90qLBYuYi5SJkYqQiZOGloaVgpJ9kH2QeI11i3aLeYl+hn6GgoOGgIaBiIKKhoqFi4KLgAj3wPtOFYvm24sFimhybllyioqJioqLCIuLFYyLjYyMjL2kpKiMrgg7i4uz3osFi5OMk4uTi6mGpYKhgaVzoGebCIv3T/cBi4v7Y42LBaGpqZqyi6iLooKdeXB3fWiLWotEpWG/f4p1iXmIe4h8hnuEeoN7gH58g32CeId1iwhgi2yceK0IiouLYCKLi9wFi/cXFYv3OQWve6N2lXGUdZBxi22Lg4qDi4MIOIsF9wGAFYtWjmeRdpF2l4Gdi5+Ll5WRoJGgj6+LwAiLkAWLo4qdipaLlomYiJmJmYaUhZGEkIKOf4uAi4OIhIWFhoaAiX2JfYl+in+LgIp4i3II9w7RFYu8ma6mn5d/lHmRc5FzjniMfYx9i3WKbgiLVgVXl3G1i9IIk/c2FYu6maymnKOcrZS5i46Lm4qqiQj3AvtziyIFi4KLfo16jHmMgIuFCCSLhsCJiwV1Y2h4Xot+i4KLhowIi8AFi6iLoYuZipmInoWjhaOCnX+XpZ+5lc2LCKSLi6oFi5+ImoWUhZV/kHmLeYuAhoaAhoCJfIt3CPsCiwXv+zEVi2CZdqeLlIuSjZKOkY6RkI+Rj5KOkY2RjpCMlIyVjJaLk4uQjJGLk4qWi5aLkouNCIiLhYuDi4KKhYuJiwh8iQWLi4eKgYmBiYiJjYmOioeIg4eCh4iHkIiPiIqFg4SDhIuEkoUIz/feFfcyi/H7gfcE94H3Jov7VfwDi/tX+ySLi/dXX+aL6AWLsYOofaF8oG6ZX5EIi4sVt4WofZp2mXWTbotlCIsuBQ77UPez+DEVi/dY9zGLi+0Fi9Kix7q9ub3CpM2LCPcxi4v7WPsxiwWBi4KGgoCDf4d+i3oIiyf3WYuL+1j7WYuL/G77WYuL+G77MYsFDkuL6xWLYKBmtWy2bL58x4vHi7+ataq2qqCwi7aLtnaxYKlhqleaT4uKi4qLiouKi4qKiosIe5qCnIuci5yUnpueu460na2urK6ctIu7i56JnIaano+aj5aSCIv3CQVqdmaAYYsIhIsFbKBolWaLV4tgemdnZmh5YItYi2uUbZtwm3ChdaZ6eHOCcotxi3KUcZxxbH1yeHl0CHhzgnKLbwj3EPhOFYuikp6am5qbnJOfi5+LnYOZe5l7kniLdIt1hHd9e317eYN3i3eLepN8m3ybhJ+LoQiO/E4Vi52Um5yXnJihkaSLpIuhhZ1+nH+Ue4t5i3mCfHp+eX51hHKLcot1knqYepiCmoudCPfn+aQVi6KTn5ubm5ufk6KLooufg5t7nHuTd4t0i3SDd3p7e3p3g3SLdIt3k3uce5uDn4uiCJ79KhWL+H73HouL/H77HosF9074FhXDi4v7uAWOdpF6lnyWfJaBmISYhJiGmIaXh5aJk4oIn4sFnoubjpqQmpGWkI+RCJKUjvAFboN1hnuLiIuHi4mMe42CkYiUCIeYBYuNi4yKjAiL94joi4vzLouL6vsSi4ssU4uLIwUOhvll+OYV976Li/xdBYv7AzAx+wOLCPz8iwX7A4sx5Yv3AwiL+F33vIsFbWF5V4tSi/sk9wn7CPcki/cki/cI9wiL9ySLxHm/bbUI9773ORWL+xn72YsFXLtJqUOLQotJbVxbCPvXi4v3GQWLzq3HvrAIi/tttIuL94MFlY+VjpWOCIv7jbSLi/eSBYyLjYuMiwiji4v7krWLi/eS+LqLBfcDi+Yxi/sDCC/fFYudfJp5iwj7AYsFeot8fIt5CIv7AwWLeZp9nIsI9wGLBZ2LmpmLnQiL9wMF/P/8JBWLx6XBtbCamJyWnZOkl6eRqYuoi6eFpX+dg5uAmn61ZqVVi0+L+wIxMfsCi/sDizHli/cCCMCLFYs5zUndi92Lzs2L3YvdSM45izmLSUiLOQgO+HT5w/j1FfsUiyoni/sQi/sW8C73EIv3EYvw6Iv3Fov3ECrv+xWLCIv7CxXDjLhci1CLUV5cU4tUi126i8WLxrm5wosI+Rf7jhWLYGhoYItgi2iui7aLtq6utou2i65oi2AI+3dLFfsPi4v4v/cPi4v8vwUc+0yLFfd0+L/3B4v3cPy/+zCLcdr7VotxPPsxiwX35/dWFfsHi8X3TsT7TgUO+Hv5TPnmFfvJYfuWZ4WJbINuc3tug3qGfIp3i3uObq/7mKX7UZkmjoSdV7lpwYuVi/rO9ya7k8WUucGLxgiLmkH4t4akhaV4qHWbcpx0km6LgYv7YXD7/1kI9+VjFayAll50cH18doZ2kX6OfZmHmYWgj52ZmZqano+fhQj3lYsVrICWXnNwfnx2hnWRfo59mYeZhaCPnZqZmZqej6CFCP35+zoVroKqcpxoCJF+kpYFlZmio5qWmpWek5yQnI+2i5yHwHyuZJpOk2uMg4v7KgiL+yM5i4r3JgWK9yWLjYeZf7Z0o2mSdY9wh3h+eH94c4Nzh3+Li4v7KAiK+yk6i4r3KQWK9yaLjoiZgqh7onaVaJ1ihGxsf36CfoJ1CIeBifu7OYuK924FivcMi++KjIqOkIurjAiwi4x3BY5Zi4qOkK2/uaPGiZiLmYmRiQj5Eft2FYv7cTeLivdvBYv3DYvujI2MjZSLq4sItYqL+3EF95SLFYv7cTeLi/dvBYv3DYvui42MjZSLrIsItIqL+3EFDvs7i/kYFYumkJ+Vl5KVk5KXj5eSm46fiwjriwWWi5OOk5OTko6Ui5aLmYuaipsIi8cFi5yPmpSYlZmclqOSko+djaiLCJ6LBbSKrIWmgaWAmnaQa52Mm4uai6+LqomjiM2Dt4OhgqiDnXSTZpFlkkSQIY5OjVmLYwiLbYpziXmA+wp8NHlTgW+Cc4F5gnmBfYKAgoB+g3yGe4Z9iX2Kfop3inCLQotZlHGcCHKdfq+LwouqjqOSnZGdlpibk5ySmpCbjJWMmYuciwioiwWNi42LjIqMioyJioiKiYqJioiKiIqHioeKhouGi4eLhYuFjYSMhYuHi4mKiYmKh4sIdosFi4uIi4SLhIuIiouKi4uIioWKhYqIiYyKi4mJiYeJh4iKiIyHjIiLh4mHi4GMg46FCI6FjYaOiI2HkYmVipWJk4qQiwisiwWyi6SQlpSWlZCgi62Lv4Wufp1/nXeWcY9PkWOSdZJnmXmzi8+LjIqMiouJi4qKi4oIi12FYn9nCIJyBYR6foJ6iwiEiwV7i3mOdpA0lkibWqB7k36Yg59/o3+3fst/yoO5h6aIooqci5gIkfcNFYuN91D3TQWLi4uMjIsIh4UFhH2He4t4i3yMZ4tUi4SIiISLCCyLBXSLdod6hIiJiImIiQj42vu9FZmOm4yci6qKpoWkf4vFdqlhjAiIiwV3i3yEgX6BfIV6iHUIDt+L98EViraUspywnK+iqqijp6Oqoa6drZ6umq2WrpWqlKiSqJGikJ2NCKWOi/sSBWSIaIVqgGuBcH53fXZ8eXx8ent6f3uDe4N7hHyGfod+iIGKgwiJfgWJgYqBi4GLfI18kH6Tc5h4nXqde598on2hfaJ/o4OjgqGEn4WfhZuGl4kInoiLIQVJkk+XVpxVnGCeaqFqoG+ic6Rzo3qkgKKAo4OghZ6FnYibipYI+J377BWL+jD3Ju+L/kQFrfihFZGLBaWLpYWlgqiAoYCagQigezZo99U7i/eP+wJMBXCpZaJZnVqdYJVnjwhVkIv7CgUO9zL4GPoGFfsqcPsPdYqLi4uK+0CL+2iL+5WM+xKNi42L+EU+9wt2CJSJi/pagosFhov7E3T7KnAIsvt7FZSJlomPiQiSiIs5fpMFfZRxk32LYYt2XqZtkYWdfZyAwGefb45ejlV3YmN4fIWHimmLZIx9jnOZCIKRi96afQWde6GCooqdi5aQlJeQk4yQipeJoIGYaaJ7lXiahJJUw5nyza2jl6+PrIYI9+j3IhV7hYKFhIOIiIt4i1sIi0qWggWldrCGqJiUj5eSkJAIk5OfgQWqe69mm2sIl3OFhAVsZIpaqmMIkoJ/cwV8bnFvcHlueIaLfZdrplmJanAIgoOL+xeUgwWafJ2EpouojJqRoKCdnpOfjKYIi56dlQW2oLS1o7kIlqKXiQWniLGfnKatwHHUT51/j4CMg4oIf4qDnAV0u2W0W6QId5eKnQWLv2azWI15jIWKfoUIDvfq+UoVu3G1falwq26cjqukq6WzmrmkhvsbqPsQNfsBRzZjhUXbc6Z4q32sZ+Oe6Yb2CPuY/FAV+xP3NOL3hPdVqKT7UHX7N/swPQj5RfhDFfdPYeD7Yyn7Mnx0gIh1mkS7YM+B3YLSktWL1ghT/AcVrmCxXLNbQmtAiT+ts72xuqy0CPvM+x4VQ2pAjECrsruwuq61rGKwXrRYCA5b+Bb6NhVYcWFSbjkIdVBUeQVJd5Sgc/tUg0d7+w+AOYA4hUWPiI6I9xNx9y1vCPeoV/crrAX3CaSslYuUi5KB1n7gf+F09y188XzxfeWJlYiZg45nj2SOgZBvp3Cmg453h3aHh42GmgiCp2OzcJF9jXiUgZNyn3CKW3MIvF8VbHF2Z35Zg26Hhm+EeYd8iIiOhpCdwJ2qrMW4rrGLCKGLb3IFzvu2FY6Ih3KCbX1ihIGCjoWOdY93jVyQbnuLaot4k4GtctFYpF6ETYAlOVYmqXOSbph+lgh0n4uLlq+ZuIuMoX3uSsXULtVgq3yqi72M9wHh0/cMhKaKpYaPhwgO9zGL950Vi5aMmo6ejZ6OlY+Oj4iPgI53jneNfYuCi4GJfYh3iHiHgIeJgpCHpIu5CM2LFYucjKSPrI6tjaCMk4uPjY2Pi46LjYmMh5Mzj12Lh4t6iXOIa4driXeKg4qGiYiIiwiHi4mOi5CKkomfiKuHrIqji5wI3YsVi5uNpI+tjq2NnYuPi5GNjpCLkIuOiIuFkz6OX4uBi4CIXYM4i4aIiIaLhouJjouQCIuQiZ+IroeviaWLnQjqixWLpYumjKiMqI2sjK6Nr4ynjJ+Lko6OkYuSi46Ii4SMgI1ljkqOSo1Zi2mLeYlxh2gIiGiJd4uGi4WIh4SLhYuIj4uRheaIuYuNCOuLFYuwjMKN0o3SjLeMnIyTkI+Ri5KLj4eNg4t1jV2NRo5GjFeLZot6inKIa4lriXaLggiJgoeHhIuFi4aPipSLkoqfiayIrIqki50I7IsVi6aMqIuqjKmMroywjLGMqIufjZWQkZOLk4uQhYyBjHeMboxljGaLaIxtjGyLbotwCIuJiV+HMwiLjAWKgIaGg4uDi4aQiZWH44m3i40I7YoVi42N9wyP94GMl5CSlYuVi5CEjH+Q+4GN+wyLiYuKiWCGNYp/hoWBi4GLhpGKl4fhibaLjAjc920Vi8SMwIu9i5GPkZSRlJCXj5iOl42XjZaMlY2Ui5GLzYvFc7xZvFqmTpFCnpSekJ2LCLOLrXunbKdsmmWLX4tffWVvbG5saXtjiwj8JosFh4uHjYiPiI+JkIuQi7CLwIvQi8+KyovDCA4zjfjhFY6kkKCTnpOdk5mVlJWUlJKVkJSRk46RjAiUjZSLBaiLpX6jc6RvmXGNcY6AjICLfwiLhQWLfYl5h3WHdIJ3e3t8eneAcYWCiYOKgot7i3yPfpJ2lXyagZ6AnoSfh5+Il4qWi5UIi5KMkoySCM38hhWIl4mXi5eLn4+dkp6WqZiimpubnJuanZoIpaAFjYyUk5yZm5menZ6gn6CcoZmjl6GcnaGaoZqklKWPkoyQi5GLoIuihaJ/qXumcaNmCJGDk4CVfpZ+onKuZ61nsGuwbZ1+mHqVd5R2j3iLeIt4inqIeol6h36IgQiFewWKh4iGh4WHhYKBfH18fXqBeIN4g3CHaItoi2WSYZlzk3CPbYwIfYsFdIt5inyICHGHBYSJgop/iX+JdYhqh3qKfIp+i32Kf4yAjQiIiwVri3CXdKFzonujhKII9xr3IRWKgoqBi4KLdo92k3eabqZ4soMI9xaLi/fOUYyLNkWLBXeLeYR7fXt9gX2GfQic+N8Vi7eVsKGqoKqlmqqLqoulfKBsoWyWZotfi2CAZXVtdmxxfGyLbItxmnaqdamBsYu2CK/9JhWKkIqRi5CLlY2VkJeRnZmXnpEIxIuL+xRXiwWAi4GOg5OEkoWSiZMI909vFYt/kICVgpaClYSViAiahvcqi4v3ckqLi/s7TosFhYyGjYeOh4+JjomNCIqPi/cpToqL+zoFwflEFY+sm6yprKWno5mji4+LkIuPiqmFpHegapxwlHGLcYuFioWLhYVlemlxa3NxcH1sigiGi4aMhotlkXGcfqmAoIaliqiLlYyVjJYI90r7vRWL8rC+1Yuii6CGnIGcgZh/lHyTfJJ+j36Pfo1/i4IIi2gFi4aLhIqAioCKg4mEiYSIg4iBiIKHg4WEhYWFhIOFhIWCh4CHgIh/in6LCIWLBXGLdo96kniTfpiEm4Och5qJmYiYipuLnwgOi/hUFYvoouG52bjaycnauNm54aLoi+iL4XTZXdpeyU24PLk9ojWLLosudDVdPV48TU08Xgg9XTV0LosuizWiPbk8uE3JXtpd2XThi+gIs4sViy+jN7w+vD/LUdtlCPt1+P4FcE59S4tHCNj3lxWpiwWsi7WNvo+UjJGIjoWPhYyEiIWIhIaHgooIVYb3QPyT8/fJQfdeBXuNeo17jIOMhY+IkomRi5KPkY+RkY6Tigj3EIUFrIu1jb6Pk4yRiI+FjoWMhIiFiISGh4OKCFaG9z78kLr3MgWj25e+i6GLtn63cbeJjYeShJeEl4aTiY+Jj4iRh5WHlIiTipKJkoqSi5KLopOem5wImpyek6GLjIuMi4yLjYqMi4uLMt4htPsQizqLP3hGZUVkU1hgSQj3mv1dFbV/uIW5i8KLv5S9nQiIkfsm+CIF93r8BBXStcTEttS11KDai+CL3XjWZdCNfYx7i3mLYH9Tc0UIDvcU+P35IxU/i0lhaUxqykm1P4tei2J9anIIi/c7i4sFiqF6nHWLdYt6eop1CIuLi/vei4sFjfsA4zT3AYvXi822rMqtTM1g14v3Aovk5Iv3Aov3ATLk+wKLCPvz+9EVSYtWwIvNi8zAwc2LzYvAVYtKi0lWVkmLCPfzixVJi1bAi82LzMDBzYvNi8BVi0qLSVZWSYsI+GZ6FSX3HPH3HAWXnIikeph5mHOHfXoIi4s0+wkz9wkFfZxzj3p+eX6Icpd6CIuL8fscJfsdBX96jnOdfpx9o4+ZnAiLi+P3CeL7CQWZeqOHnZmcmI6jf5wIi4wFDl3AYBVzmH6Yf6MIequL+B4Fi/g+i4qytK+ygIr4Sov3s4v3EomWhap6pG6VZ5RtjUOL+8mL+4uI+x6GeId7f3WAf2Vikoz8SYsI/CaLa5oF94/3ChWVtJiP9yON9zSOnIedZwiZcPdQi4v5gP2Pi4v8BQWL+1+N+z2OiY2It4m+i+iLjIuPnAj3KvcgFXyVipGLzou1iKmHi4eLb31ueUNedoxvuHqliJWSk4+QrKGvoQjMsm+dBXuVbpx2llapiJOms6i4m4rZXQjHZo/aj9mzjQXAjpCDizQIi0fPsAWxn7Cckoufi65ciHOJe4GBXnMwWIyR2GHJaZGHjXSOb2xmcIuDi2iZa55qnW6Zh4sIiIuIbYtmi0OJhHJ+dYB6jHeZCA6L+F0Vi9GZzabKwfcT5eX3E8HKp82Y0YvRi81+ym/3EVbmMcL7FKZKmUmLR4tIfUhwS1T7FTAw+xFVCExwSX1Fi0WLSZlMpvsTwjHmVfcUcMl9zovQCNuLFYsrqDXEP8RB1VbmawiL3QWLtJmppp19jHuOeY9okW2Wc5pNsWzPi+2Lvpy3ra97tI22nroIn4sFkouUipWHpoOofKx1tZa0kbOLs4u1hbWApp2jmaOUoZOaj5WJCJeKBZ5cjGB8Yq1nnF+LWIs/eVFlZHd1cHppf2+BbIRpiKd4mW2LYwiLOQXjq9TAxNfD1qfhi+qLxYDDdMF1v225Y7Jlsl2pVqJUolSWUotTi1OAU3RYdV1sY2QIZWRsXXRXdFWAU4tRCA77cos+FYv4P9mKiPvr+JWLi/fq3IuL/D39MYsF9xL3dBX4JYuLNvwli4vgBYzOFZPi+CdkgjQF/BH3bBWj3/gZ+wJzNwX70PfPFbjW9+77ZV1BBftC+DYV0r/3f/vdRFgFovhaFeGazvwjNX0FDvqUFPqUFYsMCgAAAAMEAAGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAQAAAAOwDwP/A/8ADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAgAAAAMAAAAUAAMAAQAAABQABADAAAAALAAgAAQADAABACQAJgArADAAPwBFAEcATABOAFQAVwBZAGcAaQBwAHUAeQDoAOz//f//AAAAAAAgACYAKgAwAD8ARABHAEwATgBTAFYAWQBhAGkAbAByAHcA6ADs//3//wAB/+P/4v/f/9v/zf/J/8j/xP/D/7//vv+9/7b/tf+z/7L/sf9D/0AAAwABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAB//8ADwABAAAAAQAAB+5g518PPPUACwQAAAAAAM+cIqsAAAAAz5wiq//z/6UFxQPIAAAACAACAAAAAAAAAAEAAAPA/8AAAAXn//P/0wXFAAEAAAAAAAAAAAAAAAAAAAAtAAAAAAAAAAAAAAAAAgAAAAQAABgEAP/0BAAAIAPkAAAEAAECBAAAAAS8AAAEAP/1AxAAAgJ4AAADWAAAApQAAAQo//sE2v/3BPAAAATqAAAElAAABO4AAAWEAAAEZP//BAAAJAPMABAEDP/0BaEAAANEAR8DwAAAA/sAAAXgABsF5wAhA1kAAARUAAAEngBxBAAAUgPQADoEnQAAA6gAAAQAAAAEgABDA9L/8wQAAAADIgAAAABQAAAtAAAAAAAOAK4AAQAAAAAAAQAMAAAAAQAAAAAAAgAOAEAAAQAAAAAAAwAMACIAAQAAAAAABAAMAE4AAQAAAAAABQAWAAwAAQAAAAAABgAGAC4AAQAAAAAACgAoAFoAAwABBAkAAQAMAAAAAwABBAkAAgAOAEAAAwABBAkAAwAMACIAAwABBAkABAAMAE4AAwABBAkABQAWAAwAAwABBAkABgAMADQAAwABBAkACgAoAFoAegBvAGMAaQBhAGwAVgBlAHIAcwBpAG8AbgAgADEALgAwAHoAbwBjAGkAYQBsem9jaWFsAHoAbwBjAGkAYQBsAFIAZQBnAHUAbABhAHIAegBvAGMAaQBhAGwARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABJAGMAbwBNAG8AbwBuAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=) format(\'woff\'),url(https://cdn.auth0.com/w2/font/zocial-regular-webfont.ttf) format(\'truetype\'),url(https://cdn.auth0.com/w2/font/zocial-regular-webfont.svg#zocialregular) format(\'svg\');font-weight:400;font-style:normal}#a0-lock .a0-equal-viewport .a0-zocial,#a0-lock .a0-zocial.a0-icon{width:auto;display:inline-block;margin:6px}#a0-lock .a0-equal-viewport .a0-zocial:before,#a0-lock .a0-zocial.a0-icon:before{width:40px;background-color:transparent}#a0-lock .a0-equal-viewport .a0-zocial:hover:before,#a0-lock .a0-zocial.a0-icon:hover:before{background-color:rgba(0,0,0,.4)}#a0-lock .a0-equal-viewport .a0-zocial span,#a0-lock .a0-zocial.a0-icon span{display:none}#a0-lock .a0-show{display:block}#a0-lock .a0-hide{display:none!important}#a0-lock .a0-panel{background:#fff;width:280px;overflow:hidden;-webkit-transition:height 50ms ease-in;-moz-transition:height 50ms ease-in;transition:height 50ms ease-in}#a0-lock .a0-panel.a0-disable-transition{-webkit-transition:none;-moz-transition:none;transition:none}#a0-lock .a0-panel .a0-loading{min-height:110px}#a0-lock .a0-spin-container{position:relative;top:50%}#a0-lock .a0-loading.a0-with-message .a0-spin-container{top:37%}#a0-lock .a0-spin-message{text-align:center;position:relative;top:60px}#a0-lock .a0-spin-message span{font-size:14px;color:#41444a}#a0-lock .a0-spin-img{position:relative;top:50%;left:50%;width:32px;height:32px;margin-left:-16px;margin-top:-16px}#a0-lock .a0-overlay.a0-ie8-overlay{background:0 0;background-image:url(https://s3.amazonaws.com/assets.auth0.com/w2/img/bg-transp.png)}#a0-lock .a0-overlay{margin:0;display:table;position:fixed;left:0;top:0;bottom:0;right:0;width:100%;height:100%;overflow:hidden;z-index:9999;font-weight:200;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background:#000;background:rgba(0,0,0,.8);opacity:0;-webkit-transition:300ms opacity ease-out;-moz-transition:300ms opacity ease-out;transition:300ms opacity ease-out;-webkit-transform:translate3d(0,0,0);-moz-transform:translate3d(0,0,0);-ms-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}#a0-lock .a0-overlay .a0-centrix{padding:0;vertical-align:middle;display:table-cell;margin:0}#a0-lock .a0-overlay.a0-active{opacity:1}#a0-lock .a0-overlay .a0-panel{display:none;margin:0 auto}#a0-lock .a0-overlay .a0-panel.a0-active{display:block}#a0-lock .a0-animated{-webkit-animation-duration:1s;-moz-animation-duration:1s;animation-duration:1s;-webkit-animation-fill-mode:both;-moz-animation-fill-mode:both;animation-fill-mode:both}#a0-lock .a0-animated.a0-infinite{-webkit-animation-iteration-count:infinite;-moz-animation-iteration-count:infinite;animation-iteration-count:infinite}#a0-lock .a0-animated.a0-hinge{-webkit-animation-duration:2s;-moz-animation-duration:2s;animation-duration:2s}@-webkit-keyframes bounce{0%,100%,20%,50%,80%{-webkit-transform:translateY(0);transform:translateY(0)}40%{-webkit-transform:translateY(-30px);transform:translateY(-30px)}60%{-webkit-transform:translateY(-15px);transform:translateY(-15px)}}@keyframes bounce{0%,100%,20%,50%,80%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}40%{-webkit-transform:translateY(-30px);-ms-transform:translateY(-30px);-moz-transform:translateY(-30px);transform:translateY(-30px)}60%{-webkit-transform:translateY(-15px);-ms-transform:translateY(-15px);-moz-transform:translateY(-15px);transform:translateY(-15px)}}@-moz-keyframes bounce{0%,100%,20%,50%,80%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}40%{-webkit-transform:translateY(-30px);-ms-transform:translateY(-30px);-moz-transform:translateY(-30px);transform:translateY(-30px)}60%{-webkit-transform:translateY(-15px);-ms-transform:translateY(-15px);-moz-transform:translateY(-15px);transform:translateY(-15px)}}#a0-lock .a0-bounce{-webkit-animation-name:bounce;-moz-animation-name:bounce;animation-name:bounce}@-webkit-keyframes flash{0%,100%,50%{opacity:1}25%,75%{opacity:0}}@keyframes flash{0%,100%,50%{opacity:1}25%,75%{opacity:0}}@-moz-keyframes flash{0%,100%,50%{opacity:1}25%,75%{opacity:0}}#a0-lock .a0-flash{-webkit-animation-name:flash;-moz-animation-name:flash;animation-name:flash}@-webkit-keyframes pulse{0%{-webkit-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.1);transform:scale(1.1)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes pulse{0%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.1);-ms-transform:scale(1.1);-moz-transform:scale(1.1);transform:scale(1.1)}100%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}}@-moz-keyframes pulse{0%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}50%{-webkit-transform:scale(1.1);-ms-transform:scale(1.1);-moz-transform:scale(1.1);transform:scale(1.1)}100%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}}#a0-lock .a0-pulse{-webkit-animation-name:pulse;-moz-animation-name:pulse;animation-name:pulse}@-webkit-keyframes rubberBand{0%{-webkit-transform:scale(1);transform:scale(1)}30%{-webkit-transform:scaleX(1.25) scaleY(0.75);transform:scaleX(1.25) scaleY(0.75)}40%{-webkit-transform:scaleX(0.75) scaleY(1.25);transform:scaleX(0.75) scaleY(1.25)}60%{-webkit-transform:scaleX(1.15) scaleY(0.85);transform:scaleX(1.15) scaleY(0.85)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes rubberBand{0%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}30%{-webkit-transform:scaleX(1.25) scaleY(0.75);-ms-transform:scaleX(1.25) scaleY(0.75);-moz-transform:scaleX(1.25) scaleY(0.75);transform:scaleX(1.25) scaleY(0.75)}40%{-webkit-transform:scaleX(0.75) scaleY(1.25);-ms-transform:scaleX(0.75) scaleY(1.25);-moz-transform:scaleX(0.75) scaleY(1.25);transform:scaleX(0.75) scaleY(1.25)}60%{-webkit-transform:scaleX(1.15) scaleY(0.85);-ms-transform:scaleX(1.15) scaleY(0.85);-moz-transform:scaleX(1.15) scaleY(0.85);transform:scaleX(1.15) scaleY(0.85)}100%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}}@-moz-keyframes rubberBand{0%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}30%{-webkit-transform:scaleX(1.25) scaleY(0.75);-ms-transform:scaleX(1.25) scaleY(0.75);-moz-transform:scaleX(1.25) scaleY(0.75);transform:scaleX(1.25) scaleY(0.75)}40%{-webkit-transform:scaleX(0.75) scaleY(1.25);-ms-transform:scaleX(0.75) scaleY(1.25);-moz-transform:scaleX(0.75) scaleY(1.25);transform:scaleX(0.75) scaleY(1.25)}60%{-webkit-transform:scaleX(1.15) scaleY(0.85);-ms-transform:scaleX(1.15) scaleY(0.85);-moz-transform:scaleX(1.15) scaleY(0.85);transform:scaleX(1.15) scaleY(0.85)}100%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}}#a0-lock .a0-rubberBand{-webkit-animation-name:rubberBand;-moz-animation-name:rubberBand;animation-name:rubberBand}@-webkit-keyframes shake{0%,100%{-webkit-transform:translateX(0);transform:translateX(0)}10%,30%,50%,70%,90%{-webkit-transform:translateX(-10px);transform:translateX(-10px)}20%,40%,60%,80%{-webkit-transform:translateX(10px);transform:translateX(10px)}}@keyframes shake{0%,100%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}10%,30%,50%,70%,90%{-webkit-transform:translateX(-10px);-ms-transform:translateX(-10px);-moz-transform:translateX(-10px);transform:translateX(-10px)}20%,40%,60%,80%{-webkit-transform:translateX(10px);-ms-transform:translateX(10px);-moz-transform:translateX(10px);transform:translateX(10px)}}@-moz-keyframes shake{0%,100%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}10%,30%,50%,70%,90%{-webkit-transform:translateX(-10px);-ms-transform:translateX(-10px);-moz-transform:translateX(-10px);transform:translateX(-10px)}20%,40%,60%,80%{-webkit-transform:translateX(10px);-ms-transform:translateX(10px);-moz-transform:translateX(10px);transform:translateX(10px)}}#a0-lock .a0-shake{-webkit-animation-name:shake;-moz-animation-name:shake;animation-name:shake}@-webkit-keyframes swing{20%{-webkit-transform:rotate(15deg);transform:rotate(15deg)}40%{-webkit-transform:rotate(-10deg);transform:rotate(-10deg)}60%{-webkit-transform:rotate(5deg);transform:rotate(5deg)}80%{-webkit-transform:rotate(-5deg);transform:rotate(-5deg)}100%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}}@keyframes swing{20%{-webkit-transform:rotate(15deg);-ms-transform:rotate(15deg);-moz-transform:rotate(15deg);transform:rotate(15deg)}40%{-webkit-transform:rotate(-10deg);-ms-transform:rotate(-10deg);-moz-transform:rotate(-10deg);transform:rotate(-10deg)}60%{-webkit-transform:rotate(5deg);-ms-transform:rotate(5deg);-moz-transform:rotate(5deg);transform:rotate(5deg)}80%{-webkit-transform:rotate(-5deg);-ms-transform:rotate(-5deg);-moz-transform:rotate(-5deg);transform:rotate(-5deg)}100%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);-moz-transform:rotate(0deg);transform:rotate(0deg)}}@-moz-keyframes swing{20%{-webkit-transform:rotate(15deg);-ms-transform:rotate(15deg);-moz-transform:rotate(15deg);transform:rotate(15deg)}40%{-webkit-transform:rotate(-10deg);-ms-transform:rotate(-10deg);-moz-transform:rotate(-10deg);transform:rotate(-10deg)}60%{-webkit-transform:rotate(5deg);-ms-transform:rotate(5deg);-moz-transform:rotate(5deg);transform:rotate(5deg)}80%{-webkit-transform:rotate(-5deg);-ms-transform:rotate(-5deg);-moz-transform:rotate(-5deg);transform:rotate(-5deg)}100%{-webkit-transform:rotate(0deg);-ms-transform:rotate(0deg);-moz-transform:rotate(0deg);transform:rotate(0deg)}}#a0-lock .a0-swing{-webkit-transform-origin:top center;-ms-transform-origin:top center;-moz-transform-origin:top center;transform-origin:top center;-webkit-animation-name:swing;-moz-animation-name:swing;animation-name:swing}@-webkit-keyframes tada{0%{-webkit-transform:scale(1);transform:scale(1)}10%,20%{-webkit-transform:scale(0.9) rotate(-3deg);transform:scale(0.9) rotate(-3deg)}30%,50%,70%,90%{-webkit-transform:scale(1.1) rotate(3deg);transform:scale(1.1) rotate(3deg)}40%,60%,80%{-webkit-transform:scale(1.1) rotate(-3deg);transform:scale(1.1) rotate(-3deg)}100%{-webkit-transform:scale(1) rotate(0);transform:scale(1) rotate(0)}}@keyframes tada{0%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}10%,20%{-webkit-transform:scale(0.9) rotate(-3deg);-ms-transform:scale(0.9) rotate(-3deg);-moz-transform:scale(0.9) rotate(-3deg);transform:scale(0.9) rotate(-3deg)}30%,50%,70%,90%{-webkit-transform:scale(1.1) rotate(3deg);-ms-transform:scale(1.1) rotate(3deg);-moz-transform:scale(1.1) rotate(3deg);transform:scale(1.1) rotate(3deg)}40%,60%,80%{-webkit-transform:scale(1.1) rotate(-3deg);-ms-transform:scale(1.1) rotate(-3deg);-moz-transform:scale(1.1) rotate(-3deg);transform:scale(1.1) rotate(-3deg)}100%{-webkit-transform:scale(1) rotate(0);-ms-transform:scale(1) rotate(0);-moz-transform:scale(1) rotate(0);transform:scale(1) rotate(0)}}@-moz-keyframes tada{0%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}10%,20%{-webkit-transform:scale(0.9) rotate(-3deg);-ms-transform:scale(0.9) rotate(-3deg);-moz-transform:scale(0.9) rotate(-3deg);transform:scale(0.9) rotate(-3deg)}30%,50%,70%,90%{-webkit-transform:scale(1.1) rotate(3deg);-ms-transform:scale(1.1) rotate(3deg);-moz-transform:scale(1.1) rotate(3deg);transform:scale(1.1) rotate(3deg)}40%,60%,80%{-webkit-transform:scale(1.1) rotate(-3deg);-ms-transform:scale(1.1) rotate(-3deg);-moz-transform:scale(1.1) rotate(-3deg);transform:scale(1.1) rotate(-3deg)}100%{-webkit-transform:scale(1) rotate(0);-ms-transform:scale(1) rotate(0);-moz-transform:scale(1) rotate(0);transform:scale(1) rotate(0)}}#a0-lock .a0-tada{-webkit-animation-name:tada;-moz-animation-name:tada;animation-name:tada}@-webkit-keyframes wobble{0%{-webkit-transform:translateX(0%);transform:translateX(0%)}15%{-webkit-transform:translateX(-25%) rotate(-5deg);transform:translateX(-25%) rotate(-5deg)}30%{-webkit-transform:translateX(20%) rotate(3deg);transform:translateX(20%) rotate(3deg)}45%{-webkit-transform:translateX(-15%) rotate(-3deg);transform:translateX(-15%) rotate(-3deg)}60%{-webkit-transform:translateX(10%) rotate(2deg);transform:translateX(10%) rotate(2deg)}75%{-webkit-transform:translateX(-5%) rotate(-1deg);transform:translateX(-5%) rotate(-1deg)}100%{-webkit-transform:translateX(0%);transform:translateX(0%)}}@keyframes wobble{0%{-webkit-transform:translateX(0%);-ms-transform:translateX(0%);-moz-transform:translateX(0%);transform:translateX(0%)}15%{-webkit-transform:translateX(-25%) rotate(-5deg);-ms-transform:translateX(-25%) rotate(-5deg);-moz-transform:translateX(-25%) rotate(-5deg);transform:translateX(-25%) rotate(-5deg)}30%{-webkit-transform:translateX(20%) rotate(3deg);-ms-transform:translateX(20%) rotate(3deg);-moz-transform:translateX(20%) rotate(3deg);transform:translateX(20%) rotate(3deg)}45%{-webkit-transform:translateX(-15%) rotate(-3deg);-ms-transform:translateX(-15%) rotate(-3deg);-moz-transform:translateX(-15%) rotate(-3deg);transform:translateX(-15%) rotate(-3deg)}60%{-webkit-transform:translateX(10%) rotate(2deg);-ms-transform:translateX(10%) rotate(2deg);-moz-transform:translateX(10%) rotate(2deg);transform:translateX(10%) rotate(2deg)}75%{-webkit-transform:translateX(-5%) rotate(-1deg);-ms-transform:translateX(-5%) rotate(-1deg);-moz-transform:translateX(-5%) rotate(-1deg);transform:translateX(-5%) rotate(-1deg)}100%{-webkit-transform:translateX(0%);-ms-transform:translateX(0%);-moz-transform:translateX(0%);transform:translateX(0%)}}@-moz-keyframes wobble{0%{-webkit-transform:translateX(0%);-ms-transform:translateX(0%);-moz-transform:translateX(0%);transform:translateX(0%)}15%{-webkit-transform:translateX(-25%) rotate(-5deg);-ms-transform:translateX(-25%) rotate(-5deg);-moz-transform:translateX(-25%) rotate(-5deg);transform:translateX(-25%) rotate(-5deg)}30%{-webkit-transform:translateX(20%) rotate(3deg);-ms-transform:translateX(20%) rotate(3deg);-moz-transform:translateX(20%) rotate(3deg);transform:translateX(20%) rotate(3deg)}45%{-webkit-transform:translateX(-15%) rotate(-3deg);-ms-transform:translateX(-15%) rotate(-3deg);-moz-transform:translateX(-15%) rotate(-3deg);transform:translateX(-15%) rotate(-3deg)}60%{-webkit-transform:translateX(10%) rotate(2deg);-ms-transform:translateX(10%) rotate(2deg);-moz-transform:translateX(10%) rotate(2deg);transform:translateX(10%) rotate(2deg)}75%{-webkit-transform:translateX(-5%) rotate(-1deg);-ms-transform:translateX(-5%) rotate(-1deg);-moz-transform:translateX(-5%) rotate(-1deg);transform:translateX(-5%) rotate(-1deg)}100%{-webkit-transform:translateX(0%);-ms-transform:translateX(0%);-moz-transform:translateX(0%);transform:translateX(0%)}}#a0-lock .a0-wobble{-webkit-animation-name:wobble;-moz-animation-name:wobble;animation-name:wobble}@-webkit-keyframes bounceIn{0%{opacity:0;-webkit-transform:scale(0.3);transform:scale(0.3)}50%{opacity:1;-webkit-transform:scale(1.05);transform:scale(1.05)}70%{-webkit-transform:scale(0.9);transform:scale(0.9)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes bounceIn{0%{opacity:0;-webkit-transform:scale(0.3);-ms-transform:scale(0.3);-moz-transform:scale(0.3);transform:scale(0.3)}50%{opacity:1;-webkit-transform:scale(1.05);-ms-transform:scale(1.05);-moz-transform:scale(1.05);transform:scale(1.05)}70%{-webkit-transform:scale(0.9);-ms-transform:scale(0.9);-moz-transform:scale(0.9);transform:scale(0.9)}100%{opacity:1;-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}}@-moz-keyframes bounceIn{0%{opacity:0;-webkit-transform:scale(0.3);-ms-transform:scale(0.3);-moz-transform:scale(0.3);transform:scale(0.3)}50%{opacity:1;-webkit-transform:scale(1.05);-ms-transform:scale(1.05);-moz-transform:scale(1.05);transform:scale(1.05)}70%{-webkit-transform:scale(0.9);-ms-transform:scale(0.9);-moz-transform:scale(0.9);transform:scale(0.9)}100%{opacity:1;-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}}#a0-lock .a0-bounceIn{-webkit-animation-name:bounceIn;-moz-animation-name:bounceIn;animation-name:bounceIn}@-webkit-keyframes bounceInDown{0%{opacity:0;-webkit-transform:translateY(-2000px);transform:translateY(-2000px)}60%{opacity:1;-webkit-transform:translateY(30px);transform:translateY(30px)}80%{-webkit-transform:translateY(-10px);transform:translateY(-10px)}100%{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes bounceInDown{0%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}60%{opacity:1;-webkit-transform:translateY(30px);-ms-transform:translateY(30px);-moz-transform:translateY(30px);transform:translateY(30px)}80%{-webkit-transform:translateY(-10px);-ms-transform:translateY(-10px);-moz-transform:translateY(-10px);transform:translateY(-10px)}100%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}@-moz-keyframes bounceInDown{0%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}60%{opacity:1;-webkit-transform:translateY(30px);-ms-transform:translateY(30px);-moz-transform:translateY(30px);transform:translateY(30px)}80%{-webkit-transform:translateY(-10px);-ms-transform:translateY(-10px);-moz-transform:translateY(-10px);transform:translateY(-10px)}100%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}#a0-lock .a0-bounceInDown{-webkit-animation-name:bounceInDown;-moz-animation-name:bounceInDown;animation-name:bounceInDown}@-webkit-keyframes bounceInLeft{0%{opacity:0;-webkit-transform:translateX(-2000px);transform:translateX(-2000px)}60%{opacity:1;-webkit-transform:translateX(30px);transform:translateX(30px)}80%{-webkit-transform:translateX(-10px);transform:translateX(-10px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes bounceInLeft{0%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}60%{opacity:1;-webkit-transform:translateX(30px);-ms-transform:translateX(30px);-moz-transform:translateX(30px);transform:translateX(30px)}80%{-webkit-transform:translateX(-10px);-ms-transform:translateX(-10px);-moz-transform:translateX(-10px);transform:translateX(-10px)}100%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}@-moz-keyframes bounceInLeft{0%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}60%{opacity:1;-webkit-transform:translateX(30px);-ms-transform:translateX(30px);-moz-transform:translateX(30px);transform:translateX(30px)}80%{-webkit-transform:translateX(-10px);-ms-transform:translateX(-10px);-moz-transform:translateX(-10px);transform:translateX(-10px)}100%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}#a0-lock .a0-bounceInLeft{-webkit-animation-name:bounceInLeft;-moz-animation-name:bounceInLeft;animation-name:bounceInLeft}@-webkit-keyframes bounceInRight{0%{opacity:0;-webkit-transform:translateX(2000px);transform:translateX(2000px)}60%{opacity:1;-webkit-transform:translateX(-30px);transform:translateX(-30px)}80%{-webkit-transform:translateX(10px);transform:translateX(10px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes bounceInRight{0%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}60%{opacity:1;-webkit-transform:translateX(-30px);-ms-transform:translateX(-30px);-moz-transform:translateX(-30px);transform:translateX(-30px)}80%{-webkit-transform:translateX(10px);-ms-transform:translateX(10px);-moz-transform:translateX(10px);transform:translateX(10px)}100%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}@-moz-keyframes bounceInRight{0%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}60%{opacity:1;-webkit-transform:translateX(-30px);-ms-transform:translateX(-30px);-moz-transform:translateX(-30px);transform:translateX(-30px)}80%{-webkit-transform:translateX(10px);-ms-transform:translateX(10px);-moz-transform:translateX(10px);transform:translateX(10px)}100%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}#a0-lock .a0-bounceInRight{-webkit-animation-name:bounceInRight;-moz-animation-name:bounceInRight;animation-name:bounceInRight}@-webkit-keyframes bounceInUp{0%{opacity:0;-webkit-transform:translateY(2000px);transform:translateY(2000px)}60%{opacity:1;-webkit-transform:translateY(-30px);transform:translateY(-30px)}80%{-webkit-transform:translateY(10px);transform:translateY(10px)}100%{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes bounceInUp{0%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}60%{opacity:1;-webkit-transform:translateY(-30px);-ms-transform:translateY(-30px);-moz-transform:translateY(-30px);transform:translateY(-30px)}80%{-webkit-transform:translateY(10px);-ms-transform:translateY(10px);-moz-transform:translateY(10px);transform:translateY(10px)}100%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}@-moz-keyframes bounceInUp{0%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}60%{opacity:1;-webkit-transform:translateY(-30px);-ms-transform:translateY(-30px);-moz-transform:translateY(-30px);transform:translateY(-30px)}80%{-webkit-transform:translateY(10px);-ms-transform:translateY(10px);-moz-transform:translateY(10px);transform:translateY(10px)}100%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}#a0-lock .a0-bounceInUp{-webkit-animation-name:bounceInUp;-moz-animation-name:bounceInUp;animation-name:bounceInUp}@-webkit-keyframes bounceOut{0%{-webkit-transform:scale(1);transform:scale(1)}25%{-webkit-transform:scale(0.95);transform:scale(0.95)}50%{opacity:1;-webkit-transform:scale(1.1);transform:scale(1.1)}100%{opacity:0;-webkit-transform:scale(0.3);transform:scale(0.3)}}@keyframes bounceOut{0%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}25%{-webkit-transform:scale(0.95);-ms-transform:scale(0.95);-moz-transform:scale(0.95);transform:scale(0.95)}50%{opacity:1;-webkit-transform:scale(1.1);-ms-transform:scale(1.1);-moz-transform:scale(1.1);transform:scale(1.1)}100%{opacity:0;-webkit-transform:scale(0.3);-ms-transform:scale(0.3);-moz-transform:scale(0.3);transform:scale(0.3)}}@-moz-keyframes bounceOut{0%{-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}25%{-webkit-transform:scale(0.95);-ms-transform:scale(0.95);-moz-transform:scale(0.95);transform:scale(0.95)}50%{opacity:1;-webkit-transform:scale(1.1);-ms-transform:scale(1.1);-moz-transform:scale(1.1);transform:scale(1.1)}100%{opacity:0;-webkit-transform:scale(0.3);-ms-transform:scale(0.3);-moz-transform:scale(0.3);transform:scale(0.3)}}#a0-lock .a0-bounceOut{-webkit-animation-name:bounceOut;-moz-animation-name:bounceOut;animation-name:bounceOut}@-webkit-keyframes bounceOutDown{0%{-webkit-transform:translateY(0);transform:translateY(0)}20%{opacity:1;-webkit-transform:translateY(-20px);transform:translateY(-20px)}100%{opacity:0;-webkit-transform:translateY(2000px);transform:translateY(2000px)}}@keyframes bounceOutDown{0%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}20%{opacity:1;-webkit-transform:translateY(-20px);-ms-transform:translateY(-20px);-moz-transform:translateY(-20px);transform:translateY(-20px)}100%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}}@-moz-keyframes bounceOutDown{0%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}20%{opacity:1;-webkit-transform:translateY(-20px);-ms-transform:translateY(-20px);-moz-transform:translateY(-20px);transform:translateY(-20px)}100%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}}#a0-lock .a0-bounceOutDown{-webkit-animation-name:bounceOutDown;-moz-animation-name:bounceOutDown;animation-name:bounceOutDown}@-webkit-keyframes bounceOutLeft{0%{-webkit-transform:translateX(0);transform:translateX(0)}20%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{opacity:0;-webkit-transform:translateX(-2000px);transform:translateX(-2000px)}}@keyframes bounceOutLeft{0%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}20%{opacity:1;-webkit-transform:translateX(20px);-ms-transform:translateX(20px);-moz-transform:translateX(20px);transform:translateX(20px)}100%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}}@-moz-keyframes bounceOutLeft{0%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}20%{opacity:1;-webkit-transform:translateX(20px);-ms-transform:translateX(20px);-moz-transform:translateX(20px);transform:translateX(20px)}100%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}}#a0-lock .a0-bounceOutLeft{-webkit-animation-name:bounceOutLeft;-moz-animation-name:bounceOutLeft;animation-name:bounceOutLeft}@-webkit-keyframes bounceOutRight{0%{-webkit-transform:translateX(0);transform:translateX(0)}20%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{opacity:0;-webkit-transform:translateX(2000px);transform:translateX(2000px)}}@keyframes bounceOutRight{0%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}20%{opacity:1;-webkit-transform:translateX(-20px);-ms-transform:translateX(-20px);-moz-transform:translateX(-20px);transform:translateX(-20px)}100%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}}@-moz-keyframes bounceOutRight{0%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}20%{opacity:1;-webkit-transform:translateX(-20px);-ms-transform:translateX(-20px);-moz-transform:translateX(-20px);transform:translateX(-20px)}100%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}}#a0-lock .a0-bounceOutRight{-webkit-animation-name:bounceOutRight;-moz-animation-name:bounceOutRight;animation-name:bounceOutRight}@-webkit-keyframes bounceOutUp{0%{-webkit-transform:translateY(0);transform:translateY(0)}20%{opacity:1;-webkit-transform:translateY(20px);transform:translateY(20px)}100%{opacity:0;-webkit-transform:translateY(-2000px);transform:translateY(-2000px)}}@keyframes bounceOutUp{0%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}20%{opacity:1;-webkit-transform:translateY(20px);-ms-transform:translateY(20px);-moz-transform:translateY(20px);transform:translateY(20px)}100%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}}@-moz-keyframes bounceOutUp{0%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}20%{opacity:1;-webkit-transform:translateY(20px);-ms-transform:translateY(20px);-moz-transform:translateY(20px);transform:translateY(20px)}100%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}}#a0-lock .a0-bounceOutUp{-webkit-animation-name:bounceOutUp;-moz-animation-name:bounceOutUp;animation-name:bounceOutUp}@-webkit-keyframes fadeIn{0%{opacity:0}100%{opacity:1}}@keyframes fadeIn{0%{opacity:0}100%{opacity:1}}@-moz-keyframes fadeIn{0%{opacity:0}100%{opacity:1}}#a0-lock .a0-fadeIn{-webkit-animation-name:fadeIn;-moz-animation-name:fadeIn;animation-name:fadeIn}@-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes fadeInDown{0%{opacity:0;-webkit-transform:translateY(-20px);-ms-transform:translateY(-20px);-moz-transform:translateY(-20px);transform:translateY(-20px)}100%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}@-moz-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translateY(-20px);-ms-transform:translateY(-20px);-moz-transform:translateY(-20px);transform:translateY(-20px)}100%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}#a0-lock .a0-fadeInDown{-webkit-animation-name:fadeInDown;-moz-animation-name:fadeInDown;animation-name:fadeInDown}@-webkit-keyframes fadeInDownBig{0%{opacity:0;-webkit-transform:translateY(-2000px);transform:translateY(-2000px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes fadeInDownBig{0%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}100%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}@-moz-keyframes fadeInDownBig{0%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}100%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}#a0-lock .a0-fadeInDownBig{-webkit-animation-name:fadeInDownBig;-moz-animation-name:fadeInDownBig;animation-name:fadeInDownBig}@-webkit-keyframes fadeInLeft{0%{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{opacity:1;-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes fadeInLeft{0%{opacity:0;-webkit-transform:translateX(-20px);-ms-transform:translateX(-20px);-moz-transform:translateX(-20px);transform:translateX(-20px)}100%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}@-moz-keyframes fadeInLeft{0%{opacity:0;-webkit-transform:translateX(-20px);-ms-transform:translateX(-20px);-moz-transform:translateX(-20px);transform:translateX(-20px)}100%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}#a0-lock .a0-fadeInLeft{-webkit-animation-name:fadeInLeft;-moz-animation-name:fadeInLeft;animation-name:fadeInLeft}@-webkit-keyframes fadeInLeftBig{0%{opacity:0;-webkit-transform:translateX(-2000px);transform:translateX(-2000px)}100%{opacity:1;-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes fadeInLeftBig{0%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}100%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}@-moz-keyframes fadeInLeftBig{0%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}100%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}#a0-lock .a0-fadeInLeftBig{-webkit-animation-name:fadeInLeftBig;-moz-animation-name:fadeInLeftBig;animation-name:fadeInLeftBig}@-webkit-keyframes fadeInRight{0%{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{opacity:1;-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes fadeInRight{0%{opacity:0;-webkit-transform:translateX(20px);-ms-transform:translateX(20px);-moz-transform:translateX(20px);transform:translateX(20px)}100%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}@-moz-keyframes fadeInRight{0%{opacity:0;-webkit-transform:translateX(20px);-ms-transform:translateX(20px);-moz-transform:translateX(20px);transform:translateX(20px)}100%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}#a0-lock .a0-fadeInRight{-webkit-animation-name:fadeInRight;-moz-animation-name:fadeInRight;animation-name:fadeInRight}@-webkit-keyframes fadeInRightBig{0%{opacity:0;-webkit-transform:translateX(2000px);transform:translateX(2000px)}100%{opacity:1;-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes fadeInRightBig{0%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}100%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}@-moz-keyframes fadeInRightBig{0%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}100%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}#a0-lock .a0-fadeInRightBig{-webkit-animation-name:fadeInRightBig;-moz-animation-name:fadeInRightBig;animation-name:fadeInRightBig}@-webkit-keyframes fadeInUp{0%{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes fadeInUp{0%{opacity:0;-webkit-transform:translateY(20px);-ms-transform:translateY(20px);-moz-transform:translateY(20px);transform:translateY(20px)}100%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}@-moz-keyframes fadeInUp{0%{opacity:0;-webkit-transform:translateY(20px);-ms-transform:translateY(20px);-moz-transform:translateY(20px);transform:translateY(20px)}100%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}#a0-lock .a0-fadeInUp{-webkit-animation-name:fadeInUp;-moz-animation-name:fadeInUp;animation-name:fadeInUp}@-webkit-keyframes fadeInUpBig{0%{opacity:0;-webkit-transform:translateY(2000px);transform:translateY(2000px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes fadeInUpBig{0%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}100%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}@-moz-keyframes fadeInUpBig{0%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}100%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}#a0-lock .a0-fadeInUpBig{-webkit-animation-name:fadeInUpBig;-moz-animation-name:fadeInUpBig;animation-name:fadeInUpBig}@-webkit-keyframes fadeOut{0%{opacity:1}100%{opacity:0}}@keyframes fadeOut{0%{opacity:1}100%{opacity:0}}@-moz-keyframes fadeOut{0%{opacity:1}100%{opacity:0}}#a0-lock .a0-fadeOut{-webkit-animation-name:fadeOut;-moz-animation-name:fadeOut;animation-name:fadeOut}@-webkit-keyframes fadeOutDown{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(20px);transform:translateY(20px)}}@keyframes fadeOutDown{0%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(20px);-ms-transform:translateY(20px);-moz-transform:translateY(20px);transform:translateY(20px)}}@-moz-keyframes fadeOutDown{0%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(20px);-ms-transform:translateY(20px);-moz-transform:translateY(20px);transform:translateY(20px)}}#a0-lock .a0-fadeOutDown{-webkit-animation-name:fadeOutDown;-moz-animation-name:fadeOutDown;animation-name:fadeOutDown}@-webkit-keyframes fadeOutDownBig{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(2000px);transform:translateY(2000px)}}@keyframes fadeOutDownBig{0%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}}@-moz-keyframes fadeOutDownBig{0%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}}#a0-lock .a0-fadeOutDownBig{-webkit-animation-name:fadeOutDownBig;-moz-animation-name:fadeOutDownBig;animation-name:fadeOutDownBig}@-webkit-keyframes fadeOutLeft{0%{opacity:1;-webkit-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(-20px);transform:translateX(-20px)}}@keyframes fadeOutLeft{0%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(-20px);-ms-transform:translateX(-20px);-moz-transform:translateX(-20px);transform:translateX(-20px)}}@-moz-keyframes fadeOutLeft{0%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(-20px);-ms-transform:translateX(-20px);-moz-transform:translateX(-20px);transform:translateX(-20px)}}#a0-lock .a0-fadeOutLeft{-webkit-animation-name:fadeOutLeft;-moz-animation-name:fadeOutLeft;animation-name:fadeOutLeft}@-webkit-keyframes fadeOutLeftBig{0%{opacity:1;-webkit-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(-2000px);transform:translateX(-2000px)}}@keyframes fadeOutLeftBig{0%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}}@-moz-keyframes fadeOutLeftBig{0%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}}#a0-lock .a0-fadeOutLeftBig{-webkit-animation-name:fadeOutLeftBig;-moz-animation-name:fadeOutLeftBig;animation-name:fadeOutLeftBig}@-webkit-keyframes fadeOutRight{0%{opacity:1;-webkit-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(20px);transform:translateX(20px)}}@keyframes fadeOutRight{0%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(20px);-ms-transform:translateX(20px);-moz-transform:translateX(20px);transform:translateX(20px)}}@-moz-keyframes fadeOutRight{0%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(20px);-ms-transform:translateX(20px);-moz-transform:translateX(20px);transform:translateX(20px)}}#a0-lock .a0-fadeOutRight{-webkit-animation-name:fadeOutRight;-moz-animation-name:fadeOutRight;animation-name:fadeOutRight}@-webkit-keyframes fadeOutRightBig{0%{opacity:1;-webkit-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(2000px);transform:translateX(2000px)}}@keyframes fadeOutRightBig{0%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}}@-moz-keyframes fadeOutRightBig{0%{opacity:1;-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}}#a0-lock .a0-fadeOutRightBig{-webkit-animation-name:fadeOutRightBig;-moz-animation-name:fadeOutRightBig;animation-name:fadeOutRightBig}@-webkit-keyframes fadeOutUp{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(-20px);transform:translateY(-20px)}}@keyframes fadeOutUp{0%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(-20px);-ms-transform:translateY(-20px);-moz-transform:translateY(-20px);transform:translateY(-20px)}}@-moz-keyframes fadeOutUp{0%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(-20px);-ms-transform:translateY(-20px);-moz-transform:translateY(-20px);transform:translateY(-20px)}}#a0-lock .a0-fadeOutUp{-webkit-animation-name:fadeOutUp;-moz-animation-name:fadeOutUp;animation-name:fadeOutUp}@-webkit-keyframes fadeOutUpBig{0%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(-2000px);transform:translateY(-2000px)}}@keyframes fadeOutUpBig{0%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}}@-moz-keyframes fadeOutUpBig{0%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}}#a0-lock .a0-fadeOutUpBig{-webkit-animation-name:fadeOutUpBig;-moz-animation-name:fadeOutUpBig;animation-name:fadeOutUpBig}@-webkit-keyframes flip{0%{-webkit-transform:perspective(400px) translateZ(0) rotateY(0) scale(1);transform:perspective(400px) translateZ(0) rotateY(0) scale(1);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}40%{-webkit-transform:perspective(400px) translateZ(150px) rotateY(170deg) scale(1);transform:perspective(400px) translateZ(150px) rotateY(170deg) scale(1);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}50%{-webkit-transform:perspective(400px) translateZ(150px) rotateY(190deg) scale(1);transform:perspective(400px) translateZ(150px) rotateY(190deg) scale(1);-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in}80%{-webkit-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(0.95);transform:perspective(400px) translateZ(0) rotateY(360deg) scale(0.95);-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in}100%{-webkit-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(1);transform:perspective(400px) translateZ(0) rotateY(360deg) scale(1);-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in}}@keyframes flip{0%{-webkit-transform:perspective(400px) translateZ(0) rotateY(0) scale(1);-ms-transform:perspective(400px) translateZ(0) rotateY(0) scale(1);-moz-transform:perspective(400px) translateZ(0) rotateY(0) scale(1);transform:perspective(400px) translateZ(0) rotateY(0) scale(1);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}40%{-webkit-transform:perspective(400px) translateZ(150px) rotateY(170deg) scale(1);-ms-transform:perspective(400px) translateZ(150px) rotateY(170deg) scale(1);-moz-transform:perspective(400px) translateZ(150px) rotateY(170deg) scale(1);transform:perspective(400px) translateZ(150px) rotateY(170deg) scale(1);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}50%{-webkit-transform:perspective(400px) translateZ(150px) rotateY(190deg) scale(1);-ms-transform:perspective(400px) translateZ(150px) rotateY(190deg) scale(1);-moz-transform:perspective(400px) translateZ(150px) rotateY(190deg) scale(1);transform:perspective(400px) translateZ(150px) rotateY(190deg) scale(1);-webkit-animation-timing-function:ease-in;-moz-animation-timing-function:ease-in;animation-timing-function:ease-in}80%{-webkit-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(0.95);-ms-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(0.95);-moz-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(0.95);transform:perspective(400px) translateZ(0) rotateY(360deg) scale(0.95);-webkit-animation-timing-function:ease-in;-moz-animation-timing-function:ease-in;animation-timing-function:ease-in}100%{-webkit-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(1);-ms-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(1);-moz-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(1);transform:perspective(400px) translateZ(0) rotateY(360deg) scale(1);-webkit-animation-timing-function:ease-in;-moz-animation-timing-function:ease-in;animation-timing-function:ease-in}}@-moz-keyframes flip{0%{-webkit-transform:perspective(400px) translateZ(0) rotateY(0) scale(1);-ms-transform:perspective(400px) translateZ(0) rotateY(0) scale(1);-moz-transform:perspective(400px) translateZ(0) rotateY(0) scale(1);transform:perspective(400px) translateZ(0) rotateY(0) scale(1);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}40%{-webkit-transform:perspective(400px) translateZ(150px) rotateY(170deg) scale(1);-ms-transform:perspective(400px) translateZ(150px) rotateY(170deg) scale(1);-moz-transform:perspective(400px) translateZ(150px) rotateY(170deg) scale(1);transform:perspective(400px) translateZ(150px) rotateY(170deg) scale(1);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}50%{-webkit-transform:perspective(400px) translateZ(150px) rotateY(190deg) scale(1);-ms-transform:perspective(400px) translateZ(150px) rotateY(190deg) scale(1);-moz-transform:perspective(400px) translateZ(150px) rotateY(190deg) scale(1);transform:perspective(400px) translateZ(150px) rotateY(190deg) scale(1);-webkit-animation-timing-function:ease-in;-moz-animation-timing-function:ease-in;animation-timing-function:ease-in}80%{-webkit-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(0.95);-ms-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(0.95);-moz-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(0.95);transform:perspective(400px) translateZ(0) rotateY(360deg) scale(0.95);-webkit-animation-timing-function:ease-in;-moz-animation-timing-function:ease-in;animation-timing-function:ease-in}100%{-webkit-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(1);-ms-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(1);-moz-transform:perspective(400px) translateZ(0) rotateY(360deg) scale(1);transform:perspective(400px) translateZ(0) rotateY(360deg) scale(1);-webkit-animation-timing-function:ease-in;-moz-animation-timing-function:ease-in;animation-timing-function:ease-in}}#a0-lock .a0-animated.a0-flip{-webkit-backface-visibility:visible;-ms-backface-visibility:visible;-moz-backface-visibility:visible;backface-visibility:visible;-webkit-animation-name:flip;-moz-animation-name:flip;animation-name:flip}@-webkit-keyframes flipInX{0%{-webkit-transform:perspective(400px) rotateX(90deg);transform:perspective(400px) rotateX(90deg);opacity:0}40%{-webkit-transform:perspective(400px) rotateX(-10deg);transform:perspective(400px) rotateX(-10deg)}70%{-webkit-transform:perspective(400px) rotateX(10deg);transform:perspective(400px) rotateX(10deg)}100%{-webkit-transform:perspective(400px) rotateX(0deg);transform:perspective(400px) rotateX(0deg);opacity:1}}@keyframes flipInX{0%{-webkit-transform:perspective(400px) rotateX(90deg);-ms-transform:perspective(400px) rotateX(90deg);-moz-transform:perspective(400px) rotateX(90deg);transform:perspective(400px) rotateX(90deg);opacity:0}40%{-webkit-transform:perspective(400px) rotateX(-10deg);-ms-transform:perspective(400px) rotateX(-10deg);-moz-transform:perspective(400px) rotateX(-10deg);transform:perspective(400px) rotateX(-10deg)}70%{-webkit-transform:perspective(400px) rotateX(10deg);-ms-transform:perspective(400px) rotateX(10deg);-moz-transform:perspective(400px) rotateX(10deg);transform:perspective(400px) rotateX(10deg)}100%{-webkit-transform:perspective(400px) rotateX(0deg);-ms-transform:perspective(400px) rotateX(0deg);-moz-transform:perspective(400px) rotateX(0deg);transform:perspective(400px) rotateX(0deg);opacity:1}}@-moz-keyframes flipInX{0%{-webkit-transform:perspective(400px) rotateX(90deg);-ms-transform:perspective(400px) rotateX(90deg);-moz-transform:perspective(400px) rotateX(90deg);transform:perspective(400px) rotateX(90deg);opacity:0}40%{-webkit-transform:perspective(400px) rotateX(-10deg);-ms-transform:perspective(400px) rotateX(-10deg);-moz-transform:perspective(400px) rotateX(-10deg);transform:perspective(400px) rotateX(-10deg)}70%{-webkit-transform:perspective(400px) rotateX(10deg);-ms-transform:perspective(400px) rotateX(10deg);-moz-transform:perspective(400px) rotateX(10deg);transform:perspective(400px) rotateX(10deg)}100%{-webkit-transform:perspective(400px) rotateX(0deg);-ms-transform:perspective(400px) rotateX(0deg);-moz-transform:perspective(400px) rotateX(0deg);transform:perspective(400px) rotateX(0deg);opacity:1}}#a0-lock .a0-flipInX{-webkit-backface-visibility:visible!important;-ms-backface-visibility:visible!important;-moz-backface-visibility:visible!important;backface-visibility:visible!important;-webkit-animation-name:flipInX;-moz-animation-name:flipInX;animation-name:flipInX}@-webkit-keyframes flipInY{0%{-webkit-transform:perspective(400px) rotateY(90deg);transform:perspective(400px) rotateY(90deg);opacity:0}40%{-webkit-transform:perspective(400px) rotateY(-10deg);transform:perspective(400px) rotateY(-10deg)}70%{-webkit-transform:perspective(400px) rotateY(10deg);transform:perspective(400px) rotateY(10deg)}100%{-webkit-transform:perspective(400px) rotateY(0deg);transform:perspective(400px) rotateY(0deg);opacity:1}}@keyframes flipInY{0%{-webkit-transform:perspective(400px) rotateY(90deg);-ms-transform:perspective(400px) rotateY(90deg);-moz-transform:perspective(400px) rotateY(90deg);transform:perspective(400px) rotateY(90deg);opacity:0}40%{-webkit-transform:perspective(400px) rotateY(-10deg);-ms-transform:perspective(400px) rotateY(-10deg);-moz-transform:perspective(400px) rotateY(-10deg);transform:perspective(400px) rotateY(-10deg)}70%{-webkit-transform:perspective(400px) rotateY(10deg);-ms-transform:perspective(400px) rotateY(10deg);-moz-transform:perspective(400px) rotateY(10deg);transform:perspective(400px) rotateY(10deg)}100%{-webkit-transform:perspective(400px) rotateY(0deg);-ms-transform:perspective(400px) rotateY(0deg);-moz-transform:perspective(400px) rotateY(0deg);transform:perspective(400px) rotateY(0deg);opacity:1}}@-moz-keyframes flipInY{0%{-webkit-transform:perspective(400px) rotateY(90deg);-ms-transform:perspective(400px) rotateY(90deg);-moz-transform:perspective(400px) rotateY(90deg);transform:perspective(400px) rotateY(90deg);opacity:0}40%{-webkit-transform:perspective(400px) rotateY(-10deg);-ms-transform:perspective(400px) rotateY(-10deg);-moz-transform:perspective(400px) rotateY(-10deg);transform:perspective(400px) rotateY(-10deg)}70%{-webkit-transform:perspective(400px) rotateY(10deg);-ms-transform:perspective(400px) rotateY(10deg);-moz-transform:perspective(400px) rotateY(10deg);transform:perspective(400px) rotateY(10deg)}100%{-webkit-transform:perspective(400px) rotateY(0deg);-ms-transform:perspective(400px) rotateY(0deg);-moz-transform:perspective(400px) rotateY(0deg);transform:perspective(400px) rotateY(0deg);opacity:1}}#a0-lock .a0-flipInY{-webkit-backface-visibility:visible!important;-ms-backface-visibility:visible!important;-moz-backface-visibility:visible!important;backface-visibility:visible!important;-webkit-animation-name:flipInY;-moz-animation-name:flipInY;animation-name:flipInY}@-webkit-keyframes flipOutX{0%{-webkit-transform:perspective(400px) rotateX(0deg);transform:perspective(400px) rotateX(0deg);opacity:1}100%{-webkit-transform:perspective(400px) rotateX(90deg);transform:perspective(400px) rotateX(90deg);opacity:0}}@keyframes flipOutX{0%{-webkit-transform:perspective(400px) rotateX(0deg);-ms-transform:perspective(400px) rotateX(0deg);-moz-transform:perspective(400px) rotateX(0deg);transform:perspective(400px) rotateX(0deg);opacity:1}100%{-webkit-transform:perspective(400px) rotateX(90deg);-ms-transform:perspective(400px) rotateX(90deg);-moz-transform:perspective(400px) rotateX(90deg);transform:perspective(400px) rotateX(90deg);opacity:0}}@-moz-keyframes flipOutX{0%{-webkit-transform:perspective(400px) rotateX(0deg);-ms-transform:perspective(400px) rotateX(0deg);-moz-transform:perspective(400px) rotateX(0deg);transform:perspective(400px) rotateX(0deg);opacity:1}100%{-webkit-transform:perspective(400px) rotateX(90deg);-ms-transform:perspective(400px) rotateX(90deg);-moz-transform:perspective(400px) rotateX(90deg);transform:perspective(400px) rotateX(90deg);opacity:0}}#a0-lock .a0-flipOutX{-webkit-animation-name:flipOutX;-moz-animation-name:flipOutX;animation-name:flipOutX;-webkit-backface-visibility:visible!important;-ms-backface-visibility:visible!important;-moz-backface-visibility:visible!important;backface-visibility:visible!important}@-webkit-keyframes flipOutY{0%{-webkit-transform:perspective(400px) rotateY(0deg);transform:perspective(400px) rotateY(0deg);opacity:1}100%{-webkit-transform:perspective(400px) rotateY(90deg);transform:perspective(400px) rotateY(90deg);opacity:0}}@keyframes flipOutY{0%{-webkit-transform:perspective(400px) rotateY(0deg);-ms-transform:perspective(400px) rotateY(0deg);-moz-transform:perspective(400px) rotateY(0deg);transform:perspective(400px) rotateY(0deg);opacity:1}100%{-webkit-transform:perspective(400px) rotateY(90deg);-ms-transform:perspective(400px) rotateY(90deg);-moz-transform:perspective(400px) rotateY(90deg);transform:perspective(400px) rotateY(90deg);opacity:0}}@-moz-keyframes flipOutY{0%{-webkit-transform:perspective(400px) rotateY(0deg);-ms-transform:perspective(400px) rotateY(0deg);-moz-transform:perspective(400px) rotateY(0deg);transform:perspective(400px) rotateY(0deg);opacity:1}100%{-webkit-transform:perspective(400px) rotateY(90deg);-ms-transform:perspective(400px) rotateY(90deg);-moz-transform:perspective(400px) rotateY(90deg);transform:perspective(400px) rotateY(90deg);opacity:0}}#a0-lock .a0-flipOutY{-webkit-backface-visibility:visible!important;-ms-backface-visibility:visible!important;-moz-backface-visibility:visible!important;backface-visibility:visible!important;-webkit-animation-name:flipOutY;-moz-animation-name:flipOutY;animation-name:flipOutY}@-webkit-keyframes lightSpeedIn{0%{-webkit-transform:translateX(100%) skewX(-30deg);transform:translateX(100%) skewX(-30deg);opacity:0}60%{-webkit-transform:translateX(-20%) skewX(30deg);transform:translateX(-20%) skewX(30deg);opacity:1}80%{-webkit-transform:translateX(0%) skewX(-15deg);transform:translateX(0%) skewX(-15deg);opacity:1}100%{-webkit-transform:translateX(0%) skewX(0deg);transform:translateX(0%) skewX(0deg);opacity:1}}@keyframes lightSpeedIn{0%{-webkit-transform:translateX(100%) skewX(-30deg);-ms-transform:translateX(100%) skewX(-30deg);-moz-transform:translateX(100%) skewX(-30deg);transform:translateX(100%) skewX(-30deg);opacity:0}60%{-webkit-transform:translateX(-20%) skewX(30deg);-ms-transform:translateX(-20%) skewX(30deg);-moz-transform:translateX(-20%) skewX(30deg);transform:translateX(-20%) skewX(30deg);opacity:1}80%{-webkit-transform:translateX(0%) skewX(-15deg);-ms-transform:translateX(0%) skewX(-15deg);-moz-transform:translateX(0%) skewX(-15deg);transform:translateX(0%) skewX(-15deg);opacity:1}100%{-webkit-transform:translateX(0%) skewX(0deg);-ms-transform:translateX(0%) skewX(0deg);-moz-transform:translateX(0%) skewX(0deg);transform:translateX(0%) skewX(0deg);opacity:1}}@-moz-keyframes lightSpeedIn{0%{-webkit-transform:translateX(100%) skewX(-30deg);-ms-transform:translateX(100%) skewX(-30deg);-moz-transform:translateX(100%) skewX(-30deg);transform:translateX(100%) skewX(-30deg);opacity:0}60%{-webkit-transform:translateX(-20%) skewX(30deg);-ms-transform:translateX(-20%) skewX(30deg);-moz-transform:translateX(-20%) skewX(30deg);transform:translateX(-20%) skewX(30deg);opacity:1}80%{-webkit-transform:translateX(0%) skewX(-15deg);-ms-transform:translateX(0%) skewX(-15deg);-moz-transform:translateX(0%) skewX(-15deg);transform:translateX(0%) skewX(-15deg);opacity:1}100%{-webkit-transform:translateX(0%) skewX(0deg);-ms-transform:translateX(0%) skewX(0deg);-moz-transform:translateX(0%) skewX(0deg);transform:translateX(0%) skewX(0deg);opacity:1}}#a0-lock .a0-lightSpeedIn{-webkit-animation-name:lightSpeedIn;-moz-animation-name:lightSpeedIn;animation-name:lightSpeedIn;-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}@-webkit-keyframes lightSpeedOut{0%{-webkit-transform:translateX(0%) skewX(0deg);transform:translateX(0%) skewX(0deg);opacity:1}100%{-webkit-transform:translateX(100%) skewX(-30deg);transform:translateX(100%) skewX(-30deg);opacity:0}}@keyframes lightSpeedOut{0%{-webkit-transform:translateX(0%) skewX(0deg);-ms-transform:translateX(0%) skewX(0deg);-moz-transform:translateX(0%) skewX(0deg);transform:translateX(0%) skewX(0deg);opacity:1}100%{-webkit-transform:translateX(100%) skewX(-30deg);-ms-transform:translateX(100%) skewX(-30deg);-moz-transform:translateX(100%) skewX(-30deg);transform:translateX(100%) skewX(-30deg);opacity:0}}@-moz-keyframes lightSpeedOut{0%{-webkit-transform:translateX(0%) skewX(0deg);-ms-transform:translateX(0%) skewX(0deg);-moz-transform:translateX(0%) skewX(0deg);transform:translateX(0%) skewX(0deg);opacity:1}100%{-webkit-transform:translateX(100%) skewX(-30deg);-ms-transform:translateX(100%) skewX(-30deg);-moz-transform:translateX(100%) skewX(-30deg);transform:translateX(100%) skewX(-30deg);opacity:0}}#a0-lock .a0-lightSpeedOut{-webkit-animation-name:lightSpeedOut;-moz-animation-name:lightSpeedOut;animation-name:lightSpeedOut;-webkit-animation-timing-function:ease-in;-moz-animation-timing-function:ease-in;animation-timing-function:ease-in}@-webkit-keyframes rotateIn{0%{-webkit-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(-200deg);transform:rotate(-200deg);opacity:0}100%{-webkit-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(0);transform:rotate(0);opacity:1}}@keyframes rotateIn{0%{-webkit-transform-origin:center center;-ms-transform-origin:center center;-moz-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(-200deg);-ms-transform:rotate(-200deg);-moz-transform:rotate(-200deg);transform:rotate(-200deg);opacity:0}100%{-webkit-transform-origin:center center;-ms-transform-origin:center center;-moz-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}}@-moz-keyframes rotateIn{0%{-webkit-transform-origin:center center;-ms-transform-origin:center center;-moz-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(-200deg);-ms-transform:rotate(-200deg);-moz-transform:rotate(-200deg);transform:rotate(-200deg);opacity:0}100%{-webkit-transform-origin:center center;-ms-transform-origin:center center;-moz-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}}#a0-lock .a0-rotateIn{-webkit-animation-name:rotateIn;-moz-animation-name:rotateIn;animation-name:rotateIn}@-webkit-keyframes rotateInDownLeft{0%{-webkit-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}100%{-webkit-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);transform:rotate(0);opacity:1}}@keyframes rotateInDownLeft{0%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(-90deg);-ms-transform:rotate(-90deg);-moz-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}100%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}}@-moz-keyframes rotateInDownLeft{0%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(-90deg);-ms-transform:rotate(-90deg);-moz-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}100%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}}#a0-lock .a0-rotateInDownLeft{-webkit-animation-name:rotateInDownLeft;-moz-animation-name:rotateInDownLeft;animation-name:rotateInDownLeft}@-webkit-keyframes rotateInDownRight{0%{-webkit-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(90deg);transform:rotate(90deg);opacity:0}100%{-webkit-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);transform:rotate(0);opacity:1}}@keyframes rotateInDownRight{0%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);-moz-transform:rotate(90deg);transform:rotate(90deg);opacity:0}100%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}}@-moz-keyframes rotateInDownRight{0%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);-moz-transform:rotate(90deg);transform:rotate(90deg);opacity:0}100%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}}#a0-lock .a0-rotateInDownRight{-webkit-animation-name:rotateInDownRight;-moz-animation-name:rotateInDownRight;animation-name:rotateInDownRight}@-webkit-keyframes rotateInUpLeft{0%{-webkit-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(90deg);transform:rotate(90deg);opacity:0}100%{-webkit-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);transform:rotate(0);opacity:1}}@keyframes rotateInUpLeft{0%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);-moz-transform:rotate(90deg);transform:rotate(90deg);opacity:0}100%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}}@-moz-keyframes rotateInUpLeft{0%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);-moz-transform:rotate(90deg);transform:rotate(90deg);opacity:0}100%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}}#a0-lock .a0-rotateInUpLeft{-webkit-animation-name:rotateInUpLeft;-moz-animation-name:rotateInUpLeft;animation-name:rotateInUpLeft}@-webkit-keyframes rotateInUpRight{0%{-webkit-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}100%{-webkit-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);transform:rotate(0);opacity:1}}@keyframes rotateInUpRight{0%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(-90deg);-ms-transform:rotate(-90deg);-moz-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}100%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}}@-moz-keyframes rotateInUpRight{0%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(-90deg);-ms-transform:rotate(-90deg);-moz-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}100%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}}#a0-lock .a0-rotateInUpRight{-webkit-animation-name:rotateInUpRight;-moz-animation-name:rotateInUpRight;animation-name:rotateInUpRight}@-webkit-keyframes rotateOut{0%{-webkit-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(200deg);transform:rotate(200deg);opacity:0}}@keyframes rotateOut{0%{-webkit-transform-origin:center center;-ms-transform-origin:center center;-moz-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:center center;-ms-transform-origin:center center;-moz-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(200deg);-ms-transform:rotate(200deg);-moz-transform:rotate(200deg);transform:rotate(200deg);opacity:0}}@-moz-keyframes rotateOut{0%{-webkit-transform-origin:center center;-ms-transform-origin:center center;-moz-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:center center;-ms-transform-origin:center center;-moz-transform-origin:center center;transform-origin:center center;-webkit-transform:rotate(200deg);-ms-transform:rotate(200deg);-moz-transform:rotate(200deg);transform:rotate(200deg);opacity:0}}#a0-lock .a0-rotateOut{-webkit-animation-name:rotateOut;-moz-animation-name:rotateOut;animation-name:rotateOut}@-webkit-keyframes rotateOutDownLeft{0%{-webkit-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(90deg);transform:rotate(90deg);opacity:0}}@keyframes rotateOutDownLeft{0%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);-moz-transform:rotate(90deg);transform:rotate(90deg);opacity:0}}@-moz-keyframes rotateOutDownLeft{0%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);-moz-transform:rotate(90deg);transform:rotate(90deg);opacity:0}}#a0-lock .a0-rotateOutDownLeft{-webkit-animation-name:rotateOutDownLeft;-moz-animation-name:rotateOutDownLeft;animation-name:rotateOutDownLeft}@-webkit-keyframes rotateOutDownRight{0%{-webkit-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}}@keyframes rotateOutDownRight{0%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(-90deg);-ms-transform:rotate(-90deg);-moz-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}}@-moz-keyframes rotateOutDownRight{0%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(-90deg);-ms-transform:rotate(-90deg);-moz-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}}#a0-lock .a0-rotateOutDownRight{-webkit-animation-name:rotateOutDownRight;-moz-animation-name:rotateOutDownRight;animation-name:rotateOutDownRight}@-webkit-keyframes rotateOutUpLeft{0%{-webkit-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}}@keyframes rotateOutUpLeft{0%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(-90deg);-ms-transform:rotate(-90deg);-moz-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}}@-moz-keyframes rotateOutUpLeft{0%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:left bottom;-ms-transform-origin:left bottom;-moz-transform-origin:left bottom;transform-origin:left bottom;-webkit-transform:rotate(-90deg);-ms-transform:rotate(-90deg);-moz-transform:rotate(-90deg);transform:rotate(-90deg);opacity:0}}#a0-lock .a0-rotateOutUpLeft{-webkit-animation-name:rotateOutUpLeft;-moz-animation-name:rotateOutUpLeft;animation-name:rotateOutUpLeft}@-webkit-keyframes rotateOutUpRight{0%{-webkit-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(90deg);transform:rotate(90deg);opacity:0}}@keyframes rotateOutUpRight{0%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);-moz-transform:rotate(90deg);transform:rotate(90deg);opacity:0}}@-moz-keyframes rotateOutUpRight{0%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);opacity:1}100%{-webkit-transform-origin:right bottom;-ms-transform-origin:right bottom;-moz-transform-origin:right bottom;transform-origin:right bottom;-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);-moz-transform:rotate(90deg);transform:rotate(90deg);opacity:0}}#a0-lock .a0-rotateOutUpRight{-webkit-animation-name:rotateOutUpRight;-moz-animation-name:rotateOutUpRight;animation-name:rotateOutUpRight}@-webkit-keyframes slideInDown{0%{opacity:0;-webkit-transform:translateY(-2000px);transform:translateY(-2000px)}100%{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes slideInDown{0%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}100%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}@-moz-keyframes slideInDown{0%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}100%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}#a0-lock .a0-slideInDown{-webkit-animation-name:slideInDown;-moz-animation-name:slideInDown;animation-name:slideInDown}@-webkit-keyframes slideInLeft{0%{opacity:0;-webkit-transform:translateX(-2000px);transform:translateX(-2000px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes slideInLeft{0%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}100%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}@-moz-keyframes slideInLeft{0%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}100%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}#a0-lock .a0-slideInLeft{-webkit-animation-name:slideInLeft;-moz-animation-name:slideInLeft;animation-name:slideInLeft}@-webkit-keyframes slideInRight{0%{opacity:0;-webkit-transform:translateX(2000px);transform:translateX(2000px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes slideInRight{0%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}100%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}@-moz-keyframes slideInRight{0%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}100%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}}#a0-lock .a0-slideInRight{-webkit-animation-name:slideInRight;-moz-animation-name:slideInRight;animation-name:slideInRight}@-webkit-keyframes slideOutLeft{0%{-webkit-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(-2000px);transform:translateX(-2000px)}}@keyframes slideOutLeft{0%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}}@-moz-keyframes slideOutLeft{0%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(-2000px);-ms-transform:translateX(-2000px);-moz-transform:translateX(-2000px);transform:translateX(-2000px)}}#a0-lock .a0-slideOutLeft{-webkit-animation-name:slideOutLeft;-moz-animation-name:slideOutLeft;animation-name:slideOutLeft}@-webkit-keyframes slideOutRight{0%{-webkit-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(2000px);transform:translateX(2000px)}}@keyframes slideOutRight{0%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}}@-moz-keyframes slideOutRight{0%{-webkit-transform:translateX(0);-ms-transform:translateX(0);-moz-transform:translateX(0);transform:translateX(0)}100%{opacity:0;-webkit-transform:translateX(2000px);-ms-transform:translateX(2000px);-moz-transform:translateX(2000px);transform:translateX(2000px)}}#a0-lock .a0-slideOutRight{-webkit-animation-name:slideOutRight;-moz-animation-name:slideOutRight;animation-name:slideOutRight}@-webkit-keyframes slideOutUp{0%{-webkit-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(-2000px);transform:translateY(-2000px)}}@keyframes slideOutUp{0%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}}@-moz-keyframes slideOutUp{0%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(-2000px);-ms-transform:translateY(-2000px);-moz-transform:translateY(-2000px);transform:translateY(-2000px)}}#a0-lock .a0-slideOutUp{-webkit-animation-name:slideOutUp;-moz-animation-name:slideOutUp;animation-name:slideOutUp}@-webkit-keyframes slideInUp{0%{opacity:0;-webkit-transform:translateY(2000px);transform:translateY(2000px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes slideInUp{0%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}100%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}@-moz-keyframes slideInUp{0%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}100%{opacity:1;-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}}#a0-lock .a0-slideInUp{-webkit-animation-name:slideInUp;-moz-animation-name:slideInUp;animation-name:slideInUp}@-webkit-keyframes slideOutDown{0%{-webkit-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(2000px);transform:translateY(2000px)}}@keyframes slideOutDown{0%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}}@-moz-keyframes slideOutDown{0%{-webkit-transform:translateY(0);-ms-transform:translateY(0);-moz-transform:translateY(0);transform:translateY(0)}100%{opacity:0;-webkit-transform:translateY(2000px);-ms-transform:translateY(2000px);-moz-transform:translateY(2000px);transform:translateY(2000px)}}#a0-lock .a0-slideOutDown{-webkit-animation-name:slideOutDown;-moz-animation-name:slideOutDown;animation-name:slideOutDown}@-webkit-keyframes hinge{0%{-webkit-transform:rotate(0);transform:rotate(0);-webkit-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}20%,60%{-webkit-transform:rotate(80deg);transform:rotate(80deg);-webkit-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}40%{-webkit-transform:rotate(60deg);transform:rotate(60deg);-webkit-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}80%{-webkit-transform:rotate(60deg) translateY(0);transform:rotate(60deg) translateY(0);-webkit-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;opacity:1}100%{-webkit-transform:translateY(700px);transform:translateY(700px);opacity:0}}@keyframes hinge{0%{-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);-webkit-transform-origin:top left;-ms-transform-origin:top left;-moz-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}20%,60%{-webkit-transform:rotate(80deg);-ms-transform:rotate(80deg);-moz-transform:rotate(80deg);transform:rotate(80deg);-webkit-transform-origin:top left;-ms-transform-origin:top left;-moz-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}40%{-webkit-transform:rotate(60deg);-ms-transform:rotate(60deg);-moz-transform:rotate(60deg);transform:rotate(60deg);-webkit-transform-origin:top left;-ms-transform-origin:top left;-moz-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}80%{-webkit-transform:rotate(60deg) translateY(0);-ms-transform:rotate(60deg) translateY(0);-moz-transform:rotate(60deg) translateY(0);transform:rotate(60deg) translateY(0);-webkit-transform-origin:top left;-ms-transform-origin:top left;-moz-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;opacity:1}100%{-webkit-transform:translateY(700px);-ms-transform:translateY(700px);-moz-transform:translateY(700px);transform:translateY(700px);opacity:0}}@-moz-keyframes hinge{0%{-webkit-transform:rotate(0);-ms-transform:rotate(0);-moz-transform:rotate(0);transform:rotate(0);-webkit-transform-origin:top left;-ms-transform-origin:top left;-moz-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}20%,60%{-webkit-transform:rotate(80deg);-ms-transform:rotate(80deg);-moz-transform:rotate(80deg);transform:rotate(80deg);-webkit-transform-origin:top left;-ms-transform-origin:top left;-moz-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}40%{-webkit-transform:rotate(60deg);-ms-transform:rotate(60deg);-moz-transform:rotate(60deg);transform:rotate(60deg);-webkit-transform-origin:top left;-ms-transform-origin:top left;-moz-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}80%{-webkit-transform:rotate(60deg) translateY(0);-ms-transform:rotate(60deg) translateY(0);-moz-transform:rotate(60deg) translateY(0);transform:rotate(60deg) translateY(0);-webkit-transform-origin:top left;-ms-transform-origin:top left;-moz-transform-origin:top left;transform-origin:top left;-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;opacity:1}100%{-webkit-transform:translateY(700px);-ms-transform:translateY(700px);-moz-transform:translateY(700px);transform:translateY(700px);opacity:0}}#a0-lock .a0-hinge{-webkit-animation-name:hinge;-moz-animation-name:hinge;animation-name:hinge}@-webkit-keyframes rollIn{0%{opacity:0;-webkit-transform:translateX(-100%) rotate(-120deg);transform:translateX(-100%) rotate(-120deg)}100%{opacity:1;-webkit-transform:translateX(0px) rotate(0deg);transform:translateX(0px) rotate(0deg)}}@keyframes rollIn{0%{opacity:0;-webkit-transform:translateX(-100%) rotate(-120deg);-ms-transform:translateX(-100%) rotate(-120deg);-moz-transform:translateX(-100%) rotate(-120deg);transform:translateX(-100%) rotate(-120deg)}100%{opacity:1;-webkit-transform:translateX(0px) rotate(0deg);-ms-transform:translateX(0px) rotate(0deg);-moz-transform:translateX(0px) rotate(0deg);transform:translateX(0px) rotate(0deg)}}@-moz-keyframes rollIn{0%{opacity:0;-webkit-transform:translateX(-100%) rotate(-120deg);-ms-transform:translateX(-100%) rotate(-120deg);-moz-transform:translateX(-100%) rotate(-120deg);transform:translateX(-100%) rotate(-120deg)}100%{opacity:1;-webkit-transform:translateX(0px) rotate(0deg);-ms-transform:translateX(0px) rotate(0deg);-moz-transform:translateX(0px) rotate(0deg);transform:translateX(0px) rotate(0deg)}}#a0-lock .a0-rollIn{-webkit-animation-name:rollIn;-moz-animation-name:rollIn;animation-name:rollIn}@-webkit-keyframes rollOut{0%{opacity:1;-webkit-transform:translateX(0px) rotate(0deg);transform:translateX(0px) rotate(0deg)}100%{opacity:0;-webkit-transform:translateX(100%) rotate(120deg);transform:translateX(100%) rotate(120deg)}}@keyframes rollOut{0%{opacity:1;-webkit-transform:translateX(0px) rotate(0deg);-ms-transform:translateX(0px) rotate(0deg);-moz-transform:translateX(0px) rotate(0deg);transform:translateX(0px) rotate(0deg)}100%{opacity:0;-webkit-transform:translateX(100%) rotate(120deg);-ms-transform:translateX(100%) rotate(120deg);-moz-transform:translateX(100%) rotate(120deg);transform:translateX(100%) rotate(120deg)}}@-moz-keyframes rollOut{0%{opacity:1;-webkit-transform:translateX(0px) rotate(0deg);-ms-transform:translateX(0px) rotate(0deg);-moz-transform:translateX(0px) rotate(0deg);transform:translateX(0px) rotate(0deg)}100%{opacity:0;-webkit-transform:translateX(100%) rotate(120deg);-ms-transform:translateX(100%) rotate(120deg);-moz-transform:translateX(100%) rotate(120deg);transform:translateX(100%) rotate(120deg)}}#a0-lock .a0-rollOut{-webkit-animation-name:rollOut;-moz-animation-name:rollOut;animation-name:rollOut}@-webkit-keyframes zoomIn{0%{opacity:0;-webkit-transform:scale(0.3);transform:scale(0.3)}50%{opacity:1}}@keyframes zoomIn{0%{opacity:0;-webkit-transform:scale(0.3);-ms-transform:scale(0.3);-moz-transform:scale(0.3);transform:scale(0.3)}50%{opacity:1}}@-moz-keyframes zoomIn{0%{opacity:0;-webkit-transform:scale(0.3);-ms-transform:scale(0.3);-moz-transform:scale(0.3);transform:scale(0.3)}50%{opacity:1}}#a0-lock .a0-zoomIn{-webkit-animation-name:zoomIn;-moz-animation-name:zoomIn;animation-name:zoomIn}@-webkit-keyframes zoomInDown{0%{opacity:0;-webkit-transform:scale(0.1) translateY(-2000px);transform:scale(0.1) translateY(-2000px);-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateY(60px);transform:scale(0.475) translateY(60px);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}}@keyframes zoomInDown{0%{opacity:0;-webkit-transform:scale(0.1) translateY(-2000px);-ms-transform:scale(0.1) translateY(-2000px);-moz-transform:scale(0.1) translateY(-2000px);transform:scale(0.1) translateY(-2000px);-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateY(60px);-ms-transform:scale(0.475) translateY(60px);-moz-transform:scale(0.475) translateY(60px);transform:scale(0.475) translateY(60px);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}}@-moz-keyframes zoomInDown{0%{opacity:0;-webkit-transform:scale(0.1) translateY(-2000px);-ms-transform:scale(0.1) translateY(-2000px);-moz-transform:scale(0.1) translateY(-2000px);transform:scale(0.1) translateY(-2000px);-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateY(60px);-ms-transform:scale(0.475) translateY(60px);-moz-transform:scale(0.475) translateY(60px);transform:scale(0.475) translateY(60px);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}}#a0-lock .a0-zoomInDown{-webkit-animation-name:zoomInDown;-moz-animation-name:zoomInDown;animation-name:zoomInDown}@-webkit-keyframes zoomInLeft{0%{opacity:0;-webkit-transform:scale(0.1) translateX(-2000px);transform:scale(0.1) translateX(-2000px);-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateX(48px);transform:scale(0.475) translateX(48px);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}}@keyframes zoomInLeft{0%{opacity:0;-webkit-transform:scale(0.1) translateX(-2000px);-ms-transform:scale(0.1) translateX(-2000px);-moz-transform:scale(0.1) translateX(-2000px);transform:scale(0.1) translateX(-2000px);-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateX(48px);-ms-transform:scale(0.475) translateX(48px);-moz-transform:scale(0.475) translateX(48px);transform:scale(0.475) translateX(48px);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}}@-moz-keyframes zoomInLeft{0%{opacity:0;-webkit-transform:scale(0.1) translateX(-2000px);-ms-transform:scale(0.1) translateX(-2000px);-moz-transform:scale(0.1) translateX(-2000px);transform:scale(0.1) translateX(-2000px);-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateX(48px);-ms-transform:scale(0.475) translateX(48px);-moz-transform:scale(0.475) translateX(48px);transform:scale(0.475) translateX(48px);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}}#a0-lock .a0-zoomInLeft{-webkit-animation-name:zoomInLeft;-moz-animation-name:zoomInLeft;animation-name:zoomInLeft}@-webkit-keyframes zoomInRight{0%{opacity:0;-webkit-transform:scale(0.1) translateX(2000px);transform:scale(0.1) translateX(2000px);-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateX(-48px);transform:scale(0.475) translateX(-48px);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}}@keyframes zoomInRight{0%{opacity:0;-webkit-transform:scale(0.1) translateX(2000px);-ms-transform:scale(0.1) translateX(2000px);-moz-transform:scale(0.1) translateX(2000px);transform:scale(0.1) translateX(2000px);-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateX(-48px);-ms-transform:scale(0.475) translateX(-48px);-moz-transform:scale(0.475) translateX(-48px);transform:scale(0.475) translateX(-48px);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}}@-moz-keyframes zoomInRight{0%{opacity:0;-webkit-transform:scale(0.1) translateX(2000px);-ms-transform:scale(0.1) translateX(2000px);-moz-transform:scale(0.1) translateX(2000px);transform:scale(0.1) translateX(2000px);-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateX(-48px);-ms-transform:scale(0.475) translateX(-48px);-moz-transform:scale(0.475) translateX(-48px);transform:scale(0.475) translateX(-48px);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}}#a0-lock .a0-zoomInRight{-webkit-animation-name:zoomInRight;-moz-animation-name:zoomInRight;animation-name:zoomInRight}@-webkit-keyframes zoomInUp{0%{opacity:0;-webkit-transform:scale(0.1) translateY(2000px);transform:scale(0.1) translateY(2000px);-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateY(-60px);transform:scale(0.475) translateY(-60px);-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}}@keyframes zoomInUp{0%{opacity:0;-webkit-transform:scale(0.1) translateY(2000px);-ms-transform:scale(0.1) translateY(2000px);-moz-transform:scale(0.1) translateY(2000px);transform:scale(0.1) translateY(2000px);-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateY(-60px);-ms-transform:scale(0.475) translateY(-60px);-moz-transform:scale(0.475) translateY(-60px);transform:scale(0.475) translateY(-60px);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}}@-moz-keyframes zoomInUp{0%{opacity:0;-webkit-transform:scale(0.1) translateY(2000px);-ms-transform:scale(0.1) translateY(2000px);-moz-transform:scale(0.1) translateY(2000px);transform:scale(0.1) translateY(2000px);-webkit-animation-timing-function:ease-in-out;-moz-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}60%{opacity:1;-webkit-transform:scale(0.475) translateY(-60px);-ms-transform:scale(0.475) translateY(-60px);-moz-transform:scale(0.475) translateY(-60px);transform:scale(0.475) translateY(-60px);-webkit-animation-timing-function:ease-out;-moz-animation-timing-function:ease-out;animation-timing-function:ease-out}}#a0-lock .a0-zoomInUp{-webkit-animation-name:zoomInUp;-moz-animation-name:zoomInUp;animation-name:zoomInUp}@-webkit-keyframes zoomOut{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}50%{opacity:0;-webkit-transform:scale(0.3);transform:scale(0.3)}100%{opacity:0}}@keyframes zoomOut{0%{opacity:1;-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}50%{opacity:0;-webkit-transform:scale(0.3);-ms-transform:scale(0.3);-moz-transform:scale(0.3);transform:scale(0.3)}100%{opacity:0}}@-moz-keyframes zoomOut{0%{opacity:1;-webkit-transform:scale(1);-ms-transform:scale(1);-moz-transform:scale(1);transform:scale(1)}50%{opacity:0;-webkit-transform:scale(0.3);-ms-transform:scale(0.3);-moz-transform:scale(0.3);transform:scale(0.3)}100%{opacity:0}}#a0-lock .a0-zoomOut{-webkit-animation-name:zoomOut;-moz-animation-name:zoomOut;animation-name:zoomOut}@-webkit-keyframes zoomOutDown{40%{opacity:1;-webkit-transform:scale(0.475) translateY(-60px);transform:scale(0.475) translateY(-60px);-webkit-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateY(2000px);transform:scale(0.1) translateY(2000px);-webkit-transform-origin:center bottom;transform-origin:center bottom}}@keyframes zoomOutDown{40%{opacity:1;-webkit-transform:scale(0.475) translateY(-60px);-ms-transform:scale(0.475) translateY(-60px);-moz-transform:scale(0.475) translateY(-60px);transform:scale(0.475) translateY(-60px);-webkit-animation-timing-function:linear;-moz-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateY(2000px);-ms-transform:scale(0.1) translateY(2000px);-moz-transform:scale(0.1) translateY(2000px);transform:scale(0.1) translateY(2000px);-webkit-transform-origin:center bottom;-ms-transform-origin:center bottom;-moz-transform-origin:center bottom;transform-origin:center bottom}}@-moz-keyframes zoomOutDown{40%{opacity:1;-webkit-transform:scale(0.475) translateY(-60px);-ms-transform:scale(0.475) translateY(-60px);-moz-transform:scale(0.475) translateY(-60px);transform:scale(0.475) translateY(-60px);-webkit-animation-timing-function:linear;-moz-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateY(2000px);-ms-transform:scale(0.1) translateY(2000px);-moz-transform:scale(0.1) translateY(2000px);transform:scale(0.1) translateY(2000px);-webkit-transform-origin:center bottom;-ms-transform-origin:center bottom;-moz-transform-origin:center bottom;transform-origin:center bottom}}#a0-lock .a0-zoomOutDown{-webkit-animation-name:zoomOutDown;-moz-animation-name:zoomOutDown;animation-name:zoomOutDown}@-webkit-keyframes zoomOutLeft{40%{opacity:1;-webkit-transform:scale(0.475) translateX(42px);transform:scale(0.475) translateX(42px);-webkit-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateX(-2000px);transform:scale(0.1) translateX(-2000px);-webkit-transform-origin:left center;transform-origin:left center}}@keyframes zoomOutLeft{40%{opacity:1;-webkit-transform:scale(0.475) translateX(42px);-ms-transform:scale(0.475) translateX(42px);-moz-transform:scale(0.475) translateX(42px);transform:scale(0.475) translateX(42px);-webkit-animation-timing-function:linear;-moz-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateX(-2000px);-ms-transform:scale(0.1) translateX(-2000px);-moz-transform:scale(0.1) translateX(-2000px);transform:scale(0.1) translateX(-2000px);-webkit-transform-origin:left center;-ms-transform-origin:left center;-moz-transform-origin:left center;transform-origin:left center}}@-moz-keyframes zoomOutLeft{40%{opacity:1;-webkit-transform:scale(0.475) translateX(42px);-ms-transform:scale(0.475) translateX(42px);-moz-transform:scale(0.475) translateX(42px);transform:scale(0.475) translateX(42px);-webkit-animation-timing-function:linear;-moz-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateX(-2000px);-ms-transform:scale(0.1) translateX(-2000px);-moz-transform:scale(0.1) translateX(-2000px);transform:scale(0.1) translateX(-2000px);-webkit-transform-origin:left center;-ms-transform-origin:left center;-moz-transform-origin:left center;transform-origin:left center}}#a0-lock .a0-zoomOutLeft{-webkit-animation-name:zoomOutLeft;-moz-animation-name:zoomOutLeft;animation-name:zoomOutLeft}@-webkit-keyframes zoomOutRight{40%{opacity:1;-webkit-transform:scale(0.475) translateX(-42px);transform:scale(0.475) translateX(-42px);-webkit-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateX(2000px);transform:scale(0.1) translateX(2000px);-webkit-transform-origin:right center;transform-origin:right center}}@keyframes zoomOutRight{40%{opacity:1;-webkit-transform:scale(0.475) translateX(-42px);-ms-transform:scale(0.475) translateX(-42px);-moz-transform:scale(0.475) translateX(-42px);transform:scale(0.475) translateX(-42px);-webkit-animation-timing-function:linear;-moz-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateX(2000px);-ms-transform:scale(0.1) translateX(2000px);-moz-transform:scale(0.1) translateX(2000px);transform:scale(0.1) translateX(2000px);-webkit-transform-origin:right center;-ms-transform-origin:right center;-moz-transform-origin:right center;transform-origin:right center}}@-moz-keyframes zoomOutRight{40%{opacity:1;-webkit-transform:scale(0.475) translateX(-42px);-ms-transform:scale(0.475) translateX(-42px);-moz-transform:scale(0.475) translateX(-42px);transform:scale(0.475) translateX(-42px);-webkit-animation-timing-function:linear;-moz-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateX(2000px);-ms-transform:scale(0.1) translateX(2000px);-moz-transform:scale(0.1) translateX(2000px);transform:scale(0.1) translateX(2000px);-webkit-transform-origin:right center;-ms-transform-origin:right center;-moz-transform-origin:right center;transform-origin:right center}}#a0-lock .a0-zoomOutRight{-webkit-animation-name:zoomOutRight;-moz-animation-name:zoomOutRight;animation-name:zoomOutRight}@-webkit-keyframes zoomOutUp{40%{opacity:1;-webkit-transform:scale(0.475) translateY(60px);transform:scale(0.475) translateY(60px);-webkit-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateY(-2000px);transform:scale(0.1) translateY(-2000px);-webkit-transform-origin:center top;transform-origin:center top}}@keyframes zoomOutUp{40%{opacity:1;-webkit-transform:scale(0.475) translateY(60px);-ms-transform:scale(0.475) translateY(60px);-moz-transform:scale(0.475) translateY(60px);transform:scale(0.475) translateY(60px);-webkit-animation-timing-function:linear;-moz-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateY(-2000px);-ms-transform:scale(0.1) translateY(-2000px);-moz-transform:scale(0.1) translateY(-2000px);transform:scale(0.1) translateY(-2000px);-webkit-transform-origin:center top;-ms-transform-origin:center top;-moz-transform-origin:center top;transform-origin:center top}}@-moz-keyframes zoomOutUp{40%{opacity:1;-webkit-transform:scale(0.475) translateY(60px);-ms-transform:scale(0.475) translateY(60px);-moz-transform:scale(0.475) translateY(60px);transform:scale(0.475) translateY(60px);-webkit-animation-timing-function:linear;-moz-animation-timing-function:linear;animation-timing-function:linear}100%{opacity:0;-webkit-transform:scale(0.1) translateY(-2000px);-ms-transform:scale(0.1) translateY(-2000px);-moz-transform:scale(0.1) translateY(-2000px);transform:scale(0.1) translateY(-2000px);-webkit-transform-origin:center top;-ms-transform-origin:center top;-moz-transform-origin:center top;transform-origin:center top}}#a0-lock .a0-zoomOutUp{-webkit-animation-name:zoomOutUp;-moz-animation-name:zoomOutUp;animation-name:zoomOutUp}#a0-lock .a0-animated.a0-fast{-webkit-animation-duration:.3s;-moz-animation-duration:.3s;animation-duration:.3s;-webkit-animation-fill-mode:both;-moz-animation-fill-mode:both;animation-fill-mode:both}#a0-lock .a0-spinner-css{position:absolute;top:50%;left:50%;margin:-2.5em;display:block;width:5em;font-size:30px;color:#D0D2D3;border-radius:2.5em 0 2.5em 2.5em;-webkit-animation:spinner 2s ease-in-out 0s infinite;-moz-animation:spinner 2s ease-in-out 0s infinite;animation:spinner 2s ease-in-out 0s infinite}#a0-lock .a0-spinner-css:after{position:absolute;display:block;width:1.8em;top:2.5em;left:1.6em;font-family:auth0!important;content:"f"}@-webkit-keyframes spinner{from{-webkit-transform:rotateY(0deg)}to{-webkit-transform:rotateY(360deg)}}@-moz-keyframes spinner{from{-moz-transform:rotateY(0deg)}to{-moz-transform:rotateY(360deg)}}@keyframes spinner{from{-webkit-transform:rotateY(0deg);-moz-transform:rotateY(0deg);-ms-transform:rotateY(0deg);transform:rotateY(0deg)}to{-webkit-transform:rotateY(360deg);-moz-transform:rotateY(360deg);-ms-transform:rotateY(360deg);transform:rotateY(360deg)}}@font-face{font-family:proxima_nova;src:url(data:application/x-font-woff;charset=utf-8;base64,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) format(\'woff\'),url(//cdn.auth0.com/fonts/proxima-nova/proxima_nova_thin-webfont-webfont.eot),url(https://cdn.auth0.com/fonts/proxima-nova/proxima_nova_thin-webfont-webfont.woff) format(\'woff\');font-weight:100;font-style:normal}@font-face{font-family:proxima_nova;src:url(data:application/x-font-woff;charset=utf-8;base64,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) format(\'woff\'),url(https://cdn.auth0.com/fonts/proxima-nova/proximanova-regular-webfont-webfont.eot),url(https://cdn.auth0.com/fonts/proxima-nova/proximanova-regular-webfont-webfont.woff) format(\'woff\');font-weight:400;font-style:normal}@font-face{font-family:proxima_nova;src:url(data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAGhsABMAAAAAyXgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABqAAAABwAAAAcW3K4ykdERUYAAAHEAAAALQAAADIDAwHyR1BPUwAAAfQAAAnXAAAfqJOrgpRHU1VCAAALzAAAAgcAAAYUTJ51TU9TLzIAAA3UAAAAWgAAAGB9ssMsY21hcAAADjAAAAGNAAAB6rnlRJ5jdnQgAAAPwAAAADgAAAA4DsESgmZwZ20AAA/4AAABsQAAAmVTtC+nZ2FzcAAAEawAAAAIAAAACAAAABBnbHlmAAARtAAATf0AAI+ozYVyfmhlYWQAAF+0AAAAMQAAADYFrwucaGhlYQAAX+gAAAAgAAAAJA7BB3pobXR4AABgCAAAAlEAAAOitmk6rGxvY2EAAGJcAAABygAAAdQNpjHcbWF4cAAAZCgAAAAgAAAAIAIGAT5uYW1lAABkSAAAAXkAAAOMV0997HBvc3QAAGXEAAAB6QAAAtuMD3tocHJlcAAAZ7AAAACxAAABLRMVH9p3ZWJmAABoZAAAAAYAAAAGMAVTUAAAAAEAAAAAzD2izwAAAAC/vzV2AAAAAM914IR42mNgZGBg4ANiLQYQYGJgYWBkqAHiWoZ6IK+B4QmQ/ZThBVgGJM8AAF7rBPYAAAB42r1ZS2wrZxn9ZsYev9+POL6Ok5vre6uUFtQbKKXgigWt0lu1grSUUkJVpOINCBHEopI3FDCPDVZ5qgYKi0jtKhKIxe2mtPXaEgsghdu7sFAlFhGLu/CCRYfznRk748SOnTjCR7bH9sz/+P7/nO98YzFEJCpVuUeMr3/l29+QsATwjTiO6C/G1776Lf1O3E/4zcS7LVnrTviFxFr6xtINMa0/6jXm8+bvceZV/L7qHDpN56bTxbPj7OG44dRxvMfXutN3bjnvOwd41+chXg+cjkx5OJu4ro+2OkADxy1+28A1O2PnaUtdfLsveRztTWip7z9z7JfDKX33J/+KPtz3Az2e1Nex83szz/ivM8DYBzgaTBvN2PkDPXfsm+Zodn2N2OmzG7/+6Jgz6g2PNZr6zcw48Rxdb772Ry003Dhj5brOzjBqR1eMt+H09NrRHHq6J/DZxP68CphyDQjIXYAt1wFbPgrY8iMgIC8DtvxMfoXXVwBbfgfYuO5eCQJptBPFawKISQqoSQaoyToQxXtN1tiHLXcDNq67F3ve39P9gCkfByx5AAjKJ4CQPAiE5ZPAunwKiEgduCKPAhn5ApCVZ4CcfBHIy7NAQXaAonwTSMtL8kP0rjMZn0NHfoteXgUi8iZQlLeAorwN2NIFIvJ3OUAL7wI1+Yf8E8e3gJq8B6zIbaAm/wLS8r78G+Mx0HcNEb2GSF7HvF6S78r35PvSkh+g/5fR/8/lF/JLjOIVRNAMNMjvO5aNvjam74JFHthnTbBS1aKF997C7aEN3W+jfTRYtM0JjANT8eyfNx5+PpwY+4ne5mpxkupBVaC6gwtZpYNhOx5PW1ixXUD1uYu1O8A3+zjS79v41OaK7s/SQjcXuDM4qQzeOTd1diMNPziaq7M5rmH8tIVRibP6wQBHXWcVSnSo16KVQ4xKdaqtn7xM0ka/GNcHezi/Dn5sgNMGOO4+bHDbBMNVRVLgQAR8UC1JUUuuUUtUX9JgmypKkIqSpKK4qpWhomSoKBYVJUNFyVBLDGpJjVoSo5bEqSVRaklCPgPk5RHZAm9VUYpyAyjINlCQp4ACNWaJGlOixixTY8ryJeASlaZCpUnJi8AK9cak3mSoNxnqTYZ6U6PeJOQ1IC+vAwX5A1CQN4ACdahCHapQhzLyDlCgGiXkr/I3tK+alKImBalJKWpSkJp0lZoUpCalqElFeosNxOjD8hEozp4qjhWwriPWd2ON8txhG/AOHSeK1dzG6rbcdb+Qfe3PhQ2vty3uSs1bm9OYeuZ+OkOeOo0zXNWnJkBlnNsj/vneMc6uz9kczq+Rw1fqmPqPw+ljmE/rlPUXmhcafr2gR1A0nW32VcdO2NCdwL2xy2/3gQ6eAzrGHj1jG5/VXTRcn+JXsiN98fJQ62iNZju7GaPvDp3RKIrzRseEAqlahGUTMORjgEX/EaBm2NSMMPmq6lSnOoWpTq7TCVOdDKpThuqUpzplwM4qvIaqU4LqZFGdLPaXpDpZVCe3v1X2F6A6BalONtUpRXUKUZ2yVKcc1Wmd6pSTz8rn4IBUo3LyJHCFSpWTzwNX5GlgmapVpmptULUuUbUqVK0VqlZVvgxcoXaFqV15aleC2mVRuyxql0XVClG1slStHFUrR9XKUbWqVK0qVcuiauWoWiGqVp6qFaZqZahaYapWhnqVoV6FqVfriGsU0drEqtyP6DyAdfi1/AZrYVoV1S7jL8YdtLpGbu0rs87tEjqeg1Y9qrOq0oqqpb6GlVGH3Owxr3V4To9cbh9xhjux69+J0338cWVyOYCWm1ql0U0ckGOqjT2+qgb16DK6yrqTvv4oX/vrksl10nHOuXUNuLiFPvOYt3I+7yj7t8B71ekW0MAzCq2+ide9Uc9NjrxHXu9Oc0h+vuJZHyqZx0PX4xvc+Rb3vOvHg9w5QZxxH1kX9vmAoucDlGmrZJpxorIInagsqmSayf4s8ipGXsXJqwR5FSevkuRVnLxKkldx8ipJXqXIqzR5lSGvsuRVjrzKk1cF8ipJRhXJKGNC9aFcipFLcXIpTi7FyaUCuVTwKhHlUpwsKnpZ3833bqZXzqgWaSwfRARfReRM+y1lSuBPwScwvstUx85QfRdT3YVbQMYHn1aRUc6ZAbzdts1M1KIrPiP/R/twlz67dUH5tA5+bMzbGs7sIA5RHf+EeujmYhXaGSPpqwzA8tG9H601ZnsIjLapHmAhDW4uFHd1JKvqRKa5z9O1cV7/espjW3ZR4zfxbE2sHFVTWqw82zjaxHOiG4PidubmWGNiJOtu1hg5raavh7n2JjJAe/L+m+NuXNvdV+okz1D969kmPItqvUVv5Wp9miofpV6b8jBgQ7UfwVlbQMyn3Ul5DDDlCSBDHTcR4ydxvip4Ul4AIlTktE95Iz7lteXPgKu2MaptmhVViA4wAJTpA22Ocok+0Ma1cYxbR1xkjspy1GvMUVnWqkHmqCTvs5WZqQy5C56szHxlyIfkHhxr1kqhQrsPx5q7DHrTMjOY61DLzGOXPMeoDrXCbBZm9ozQN+Y936h3yAryaWCZWa7KGFXlcWCFe7HKuFSZtXLyPLBMH2gzRmvMWklmLUN+LD9F75q7DOYug8644nlCjWOVcawyjq4DNBjHqs8BrtEB2sxgWTpAm3ksyyivMptl6QNtXF3FjBLe+tex+g9zHo9iFo9hhXV9dXWfwqq+iNV8Hb2/gdV7hz29J2boP5r/bLF/gphc81ixDZ3qu7uNiqUup8dqt6t3tXlfY+ckM8//MLZmZ0PysjlPtpr/TtJcWXgAR9fF+860+2fqe+epuH3fbE/SWe0B0d2bNcfj48YI9yaOqzvD6c6ZO9WNz1JbZ2u+/xy8+6Gn5opR9XuUa5uTxsq2Zt0LaB3Pa1o3TGvrzONqn3ZXk/d8u/wHan96rI/9C9Qar/hH/2Kc+87xovdCFr8PPouhjBPz4ClRashFP/ry/3hsXmD0Ohd6V6sDxTeRnzVXW8zSFvJ5DLkkBySQycrIbBUgwZwZk4eANGu8AGu8IGs8mzVeiDVemDVehNkyxRovyhovJM8BafkOYLByi7JyizLXWcxy1uj+doHOYZ1jKtAtVOgWLtMtVLzx5QH1FMujsaqLqNJFLNE/lOgcSvQMl+gWSvQJJd8d72Glq94gwHmu0BvkmEdtOqcQXYFNV1CkK3Ddks0olBmFMOcf4fyjnHmMPqFAn3CZPmGJPqFEh1CiQyjRIZh0CDk6BJsOwfaclkYqxkjF6BZKdAvuf2455vDLjGCBbqHCOBboFir0CRX6hAJr3xDdQhCji/FuXA4jr2C+D2E9n8YMnsH4n8W67WC9nsM6vYlete132eotuf0/yz1sXwB42o2Uz0ocQRDGv+ru3RgJIVl3ZpeJyBAkiIQlePIBFhZREJdEc90kmASWjfgHxKBePPgEnn0A8Ql8AI8eQg7iSTDmESQXU13Tu+mZ7Mgcprun+NXXX/VUDwjAKCbxHtTtbPYwAsMR3N/LTFDQMKvrnY+Iul8/d/Dy2/qnHqY2ttY20GBCCWWfhNcu6xGeYQpvMIsvWMM2yhx/zKsjnOGaRqhBb2mHjiVOdJpo0Lm8B/ST7lSkmqqnjtWF+qNj3dSr+kCf6h/6zkRm1nwwh+bEXCW7mstkLpUTndKM+NCoIkLsHJZ4JI7YsSJjUIiq5VJhIcrXCnOpoBDla70o5CufqheiogyVqFccUx58+wp2sYd9/vJPmNrBJrakG6pcWSh59Uweock0YQzjsvcwop0ilLizp5BWsePzAmR7KDmOV66q1x674lH/Tn6eMzTHYkxLjq8+L+tslt2hjgl3hpMuvuxpVt1+2p22fY893eUMZWub+K+2Ffcl+nuG7IH4DsJFW16XVXNOuzW4FcM8L6UUEj7Ps8+2cj23Bp6DBzyHBTyHOZ7fpRQe9uyzRTyHKaXpTO8o7oIxjtSkpn7vDNfsd042p8GP/R+Pck22n3+zwhwWcSvzAn5xxiJueFwQfk56WDEf81jGU76RmnMDvpt2rslN3R+sFfsIhVfo4rtEmmj/BeELSGkAeNpjYGKezBTBwMrAwjqL1ZiBgVEeQjNfZEhjWsXAwMTAysYMolgaGBjWBzA8+M0ABbk5xcUMCgy8v1nYgv4FMTCw6zMeUGBgnO0LlGO+yxoGpBQYWADVjRASAAB42mNgYGBmgGAZBkYGEHgC5DGC+SwMJ4C0HoMCkMUHZPEy1DFsYfjPGMxYwXSM6Y4Cl4KIgpSCnIKSgpqCvoKVQrzCGkUl1T+/Wf7/B5vEC9S5gGEbYxBUPYOCgIKEggxUvSVcPSNQPeP/r/8f/z/0/+D//P/ef//9ffng2IODD/Y92Ptg14PtD9Y/WPag6YHZ/YO3XrA+gbqTBMDIxgDXxMgEJJjQFQCDgIWVjZ2Dk4ubh5ePX0BQSFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTS1tHV0/fwNDI2MTUzNzC0sraxtbO3sHRydnF1c3dw9PL28fXzz8gMCg4JDQsPCIyKjomNi4+IZGhta2ja9L0uYsWLl66ZNmKVStXr1m3dv2GTVs2b92+bfeuPXsZilJSM++ULyjIflyWxdA+k6GYgSEd4rqcaoblOxuS80Ds3Jq7SY0t0w4eunL15q1r13cwHDjM8Oj+g6fPGCpu3GZo7m7q6ezrn9A7ZSrD5NlzZjEcOVoI1FQJxABuDI0XAAAAAAAD3QVWANMBCgCaAKwAsAC6AL8AzwDXAJQA1wEMANcA3QDhAPAA9gEKAM8AvQDIALQAxQBEBRF42l1Ru05bQRDdDQ8DgcTYIDnaFLOZkMZ7oQUJxNWNYmQ7heUIaTdykYtxAR9AgUQN2q8ZoKGkSJsGIRdIfEI+IRIza4iiNDs7s3POmTNLypGqd+lrz1PnJJDC3QbNNv1OSLWzAPek6+uNjLSDB1psZvTKdfv+Cwab0ZQ7agDlPW8pDxlNO4FatKf+0fwKhvv8H/M7GLQ00/TUOgnpIQTmm3FLg+8ZzbrLD/qC1eFiMDCkmKbiLj+mUv63NOdqy7C1kdG8gzMR+ck0QFNrbQSa/tQh1fNxFEuQy6axNpiYsv4kE8GFyXRVU7XM+NrBXbKz6GCDKs2BB9jDVnkMHg4PJhTStyTKLA0R9mKrxAgRkxwKOeXcyf6kQPlIEsa8SUo744a1BsaR18CgNk+z/zybTW1vHcL4WRzBd78ZSzr4yIbaGBFiO2IpgAlEQkZV+YYaz70sBuRS+89AlIDl8Y9/nQi07thEPJe1dQ4xVgh6ftvc8suKu1a5zotCd2+qaqjSKc37Xs6+xwOeHgvDQWPBm8/7/kqB+jwsrjRoDgRDejd6/6K16oirvBc+sifTv7FaAAAAAAEAAf//AA942sW9CWAUVbYwXLeq1/SSrl7S2ZNOJ+mEkDTpTtI0ISxhFUJACGEZREAERMMiuwjIIAMY2VwRN0YZxsFlqjotKKMI7rvjMMI4juPojEt8OPJ86nMwKb5z7q3qdEJA5nvv+3+xu6uqO1Xnnnvu2c+5HM8N5zh+rn4yJ3BGrkImXHBgzKjL/CokG/R/GRgTeDjkZAEv6/FyzGjI6hgYI3g9LPrEIp/oG87nK4Vkj7JAP/nso8N1b3FwS67l3GmyTd/MmTkbN4WLmTiuTBZ07bEUnisjkj0ocSellJCst7fjS7KE2qx6zlQWt3m4cboyyRaMW+mRnErKZKtNdLYJRhNf6I1ycoogOiVrtF9lpKomlOZxGwqKXT7B3zJ5+aRJyyenEEPRkbXRpqZobVOTPq2jkaPwzBF8/CP6hZyVS+eWczAwrkxKDcctOs4Ij0sLESkDYZINzva2FANCYvFwqfCVJRhPYUcGh2wDYJzwizSnDX7hZde9wXgaPZIz4esUC0AnRGUvB5+pUckpSo4o16/SVVUTptCmEj9fpEKOx3NGhcIjC53OOaNJ08h57Ej3TXjEiLDji+tayBP+rkMYR4DjdHHAaxaXB3MXywS8Sp5wzIjjsYRjegJ4NtvCYVlnbZdTc0OhOEcy9bYyWcyGixxcdHlDMNr8oOwjZQhXJOzywyss0JfRT19+F77wq0D5u2vfLXtv1cMr31m5f827pe+te7/8g1UPr/79qv1rTrx149tk3g6yaAeZp+zF1w7lth3siF5H3AvcmHNh3RZDEVfCBbka7j4uFkCoCwFGS7vULxQL6FLK2oYEis1lMQeOwxWWy4V2KT0Uc5TjNw7RDDQTCUq2k3Kpq10qdcjFpCymc/QNwfiKPJxXVxZzpveDM6nIIYdhFvJc7XJ/+CwFypFIVM4Li045zRMF8tEF4BIXlcrFQ8SWltc3XANUJTmckgdIajDJJV6xwlBdVROpDnvSvMbigJir87jtvNHjry50udO8op2QQaS6qjgwZkudvKCq8crhI8qyTr+4/7sDW5bsb7j2pvE11QsfX7Jf+eDaK3/WPJfMvOqqebOOHxk+10G227zFJXUjZ/Z/8EPx2eeyHowt8SkPuP3DL98wfsKty8akPP10mnC6/8hsUm+Z3rHLvqB+SGMu4lDPRc99rj8O9GvhvDD3RYDJh7hYOuAxVohLq9TaHssA3FHClj3W9nhFXqEA014Bh6lmephqbSdSP6RyXFuAM8nqkJ2kLG5gZ0Df2XBWzM6KHXIZnPnomVyJhG+FVWgW0rMAX3JZseh8MiM3z1+YSRdlRTogONsXjcqeVDgycNFoEs37C4oj7rRwqAaw5i8wuEjYTKpq8vGrfPyGflFgiD57955nnr37rqP75jVOmD9/QuO8oHBNa8edZOuzpOLZo8ofj94/f9+8efvm67y3HT92++7jx3dPW7Jk2vTrr/9xp7757EESvf34cXZ58eJp05ctY/RXB7gzAO4CXJgbwl3PxfIQb37EW5mBsSR5kB6QM5SygBKxvc1YAixArrK1SyUOuRYGb/O0y/XwWVUCo9NXRqNSrRhP8ZeVu5B6bE7Z60PiKssD4vJFpUHik5zRll2JtIV4GMRHiqtVbNgFY5o3zVsT8RrgwFccAPRU8BQ/keJAccBOXG7vIIGhqq5i6uz6WX98cNex0ujVjYOjjROrJ4eeaFqw6wbls5HhR/8444HVI/7ROnfFqutrmuvHXP7M8JqxI/zjBo64krQ0rL9yhO+xjdueunPjwPmjRpflTph+dXT9Lye8vOPuFfXVu0JX3r3kuptmrx551azK5fyk5lWZ5bUj+wwaNQtwRpBfkibKL+sZt1RZJQHWrPLJi/BK2d7FCXvyvi5+l8zl8JnNygLeqV8Lz3Rx9DnkpGyE59gpo6pxOAFjvMfthEXZ/KvbNrfMm3/d5tvOkjPkb/Lc15Tt7Z8p216eL3MU/iJlAfko+V4pJ2Vd4l4ub43TwQeMaU6Pmy/avHv//t2br503T3lnvkw+If8kH8tzX1e2f/GZcgveq1bg+VbAhQgcLKZHXKSquHAGpdSTki4Ut6siIiS7VK4aiHgDYWPEa/QaA15/xFj7xhsDjqUstRyPvvVW9Lhlacox4Z0F18xZ9+mn6+Zcs2DODZ9+egN9FveS8JrudljnkzmJC0rGsEys7ZI+FOMI8kIuBbgk4fCQCMgWrTg0iQ/FzWzd6kIxcwp+bTbCL1PMeJjCmctQdiFg1T4RBLfHJ/rFWrJ2D1mrbN7DL95G7lWu3qY0k4MAQ4tyhtxFTJyDK+diqZrkNnIouUU6KwYQ2/gC7gHaASx4yQBkXqNNszEwiESAqlsuH1A/Y8GUOeEpZqs3PPz6iXOb5z89aHzukrABx1pHbudL+QZYoQU4VpmY2vFFJF1Q5oD3CHbODLSk1wD31JHT5Pann8a/bTnXTloBRjNXmqRdaAdESqFUqqoXsoXeoktfAF1hMvzP1IQpU+B+3LlT/Gb9BoAljUMAkEvydpxl9fkeEibk031KVqn+kbNTqU7RfO5z3V6gCy/AALLYiQ/PEdpjBmQoAQGg6EOhyACZleGQC1CTAbkEbFUuyAA24jQgywjkwKFV5ZeDhHAoV0AeATxBqHHn8uHQIL66qoIvsJPmQPO6p5csfmpdcwCOnlq85Gk4+tY3YvXlE1YP9+WPWPXQ6hH8wYWvHN5y+eVbDr+y8JpXD2+bOHHb4VffefPR7RMmbH903vxHW8ePb0X8AQvk14AeYQBZEtMhPyRUMzMGJd1JWYCVYiKISio+Ef0kDBRjzCPb3j3zkfAa2X72oM73JVtrTaCTDAc85HINXMyBWLABFqgkyhba23IdggnunBeU0ul6jqUbkSjTHUCU+UhANgc8RYxKuaJsTAfOmo3yGR5ZUwjIIJRhAsFWD9IDHoi/wNg0lVjv2vKXW/rPuvexFfwVHQW3Hzkyf7JvzKL6v+3W7bx2ycznN429+9b7d089cXTJ7nuvXXplaPjsPg8xWCthzqIAaxmsr1gpwqoTmOiUXUJ73G4uzQBRacfJ6wur76Rc7GyXxPyTopwNOClHcM2AFFiNxVEA1S4it3c5Y5607GhUVSConPMVGKtR4iEXx/UQDjEtAmdX5y8orNxU/3rL5j3Ku8tLvJtv2nv/qrfvvKGp4+GPiK1qyryaqmtn1ymf/8fjyrcv3T9u2vVXvqB7n58ev3rPnVctf+k39UsbKs2GivHrx8of3Qh0GAX8L4S5TAFdeyoXM+Ns8simOIuZtwFLAMUP9ClDiCre5pOSNSSbYFhCKGai/MFkAFZhNlGugawiFYdp4ejcS7wo2XA2qglwDo8fqACU/ihfScYcOvS1MovsI9XHhVkdsRPKG6T6BL+K4XkF4BnpKxu17Sy6LAHPNsSzA/DsNmfZAM/uFMBzTlCynpRFIAzRiiCIqeYySXTIBiDAdFgvufApgu4BqxgwbhDbBLM7iyodQhZT5cxiG7FY01ESu5GScBoS2oYxQNkdzgASk86fv2Jb6z823HPnusfXHxQ2dC6JPHTFyhdvVD78XHnmyIH9tyxo2byikj97QlkVrr/6za1/6Eys9Y1AN/lcBbdYHVExjAjFgWyBEbn6ZqGa7cIRBemydwCKfSHJ4ZBLYQReGEk/1EiB2NsseheOQPKKssmITKAvqFMSXHCJMueAUVqckikq6UXJqKoP4ZDXiMRvJzlEG4qdIJPw5goJxaq58Y4vdp25e9GATTMWH5hU9fqS9W/dtPaLO1cc3Tg18L2+ePiKsevveHDVlF/yB+9UjrXcHa8duP6NGwLjls9569b1v1835ufxtyO1180ecPvPVq1rZvMYAdpyUD5RALJP4xNIT8grkElwYDVSQc94NPGRiPB+5xnlB16n23TiwI8TdJuAqyL+FgP+ckCm1HHXqhj0AQateL+BeL9BFG25wC1zHVIFrjnQMCRDUK5w4iW5kKFRiuJXIuBzMFyIVojOQ1Z3ZpavVKBEMdAHmilnEL2lVaryVROpAHWdslYepRPDXX4F0XTSCj5gF1zuXIGpXYDHJzZvuH/A7J9vHzvzidumPrBh82/v+FL55D9u+3bf6pUPD5rVXFTcPHNQWqD/2NqcQMPUyK5/7CKz1h7pW/LQmjFrJvbP6DNx58/WPFTS98jaVU80NT1x17SF106tnFSZo9fnVE7kKwoHleQ59Ib0stHlzbNnM/t0wrl23Vp9C2C5kluqSl2PxkWDQF95xamoxOchfYUoovyAFb8DjU6pNCSbgT2h5eOHyYDFBDSUKbaleoQ8ihRUypHF5omSMyoVO2PmTORXUlBkrLaK65I7gQiyMJQ6AUphKpoiFcC2DBNI+t8oOVVetePF5f+8d8mAn18xbcfkvnzo9evXv7nhmwfXTHmwWpfRb9jcuvV3CA+9QExjNsbfXr7qj/JNo/Ycqhs47ucPNGdZG5bNfvOO1TdOHRNsbh4UuI36C0CeC6dBnrvAtumS6DY0aJ0o0d1JPgMplbkOPD3kuthTwneX80J27eTJtXDCcN6ifE/ugmeKXAZXzcU8+KgMHdw8yHSITPpEZ0hTd6S0kJzVTeOJ9NR4ih0IAQCQpPqYssIjmlY2TV6+KcoUoAm5i8O6y/j3lzc1LZ9Mdb6nQOfbD2uMAy7rMRNPrbCjM43/kp91H3lkv/KYEjuA8NaS/cJrQpz6ajKZxgSqIShLerTsTEHZnNCUCLzgJh3XCzvI/tZWsmXbNraek54VqTYTeFwtf7rTLex46gBpJE37lan3UdxknWsX1sB6zQPd5mouVoLz4dep9Jij6jbuk1J+SLaDaVQE2LFTWpQNqopjd4vOuODM8QeQ0xXBikXZnumULECPOX6QoQZnHtKgoNIgsjU0j/QeN9rduGIZA3clZjWr8fNtRz8pGTqucWhJuufQ6OGzZw+fO/OJxXc34zw36/bNvia+fdCCywbXVA0tyqyyDxpx3YjFl9VPDA5p2tWxQtP2cHyjzy3Vn9VngT04jvsULEKYeyk/3Jaal2Uvk8fq26W6YLy/lSr1QHi2sDwcrhWHpIpgXEcvE6mRKolhpvmHHbIXBj3U0y4NZZaziVlC42F51mQeGfTZt305T1mKlFdhl0Yd08v5af+yS75j0ihHW+6oPFdZ22h8j8F7/i35t/gNdljDUm6Ua8v1jRpdAf+RJ3Pz8tXjigppSCaRy4aKzsM2nTuron9tHV3n7v6w+gfUghk+djjwRc7k9ZeFRZUPOkGf0jlRCwFCDRJc3IhlRLs3EhYMHlznuO45X4EOLS3UPsHmAm2FL2I8wIUyyDD6H2TVH54jpfePXLJ5eNPVJj6yf+ptj255f9WMzf6044t1waL8EUNLlVcUZZfyzUsrp9zzp3Uvy6WvfnJYOfkIeXXulEk3l1c7rxy1+TD59hRZ+efHlY9+u+qFVYNn1NsbZz5799bTWyfWr+j81p3RL1TcuP1nP5DI6leU77av/uM905bVbjxIit+Z1jKtnvD9xjJfI6iv+lkgo4ygAfXlYhx6l4QwFVRxg4kjwDYNSLGWoGyl8soEyzcFUBIGYeUTfILLJ+j4DFLGpytn5nZuv/oRcvp76k8wKT+QD/hWWHG7QQ6+C8+wg7afz13FniKnAoem8jAfOHS6lz4qHR/loxw61YleLCnVgVahbAHRlY2iSw8rBI0BV7aIYp6TvchPLFEpXUSpn++U9Aic6GOsBcWVwV/kY0LeV60d7Ob3HX5729zF97z7jFJHWmcvWjRbWUE2Tps3b5qyQd/80t1rf+MRj9/4q7dPXD3t8kUnZo8fdxXjASCL9aNB1mRzYeZDkp2aJmMVmEKGwDPVi5OtTljIYGl50jQ6QsVcx/QRzuPmkDC8vK+gsJhvXnyMmO46RhyT3ggfufYN5VtifWPh78JvvaTsu0v54dhi/uC9JOXw/N9sWzh1sfLln95TPl8yZZ7y+oLDJIXxZMCzfir1G7u5/iqWUzQsuxE6D4UuBVCb4qDeYWQ4aQioO0Vly4g6IHQH5wOsoasOIPXtJh0nyMiYskJ5XvmGWHf9qeWaU7cr3+ibn1Bef1l5V9l0YuN7mzaf2MBwhPMdBTgs3DAVCrMGBRgMcT0jKz0CZKUAgfyltjc1zc0W0KJ5QyikWt3M4mav3cIjnaP5g53N/FP65hPKvhPw5O7PNIOGRJ/Z+/NSenke2PoSH1Lt3K6nJZ7FntQpqfP/qb4J5j8PNVlNgZWyg7JoARkXlL1wZgqijxgfZHdR1u4GTGeAju7OwAe602CAPrjkBj4Vs+ipMpGhabNpIkxERlQ2AYHLnB31WU2TRdrJd3UjnWogadGANhHfvPQ4Md5Brnz5hdojLYx6Zv82rMzntyxQPnn0ZeXIcf7gA8Ty5NXKp0svn8cI6LLQiRMKv2LzE2Qkw6E+QudtsMoJjIwTSPpwXEihWBS6Zs0CWORDksWBmizgk/qbtDnDAAdavYDHM/wrX3/dCZPTeYIvP3uQb+48mJgzshGeJ3C+pDlTPQjUjsaXPnHH3WeQsbC/dZz7XBgDf2tDjceq2UhGLUJioJPMjDHByiwdowgmWcK8gfuhb9WxdO7m624+o7zz8ZpDy7YtFh7qmPHxlyo9naa46NcDF7pwdwTQIVM9XhbM0SgDlfjMwB+NOHgvKe18j29WTikRMOo6V/HbOtd1lvP1O5QGeM5GjhPegOfoNe5Lx8HwYNDwEBMopQp6IBxjF4I9G8/w0/XNP67rWgOGHLiXlRup3stgDidBzbyPVoDa6sD7UEckehuNaCHyOiQ/HEdMMFmibCQ4DJhF4ifibjKRrCDLyMQzysx5ygx9c0ezcPDsQV3ejx/jS6WfSroG1edLhqSndy09s0MW1Kdb0FFihvnh0ToFOtcwaVIxSZCK4OHf87/7+vNOoM6ORiF29qDwbkdQsy31b8B6TOWyuFFczMYxZ0RMh0szA4k1m3rdHLASwZoEXiebgeflwGcaWJOyjY46wwWGJeHMJsqlnQ4q7dOcDp4uLZfbGQ45q6tA9PPNMhn8+t1E99SCBU8pHXe/rhwf8cObb5w9+8abP5C/kTvIsEPX/k45q/xBOfu7aw/xtpPKFyT95CniVb5M8GjdI9Tf4ELvcBenQg+K2ULXmFnQVHbKqi0hjVuj8EO1XXahezhZ0Pl9GaRLtv3sna/++bZyJxkzb+PGecohffN3h5/8TuH4E6tmzVnFqXiLU7w5wWqaonqe0jS85SMAfoo3F+DN5aD4QryhGZkDyIrZHTpkW2Z0cHAMlVZkVvki4NFi7o5HjwM9uQYNlejfremJzsNLD6y691mGz4VTDj5ycEYPnN6tfPDKhtbNExlWS4+3Htt0SEMswyvG9lK5dPROUeqzMOpDrSJud1DUUudURkLBcFAFw62iFjVwN0ZgrClIFA47VXVQs0hCtZ03wsr2J6N76uv/Hbni+iFkgvKlcuIMYH3Tz+cj1r96buru2XUpnZ8TReH5d1dfNXslXadRsOdXAe4ruNlcrFzzo7kR1EyBuUDEk4DmdimHrdOA6v/IEZlbySg+qQOzvaAcrYOAU07zIryZOtA1OCJ6qdHgFqW0ZJ9ahbG6CsQH0zxAXc01Uos1P7p13F83b9tSM2P1zZtWz6gh7r+SAS9uGf/O4gXr4dqmm+FaoOkG+VrlwPEjk65b3FgxvKzAFxh4+foJj396PDZ+/JVjS+sCBQUlQ5o2Xj7ixusayxkvQr/aXKpXDuBihmTfhySE0OBCFq0H1qY3IGvTC+aymEGPhwb0onVZY8h+oroy5aozuk0nTvy4TreJ8TpY98hrHFyEi9kpr1P5pmQOU1c7sk5AoUDFEyqQ6HGXTRgAt1OvLEqAtHwqCUDbyed2f/skaXzyW1i7f1U+Ut7lc4Rox1sHjh8/IIQ7XlF+VN4hlWxsms5sQLlFx8bxVG3ucutwBsrT4ClUEPh0xEEegH+Ozi+U94BlS7oJKMkI6MScsZzy7N2qHDNbgGdzNB6pM4TDCb5NwEwkzLNntFO+jbZR3e+/XkhtIwFsI/6YnJL2L71kOXbk+fDXM+h1c4VsSTFJKcfsst4M3+mOCVyM16egVXSIF3R6c4qlImEXwe2B/k3WKMUQwB6m4MObnVhICsl8jmTBh1VZc45TflC+O8fBYD7VZeELuPI3HXYYkwnwM5zKzmJ1JZrC1KkKegTKTiYxeeTzuhTK5830EfR/EywWH8kjs8hM4lPyeE75WNmobOSf4fcqVvJt54LOet7b2a7NgxeeY0IZbew2D2bqf0YJk4KSxkhnA6bF2G1agLR0xEVWklXE1fn11yCdn+JHd3zc+RofwfvPABqeQeVZhSpPjRqHFJgySZVG2ci8vbCKNR26mvioO88zg3+qc7TwTecw/o0XhGMnjnXUqbJ6urKWnAUeQNcHU1Wt7eiWUP0RaB4b7VyKDnXTuJ7GpzCok8IiZer6UJXV6WTfObinstbwzR1nq2/nLiUmA6LVv498uk+/4exUGvNbS16i8IDOzoYI8AA5cyo8xpOwcOMGFQJHnLCQGQniiQqYoLlRvAAVKKa+IsIBYPuUWd/o37jjX0gbAf6gMJWuHZFLhE3omqFxEuK3kABpuJ+M3v9f3/IH+cc6m9hsw5jOnT2Xpdt27gkYk5fDZ2FGBgUP3Tj0DhjrMOh2/rh04u2IA90yclq/F35fRH9PdO1JqNDCYzIRRBY0QZS8RfL26vcq76NMmQg65nHhe7BZy7klasZANpJBobU95kCPl8UE5kVZtgPNCwSkgq5Un61d8jnkdFypAbBjvLZ2OQgnPqR4G0rJdLFNb3FkU7eDHhV9YwZT9G00m8Le5bhW3fA11MUo+qupV5FXvYrVlJdPHHj1ysHvLrlp/sG10w+cHbFqYUPfP0UemVO3em7dqTUzRq8vKlo/esYaEpy4cWzxhtsnX7X+zn3emglrx3Uubhkysmz8TQ0T5lRX7qmsvgrH3AqyaSrlqzncFap+QtmS28zYa8yAA880w2hzmaseRseLIeqsRzeO2dEu56G3GXUCA3IS2a3m82SKkhn0PObwRhUW/ScYRvYXFAc8oiqp0BlvbD1Ve+CKF7777oWZBwYU7Rq7/p571o/dWQwrVBk/Sfns9H8qX0weu4WU9h/71G27DjdE6ZqaAPP1GsyXixukRhRtALSA8JrMTKUCjcbiUJUoG9jmkiMqmVBlMaSi0BSYVuV0cBgzQEAcaaobZwLJ++iHTTsm3L75wIHNO5t2bPn2I5JKnidF0sbrDyl/fXrVZpn5oj/XZXXhLwXxZ9fwZ6RcHeHJ6sKf6GjHiA3lU16gFrON4S9FRD3YTvGXwnwcWejtQyANzB5E5xPqx5QqNKIQKVFM+O74lb8acOrUgF9defy7D++5acyuwsJdYzbsJWdOk8xJ43n+7MEtYyeT9P+87alx/cmW/uMOa770z3VlgEMPl8tN42IuBN1qBK6HUGcb2+NpZpcOyD0Ncz7ygpL3pGz0tMe8NCzp5VhYUjZ6AfZUB8JudTEsg6YIFJCmhiep54zLIT465xEvDoBz+SoEBH3DFzv/QsydBtuBXzTcWzVn7LsrPlH+8hFfzvuHtIxcv4uc2fFVq3LidPXy+wZUbR/ZQPJJbcXU8cEHkQZyYBCf6hdybm46g55FlC0wBIJ+SntY5kyo+FFniAuj/7IT1qstFHO6cAxOB2giLiceunA41DtiAalISRedTKiXhGlCCpBIgSGHsMhezv6D2++7vKni5lGvvnpK8B+JPHi4eXNZ08TIkY4PBT/FrbJYl0X5SV9uERfLpawEyYJoZFFmph50jxGQW06powCoo0B1DgdU6qjAIDjyEqeLhSqEVE8u5SW5HoDTFZXLUIvlsqLU6E0ilmpQeTBMURyIUHdlHXVk8k5HF+VM+ObFmfsHnho4e+st4za9OG3u0jf6XzUlXPurmc9/C2R02c7i4p2X3UTOfkVSJ43f1tE8/5dXDcmov/y+Ddl1ixuWjptGbGS98snjDf3J9RG0b7cDFwYdAdbkKFUXSAkn8ZFUc8LUcdmoOwGMDTQKU2x0lYLeRmUqJxtSxe58Iw3YociYhbj9VP+nWh7cd+rqOY1bSvXNCl8/Y9/ezuH84sXTGiKdDYD7ZUAc6/SzQL5ZuKEsRsL88UZde8xMOJYNAuxB727HV5tJT0zweBt1aQCjxyxKg5FmUQKDUCMVAsCybNySceOWVJ/S7V/U2Lio8ceDwocdflxL5yqVxfSZdpDB44Aj4ePSdGy+UQ0ScJq9zFlha2/zGhx24BPwfJQcZtAg20QndRye58MQIsk+jGJOBeedIYPGDms8deCXE+cQKwVLObQvMmmyLu3HLx86lG/wUAgpr2yFeSmlOlqou3+DrvSEh8PW5eHQ9e7haD1FniQpyjzykPKNcuJWMNAPkg+VIZ1/J3t3Kd9rzyJzLuznARTjq8vP03qqy88Df2vwwZrxcQtUHcyRgT4NolKQZA3LObBqPLCgCxLSF+jIxxZNho3mj4hwiILKD5+ZPkpSUgaVRjQfFpSAnOTReZhjvyeZwQH9bD1V8uT8a7dllj+9cNsdpyY0DV/v/9Mvh60rFj7cHJk/e9Lo6+66s7Oa39w0c1xNZwO/OdZY3dmg4pyj8il5LZB/fy2QpLXg6Qlk66nI71oe+OWpBbMbtvYBiIZesX9v52h+4eKZdCmoPH40wKH6TKh4d5lVHp9hZj4TlOyOhM/EKHb5TNp0gsVKqRLdJqD9quk3JJ8Gh/mEfsJE+YQ1X5LQl2tGbTz+2fGNoz7au+nmPXtu3gSCaOeX27d/uXPhszsnTdr57MJbjj3XesuzR6kOomzRNavwXZUEn5UyaCuHWVwJrKV3wZuKmogjRG36NFUToUCnJjQRl5Waf2jTw9wTNfSuYpFpIoEMZjI7VD2k/6+vfPGb/3rh6E1Ufu7dMGZnkbJF3wzSU/nyDOghD3Uq/IFo41Ok8Mmx/akMbQD4vV3w2zT4bRR+G2ahdbH8zC74kzWBNJXX5yQ0ARuF38Y0gUyqCRidPZi7XzT0YOcN37x45a+if/rTTc++8F8fIvCFRTvGbCBnzpA0UKDOHuT5h0g62aT85anGKKgBY9U1x+8H+G1cpbZeE+g2YwydpqDLNsYcqI+VmLtTpEejxYGP/iwrMHJvvvDhzjEz3zOMr+mcyXIjQFdbC88o5T5iOc2yztAec9IZNbAIaepJOcvTLmUxH0ihh4ZG0eY9Y3jeiLatXbI6JPMxOcf7Lyn/GJy0pVjNrrI2C75LOY623Jx8OM3D9xgcJwUH86Ix+BUepUS5w2ACW3Ny8/JVO7iCnHeFhgyzUjX3S5vOmU69LIVO2d0tMxo0e5LqKcTvnE7J3c0Do1eVBs0DY1Cze6+K/O5nV86rv+amm66p//2T/7h3evC+6ZOuCjddt+S6pvCfn9/wl017o5ePHhioysksHbhk3IbHtu2pGjaiJq+vNzM9OPi6kVufuJzi1H3uc36D7jRIm1mq/ms1q2qPnqk9xlC3/EeQPR6qAQGl0YCIJ5H86KHJTR7UgNK1QBaqcRyqcVQDEsM0pYkpnaghF1eL7v2nXnstVJ5TZQuP+vm6jaAFkVTlP490nq2uT0vdP2TTOn4g0hfMvSJ8yPggro6YyJzVKrApYY0PglxABw7IH8kckq0qH7QJNCEDdAKbqBpL1JdDiV5Th4tbT82fM25LyalTtU9e98BDxMc/03nHoivG1vCHOvyb6qeznLZzHcCTUwCWJF8OuZAvRwib0ULVfY4ukU+Vli+EDzuz+E9B2gNSQU5xcB8r9xLjWDETOnLC9HZxIugMxkJvly/H0eXLERO+nOdb/+mnPhvOIVmP2eEXEn/syMB3TqfgVb0kVMiEN8E1u5ySztw8LxSeDp3n5jFSN8+RuhXsdrJObwIjXdIf00tGh2RKcgANMaMHyITUXpFE6miLh7MI/o8GuT/lo3dPH/3y3Y+Vtz7+4tNPYNSV/Dv46vDz73WWUdqD8QtnYPzdfT7koj4fvL+Z+M0khbQoB//zy//4RjlIWr45xykK6SAfKzHSqOQpOvjydjZXoD/jXIlcGadNE6Zu2JCFOoM0fVi2sQA1EKrMW6KJWbMTYwFVemsGE20C/ZUH1o4M5xWVR4Z5Ktlc/rh09dW8/ZijuN9Spn/MgnEthWcm+YBMqqQUTJfmA5pFvlDSBZMikh/28xuO3Nt5wzPs3inKWt6tbwF7YDFopNRMsbZLmUHZS11BcaImS/iCUg7NlHYzn4s9FHPn0EhihhkXRizHjWc5BBYrxsbdOer64NAMc+WAGUBEzGCyOGV9KpXW1ag9VtXUEg+yItFtBA3CnUZPYRlXFadURR5feeON/RtnzBgfufHGlY9HSHzD+IFk3daDd0wZobTsDAR2KYuHT7/911vJhoHj1fjTuVOkiPqcchI+J0H1XLFSCKbjoc26+w4tF5hwfsBDuYaHVMSDHRCQTx08Unow7u3Cg+4kjDeezfDgCsWyaflLthc4li4bD3X5ZkQQxUM2ZuBiSCkdyQ7jrJIXY0yS3SmbXYgHL9WiqyJ0zGWkmmpSwEg8FCmGMuJfFwEUNEbWrVv5eE1VVc3jK9d9M3042b0rENhJbh8x5Y6DW5VNA8cDapSNW3+Nck1oEt4HXTefm8PGgqw316omY+HE5ofUFId4PhtGPg3uxB0MRQh4vpo+mirK+jSULjYvky65opyCVl0q8mJM+8G8PH045PLa9QUVen+BEDEVDFkyrvryfoWZWaXZS313Gpw5fQdOXqhdyBXmzd9358TSYRPGDyslaxzDF62aellxaf34CfWlyjbmA1iobCFbhG9p/dkYTnWg6Np7KT2zaaVnFlZ6ZuleemZJKj2jyYRaKhIJuxY2Y8lZs63oSECYO6CZppb9OEOIdzSofoiw8JpuM8iyHG4VxwQESjM1zdUFE+7mNKXEAl8YLDR4oDMzvUrzrniB03pZDomQGQrFnSohWkC/yqOCTWS+KYsY58z2TJpaanAyM7/K2VXIREtOPP7qYlRusY5pQvtz+55fvGPw3DlDd1z/3L6jX37YMnNmCznzGsnMufN2750bp3g613pmbL7T+/TvsknWGysO5vAr8g4AjZSf+1RXrV/I9eee4GIhGEVbaqgMTL8iQS2oEc3tcr+QI/9YUC4A26YEC9FCKbYyKYOWoUlZQEJRtBulcAgNxpjBrUVO2mrcBrBbc23tsdwavJibBVxhAAy/BsRYjA/1j0ajcq4bK5Cy8wsq+lFFvl8IkFARlQrEWH5pGAN7nFPOrYFfigSTzdBpyaR+Ba9lPSXUGN7r8/hhYo2Yz6cpAxU8S92urgqUHyzuE7jlz2sf/Gzg0YwNExbsyM4cYiblXxl2BiNDfx2um+udc/XRuuvqp5fPuG3i9Tdl8YHt4SGL+q86Nm/NyqXDp95wVd/J5dPs23Pz75jtbAjmHb06x58z4WD1jkmRQYxex3AfCn/XraK1XTdwyDHyWPZZYTCeovKO4qAknETGgdezHZh/ERdZllkAWYWAlgwuLZ94WG+yprrSMgmSAnpsqYKXh0VabrB1pELxMNHDL0yZaJtLKWBb2Cl2sEyJxjZByYt4jYgSFvYMGF000lRVnG8Yc/28eddHV6z+9UM3LqvF49plNz708I0rqt8mBW+9pfz1bZJx/YZ9D9+4fMCyefOWDVh+48P7Nlw/cMU116wgb+1+663dt735ZnLsIw1zxO1JsY+4Q7RzNoyCyQ4rBo9BatALwIfc6NIPUb3PTpMzbc52yRSK2ezUMMFEmJRQzG7DM7sbzhwh6ouw2bX4iad7WMvD/vkxDQX/JaIpylhyi5JJPlMyv1bSUf6RVhZd6Wy59UjrN9+0HrlVjYcnZIaRAz2KRT5Q1glqYZ12pEUWQHYIVH7ccUcpv6VzjeDDd3qv6LnpwlpYV2FuJNABrcyQQ/p2ZsL0wzcvzcBE1+UoWn3kDslVHmTJUhW1MqTBITkIF/qE5NFYsJZQ+A/pLE5vTlEIJzzojGVklkeRKHIw5ErcmQOHs4x0KQOFSiRZ4Vdr17rFXQ1GVtjncufqvTTHig/YSXR2/0fnzFjK7ID1006990TH5unhvROmzC8dMf2qq6aPKL1iSvzTwz8Odbj75g3JLxo1Mn/goLIFTYbWuuaGYX3rCnL7DFzUMHtzZmN87cPbN/SvG12XX5Ht9WZV1M0e1LQt0PDEbb8WrN7i7Ey7y2TOnziwMFLstWRMpr6q93Tz+GXUH+TlBnbV+JotXCbMgifE6tjYKYElptaxYeGjlRX2yhl0goSkusWipOMyLF0bGQ6NIk+MYEcjdB+yz5GV6idQwfRz7fqP9ItBxysCODYy2lY1AKk2GK9mR8FgvJQd+bqSSuuoVHWyNe504MKOh9hZiNVnmtmKH4QrHljeYbtX5ysti9ZSJhisFp1DUszO7OJAGde3fzQ585MWu7E8q0hSYZG/wA7WdvL0Jhjg9KNk5HO7iOGZJUueUc7uek45cnTkvEdP37Txq4NXX33w9M9vOv3ovA/+u+3p5dGSm0ff+uprrZdtKqldfTjGP3aMjHx2ybPwNzuVs0eX4G3wt/i3Pz+Nf/uV8hpZ/v2W2pohr993zztDI9FWzMnlW/l9+iCXyQW49ZQH5jL8FAXjAjsyB+N2FVMlFFNZbImBgY1Wld4X0jRMWnSRhUqTxQoMz4NlI/Z05mGmbBCUEqlIC0boqXPfgmoVLS2nFYvJgSseA1dddaxq2Gr01p+1NjTXL28YsvSR2jkTKx4Yv3XaLfePq+17eXr65X1rxwmz5rZMmFkzdOo1CzIis4cps0c0L5tTNaAgb3qefyBd73XcRuEJYQanB6rlaF2sn73XkdFvKU/Bm4eMYgfkG7JQuUvZSZayT5bPreaE64FjqBnhWqWgzszyr3SaBhvTCVS95BIpWFgN6BdrhR27hLJtnWfIFu5/Vpengzk0CI+pdfbFXJB7WK0eTWPzlxKMO7Q5lXzheICexIoCCFgRmgIFIVwYmeoks3JlG1sANgeuTyxQxrNASKtRzmUX4C9zqZYUN7IlgkXLtE45xZEm+H107gNFoM8ZbS6OckFRytUmm2XZ9qhTFtWl7/UH/B6RXS8jo5X4qleXdT4ZVwa/v/feP79/397333pj6MwZ/l80bZy6paB//4ItwlNPdi57dVVcUeJ7/vz+Pfe9/76ykHzTNGx0wysvvUSEcFGgmtkbnO4I/7k+Su2NLnspYTYlosIioJn/XHdkwwYmc8qFqfxgWg/u4RpVHLsSayRV/fM0rdo7lVV7i6zaG5Hj1aqqzAJ1yl2wapuVsBnK9y5quf/+lkV7105cOXly7YBJulmL7rtvUcu997YMuPzy5c2TGVy1YGu+pjsK40nl5qrWJqtSkCxhDDCjraejSTI6O+i5emr86I1Iqw4q0kFa2tii7pLqQjepDvSLqZoic7azaoeuolasetAKW1tb+b2t5B5lfqsylTxCaxWFmfwJwwOgc0zkaMwkbmVYc2k8hqoWjpNaVTw81kHTexxWzY9kRgesDYu1YgZHGi1hcHYrYTDQesVCLQ7c1P/R6VvjT71ANnbuJMajU4YNv9FnyBpav3HVgndu3bz2yFPjBw8ZWMbooUGYwJ8C+Eq4mRwofKpc6OJ7CGe6CmcpzWhwhOJ+lQmG5D40ylGslcXJxB+lPC2XlpZ5UDlMd9KkKpcm4f2sULGL17Gkc4ERQENT6cahjVOfH+70DD10xahN0xuXvbrrkUWX5Q8bWNx2Z8tvhBMLKyNDqlcJNwuLqyJXzN64al7DVVYhO9hQvnDzZRqNazkMOYyf9JrDADSOJbZ5bylPwO8DmL5AfaxhwU9zi8aqVG5iLMMkaJWLQFFqhbcqGyWzI07ojTG1w0x9VJh+ohamY+wL5B0SC/4riLxzG2ldenDJbcJcUvj2vz7Ux842CldhjTGZR7bxm8CGBD5ookVBFy4udiWXHmEjEvI9rTeZPJnhQFlGDoFeks4N52BZavLMpPFDmtFnOBl3JTqJcLKQxubRJMZIigvpzAHSjOrpIgue4eQFImFj14INXnZFsL6+b/bEQUurfKUDxm2YOXSFEptZG/DX5fU7eLN3/KCGmYXoZxVmkocMuzkDl8upVb+aktqj8DdCC3/dyq4DW/R3/djxFj9rO6zzkSCrfwBZjbpWA9fFcyRP1zpKv2CvCeTjtJ+Eyn0uoWfEyKN773/26H17jx64clLznDnNk64UPtzx4gs7d7z40vYrli+/YubSpefJ0wjN/WL/gzxVnnoL33aRUcrTb+LRRk2UJolUkGFglBsiNL8nBbhrOvcrlpkludRMYFM4bkkzEhvrIMOGLYZiadR6T7OBAWswEhObUt1JsFY0Q0CgeZqSN4TTrHrBXNTsdYnoDKCxFTfWDmSqcyCTlCjmQbaZzDYWRU2z0GifZBBBnKcjURCW8KFOFCYgFVUT6tgGoyYQFunUtQoLb+m4kzeRiZ8tWrT/zBnd9A46lR0pGKd8ZgXPK9ZNzzyzicxnPTMQBwtUHPi4PVzMy+KrcTdbfhoi7LleQITKnNoMXjrugvPHncVsVS9TxLNEHGmWF0bq7zbSLDFuMlvsblbMhB6jdPQYxXWikIUCHHmZJSoTg9hz0GbSO/NNHv2s/o9N39pGGfEuYny2ediItb7uiOCfGTLsJpUtH0a23AfooQFw0aGfAzy5LxfhBnC/Z5XjUnU4lo5o6BNWRW+8vH9pOpBFZThezsgiHIr1pz1s+gfNoLno8Gu52EoLzdMTeCNgFfRk5VjaWQPEEg3Fq9m1fqFYNXWHVIeBWGqq8bCmHFA4EMs+MSuwb1SqEdv6lAX7U/z1L6cekSR5ECP+AdGeEuGSZYH5PNLSpMMYq330oRmjb57WQzqQRmHhto67eAOZ+Onixfu//prfA+JicPUqfhO/uKpmxiwUF3NUcfGLyzof7oUYeS6sLBZ2C99y+Vwf7houVojuslJdu5QbZMVWZZQde1ztkoclyto9tFbP7pB99nawruS+mLnmoTQD3FS2uCgO4tb03MJSiqr0XPgyKyqVijHOmkkdRd4qbDiAWSYet11HrSKW41NMKItCVh/uKkWsvKz5ssq5Mx9b2jr+s21HPyE5kwcA71/ZNGHQNZcNqa5WyxGvrZ0zZGj4stIhk3bunbUwrhtaOxlLF9maozm5hrM0v8N+fiWbtauSLTUoO2jI0qoGjxKVbGHiF3pUszViPuAPSSVthrPK+x0mvrX7M1N6e6apl2eeXz1nIUAZ51XQ3U1yQZYn19GRFlWuJz/XDnbyec9N7XquFhQhrIS567nogfUHjD2Hu+65F1/asu/uK5MGrD+Bz33lFTpo7dn/hGf7uEJua89nF2jPRgtUZOs4N6gyeoKGi+kk9kWiljvl6HEPk9rFSGYmFGUFlGvHCW9Jp3FUj1PW+2ltSgGMojAqi2CDxkzYMAn5G41HJvBJzRFa1B/GdUcTyjw9h9m86OqSwaX+Pt7ifisWXR0YXFrYx1sULEoe9Qc33e4LBn1jLrvpNvwce1kHB+PXqeM/BON3gR5cwC3siQF3AgNiUMoHGcc8KJkhWlFhOinbnbQmDG2IHCerqLCb0MlK3FEWoUiLSjnOmJ73UB8TcYtM6+w2RlXKu7qfdhvlBM3jMhUGNktzuiQIuY6eDx/x4ztAXKfUEyrD6RiNQUrXLi6PW39BykaNWvXN5HR5F/KxKQW6EmgFMM3DwegGzjIte7Myr1qmGLfZna4UtYUY+hfV9SHneLEyzupgVUhdlaa8pigGkrSb8xbPu+seW7PmMfegvmWDBpX1HdRtFe17bN2NU5rXvls2eHBZ38GDqe+rg+OMDbR2xImRc4zeSly4e9Gi3WFV60fiepM1UU/owsZqoMAkSgptWgSdFTJicN1N7Qo9jMwJo/GTrnJGeAnEJ+qE0TpT5yha1/h0x1TF9ABJJVsSBY6JSlrW52ktrT+t4n6eVH9KnZtaESq6xJhvQOobjGepk1KtFaZidkyfhOWPclLuk4qeL6vemZ4BmkKQxQT6BmAOcosqolS1kDOC0eillrPqk5TqQLK2XSFcqMj1GaUtO6+M6twr/f3GTg/WDy3Pmli29T9+M7v3utdTtrFpVCHPunIgKOi5wVW26+M/JmqBosAfLTCjY3+qAtVxsQpUTBszcyxFrHslKkbGk6pROz6giePalKGU4M6DZdj/FJYeMKBOkQRD5x0k700UGioQjHN3g8H50/hwXQwG94Xx4aICJRkc89GXXgRh0gOeV16hMozBdIjaQH7sK3cxqDBV1xeOpzJWitGvwotA2WY1YwM6J6s0xPhFLvDZIrSazJiW7ImeB/wFfNbJE/y3kYyBjiRPDKdHlSO6plvjpZVdbBT4yiFYsA8B3jG2oXWK0tPMRxPtFIX1smZMAdFpzd4EVEHEsDgGqWnVGSSjs+VqMiTPrYC3Wf/W/dCgwfutoOrEujNsChK3BBg/hbdyuCfaKqVqFY2J3tNCS2hS4J7o4E8BHRmmRh+lyBPYbGPaTRZTGQrOaNOr3V04dwTuPdUQp7Sfxc1Q82JstEYrKGWE4wKbUFeIZsBZaU1emyHVCrPHOWk1DLbJc9ALaU6WDGfV0lBZWp8rgwGULBMxRJR0PlKTg6fOZGhS0FCrztS/qMhPnFI8g/2m305ri7O5+Wr+oV3rJ4PFhByxCmo01sCisbQPEzJ7O21bELPTMLU9C4wNq13LWkSxj4Fok9YdgJa6mlxqaFUrvC8loqur9B5J1N1G6+9lZaXyvMJ/TWxqAf5/kpHKEX7ME/xMrQ6fH6NsY6X4yoontJ4AlaCvmWGV3XFeVa6UGdQ8n/nBuE0VFYXJlbopICr8TJT7aVplonVrVxUvrq0UVsUrp/kxZJoZTa7klV2ZQD0puf4orRDFVBQbq1pMrvHtXXfTKn89Lb3pbMn1wOfrbKx3kv4NoO9U2vV1TK8Vwvm9VQj7tGxXmy47N5HtemlFwmhJXKRQeM2bJO+en6gWFlajBPn/CX4ULBcrdC6nguYnRsBfzgyW7mMouMAY/L2NoTBpDHn/5hhUC+ciwzjA5NMlDQOkljaOf9JxVHM7ehkHKlxFbD2FtCwEItUkjw3DkNVsBVU75BI4K2VnpV3jjsBnSbXofNLmysjT9T1v5HJRX1hP2f2qcT2FRMn/U/TY68q6CGrWoYFU0nOx/RSmpp23/nQqzg5RnGEP2SW9YQ3MwspwPI9JgzJgp1U9MCYXOGkZDKCLNjSr6MJVNeKqAGnElaH7d9fpBeT+RTCz6nw14KfQ8rvzlQPCrQFB36qrppFLM4mYiddMjGayhpQqp+aQACmdpbxPArOUU/Cxufv5HPxNYl2BLZDO5XMl3Eou5knk0vrVZhgMx7m4wkqT+2kWq/00+2CJBLJpD4Z0i8UnjaJbl029hVanbDYhG/d7UM6mUWO7zcplleC3RjDUzdFEgNwbCRsTMfKA0R/BNCkvKUYkp1F8ByhSj99XHrtm0Q0UrW8+FG5bOn/J9wv58OzVb/7w/jU/f+PsWv7g64DL5sG7Zytf7r8bsXnlyPtmE/uDb2wWTDXKl52rBwFi32tluSOfg2w7yzlAYtf2VgXu6a0KPE2tAo/ZRRfTZs6rBKfKffdqcMKjStZbTbj+k4Su//8KHqro94DnaarS9QaQ7nea3p+Ax9s7POm9wZPRBY/7QvhRlf0eIPVnDPXCMGm6P4XrEMCVDXR7zfmQSVlBqTgc9zCGgAmTpcmQYh1/OupZrC+F2stPg78P/Zb5K3NELPbw06qZ88dhItVdi76b3t9jYHp10ZMFbM2Hhvc6xm/VFb4ysdBZfy0vzIGJs2KlVfcqdVuiSt2uVqnLPC1TOb9OXUAvYVKteo5q63VVrAv3MXnb1WPExqVp9h5z3Fjt1KKyggorpHW18/Gycg4Ag7eHQpgq4FS1VBqyTbOLLB8Sndc+Ndif3G/kDLm29a253TuOfLr62MpD3yqfk9OrZs1Zw2KZ2899rntfv5AbwJ1WocqkjSyNqiiowTzuWgrMAFu7NMBBfc/okLazzvRGR7tkdNCwh9fTjr57TJv/57XPr2LlICUOqfiY7PD+S3IdaxMdLldZmxPf4Yu2QEmxC5ijw5VUBeKMxuAyHHGHQMtwFQdKtAKQHue0/KPvAMBDDvatjekwNzIqhZ2ytZIWWcYy833UW4c13vijGjFm9OaqXXS05uW6rqIPbBRJc8QM1VWDdMyR5RG3n375l/9RNnjs4LJ+jXOvmdvY749Pb/3txJnlDz01R71QUjeqruTa0VfcIHz860/23lg9LRLpM8CHpSDe4OBrR25pmzT+jgHjxvYvCGXlpFfUXl0fmhKtCYQyIoMWXdGRx3zltK5dvxekRiFXCVZlUmV7SbfK9mBXZTtrm1kE01KkVraXqZXtODFF2DXIZqce2XTxENa2F/gL/6/L26kn/hJL3De+RXLv6biUOnfd08r7HUcSxe7JeCgHPKy5pAr/0AUr/MM9KvwpFiqClTQz0Cn1+98o9Ud7/tLK/RfQZIBLKPrn/zsRV+jCR4Cr4m5MxkdZN3yEuvDB3IolrNk/xUeFig90LJZ0o4vDjC6KAipKCv8vUaIFLy6RQg5RD8WeBZdCI8JtiI2XX+6FTrYDXgZwo7hXk/EyqBteRmh4kSqD8T7MDogE44WqHTCa4qoWcFXrkAbknxQTkZBgfAA7qlWROJQhsa3cm24qi1cwV+1l8M0AH8ufSReHmGkLiT6Vg0agSVDOscY28gjM0OMQo7QFMrZDRryiJJT7VMJ8+KoHRKM/uQR7D6RcIspbew2wlF3SDOwF66FCtSLoZ0csMRc6dS6aaQ19lBvB/Tp5NvrBbBSicK0Lx/sw5WFYKGl+Il10O5LORTmg2FeO3sIAKBHlKvLDDPmS1yENwZ6TA+C7AUF5CAjIUdiNyYdEnY2uMGmA2GZx9ItQThe5MOIvBdma9yoZxcmOyYvxQM3D1ZyE4amar+siuO5QE287NmooFmZrubgarhXKH2u4eu65S+CQYOzGBzDKHxKMV6qUPyyZawbB5o0wco9056FtYUrudezLuqDaIFYeDr+JBHGTFEC6VCcethSW9ausrnFQvJddhOCHgMyOVQTDP03w3fiss7c406Ux3nIafPIM7ltWV1fWd/AlcGBh2nkxKcpzDM8I3wPma7nh3P0c3XJFKg1jDw62/UqlOgGSO4xzINWH4gMz/DgNA/Xt0kCHpEfajSKxj6Dor7BRw7lO1Z5Goi2dkFd14hAL8BO3MdtfmlE1kHFoOS+fdsfLxq7gecUVVXS7n4GIZdmixz919obXfKyA6NHcozjQDc3FDM9FrOPHxP6zbhj++6UqZoll1Iav3iOGTqPtwC/G3ls9Z+y7Kzf9YfjQt7cMWz9/EKC6sbUso2jDqBlr+D20Kciiket3kvLx68f3Wbeb4vnpp2l7kD214d0jG+ZPndjSp/Gmxglzho3pVxeOXPVyxdTGfvdjvxhlFe0X05dbxyXaxIDtEfcxAi4Oxj0qAbNmHBbQPy20l3o8nVEmtuIotGD0zCTYnC5PVm5pH0qUPmyvn4smdSw9rwRZhQeM6NIobTfDGZx9ktrN0A7i3drNpJILBNCK+Z59aFb+MU+Nm63wswQ2jJu98i9y5uOk3jT3Oy9Xo2U0nS03uNZN8pDOaL8XkPkeLoMrOL/jS76xPZ7JOr5k6pmbLot1fMmiHV+yMB8a3XTGrAt0fMm8aMcXUPTIxbq+7EftTmm/SO8X3e3K+53vqP1fkseTC+P52U91sPH31sGmUO1gE0t1MKX+3+9hg4raT/WxWc1UtAt1syFvav7TrjFlc0Xnj6kQxpTLxpSLYyoOSnlsTHl0THk4JixyMubRMWX0Mqbci41J1bd4Ix1b78N67+hLL219cM9qoza888clXMd0K6XqahwgyxdkY2uGsfm4PiBl7k0aHe4sIlUkHINVITbeEhhvARtvAY43EpTSTuIWI1jXhd3TK53tbf7KMpDqiAQ/RYIfkYC7mmWnARLMfQpwSZaJbVaXjvqz/E65ogouVVJ0GBE1arJyKpbFXWzGu6Vj0NlPFtu9o+sRkNgjRoDEjnSR9hImsCtH9oK6k6pU7ryL0gZfo0lpjOHtB+N6J80RTooLkqS4oO1CccYZuLyuPYUNz37crvWt4WbC25h/635anHEmJemWUywJOXFLgPEEvGXBPbvFGUlSnNH2E3HGckZgQfXeL7+s3V049wjceyStXUIv80w1ziiw7fC0EqaMEC3BTUQabf8PIo1TNT3s76es2mQmipx+bEJ4E6daHxb9E8B5i7CKz0v3QDK304384oLfi7KcFpkXU+mTCdIn00H7a7nFdrqiM9G+MpmtLK52WDDqbY4UrzOxmQsn+3O0skUB25iCfRU3mqypTi1/AwRPcUAPggXEDBYtcqKbA6Lu1sDlx+feWdV0RjlV9lnxvBU75p0qf4hcq3zV/g/li4/2btp8N+3m8t57xP3Ubx7fdO3cjMFPTG2YOW+0ckz5xT+V90janzZIv71p/W9/S2nrLuy3ALaUCzSbmy/QBQfrNnOYCO7TVf1doXXGkfnyEPbGSWQYBZMa5Uj5XXYVbbqHW/HIhsJoVwspOacQsOYuKY9GL9BCR+jV+LnrVOSI2lhnS5/FXRbOcmrh+NHCET7cXD8jud2Obm1Pa0bl56NhLaTS7KoJaoTZq3XgyTG3a/3D3TDlLIGK9omg2VMc49uZ4iHswyO6nFTfwIypXlvxUBF7wXY8B6l8/fsFmvLo3CBb1yU683DdYM9Kgr1796D83roHafFICnV2Th4NImAN0SW2EaIStfdWQptUQdprQyFyNuHf6II9jXU9prBnarDnm5lC0FU1nqPCTjfPUfGeIx7GETjdYhqLg0guGEJ+5gWG0M1X0dsMfAB8bcu+PZsvMAX8V4zbdU2DNo7tMI5SrprbqY6jXBtH2IzNE+IZCSXW1RWHhLH1cQCj64NF+2rgsY+DNheGgbblGPvBda1KGlYhW0cYj8wuFZ2HBZ3V4sovD1OSC5erY5Yz8mFBOQpLo72Q30X8CL2hI96r56DhQtj5rufy6lyh4Umn4qk5EXvcqGIqDzDlQulQFo5nMOlQqeoWRUgDVRRP2YinbI4JBFQtClQkVRgL4GIJXCyh2yvRECTrgC0Any0R5bwi+KxwyhbaXLwo70JL8zyzn2Gkm/rQDTuPaQImnEDI2i6toRtqhCmayjBcxQg/N6E0CGBVviJ8oNsDRxbOzVVwuMGH0dKubYzjCsqpFrZhhPUkLRhzYKU47YbI6ha1nnOC+llcK+zrPF4/Y+jQGfXwXj99GL942zZlL70gzC0fMnjGiBFJPATsrjTQ0YtxPyvayYG2IPdp7RCZto6zEUhekbgSLbAiS7QV6cR6/LjBoctkCQI+N/ZF9OBOeGKbhcso7hGsRFZPg5VsKxcaqlQjlQYXm4IA4Pye+zf0237NrYD2ZY/eEL61ZfNHlWRL/bRNe9eMnnHznmqK6wmRdbf9FbHdXLdp91+WTSQfBo8qc6qfa72+mcUDaZ8j4DcuzosVcxfodJR+gU5HGIcTcIjuqGQT20RPmpeO8KJNj5Dbd2981IIc/vzuR3qRxYr+5zBiN6Y20e3x0qAxZi//BIwYzezRnMnPOPh5UApfajGtLjgz0Uq9AJxZF4Azuxsu44DL9EwW45Z+EqUqB+8O8R4MdT6450IQv/wy0jmDuZlK+TL0p3eHGpsRSP5wPIexoNJQ1zj6auNocwvIgTKdPUaEnc+K0b+T76SdcorZBotyppvtVZYvsqaZF6WVC2Q/dB/p0p51+8Bpzhu1rqlnJT/Nq8Z+TTBnIlh3vXRswt1SLrFjE41+9ta1qZQSznm9m3QbEnSDvQRVGXChXoL8/0YvQUOil6D4b/YSNLyjcBdoJiioOGwGHOaAtF/AxTxINb5wPItRTSB0Hl77BCXnSS1AjhtAFjrZrmIYFW8z2QjuaYWFEzz2r0MD7pKm4ALU0uu0fHQ+0Zw/R+290AzmtJhm6heCTVTM3a76AhxCu2ocwYFJ3XOHhYwLhfa4NdWrs6nbLwVo4lCmK2EpGV2hEN3qwRKKpebjnKc6cX8BG1xGIUIVNx3dP8HhYgwiVZS5/ChlDpkYlpKJD912TroLD0snSvNWJ2Xx0+XEEovUrot880FS9eLmb0YlJRBPHfVfN7+ovNnw4x9u/XMk8v72P/xIPiJ3kaHxJde8pOYRv3LtikO87ZTSvmsLiW2+VTmdkJfGkSAvC2gN3e3qzvW5YUrIFkIzOeWwkR1jD+F4uSPTAigpR/dIf7bhoYMmSeCQHWK7VE7bdVew8LocxVAd5m3m6rBQVpQN2VSBiVlcmWynVnWLCURRW1p2UTHdxhxRxxmS5Cq2o+ruHslPbNCttr/RUw+JnUcZ27EzfdCVm8f9hVg7dbZHfjHmvvCcy95dpXx76+6zy1C/v4/w996rKPcJGXw57xuyaGT9wqFFVPR+XzZufJB5SGrD20c2fP89avw7n3125/YjR2orpo3rVzFuWqJWyms4xJlAy6H9xZIzMHAP6txw3MqWUjprzMUyMtpSDUZgvDQJNkjzkj30QpaT7T9mxFRyq1Pdsx0TX7MMcCU99wLpGxdaPUkpHSd6ppaFhifnd+gMveWRcbpl/GjqVymhe14LYVYibmTd11jH/66dRtHdLDKnCrM7NG8Ku9difjfYFRncdE5yBONmZkGkdVUl010d4xnMPsigrV/UBhNYpCpbcWdmgTqBzQ7c6NeNvkZaix0zWm3UPBB7NQh6taZ7MZ579NjgunXQ+B9+p9tIv/Oe17cjqVmHbjj9E/p7Q8tP/97QT/39VKGJbNS3AB+v1LrrBGWzjtbo0V2Z7O30Rcv1zKms6FQQJZ26CysspqSimqm4O+ZUs9VbNQL3ytTZ5x8ZNAG3Br+sf+3EuXSPb3jeXdq+6zRxPbXrYdoW5K5uG3K6ztuQs8dGnLqP6Cachwc10k04Kd7+v9nvnOdmCk2CjuLPr3UzkDxhQCLIQsSjlKFVhWCWk72raD6XnmGKOsOrzDmpM0zWpUV7xW3ReVdmLpwyKzQlxemoHjkxWj+TrIXzMJyL7FzF/uIqw+jogEkAtjoX9IzulQqwO+hc+HG3GhV2nBApL1HLgnukGtTcNns7g1egykZ6tNfJKfqp6SI3TBxQ/7P56nlVz+nr32MycU/XM4KDzqUPe6SnqlIGJlRyhxjjTKcTW6BNrAax105ba2sQ08T+82a48OJTTqq7wO1JAWPoyZE6lRyA7rYQEz+df5/25cROEIIOe1aoH2qXibieNrJQP87rNbFl2/Nbtz6/jZyZvXXr7Flbt1F50XLutH4F4AD3UMzjRqh9dI054bBs04FK6A2F2CXazCJfa2Yh6Vnf5lQ7ra/DfkqZdur06rbHbpF65O92qDW9+A5bIg6onUy+n7y8qWlAbRPbe7epqZZ9Th6gniP/4TbyE2mvBtzfxaA1BDHpEu2JundC0hogcd3+1qf9LW4yo0v8Oe31zlpYRHo0gEi0fYD7VJ/7XI/7WPVFz0qplnZs1XYz40ip1VYm5bCehXmhuMlIL6SHZZMVNwSmYVXdSTnL1R7Lor1ssvLM2OIhpsvSmi1JxhBVU7KwzYG5L5WuqKkUB7CsxKQGHWn9DHbf81eHa7hERSJtZ2DwuL3woeokvK+AC1RP5HVNi+vJ8h+0QsTb/h7hizrjOh3f0Pl+5O93qPtu/kvZNoScavVWpte0/o2k0BLEO29qrUmv9LZu2kO33yS2v+Pa8Qu3C9PpfldubrW6o4/ZGg7HOSZEhZDWWgr3izfZxVCIbUFhOKm2V+l9JywkLBDfSdW02CvUzmQuGiap6PBIUTdsApGDbVmIiK11Ue3wC6KfRDZECT9106ap0b2OvXpfdbVyPdkBrxeQMpQ6skJpxRfTJ2AR/FX4K6yEQFLv70Q3V6pPaGoFk3OVok/EP+ko4GiXGk74HnidB4583H3MtwNcpGsbjgzag0/HrHY5NS/MWlOLrIG/m1ZRYf/7Xvt7IEZczKrx4ZYJuV470IabNfb3oh/ZgPVGvlzQUzOyc1jPMosbQ35pWWyfzZjJm6l1s9R28fB3bePBJW3tkLP/sdaWocHCUD3u6cGXNeL+CTV0c4+H4oUPpWmbe5CN3bd+AHpAPHxA8ZCB/UspFtLC1ObvsSNJatf4My91/GlsZwOqdKVpo+7apsR73jYlSQMk5w9s2PlD6vhQqxHU4VgMLXRPlT5cFdef+0C1y0qqw+FYFk8ryjBTAPs9VeDYwursttnTCmsKvXSAMYenmNJ89FK2XcH2faW03QvNLfSHYiWl+F1JMfystAQPSz1mTOyl3tf+SAvVfYEWKoHrYrfTUqdGC31L4CgrB44qq+GoIoyYykdDxpxbRrMzK8Q2U07ffiwk1tvWLr4LUQptZeFXaSVp+xfy3sOPqwge/dprp/jSxkj/xsb+kerzN4a5KCnR9WSYqOK+gntGw3wZYL4v0lIP9NM4GmA9HO6O9OD/MtLRnVBhY7sSdqG6TEM1IBj3kTODNST1FWVTTvTfQy35KYTW/yQiNQL+Pw8DuIIAAAB42mNgZGBgAGLFKc9XxvPbfGWQ52AAgfOlD1pg9H/Dfxkccez6QHUcDEwgUQBgngybAAAAeNpjYGRgYNf/58DAwLHvv+H/yRxxDEARFPACAIYVBk142m2TX0hTURzHv/ec37kbI4bIiKBmD2IFIWEhY4w9RJGz9jBERkhIDNqDMJKaUC+BRERchtyXfJIYFRSIj3uQkBghQTGCiB7EImL0YNKDiJjC+p47ViY+fPief79zz/l+z1U/cTEMwKK6AGcDJR1BQVZwUj7jstlG0pxC2qmhoAaRVwn0qWWkRJByNlFSRc5tUR8A8gt51h6XOkZlFgPyFEl5jylpIC/nkZA31AZyThMlW2v36KDncdS9gIwpQMwAfFNG3izAlzkyzf4r9t/CV93w9Qq6ZIvjhzDtco2pw3d7uPfXtpow517z23M8O+fsnqEkomYYYXMEIjVcUz0Ys2em9ul7vOv91m9njXe4ghF5Dk/vIEfNSRk5dQfxoO2h4qzjtrPeGpAEPLY9dx4exz3eNydVahVZ+uPpZSRUBTF5xDG3tetGENHbiNi2buA6fYzQU5/aK1GubXs/EXx3GP3ST+95VrtGf0BSDbU+uUmM6Sgyeg1pOYyU9V5vIKN+8B4TrLE+nsAoydq76FkkbDbcA+oYYjqNS7bWvYWYu4gYPcnq0zgXeH4AoYXWrs0hyGAPqrtVYw5T1CZZNN8R62SwH57pbpBJvZ3TX2wOzEt2UAk8P4CQi5HAj/L/0P9n9H6c+pG8CLz38DjQ/dCnQG0Oe2EOQV7U8BLyoRnk7JnUEL3yA+8QOvNP1Q3m846cbYMm9Sa1yDnm0EGW6O9L/hObuGrfuEVPYpxYLalVPDTfOM5aNcMaYvc1TzCoq+jVX/gGi3xvxF1FHPE/3KrOPAAAAHjaY2Bg0IHCEoYbjEaMV5iKmHmY3ZhzmCcxn2DhYrFjiWFpYZnH8odVibWC9RGbDtsUdgF2E/YjHC4cdRyHOK5x/ODk4azhSuKawvWL24O7h/sY9y+eDJ4FPPt43vEq8XrwdvAe4pPii+M7xi/D38e/j/+PgJJAj8ABgQ+CcoJ+gmmCswR3CF4Q/CCUJXRCmEs4S/iUiITIJJFrogKicaJTRDeJSYjFiK0R5xHPEZ8n4SExR+KRJJtkm+QOyU9SClIdUkukuaRzgHCdjIzMEVk72UWyJ+TS5FbJu8kfkH+gwKWgoXBA4Y6ihmKF4gklI6UApT6lLUp/lGWUM5S7VHhUJqkGqR5TY1CzUatS+6Weo/5Ew0rjjKaQZojmPC0BLQutJK0JWm+0g7Qv6RjpTNH5oTtJT07PQe+APod+gP4cAyEDH4MZhjGGD4wyjL4Y7zIpMNUzfWCWZHbK3MR8kYWLRY7FNIsjlgqWs6xkrKqsbljbWF+wibOZYytgm2S7zU7AboLdJXsj+1UOJg6XHJ0cMxz34ICnHG84PnP85yTm5OfU5LTNWcQ5w3mf8ysXOyCMcWlwaXBlc81y7XLjcytxN3K/AgD9d5M/AAAAAQAAAOkATgAFAAAAAAACAAEAAgAWAAABAADsAAAAAHjanZI9TsNAEIXfOuEnAkFoEKJALoMExoEkIFMBLUSIIJAQjUMMicifsAkgUVJScgKOwQngEpScgZK3641lOYoLNMruN+O3M7M7ATCPD2QgsjkAXf5CFlihF7KBabxqzuAEb5qzKOBH8wSqYk7zJAriUvMULsSL5hyWxbfmGVTEr+ZZVAxLcx5LRkPzAvLGs+ZPLBrDHr5gG+84QA99POEOLdygiQAm+7nCKvcjuIzfkmr82qGyC1+ta4xtwqaVYZH30KaZsSy+8jzuHvcB1waVx+QeHlU2l4oqvYGiQ57Zp9emblg3WdWhbnyGGmt0GK/rLE6sx/S6ZlT5THXrUyfrmSiyZ1vZLnPUGJEcjzapDPheUj+ITljYwk6i6rDm+kin47trqXeUFFDjUuspTTiVHq5Tp2SlfJMzCjh5Bxu0B2VWlNsfySRv2PnnqXH3S77DOf067yTPBtFbnrLqvfqP9ZlHRrfVWmYXJb6yo6YczrqI0h/4ZoqHAAAAeNpt0EVs03EUwPHv2ypb5+4b7tL/v+0Eb7f9cXdnsK0tjG10FBhOGC6BkHCDYBcguAYCHIDgFiTAgTMeDsAVuv1/3HiXT95LnuQRRVv8sdKN/8UnkCiJJhoLVmzYiSEWB3HEk0AiSSSTQipppJNBJllkk0MueeRTQCFFtKM9HehIJzrTha6RPd3pQU960Zs+9MWJho4LNx6KKaGUMvrRnwEMZBCDGYIXH+VUUInBUIYxnBGMZBSjGcNYxjGeCUxkEpOZwlSmMZ0ZzGQWs5nDXOZRJRaO0sImbrCfj2xmNzs4wHGOiZXtvGcj+8Qmdnaxldt8kBgOcoJf/OQ3RzjFA+5xmvksYA/VPKKG+zzkGY95wtPIj2p5yXNecAY/P9jLG17xmgBf+MY2FhJkEYupo55DNLCERkI0EWYpy1jOZ1awkmZWsYbVXOUw61jLejbwle9c4yznuM5b3kmsOCRO4iVBEiVJkiVFUiVN0iVDMjnPBS5zhTtc5BJ32cJJyeImtyRbctgpuZIn+VIghTZ/XXNjQLOH64NOp7PC1OtUqtynK13Kslb1SINSU+pKl9Kt9CiLlSXKUuW/eV5TTc3VNEdt0B8O1VRXNQXMkm6YegxLZTjU0JZ4jPJWDZ95R0Rd6VK6/wL2aJv4AAAAeNo9zTsKwkAUheFM3g9jXiPaRBJBBGcJNhYmCGnEKgFrl2BtY6lrubFyUe5BDzqZ7nyn+V/scyN21xpyD23P2KPra1u0JcVdQ/yIce1yssWp1cgoKjLEjsyiehozXfxgAeYAG7D2Eg5gbyRcwCklPMB9S/iAN5cIAD+XGAHB4g9GoayP8YZTXfRGfQEjcLxUjMHorJiA8VYxBROhmIHpWpGD2UpxAvJ8YEdcfAGjxlPkAAAAAAFTUDAEAAA=) format(\'woff\'),url(https://cdn.auth0.com/fonts/proxima-nova/proximanova-semibold-webfont-webfont.ttf) format(\'truetype\');font-weight:700;font-style:normal}@font-face{font-family:auth0;src:url(data:application/x-font-woff;charset=utf-8;base64,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) format(\'woff\'),url(https://cdn.auth0.com/fonts/widget/fonts/auth0-widget.eot),url(https://cdn.auth0.com/fonts/widget/fonts/auth0-widget.ttf) format(\'truetype\');font-weight:400;font-style:normal}#a0-lock [class*=" a0-icon-"]:before,#a0-lock [class^=a0-icon-]:before{font-family:auth0!important;font-style:normal!important;font-weight:400!important;font-variant:normal!important;text-transform:none!important;speak:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}#a0-lock .a0-icon-budicon-2:before{content:"d"}#a0-lock .a0-icon-budicon-3:before{content:"e"}#a0-lock .a0-icon-budicon-9:before{content:"p"}#a0-lock .a0-icon-budicon-1:before{content:"g"}#a0-lock .a0-icon-budicon:before{content:"c"}#a0-lock .a0-icon-badge:before{content:"f"}#a0-lock .a0-btn-small{font-size:10px;letter-spacing:1px;text-transform:uppercase;border:1px solid #f1f1f1;padding:4px 10px 4px 11px;margin:0 5px;border-radius:100px;display:inline-block}#a0-lock .a0-btn-small:hover{background:#f1f1f1}#a0-lock .a0-btn-small:focus{background:#e9e9e9;border-color:#e9e9e9}#a0-lock .a0-panel{text-align:center;border-radius:3px;-webkit-box-shadow:0 1px 10px rgba(0,0,0,.4);box-shadow:0 1px 10px rgba(0,0,0,.4);font-size:13px;position:relative;color:#4d4d4d;display:block}#a0-lock .a0-panel *{font-family:proxima_nova!important}#a0-lock .a0-panel .a0-mode{-webkit-animation-name:fadein;-webkit-animation-duration:.3s;-webkit-animation-iteration-count:once;-webkit-animation-timing-function:ease-in;padding:0 20px 20px;margin:auto}#a0-lock .a0-panel *,#a0-lock .a0-panel input{font-smoothing:antialiased}#a0-lock .a0-panel a,#a0-lock .a0-panel button{-webkit-transition:all .2s ease;-moz-transition:all .2s ease;transition:all .2s ease;font-weight:700}#a0-lock .a0-panel .a0-header{margin-bottom:0;margin-top:0}#a0-lock .a0-panel .a0-header h1{font-size:24px;font-weight:100;margin-bottom:10px}#a0-lock .a0-panel .a0-icon-container{height:90px}#a0-lock .a0-panel .a0-icon-container .a0-image{margin:auto;display:inline-block;margin-bottom:10px;margin-top:20px}#a0-lock .a0-panel .a0-icon-container .a0-image.a0-gravatar img{border-radius:58px}#a0-lock .a0-panel .a0-icon-container .a0-image img{width:auto;height:58px}#a0-lock .a0-panel .a0-icon-container .a0-avatar{background:#f1f1f1;margin:auto;display:inline-block;margin-bottom:10px;border-radius:100%;width:60px;height:60px;margin-top:20px}#a0-lock .a0-panel .a0-icon-container .a0-avatar i{color:#EB5424;font-size:28px;display:block;padding-top:16px}#a0-lock .a0-panel .a0-footer{margin-top:20px}#a0-lock .a0-panel .a0-footer .a0-logo{margin-top:20px;position:absolute;bottom:10px;right:0;left:0;display:block}#a0-lock .a0-panel .a0-footer .a0-logo i{color:#EB5424;font-size:18px}#a0-lock .a0-panel .a0-instructions{margin-bottom:10px;line-height:18px}#a0-lock .a0-panel .a0-last-time{font-size:14px;margin-bottom:20px}#a0-lock .a0-panel .a0-corporate-credentials{margin-bottom:10px}#a0-lock .a0-panel .a0-password,#a0-lock .a0-panel .a0-repeatPassword{border-top:1px solid #ccc}#a0-lock .a0-panel .a0-sso-notice-container{margin-top:20px}#a0-lock .a0-panel .a0-sso-notice-container i{position:relative;top:1px;margin-right:2px;font-size:11px}#a0-lock .a0-panel .a0-sso-notice-container .a0-sso-notice{font-size:10px;text-transform:uppercase;letter-spacing:1px}#a0-lock .a0-panel .a0-email .a0-input-box,#a0-lock .a0-panel .a0-password .a0-input-box,#a0-lock .a0-panel .a0-repeatPassword .a0-input-box{position:relative;height:50px}#a0-lock .a0-panel .a0-email .a0-input-box i,#a0-lock .a0-panel .a0-password .a0-input-box i,#a0-lock .a0-panel .a0-repeatPassword .a0-input-box i{font-size:14px;z-index:1000;top:18px;left:16px;position:absolute;color:#999}#a0-lock .a0-panel .a0-email input,#a0-lock .a0-panel .a0-password input,#a0-lock .a0-panel .a0-repeatPassword input{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:16px 10px;padding-left:40px;border-radius:0;position:absolute;right:0;left:0;bottom:0;top:0;background:#fff;max-width:248px;width:100%}#a0-lock .a0-panel .a0-email input:focus,#a0-lock .a0-panel .a0-password input:focus,#a0-lock .a0-panel .a0-repeatPassword input:focus{background:#fff}#a0-lock .a0-panel input::-webkit-input-placeholder{color:#9da4ad;-webkit-transition:color .2s ease-in}#a0-lock .a0-panel input:-moz-placeholder{color:#9da4ad}#a0-lock .a0-panel input::-moz-placeholder{color:#9da4ad}#a0-lock .a0-panel input:-ms-input-placeholder{color:#9da4ad}#a0-lock .a0-panel input:focus::-webkit-input-placeholder{color:#666}#a0-lock .a0-panel input:focus:-moz-placeholder{color:#666}#a0-lock .a0-panel input:focus::-moz-placeholder{color:#666}#a0-lock .a0-panel input:focus:-ms-input-placeholder{color:#666}#a0-lock .a0-panel .a0-inputs{border:1px solid #ccc;border-radius:3px;overflow:hidden}#a0-lock .a0-panel .a0-email input{border-bottom:0;border-top-left-radius:3px;border-top-right-radius:3px}#a0-lock .a0-panel .a0-password input{border-bottom-left-radius:3px;border-bottom-right-radius:3px}#a0-lock .a0-panel .a0-separator{margin-bottom:10px;margin-top:6px;color:#999;font-size:12px}#a0-lock .a0-panel .a0-separator span{letter-spacing:1px;text-transform:uppercase}#a0-lock .a0-panel button.a0-primary{padding:20px 10px;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;white-space:nowrap;text-align:center;text-transform:uppercase;font-weight:700;display:block!important;width:100%!important;float:none;min-width:auto;letter-spacing:1px;margin-bottom:20px;margin-top:20px;background-color:#16214D;color:#fff;cursor:pointer;border-radius:3px}#a0-lock .a0-panel button.a0-primary:hover{background:#0b1025}#a0-lock .a0-panel button.a0-primary:focus{background:#3e4975}#a0-lock .a0-panel input[disabled]{background-color:#d9dee0}#a0-lock .a0-panel .a0-success{color:green}#a0-lock .a0-panel .a0-error{color:red}#a0-lock .a0-panel .a0-error,#a0-lock .a0-panel .a0-success{margin-bottom:10px;padding:0 15px}#a0-lock .a0-panel.a0-errors.a0-errors-global{border-color:red}#a0-lock .a0-panel.a0-errors .a0-error-input i{color:red}#a0-lock .a0-panel.a0-errors .a0-error-input span{position:absolute;top:15px;right:14px;font-size:9px;letter-spacing:1px;text-transform:uppercase;color:red;border:1px solid red;padding:4px 6px 4px 7px;border-radius:3px;display:block;z-index:10000}#a0-lock .a0-panel.a0-errors .a0-error-input input{color:red}#a0-lock .a0-panel.a0-errors .a0-error-input input::-webkit-input-placeholder{color:red}#a0-lock .a0-panel.a0-errors .a0-error-input input:-moz-placeholder{color:red}#a0-lock .a0-panel.a0-errors .a0-error-input input::-moz-placeholder{color:red}#a0-lock .a0-panel.a0-errors .a0-error-input input:-ms-input-placeholder{color:red}#a0-lock .a0-panel .a0-close{position:absolute;top:20px;right:20px;display:block;cursor:pointer;font-size:16px;color:#ccc}#a0-lock .a0-panel .a0-close:hover{color:#333}#a0-lock .a0-panel .a0-signup-footer small{margin-top:10px;display:block}#a0-lock .a0-panel #a0-change_password .a0-password{margin-bottom:0}#a0-lock .a0-panel #a0-change_password .a0-password input{border-radius:0}#a0-lock .a0-panel #a0-change_password .a0-collapse-reset .a0-instructions{margin-top:0;margin-bottom:20px}#a0-lock .a0-panel #a0-change_password .a0-reset_easy_password input{border-bottom-right-radius:3px;border-bottom-left-radius:3px}#a0-lock .a0-sad-placeholder{display:none}#a0-lock .a0-no-placeholder-support .a0-sad-placeholder{display:block;text-align:left;font-weight:700;margin:14px 0 10px}#a0-lock .a0-no-placeholder-support .a0-inputs{border:0!important}#a0-lock .a0-no-placeholder-support .a0-inputs .a0-email,#a0-lock .a0-no-placeholder-support .a0-inputs .a0-password,#a0-lock .a0-no-placeholder-support .a0-inputs .a0-repeatPassword{border:0}#a0-lock .a0-no-placeholder-support .a0-inputs .a0-input-box{border:1px solid #ccc}#a0-lock .a0-no-placeholder-support .a0-inputs .a0-input-box input{border:0!important}@media screen and (max-width:480px){#a0-lock .a0-ie8-overlay{background:none!important}#a0-lock #a0-onestep{-webkit-transition:none;-moz-transition:none;transition:none}#a0-lock .a0-popup .a0-overlay{display:block;overflow:auto;position:static;background:#fff}#a0-lock .a0-popup .a0-centrix{vertical-align:top;display:block;position:static}#a0-lock .a0-popup .a0-centrix .a0-panel{-webkit-box-shadow:none;box-shadow:none;background:#fff}#a0-lock .a0-popup .a0-centrix .a0-panel .a0-mode{padding:0 20px 20px}#a0-lock .a0-popup .a0-centrix .a0-panel .a0-icon-container{height:60px}#a0-lock .a0-popup .a0-centrix .a0-panel .a0-icon-container .a0-image{margin-top:10px}#a0-lock .a0-popup .a0-centrix .a0-panel .a0-icon-container .a0-image img{height:40px;width:auto}#a0-lock .a0-popup .a0-centrix .a0-panel .a0-icon-container .a0-avatar{margin-top:10px;width:40px;height:40px}#a0-lock .a0-popup .a0-centrix .a0-panel .a0-icon-container .a0-avatar i{font-size:20px;padding-top:10px}#a0-lock .a0-popup .a0-centrix .a0-panel #a0-change_password .a0-collapse-reset .a0-instructions,#a0-lock .a0-popup .a0-centrix .a0-panel h1{margin-bottom:10px}#a0-lock .a0-popup .a0-centrix .a0-panel .a0-db-actions,#a0-lock .a0-popup .a0-centrix .a0-panel .a0-options{margin-top:20px;font-size:14px}#a0-lock .a0-popup .a0-centrix .a0-panel .a0-footer{margin-top:40px}}@media screen and (max-width:480px){body.a0-lock-open>*{display:none}body.a0-lock-open .a0-lock-container{display:block}.a0-lock-container{background:#fff;opacity:1}}';
    function insert(css) {
      var head = document.getElementsByTagName("head")[0];
      var style = document.createElement("style");
      style.type = "text/css";
      head.appendChild(style);
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }
    insert(style);
  }, {
    fs: 74
  } ],
  26: [ function(require, module, exports) {
    module.exports = function() {
      return window.matchMedia && !window.matchMedia("(min-width: 340px)").matches;
    };
  }, {} ],
  27: [ function(require, module, exports) {
    var _ = require("underscore");
    var $ = require("../bonzo-augmented");
    var Emitter = require("events").EventEmitter;
    var create = require("../object-create");
    var template = require("./loggedin.ejs");
    var buttonTmpl = require("../html/zocial-button.ejs");
    var stop = require("../stop-event");
    module.exports = KerberosPanel;
    function KerberosPanel(widget, options) {
      if (!(this instanceof KerberosPanel)) {
        return new KerberosPanel(widget, options);
      }
      if (2 !== arguments.length) {
        throw new Error("Missing parameters for KerberosPanel");
      }
      this.name = "kerberos";
      this.widget = widget;
      this.options = this.resolveOptions(options);
      this.el = null;
      Emitter.call(this);
    }
    KerberosPanel.prototype = create(Emitter.prototype);
    KerberosPanel.prototype.query = function(selector) {
      if (!this.el) throw new Error("Can't get element since no `el` is set to local context");
      return $(selector, this.el);
    };
    KerberosPanel.prototype.create = function(options) {
      var opts = this.resolveOptions(options);
      var widget = this.widget;
      this.el = $.create(widget.render(template, opts))[0];
      this.bindAll();
      return this.el;
    };
    KerberosPanel.prototype.render = function() {
      return null != this.el ? this.el : this.create.apply(this, arguments);
    };
    KerberosPanel.prototype.resolveOptions = function(options) {
      return _.extend({}, this.widget.options, this.options, options);
    };
    KerberosPanel.prototype.bindAll = function() {
      var self = this;
      var widget = this.widget;
      var options = this.options;
      var connection = widget.$ssoData.connection;
      var strategy_name = widget.$ssoData.strategy;
      var strategy = widget.$strategies[strategy_name];
      if (!strategy) return;
      this.query("form").a0_on("submit", function(e) {
        stop(e);
        widget._signInEnterprise(e);
      });
      var button = $.create(buttonTmpl({
        use_big_buttons: true,
        name: strategy_name,
        title: options.i18n.t("windowsAuthTitle").replace("{connection}", connection),
        css: strategy.css,
        imageicon: strategy.imageicon
      }));
      this.query(".a0-last-time").html(options.i18n.t("signin:domainUserLabel"));
      this.query(".a0-strategy div").remove();
      this.query(".a0-strategy").append(button);
      this.query(".a0-strategy .a0-zocial[data-strategy]").a0_on("click", function(e) {
        stop(e);
        widget._signinSocial(strategy_name, connection, null, self);
      });
      this.query(".a0-all").a0_on("click", function(e) {
        stop(e);
        widget._signinPanel(self.options);
      });
    };
  }, {
    "../bonzo-augmented": 18,
    "../html/zocial-button.ejs": 23,
    "../object-create": 41,
    "../stop-event": 44,
    "./loggedin.ejs": 28,
    events: 75,
    underscore: 78
  } ],
  28: [ function(require, module, exports) {
    module.exports = function anonymous(locals, filters, escape, rethrow) {
      escape = escape || function(html) {
        return String(html).replace(/&(?!#?[a-zA-Z0-9]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;");
      };
      var buf = [];
      with (locals || {}) {
        (function() {
          buf.push('<div class="a0-loggedin a0-mode">\n    <form novalidate>\n        <span class="a0-centered a0-last-time">', escape((3, 
          i18n.t("signin:returnUserLabel"))), '</span>\n        <div class="a0-strategy"></div>\n        <div class="a0-emailPassword a0-hide">\n            <div class="a0-email">\n                <span class="a0-email-readonly"></span>\n                <input name="email"\n                       type="email"\n                       value=""\n                       disabled\n                       placeholder="', escape((12, 
          i18n.t("signin:emailPlaceholder"))), '"\n                       title="', escape((13, 
          i18n.t("signin:emailPlaceholder"))), '"\n                       class="a0-hide">\n            </div>\n            <div class="a0-password">\n                <label class="a0-sad-placeholder">\n                  ', escape((18, 
          i18n.t("signin:passwordPlaceholder"))), '\n                </label>\n                <input name="password" type="password"\n                       autofocus\n                       placeholder="', escape((22, 
          i18n.t("signin:passwordPlaceholder"))), '"\n                       title="', escape((23, 
          i18n.t("signin:passwordPlaceholder"))), '">\n            </div>\n            <div class="a0-action">\n                <button type="submit" class="a0-primary a0-next" style="width: 100%;">', escape((26, 
          i18n.t("signin:action"))), "</button>\n                ");
          27;
          if (options.showForgot !== false) {
            buf.push('\n                <label class="a0-create-account">\n                  <a href="', escape((29, 
            options.resetLink || "javascript: {}")), '"\n                    class="a0-forgot-pass">', escape((30, 
            i18n.t("signin:forgotText"))), "</a>\n                </label>\n                ");
            32;
          }
          buf.push('\n            </div>\n        </div>\n        <a href="#" class="a0-centered a0-all a0-btn-small">', escape((35, 
          i18n.t("signin:all"))), "</a>\n    </form>\n</div>\n");
        })();
      }
      return buf.join("");
    };
  }, {} ],
  29: [ function(require, module, exports) {
    var _ = require("underscore");
    var $ = require("../bonzo-augmented");
    var Emitter = require("events").EventEmitter;
    var create = require("../object-create");
    var template = require("./loading.ejs");
    module.exports = LoadingPanel;
    function LoadingPanel(widget, options) {
      if (!(this instanceof LoadingPanel)) {
        return new LoadingPanel(widget, options);
      }
      if (2 !== arguments.length) {
        throw new Error("Missing parameters for LoadingPanel");
      }
      this.name = "loading";
      this.widget = widget;
      this.options = this.resolveOptions(options);
      this.el = null;
      Emitter.call(this);
    }
    LoadingPanel.prototype = create(Emitter.prototype);
    LoadingPanel.prototype.query = function(selector) {
      if (!this.el) throw new Error("Can't get element since no `el` is set to local context");
      return $(selector, this.el);
    };
    LoadingPanel.prototype.create = function(options) {
      var opts = this.resolveOptions(options);
      var widget = this.widget;
      this.el = $.create(widget.render(template, opts))[0];
      this.bindAll();
      return this.el;
    };
    LoadingPanel.prototype.render = function() {
      return null != this.el ? this.el : this.create.apply(this, arguments);
    };
    LoadingPanel.prototype.resolveOptions = function(options) {
      return _.extend({}, this.widget.options, this.options, options);
    };
    LoadingPanel.prototype.bindAll = function() {
      return this;
    };
  }, {
    "../bonzo-augmented": 18,
    "../object-create": 41,
    "./loading.ejs": 30,
    events: 75,
    underscore: 78
  } ],
  30: [ function(require, module, exports) {
    module.exports = function anonymous(locals, filters, escape, rethrow) {
      escape = escape || function(html) {
        return String(html).replace(/&(?!#?[a-zA-Z0-9]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;");
      };
      var buf = [];
      with (locals || {}) {
        (function() {
          buf.push('<div class="a0-loading a0-mode">\n    ');
          2;
          if (locals.alt_spinner) {
            buf.push('\n    <div class="a0-spinner a0-spin-img" style="background-image: url(\'', escape((3, 
            locals.alt_spinner)), "')\"></div>\n    ");
            4;
          } else {
            buf.push('\n    <div class="a0-spinner a0-spin-container">\n        <div class="a0-spinner-css">\n          <span class="a0-side a0-sp_left">\n            <span class="a0-fill"></span>\n          </span>\n          <span class="a0-side a0-sp_right">\n            <span class="a0-fill"></span>\n          </span>\n        </div>\n        <div class="a0-spin-message">\n            <span>&nbsp;</span>\n        </div>\n    </div>\n    ');
            18;
          }
          buf.push("\n</div>\n");
        })();
      }
      return buf.join("");
    };
  }, {} ],
  31: [ function(require, module, exports) {
    var Emitter = require("events").EventEmitter;
    var create = require("../object-create");
    var template = require("./loggedin.ejs");
    var loggedinBtnTmpl = require("./loggedin_button.ejs");
    var stop = require("../stop-event");
    var _ = require("underscore");
    var $ = require("../bonzo-augmented");
    var gravatar = require("../gravatar");
    module.exports = LoggedinPanel;
    function LoggedinPanel(widget, options) {
      if (!(this instanceof LoggedinPanel)) {
        return new LoggedinPanel(widget, options);
      }
      if (2 !== arguments.length) {
        throw new Error("Missing parameters for LoggedinPanel");
      }
      this.name = "loggedin";
      this.widget = widget;
      this.options = this.resolveOptions(options);
      this.el = null;
      Emitter.call(this);
    }
    LoggedinPanel.prototype = create(Emitter.prototype);
    LoggedinPanel.prototype.query = function(selector) {
      if (!this.el) {
        throw new Error("Can't get element since no `el` is set to local context");
      }
      return $(selector, this.el);
    };
    LoggedinPanel.prototype.create = function(options) {
      var opts = this.resolveOptions(options);
      var widget = this.widget;
      this.el = $.create(widget.render(template, opts))[0];
      this.bindAll();
      return this.el;
    };
    LoggedinPanel.prototype.render = function() {
      return null != this.el ? this.el : this.create.apply(this, arguments);
    };
    LoggedinPanel.prototype.resolveOptions = function(options) {
      return _.extend({}, this.widget.options, this.options, options);
    };
    LoggedinPanel.prototype.bindAll = function() {
      var self = this;
      var widget = this.widget;
      var options = this.options;
      var strategy_name = widget.$ssoData.lastUsedConnection.strategy;
      var strategy = widget.$strategies[strategy_name];
      if (!strategy) {
        return;
      }
      this.query("form").a0_on("submit", function(e) {
        stop(e);
        widget._signInEnterprise(e);
      });
      if (options.gravatar) {
        gravatar(this.widget, widget.$ssoData.lastUsedUsername);
      }
      var button = $.create(loggedinBtnTmpl({
        name: strategy_name,
        title: strategy.title,
        css: strategy.css,
        imageicon: strategy.imageicon,
        username: widget.$ssoData.lastUsedUsername
      }));
      this.query(".a0-last-time").html(options.i18n.t("signin:returnUserLabel"));
      this.query(".a0-strategy div").remove();
      this.query(".a0-strategy").append(button);
      this.query(".a0-strategy .a0-zocial[data-strategy]").a0_on("click", function(e) {
        stop(e);
        widget._signinSocial(strategy_name, widget.$ssoData.lastUsedConnection && widget.$ssoData.lastUsedConnection.name, options._getLoggedInAuthParams(strategy_name, widget.$ssoData), self);
      });
      this.query(".a0-all").a0_on("click", function(e) {
        stop(e);
        gravatar(widget, "");
        widget._signinPanel(self.options);
      });
    };
    LoggedinPanel.prototype.query = function(selector) {
      return $(selector, this.el);
    };
  }, {
    "../bonzo-augmented": 18,
    "../gravatar": 19,
    "../object-create": 41,
    "../stop-event": 44,
    "./loggedin.ejs": 32,
    "./loggedin_button.ejs": 33,
    events: 75,
    underscore: 78
  } ],
  32: [ function(require, module, exports) {
    module.exports = require(28);
  }, {} ],
  33: [ function(require, module, exports) {
    module.exports = function anonymous(locals, filters, escape, rethrow) {
      escape = escape || function(html) {
        return String(html).replace(/&(?!#?[a-zA-Z0-9]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;");
      };
      var buf = [];
      with (locals || {}) {
        (function() {
          buf.push('<div tabindex="0"\n		data-strategy="', escape((2, name)), '"\n		title="', escape((3, 
          username ? username + " (" + title + ")" : title)), '"\n		class="a0-zocial a0-block a0-', escape((4, 
          css)), " ", escape((4, locals.imageicon ? "a0-image-icon" : "")), '">\n	<span>', escape((5, 
          username || title)), "</span>\n</div>");
        })();
      }
      return buf.join("");
    };
  }, {} ],
  34: [ function(require, module, exports) {
    var _ = require("underscore");
    var $ = require("../bonzo-augmented");
    var Emitter = require("events").EventEmitter;
    var create = require("../object-create");
    var stop = require("../stop-event");
    var bind = require("../bind");
    var template = require("./reset.ejs");
    var regex = require("../regex");
    var empty = regex.empty;
    var trim = require("trim");
    var email_parser = regex.email_parser;
    var slice = Array.prototype.slice;
    module.exports = ResetPanel;
    function ResetPanel(widget, options) {
      if (!(this instanceof ResetPanel)) {
        return new ResetPanel(widget, options);
      }
      if (2 !== arguments.length) {
        throw new Error("Missing parameters for ResetPanel");
      }
      this.name = "reset";
      this.widget = widget;
      this.options = this.resolveOptions(options);
      this.el = null;
      Emitter.call(this);
    }
    ResetPanel.prototype = create(Emitter.prototype);
    ResetPanel.prototype.query = function(selector) {
      if (!this.el) throw new Error("Can't get element since no `el` is set to local context");
      return $(selector, this.el);
    };
    ResetPanel.prototype.create = function(options) {
      var opts = this.resolveOptions(options);
      var widget = this.widget;
      this.el = $.create(widget.render(template, opts))[0];
      this.bindAll();
      return this.el;
    };
    ResetPanel.prototype.render = function() {
      return null != this.el ? this.el : this.create.apply(this, arguments);
    };
    ResetPanel.prototype.resolveOptions = function(options) {
      return _.extend({}, this.widget.options, this.options, options);
    };
    ResetPanel.prototype.bindAll = function() {
      var options = this.options;
      this.query(".a0-options").toggleClass("a0-hide", !options.showResetAction);
      this.query("form").a0_off("submit").a0_on("submit", bind(this.onsubmit, this));
      this.query(".a0-options .a0-cancel").a0_on("click", bind(this.oncancel, this));
      return this;
    };
    ResetPanel.prototype.onsubmit = function(e) {
      stop(e);
      if (!this.valid()) return;
      this.submit();
    };
    ResetPanel.prototype.oncancel = function(e) {
      stop(e);
      var widget = this.widget;
      widget._showSuccess();
      widget._showError();
      widget._focusError();
      widget._signinPanel();
    };
    ResetPanel.prototype.valid = function() {
      var ok = true;
      var email_input = this.query("input[name=email]");
      var email = trim(email_input.val());
      var email_empty = empty.test(email);
      var email_parsed = email_parser.exec(email.toLowerCase());
      var password_input = this.query("input[name=password]");
      var password = password_input.val();
      var password_empty = empty.test(password);
      var repeat_password_input = this.query("input[name=repeat_password]");
      var repeat_password = repeat_password_input.val();
      var repeat_password_empty = empty.test(repeat_password);
      var widget = this.widget;
      widget._showError();
      widget._focusError();
      if (email_empty) {
        widget._focusError(email_input);
        ok = false;
      }
      if (!email_parsed && !email_empty) {
        widget._focusError(email_input, widget.options.i18n.t("invalid"));
        ok = false;
      }
      if (password_empty) {
        widget._focusError(password_input);
        ok = false;
      }
      if (repeat_password_empty) {
        widget._focusError(repeat_password_input);
        ok = false;
      }
      if (repeat_password_input.val() !== password_input.val()) {
        widget._focusError(repeat_password_input, widget.options.i18n.t("mustMatch"));
        ok = false;
      }
      return ok;
    };
    ResetPanel.prototype.submit = function() {
      var panel = this;
      var widget = panel.widget;
      var email_input = this.query("input[name=email]");
      var username = email_input.val();
      var password_input = this.query("input[name=password]");
      var password = password_input.val();
      var repeat_password_input = this.query("input[name=repeat_password]");
      var connection = this.options._getAuth0Connection();
      var callback = panel.options.popupCallback;
      widget._loadingPanel({
        mode: "reset"
      });
      widget.$auth0.changePassword({
        connection: connection.name,
        username: username,
        password: password
      }, function(err) {
        var args = slice.call(arguments, 0);
        if (!widget.$container || widget.query()[0] !== widget.$container.childNodes[0]) {
          return console && console.log && console.log("this password reset was triggered from another node instance", arguments);
        }
        password_input.val("");
        repeat_password_input.val("");
        if (!err) {
          email_input.val("");
          widget._signinPanel(panel.options);
          widget._showSuccess(widget.options.i18n.t("reset:successText"));
          return "function" === typeof callback ? callback.apply(widget, args) : null;
        }
        widget.setPanel(panel);
        if (400 === err.status) {
          widget._focusError(email_input);
          widget._showError(widget.options.i18n.t("reset:userDoesNotExistErrorText"));
        } else {
          widget._showError(widget.options.i18n.t("reset:serverErrorText"));
        }
        return "function" === typeof callback ? callback.apply(widget, args) : null;
      });
    };
  }, {
    "../bind": 17,
    "../bonzo-augmented": 18,
    "../object-create": 41,
    "../regex": 43,
    "../stop-event": 44,
    "./reset.ejs": 35,
    events: 75,
    trim: 77,
    underscore: 78
  } ],
  35: [ function(require, module, exports) {
    module.exports = function anonymous(locals, filters, escape, rethrow) {
      escape = escape || function(html) {
        return String(html).replace(/&(?!#?[a-zA-Z0-9]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;");
      };
      var buf = [];
      with (locals || {}) {
        (function() {
          buf.push('<div class="a0-reset a0-mode">\n    <form id="a0-change_password" class="form-reset-password" novalidate>\n        <div class="a0-collapse-reset">\n            <div class="a0-header a0-instructions">', escape((4, 
          i18n.t("reset:headerText"))), '</div>\n        </div>\n        <div class="a0-emailPassword">\n            <div class="a0-inputs">\n\n                <div class="a0-email">\n                    <label for="a0-reset_easy_email" class="a0-sad-placeholder">\n                      ', escape((11, 
          i18n.t("reset:emailPlaceholder"))), '\n                    </label>\n                    <div class="a0-input-box">\n                      <i class="a0-icon-budicon-1"></i>\n                      <input name="email"\n                           id="a0-reset_easy_email"\n                           type="email"\n                           value=""\n                           placeholder="', escape((19, 
          i18n.t("reset:emailPlaceholder"))), '"\n                           title="', escape((20, 
          i18n.t("reset:emailPlaceholder"))), '">\n                    </div>\n                </div>\n                <div class="a0-password">\n                    <label for="a0-reset_easy_password" class="a0-sad-placeholder">\n                      ', escape((25, 
          i18n.t("reset:passwordPlaceholder"))), '\n                    </label>\n                    <div class="a0-input-box">\n                      <i class="a0-icon-budicon"></i>\n                      <input name="password"\n                           id="a0-reset_easy_password"\n                           type="password"\n                           value=""\n                           placeholder="', escape((33, 
          i18n.t("reset:passwordPlaceholder"))), '"\n                           title="', escape((34, 
          i18n.t("reset:passwordPlaceholder"))), '">\n                    </div>\n                </div>\n                <div class="a0-repeatPassword">\n                    <label for="a0-reset_easy_repeat_password" class="a0-sad-placeholder">\n                      ', escape((39, 
          i18n.t("reset:repeatPasswordPlaceholder"))), '\n                    </label>\n                    <div class="a0-input-box">\n                      <i class="a0-icon-budicon"></i>\n                      <input name="repeat_password"\n                           id="a0-reset_easy_repeat_password"\n                           type="password" value=""\n                           placeholder="', escape((46, 
          i18n.t("reset:repeatPasswordPlaceholder"))), '"\n                           title="', escape((47, 
          i18n.t("reset:repeatPasswordPlaceholder"))), '">\n                    </div>\n                </div>\n\n            </div>\n\n            <div class="a0-action">\n                <button type="submit" class="a0-primary a0-next" style="width: 100%;">', escape((54, 
          i18n.t("reset:action"))), '</button>\n                <div class="a0-options">\n                    <a href="javascript: {}" class="a0-centered a0-btn-small a0-cancel">', escape((56, 
          i18n.t("reset:cancelAction"))), "</a>\n                </div>\n            </div>\n        </div>\n    </form>\n</div>\n");
        })();
      }
      return buf.join("");
    };
  }, {} ],
  36: [ function(require, module, exports) {
    var _ = require("underscore");
    var bind = require("../bind");
    var regex = require("../regex");
    var stop = require("../stop-event");
    var $ = require("../bonzo-augmented");
    var template = require("./signin.ejs");
    var create = require("../object-create");
    var Emitter = require("events").EventEmitter;
    var buttonTmpl = require("../html/zocial-button.ejs");
    var loginActionsTmpl = require("./login_actions.ejs");
    var gravatar = require("../gravatar");
    module.exports = SigninPanel;
    function SigninPanel(widget, options) {
      if (!(this instanceof SigninPanel)) {
        return new SigninPanel(widget, options);
      }
      if (2 !== arguments.length) {
        throw new Error("Missing parameters for SigninPanel");
      }
      this.name = "signin";
      this.widget = widget;
      this.options = this.resolveOptions(options);
      this.el = null;
      this.gravatar = _.debounce(this.gravatar, 300);
      Emitter.call(this);
    }
    SigninPanel.prototype = create(Emitter.prototype);
    SigninPanel.prototype.query = function(selector) {
      if (!this.el) {
        throw new Error("Can't get element since no `el` is set to local context");
      }
      return $(selector, this.el);
    };
    SigninPanel.prototype.create = function(options) {
      var opts = this.resolveOptions(options);
      var widget = this.widget;
      this.el = $.create(widget.render(template, opts))[0];
      this.bindAll();
      return this.el;
    };
    SigninPanel.prototype.render = function() {
      return null != this.el ? this.el : this.create.apply(this, arguments);
    };
    SigninPanel.prototype.resolveOptions = function(options) {
      return _.extend({}, this.widget.options, this.options, options);
    };
    SigninPanel.prototype.renderAndBindSocialStrategies = function() {
      var options = this.options;
      var list = this.query(".a0-iconlist");
      var socialStrategies = _.chain(options.$client.strategies).where({
        social: true
      });
      if (options.connections) {
        var connections = options.connections;
        socialStrategies = socialStrategies.map(function(s) {
          var n = connections.indexOf(s.connections[0].name);
          connections[n] = "";
          return [ n, s ];
        }).sort().map(function(x) {
          return x[1];
        });
      }
      socialStrategies.map(function(s) {
        var e = {
          use_big_buttons: options._useBigSocialButtons(),
          title: options.i18n.t("loginSocialButton").replace("{connection:title}", s.title)
        };
        return _.extend({}, s, e);
      }).each(function(s) {
        return list.append(buttonTmpl(s));
      });
      if (options._getSocialStrategies().length > 0) {
        this.query(".a0-separator, .a0-iconlist").toggleClass("a0-hide", false);
      }
      this.query(".a0-zocial[data-strategy]", list).a0_on("click", bind(this.onsocialclick, this));
    };
    SigninPanel.prototype.bindAll = function() {
      var widget = this.widget;
      var options = this.options;
      this.renderAndBindSocialStrategies();
      this.query(".a0-email input").a0_on("input", bind(this.onemailinput, this));
      this.query("form").a0_on("submit", bind(this.onsubmit, this));
      var actions = $.create(widget.render(loginActionsTmpl, options));
      this.query(".a0-db-actions").append(actions);
      if (options.usernameStyle === "username") {
        var placeholder = options.i18n.t("signin:usernamePlaceholder");
        this.query(".a0-email input").attr("type", "text").attr("title", placeholder).attr("placeholder", placeholder);
        this.query(".a0-email label").text(placeholder);
      }
      var signup_btn = this.query(".a0-sign-up");
      if (!options.signupLink && signup_btn.length > 0) {
        signup_btn.a0_on("click", bind(this.onsignupclick, this));
      }
      if (!options.resetLink) {
        this.query(".a0-forgot-pass").a0_on("click", bind(this.onresetclick, this));
      }
      this.query("input").val("");
      var anyEnterpriseOrDbConnection = options._isThereAnyEnterpriseOrDbConnection();
      var anySocialConnection = options._isThereAnySocialConnection();
      var anyDBConnection = options._isThereAnyDBConnection();
      this.query(".a0-email input").toggleClass("a0-hide", !anyEnterpriseOrDbConnection);
      this.query(".a0-zocial.a0-primary").toggleClass("a0-hide", !anyEnterpriseOrDbConnection);
      this.query(".a0-password").toggleClass("a0-hide", !anyDBConnection);
      this.query(".a0-separator").toggleClass("a0-hide", !(anyEnterpriseOrDbConnection && anySocialConnection));
      this.query(".a0-inputs").toggleClass("a0-hide", !anyEnterpriseOrDbConnection);
      this.query(".a0-action").toggleClass("a0-hide", !anyEnterpriseOrDbConnection);
    };
    SigninPanel.prototype.onemailinput = function(e) {
      stop(e);
      var mailField = this.query(".a0-email input");
      var pwdField = this.query(".a0-password input").first();
      var nextButton = this.query(".a0-action > button.a0-next");
      var emailDomain = this.options._extractEmailDomain(mailField.val() || "");
      var isEnterpriseConnection = this.options._isEnterpriseConnection(mailField.val() || "");
      var adConnection = this.options._findConnectionByADDomain(emailDomain);
      var msg;
      if ("username" !== this.options.usernameStyle && this.options.gravatar) {
        this.gravatar(mailField.val());
      }
      if ("username" !== this.options.usernameStyle && adConnection) {
        this.hrd = true;
        this.currentADConnection = adConnection;
        this.currentADConnectionDomain = emailDomain;
        this.query(".a0-sso-notice-container").removeClass("a0-hide");
        this.query(".a0-password").addClass("a0-hide");
        this.oldText = nextButton.text();
        msg = this.options.i18n.t("signin:actionDomain");
        msg = msg.replace("{domain}", emailDomain);
        nextButton.text(msg);
        nextButton.attr("title", msg);
        return pwdField.attr("disabled", true);
      }
      this.hrd = undefined;
      this.currentADConnection = undefined;
      if (this.oldText) {
        nextButton.text(this.oldText);
        nextButton.attr("title", this.oldText);
        this.oldText = undefined;
      }
      if (isEnterpriseConnection) {
        this.query(".a0-sso-notice-container").removeClass("a0-hide");
        this.query(".a0-password").addClass("a0-hide");
        this.oldText = nextButton.text();
        msg = this.options.i18n.t("signin:actionDomain");
        msg = msg.replace("{domain}", emailDomain);
        nextButton.text(msg);
        nextButton.attr("title", msg);
        return pwdField.attr("disabled", true);
      }
      this.query(".a0-sso-notice-container").addClass("a0-hide");
      this.query(".a0-password").removeClass("a0-hide");
      return pwdField.removeAttr("disabled");
    };
    SigninPanel.prototype.gravatar = function(email) {
      gravatar(this.widget, email);
      return this;
    };
    SigninPanel.prototype.onsubmit = function(e) {
      stop(e);
      var widget = this.widget;
      var options = this.options;
      var ok = true;
      var password_input = this.query("input[name=password]");
      var password_empty = regex.empty.test(password_input.val());
      var password_disabled = password_input.attr("disabled");
      var password_required = options._isThereAnyDBConnection();
      var email_input = this.query("input[name=email]");
      var email_parsed = regex.email_parser.exec(email_input.val().toLowerCase());
      var email_empty = regex.empty.test(email_input.val());
      widget._showError();
      widget._focusError();
      if (email_empty) {
        widget._focusError(email_input);
        ok = false;
      }
      if (!widget._ignoreEmailValidations(email_input)) {
        if (!email_parsed && !email_empty) {
          widget._focusError(email_input, options.i18n.t("invalid"));
          ok = false;
        }
      }
      if (password_empty && password_required && !password_disabled) {
        widget._focusError(password_input);
        ok = false;
      }
      if (this.hrd) {
        return this.enableHRD(this.currentADConnection, this.currentADConnectionDomain);
      }
      if (ok && this.currentADConnection) {
        var conn_obj = this.options._findConnectionByADDomain(this.currentADConnection.domain, widget.$client.strategies);
        return widget._signinWithAuth0(this, conn_obj);
      }
      if (ok) {
        return widget._signin(this);
      }
    };
    SigninPanel.prototype.onsocialclick = function(e) {
      stop(e);
      this.widget._signinSocial(e, null, null, this);
    };
    SigninPanel.prototype.onresetclick = function(e) {
      stop(e);
      this.widget._resetPanel(this.options);
    };
    SigninPanel.prototype.onsignupclick = function(e) {
      stop(e);
      this.widget._signupPanel(this.options);
    };
    SigninPanel.prototype.enableHRD = function(adConnection, emailDomain) {
      this.hrd = undefined;
      var emailField = this.query(".a0-email input").first();
      var pwdField = this.query(".a0-password input").first();
      var nextButton = this.query(".a0-action > button.a0-next");
      var emailParsed = regex.email_parser.exec(emailField.val());
      this.query(".a0-password").removeClass("a0-hide");
      this.query(".a0-sso-notice-container").addClass("a0-hide");
      nextButton.text(this.oldText);
      pwdField.removeAttr("disabled");
      this.widget.setPanel(this);
      var placeholder = this.options.i18n.t("signin:usernamePlaceholder");
      this._oldPlaceholder = emailField.attr("title");
      emailField.attr("type", "text").attr("title", placeholder).attr("placeholder", placeholder);
      this.query(".a0-email label").text(placeholder);
      emailField.focus();
      if (emailParsed.length > 1 && this.options.defaultADUsernameFromEmailPrefix) {
        emailField.val(emailParsed[1]);
      } else {
        emailField.val("");
      }
      this.query(".a0-corporate-credentials").toggleClass("a0-hide");
      this.query(".a0-domain").text(emailDomain);
      var actions = $.create(this.widget.render(loginActionsTmpl, {
        showSignupAction: false,
        showResetAction: false,
        showCancel: true
      }));
      this.query(".a0-db-actions").first().deepEach(function(child) {
        $(child).hide();
      });
      this.query(".a0-db-actions").append(actions);
      this.query(".a0-db-actions").show();
      this.query(".a0-cancel").a0_on("click", bind(this.oncancel, this));
      this.currentADConnection = adConnection;
      emailField.a0_off("input");
    };
    SigninPanel.prototype.oncancel = function(e) {
      stop(e);
      this.currentADConnection = undefined;
      var widget = this.widget;
      widget._showError();
      widget._focusError();
      widget.setPanel(this);
      var emailField = this.query(".a0-email input").first();
      var pwdField = this.query(".a0-password input").first();
      this.query(".a0-db-actions").first().deepEach(function(child) {
        $(child).show();
      });
      var oldPlaceholder = this._oldPlaceholder;
      this._oldPlaceholder = undefined;
      this.query(".a0-db-actions .a0-cancel").remove();
      emailField.attr("type", "text").attr("title", oldPlaceholder).attr("placeholder", oldPlaceholder);
      emailField.val("");
      pwdField.val("");
      this.query(".a0-email label").text(oldPlaceholder);
      this.query(".a0-corporate-credentials").toggleClass("a0-hide");
      emailField.a0_on("input", bind(this.onemailinput, this));
      emailField.focus();
    };
  }, {
    "../bind": 17,
    "../bonzo-augmented": 18,
    "../gravatar": 19,
    "../html/zocial-button.ejs": 23,
    "../object-create": 41,
    "../regex": 43,
    "../stop-event": 44,
    "./login_actions.ejs": 37,
    "./signin.ejs": 38,
    events: 75,
    underscore: 78
  } ],
  37: [ function(require, module, exports) {
    module.exports = function anonymous(locals, filters, escape, rethrow) {
      escape = escape || function(html) {
        return String(html).replace(/&(?!#?[a-zA-Z0-9]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;");
      };
      var buf = [];
      with (locals || {}) {
        (function() {
          buf.push('<div class="a0-create-account a0-buttons-actions">\n  ');
          2;
          if (locals.showCancel) {
            buf.push('\n  <a href="', escape((3, locals.cancelLink || "javascript: {}")), '"\n    class="a0-cancel  a0-btn-small">', escape((4, 
            i18n.t("signin:cancelAction"))), "</a>\n  ");
            5;
          }
          buf.push("\n  ");
          6;
          if (showSignupAction) {
            buf.push('\n  <a href="', escape((7, locals.signupLink || "javascript: {}")), '"\n    class="a0-sign-up a0-btn-small">\n    ', escape((9, 
            i18n.t("signin:signupText"))), "\n  </a>\n  ");
            11;
          }
          buf.push("\n  ");
          12;
          if (showSignupAction && showResetAction) {
            buf.push('\n  <span class="a0-divider"></span>\n  ');
            14;
          }
          buf.push("\n  ");
          15;
          if (showResetAction) {
            buf.push('\n  <a href="', escape((16, locals.resetLink || "javascript: {}")), '"\n    class="a0-forgot-pass  a0-btn-small">', escape((17, 
            i18n.t("signin:forgotText"))), "</a>\n  ");
            18;
          }
          buf.push("\n</div>\n");
        })();
      }
      return buf.join("");
    };
  }, {} ],
  38: [ function(require, module, exports) {
    module.exports = function anonymous(locals, filters, escape, rethrow) {
      escape = escape || function(html) {
        return String(html).replace(/&(?!#?[a-zA-Z0-9]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;");
      };
      var buf = [];
      with (locals || {}) {
        (function() {
          buf.push('<div class="a0-notloggedin a0-mode">\n    <form novalidate>\n      <div class="a0-collapse-social">\n        <div class="a0-iconlist a0-hide"><p class="a0-hide">', escape((4, 
          i18n.t("signin:or"))), '</p></div>\n        <div class="a0-separator a0-hide"><span>', escape((5, 
          i18n.t("signin:separatorText"))), '</span></div>\n      </div>\n      <div class="a0-corporate-credentials a0-hide">Please enter your <strong>corporate</strong> credentials at <span class="a0-domain"></span>.</div>\n      <div class="a0-emailPassword">\n        <div class="a0-inputs">\n\n          <div class="a0-email">\n              <label for="a0-signin_easy_email" class="a0-sad-placeholder">\n                ', escape((13, 
          i18n.t("signin:emailPlaceholder"))), '\n              </label>\n\n              <div class="a0-input-box">\n                <i class="a0-icon-budicon-1"></i>\n\n                <input name="email"\n                       id="a0-signin_easy_email"\n                       type="email"\n                       placeholder="', escape((22, 
          i18n.t("signin:emailPlaceholder"))), '"\n                       title="', escape((23, 
          i18n.t("signin:emailPlaceholder"))), '">\n              </div>\n          </div>\n\n          <div class="a0-password a0-hide">\n            <label for="a0-signin_easy_password" class="a0-sad-placeholder">\n              ', escape((29, 
          i18n.t("signin:passwordPlaceholder"))), '\n            </label>\n\n            <div class="a0-input-box">\n              <i class="a0-icon-budicon"></i>\n\n              <input name="password"\n                     id="a0-signin_easy_password"\n                     type="password"\n                     placeholder="', escape((38, 
          i18n.t("signin:passwordPlaceholder"))), '"\n                     title="', escape((39, 
          i18n.t("signin:passwordPlaceholder"))), '">\n            </div>\n          </div>\n\n        </div>\n        <!-- .a0-inputs -->\n\n        <div class="a0-sso-notice-container a0-hide"><i class="a0-icon-budicon"></i> <span class="a0-sso-notice">Single Sign-on enabled</span></div>\n\n        <div class="a0-action">\n            <button type="submit" class="a0-primary a0-next">', escape((49, 
          i18n.t("signin:action"))), '</button>\n            <div class="a0-db-actions">\n            </div>\n        </div>\n      </div>\n    </form>\n</div>\n');
        })();
      }
      return buf.join("");
    };
  }, {} ],
  39: [ function(require, module, exports) {
    var _ = require("underscore");
    var $ = require("../bonzo-augmented");
    var Emitter = require("events").EventEmitter;
    var create = require("../object-create");
    var stop = require("../stop-event");
    var bind = require("../bind");
    var template = require("./signup.ejs");
    var buttonTmpl = require("../html/zocial-button.ejs");
    var regex = require("../regex");
    var gravatar = require("../gravatar");
    var empty = regex.empty;
    var email_parser = regex.email_parser;
    var slice = Array.prototype.slice;
    module.exports = SignupPanel;
    function SignupPanel(widget, options) {
      if (!(this instanceof SignupPanel)) {
        return new SignupPanel(widget, options);
      }
      if (2 !== arguments.length) {
        throw new Error("Missing parameters for SignupPanel");
      }
      this.name = "signup";
      this.widget = widget;
      this.options = this.resolveOptions(options);
      this.el = null;
      this.gravatar = _.debounce(this.gravatar, 300);
      Emitter.call(this);
    }
    SignupPanel.prototype = create(Emitter.prototype);
    SignupPanel.prototype.query = function(selector) {
      if (!this.el) {
        throw new Error("Can't get element since no `el` is set to local context");
      }
      return $(selector, this.el);
    };
    SignupPanel.prototype.create = function(options) {
      var opts = this.resolveOptions(options);
      var widget = this.widget;
      this.el = $.create(widget.render(template, opts))[0];
      this.bindAll();
      return this.el;
    };
    SignupPanel.prototype.render = function() {
      return null != this.el ? this.el : this.create.apply(this, slice.call(arguments, 0));
    };
    SignupPanel.prototype.resolveOptions = function(options) {
      return _.extend({}, this.widget.options, this.options, options);
    };
    SignupPanel.prototype.bindAll = function() {
      var options = this.options;
      this.query(".a0-options").toggleClass("a0-hide", !options.showSignupAction);
      var list = this.query(".a0-iconlist").html("");
      _.chain(options.$client.strategies).where({
        social: true
      }).map(function(s) {
        var e = {
          use_big_buttons: options._useBigSocialButtons(),
          title: options.i18n.t("signupSocialButton").replace("{connection:title}", s.title)
        };
        return _.extend({}, s, e);
      }).each(function(s) {
        return list.append(buttonTmpl(s));
      });
      if (options._getSocialStrategies().length > 0) {
        this.query(".a0-separator, .a0-iconlist").show();
      } else {
        this.query(".a0-separator, .a0-iconlist").hide();
      }
      this.query(".a0-email input").a0_on("input", bind(this.onemailinput, this));
      this.query(".a0-zocial[data-strategy]", list).a0_on("click", bind(this.onzocialclick, this));
      this.query(".a0-options .a0-cancel").a0_on("click", bind(this.oncancel, this));
      this.query("form").a0_off("submit").a0_on("submit", bind(this.onsubmit, this));
    };
    SignupPanel.prototype.onzocialclick = function(e) {
      stop(e);
      this.widget._signinSocial(e, null, null, this);
    };
    SignupPanel.prototype.onsubmit = function(e) {
      stop(e);
      if (!this.valid()) return;
      this.submit();
    };
    SignupPanel.prototype.oncancel = function(e) {
      stop(e);
      var widget = this.widget;
      widget._showSuccess();
      widget._showError();
      widget._focusError();
      widget._signinPanel();
    };
    SignupPanel.prototype.onemailinput = function(e) {
      var mailField = this.query(".a0-email input");
      if ("username" !== this.options.usernameStyle && this.options.gravatar) {
        this.gravatar(mailField.val());
      }
    };
    SignupPanel.prototype.gravatar = function(email) {
      gravatar(this.widget, email);
      return this;
    };
    SignupPanel.prototype.submit = function() {
      var panel = this;
      var widget = this.widget;
      var options = this.options;
      var connection = options._getAuth0Connection();
      var email_input = this.query("input[name=email]");
      var email = email_input.val();
      var password_input = this.query("input[name=password]");
      var password = password_input.val();
      var callback = widget.options.popupCallback;
      widget._loadingPanel({
        mode: "signup"
      });
      widget.$auth0.signup({
        connection: connection.name,
        username: email,
        password: password,
        auto_login: false,
        popup: panel.options.popup
      }, function(err) {
        var args = slice.call(arguments, 0);
        if (!widget.$container || widget.query()[0] !== widget.$container.childNodes[0]) {
          return console && console.log && console.log("this signup was triggered from another node instance", arguments);
        }
        if (!err && widget.options.loginAfterSignup) return widget._signinWithAuth0(panel);
        if (!err && "function" === typeof callback) return callback.apply(widget, args), 
        widget.hide();
        if (!err) return widget.hide();
        widget.setPanel(panel);
        if (400 !== err.status) {
          widget._showError(widget.options.i18n.t("signup:serverErrorText"));
          return "function" === typeof callback ? callback.apply(widget, args) : null;
        }
        if ("invalid_password" === err.name) {
          widget._focusError(password_input, widget.options.i18n.t("invalid"));
          widget._showError(widget.options.i18n.t("signup:invalidPassword"));
        } else {
          widget._focusError(email_input);
          widget._showError(widget.options.i18n.t("signup:userExistsErrorText"));
        }
        return "function" === typeof callback ? callback.apply(widget, args) : null;
      });
    };
    SignupPanel.prototype.valid = function() {
      var ok = true;
      var email_input = this.query("input[name=email]");
      var email_empty = empty.test(email_input.val());
      var email_parsed = email_parser.exec(email_input.val().toLowerCase());
      var password_input = this.query("input[name=password]");
      var password_empty = empty.test(password_input.val());
      var widget = this.widget;
      widget._showError();
      widget._focusError();
      if (email_empty) {
        widget._focusError(email_input);
        ok = false;
      }
      if (!email_parsed && !email_empty) {
        widget._focusError(email_input, widget.options.i18n.t("invalid"));
        ok = false;
      }
      if (password_empty) {
        widget._focusError(password_input);
        ok = false;
      }
      return ok;
    };
  }, {
    "../bind": 17,
    "../bonzo-augmented": 18,
    "../gravatar": 19,
    "../html/zocial-button.ejs": 23,
    "../object-create": 41,
    "../regex": 43,
    "../stop-event": 44,
    "./signup.ejs": 40,
    events: 75,
    underscore: 78
  } ],
  40: [ function(require, module, exports) {
    module.exports = function anonymous(locals, filters, escape, rethrow) {
      escape = escape || function(html) {
        return String(html).replace(/&(?!#?[a-zA-Z0-9]+;)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;");
      };
      var buf = [];
      with (locals || {}) {
        (function() {
          buf.push('<div class="a0-signup a0-mode">\n    <form novalidate>\n        <div class="a0-header">', escape((3, 
          i18n.t("signup:description"))), '</div>\n        <div class="a0-collapse-social-signup">\n          <div class="a0-iconlist"><p class="a0-hide">', escape((5, 
          i18n.t("signin:or"))), '</p></div>\n          <div class="a0-separator"><span>', escape((6, 
          i18n.t("signin:separatorText"))), '</span></div>\n        </div>\n        <div class="a0-instructions">', escape((8, 
          i18n.t("signup:headerText"))), '</div>\n        <div class="a0-emailPassword">\n            <div class="a0-inputs">\n              <div class="a0-email">\n                  <label for="a0-signup_easy_email" class="a0-sad-placeholder">\n                    ', escape((13, 
          i18n.t("signup:emailPlaceholder"))), '\n                  </label>\n                  <div class="a0-input-box">\n                    <i class="a0-icon-budicon-1"></i>\n                    <input name="email" id="a0-signup_easy_email"\n                         type="email" value=""\n                         placeholder="', escape((19, 
          i18n.t("signup:emailPlaceholder"))), '"\n                         title="', escape((20, 
          i18n.t("signup:emailPlaceholder"))), '">\n                  </div>\n              </div>\n              <div class="a0-password">\n                  <label for="a0-signup_easy_password" class="a0-sad-placeholder">\n                    ', escape((25, 
          i18n.t("signup:passwordPlaceholder"))), '\n                  </label>\n\n                  <div class="a0-input-box">\n                    <i class="a0-icon-budicon"></i>\n                    <input name="password" id="a0-signup_easy_password"\n                           type="password" value=""\n                           placeholder="', escape((32, 
          i18n.t("signup:passwordPlaceholder"))), '"\n                           title="', escape((33, 
          i18n.t("signup:passwordPlaceholder"))), '">\n\n                  </div>\n\n              </div>\n            </div>\n            <div class="a0-action">\n                <button type="submit" class="a0-primary a0-next">', escape((40, 
          i18n.t("signup:action"))), '</button>\n                <div class="a0-options">\n                    <a href="javascript: {}" class="a0-centered a0-btn-small a0-cancel">', escape((42, 
          i18n.t("signup:cancelAction"))), '</a>\n                </div>\n            </div>\n            <div class="a0-signup-footer">\n              <small>\n                ', (47, 
          i18n.t("signup:footerText")), "\n              </small>\n            </div>\n        </div>\n    </form>\n</div>\n");
        })();
      }
      return buf.join("");
    };
  }, {} ],
  41: [ function(require, module, exports) {
    module.exports = Object.create || function() {
      function F() {}
      return function(o) {
        if (arguments.length != 1) {
          throw new Error("Object.create implementation only accepts one parameter.");
        }
        F.prototype = o;
        return new F();
      };
    }();
  }, {} ],
  42: [ function(require, module, exports) {
    var EventEmitter = require("events").EventEmitter;
    var small_screen = require("../is-small-screen");
    var ocreate = require("../object-create");
    var regex = require("../regex");
    var i18n = require("../i18n");
    var bind = require("../bind");
    var _ = require("underscore");
    var okeys = _.keys;
    module.exports = OptionsManager;
    function OptionsManager(widget, options) {
      if (!(this instanceof OptionsManager)) {
        return new OptionsManager(widget, options);
      }
      EventEmitter.call(this);
      this.state("loading");
      this.$widget = widget;
      this.$client = widget.$client;
      this.$strategies = widget.$strategies;
      this.$auth0 = widget.$auth0;
      _.each(okeys(widget.$options), function(key) {
        this["$" + key] = widget.$options[key];
      }, this);
      _.each(okeys(options), function(key) {
        this[key] = options[key];
      }, this);
      this.i18n = i18n.getDict(this.dict);
      this.authParams = _.extend({}, options.authParams);
      this.rememberLastLogin = null != options.rememberLastLogin ? !!options.rememberLastLogin : true;
      this.integratedWindowsLogin = null != options.integratedWindowsLogin ? !!options.integratedWindowsLogin : true;
      this.gravatar = null != options.gravatar ? !!options.gravatar : true;
      if ("function" === typeof options.popupCallback) {
        this.popup = true;
        this.popupOptions = _.extend({}, options.popupOptions);
        this.popupCallback = options.popupCallback;
      }
      if (options.responseType) {
        this.responseType = options.responseType;
      } else {
        this.responseType = this.popup || !options.callbackURL ? "token" : "code";
      }
      this.$auth0._useJSONP = options.forceJSONP || this.$auth0._useJSONP;
      this.$auth0._callbackURL = options.callbackURL || this.$auth0._callbackURL;
      this.$auth0._callbackOnLocationHash = "token" === this.responseType || !!this.$auth0._callbackOnLocationHash;
      this.closable = null != options.closable ? !!options.closable : !this.container;
      this.loginAfterSignup = null != options.loginAfterSignup ? !!options.loginAfterSignup : true;
      this.defaultADUsernameFromEmailPrefix = null != options.defaultADUsernameFromEmailPrefix ? !!options.defaultADUsernameFromEmailPrefix : true;
      this.sso = null != this.sso ? !!this.sso : true;
      this.$widget.getClientConfiguration(bind(this._onclientloaded, this));
    }
    OptionsManager.prototype = ocreate(EventEmitter.prototype);
    OptionsManager.prototype.state = function(state, message) {
      if (0 === arguments.length) {
        return this.$_state;
      }
      this.$_state = state;
      this.emit(state, message);
      return this;
    };
    OptionsManager.prototype.ready = function(fn) {
      function done() {
        if ("loaded" === this.state()) {
          return fn();
        }
      }
      if ("loaded" === this.state()) {
        setTimeout(bind(done, this), 0);
      } else {
        this.once("loaded", bind(done, this));
      }
      return this;
    };
    OptionsManager.prototype._onclientloaded = function(client) {
      this.$client = _.extend(this.$client, client);
      if (this.connections) {
        this.$client.strategies = _.chain(this.$client.strategies).map(strategiesConnectionsMapper(this.connections)).filter(hasConnectionsFilter).value();
      }
      for (var i = 0; i < this.$client.strategies.length; i++) {
        var sname = this.$client.strategies[i].name;
        this.$client.strategies[i] = _.extend({}, this.$client.strategies[i], this.$strategies[sname]);
      }
      this.auth0Strategies = _.chain(this.$client.strategies).filter(auth0StrategiesFilter).value();
      var auth0Conn = this._getAuth0Connection() || {};
      if (this.mode === "signup" && !auth0Conn.showSignup) {
        this.mode = "signin";
      }
      if (this.mode === "reset" && !auth0Conn.showForgot) {
        this.mode = "signin";
      }
      this.showSignupAction = this.disableSignupAction !== true && (auth0Conn && auth0Conn.showSignup || this.signupLink);
      this.showResetAction = this.disableResetAction !== true && (auth0Conn && auth0Conn.showForgot || this.resetLink);
      var auth0ConnStrategy = this._getClientStrategyByConnectionName(auth0Conn.name) || {};
      if (!this.usernameStyle && (auth0ConnStrategy.name === "ad" || auth0ConnStrategy.name === "auth0-adldap")) {
        this.usernameStyle = "username";
      }
      this.state("loaded");
      return this;
    };
    OptionsManager.prototype._isThereAnySocialConnection = function() {
      var client = this.$client;
      var filter = {
        social: true
      };
      return !!_.findWhere(client.strategies, filter);
    };
    OptionsManager.prototype._isThereAnyEnterpriseOrDbConnection = function() {
      var client = this.$client;
      var filter = {
        social: false
      };
      return !!_.findWhere(client.strategies, filter);
    };
    OptionsManager.prototype._isThereAnyDBConnection = function() {
      var client = this.$client;
      var filter = {
        userAndPass: true
      };
      return !!_.findWhere(client.strategies, filter);
    };
    OptionsManager.prototype._isThereAnyADConnection = function() {
      return _.some(this.$client.strategies, function(s) {
        return (s.name === "ad" || s.name === "auth0-adldap") && s.connections.length > 0;
      });
    };
    OptionsManager.prototype._extractEmailDomain = function(email) {
      var parser = regex.email_parser;
      var emailM = parser.exec(email.toLowerCase());
      return emailM ? emailM.slice(-2)[0] : null;
    };
    OptionsManager.prototype._findConnectionByADDomain = function(domain, strategies) {
      return this._filterConnections(domain, strategies, {
        userAndPass: true
      });
    };
    OptionsManager.prototype._findConnectionByDomain = function(domain, strategies) {
      return this._filterConnections(domain, strategies, {
        userAndPass: undefined
      });
    };
    OptionsManager.prototype._filterConnections = function(domain, strategies, criteria) {
      strategies = strategies || this.$client.strategies;
      var conn_obj = _.chain(strategies).where(criteria).pluck("connections").flatten().map(function(e) {
        var l = [];
        if (e.domain) {
          l.push(e.domain);
        }
        l = l.concat(e.domain_aliases || []);
        e.domains = l;
        return e;
      }).find(function(e) {
        return e.domains.indexOf(domain) !== -1;
      }).value();
      return conn_obj;
    };
    OptionsManager.prototype._isEnterpriseConnection = function(email, output) {
      var client = this.$client;
      var domain = this._extractEmailDomain(email);
      var conn = this._filterConnections(domain, client.strategies, {
        userAndPass: undefined
      });
      if (conn && output) {
        output.domain = conn.domain;
      }
      return !!conn;
    };
    OptionsManager.prototype._isFreeSubscription = function() {
      return this.$client.subscription && !~[ "free", "dev" ].indexOf(this.$client.subscription);
    };
    OptionsManager.prototype._getAuth0Connection = function(username) {
      if (null != this.defaultUserPasswordConnection) {
        return _.chain(this.auth0Strategies).pluck("connections").flatten().findWhere({
          name: this.defaultUserPasswordConnection
        }).value();
      }
      var domain = username && ~username.indexOf("@") ? username.split("@")[1] : "";
      if (username && domain && this.$client.strategies) {
        var conn = _.chain(this.$client.strategies).pluck("connections").flatten().findWhere({
          domain: domain
        }).value();
        if (conn) {
          return conn;
        }
      }
      var defaultStrategy = _.findWhere(this.auth0Strategies, {
        name: "auth0"
      });
      defaultStrategy = defaultStrategy || (this.auth0Strategies.length > 0 ? this.auth0Strategies[0] : null);
      return defaultStrategy && defaultStrategy.connections.length > 0 ? defaultStrategy.connections[0] : null;
    };
    OptionsManager.prototype._getLoggedInAuthParams = function(strategy, ssoData) {
      switch (strategy) {
       case "google-oauth2":
        return {
          login_hint: ssoData.lastUsedUsername
        };

       default:
        return {};
      }
    };
    OptionsManager.prototype._getClientStrategyByConnectionName = function(connName) {
      return _.chain(this.$client.strategies).filter(function(s) {
        return _.findWhere(s.connections, {
          name: connName
        });
      }).value()[0];
    };
    OptionsManager.prototype._getClientStrategyByName = function(name) {
      return _.findWhere(this.$client.strategies, {
        name: name
      });
    };
    OptionsManager.prototype._useBigSocialButtons = function() {
      return null != this.socialBigButtons ? !!this.socialBigButtons : !this._isThereAnyEnterpriseOrDbConnection();
    };
    OptionsManager.prototype._getSocialStrategies = function() {
      return _.where(this.$client.strategies, {
        social: true
      });
    };
    OptionsManager.prototype._focusDisabled = function() {
      return null != this.focusInput ? !this.focusInput : small_screen() || !!this.container;
    };
    OptionsManager.prototype._shouldShowLastLogin = function() {
      var $ssoData = this.$widget.$ssoData;
      var connectionStrategy = $ssoData && $ssoData.lastUsedConnection && $ssoData.lastUsedConnection.strategy;
      var isADOrAuth0 = connectionStrategy === "auth0" || connectionStrategy === "ad";
      if (window.cordova && isADOrAuth0) {
        return false;
      }
      var shouldShow = $ssoData && $ssoData.sso && $ssoData.lastUsedConnection && this._isEnabledConnection($ssoData.lastUsedConnection.name) && !!this.rememberLastLogin;
      return shouldShow;
    };
    OptionsManager.prototype._isEnabledConnection = function(connectionName) {
      var strategy = this._getClientStrategyByConnectionName(connectionName);
      return strategy != null ? true : false;
    };
    function auth0StrategiesFilter(strategy) {
      return strategy.userAndPass && strategy.connections.length > 0;
    }
    function hasConnectionsFilter(strategy) {
      return strategy.connections.length > 0;
    }
    function strategiesConnectionsMapper(connections) {
      return function(strategy) {
        var cloned = _.extend({}, strategy);
        cloned.connections = _.filter(cloned.connections, function(connection) {
          return _.contains(connections, connection.name);
        });
        return cloned;
      };
    }
  }, {
    "../bind": 17,
    "../i18n": 24,
    "../is-small-screen": 26,
    "../object-create": 41,
    "../regex": 43,
    events: 75,
    underscore: 78
  } ],
  43: [ function(require, module, exports) {
    var r = module.exports;
    r.email_parser = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    r.empty = /^\s*$/;
  }, {} ],
  44: [ function(require, module, exports) {
    module.exports = stop;
    function stop(e) {
      e.preventDefault();
      e.stopPropagation();
      return e;
    }
  }, {} ],
  45: [ function(require, module, exports) {
    module.exports = {
      "google-openid": {
        css: "google",
        title: "Google OpenId",
        social: true
      },
      "google-apps": {
        css: "google",
        title: "Google Apps",
        social: false
      },
      "google-oauth2": {
        css: "googleplus",
        title: "Google",
        social: true
      },
      facebook: {
        css: "facebook",
        title: "Facebook",
        social: true
      },
      windowslive: {
        css: "windows",
        title: "Microsoft Account",
        social: true
      },
      linkedin: {
        css: "linkedin",
        title: "LinkedIn",
        social: true
      },
      github: {
        css: "github",
        title: "GitHub",
        social: true
      },
      paypal: {
        css: "paypal",
        title: "PayPal",
        social: true
      },
      twitter: {
        css: "twitter",
        title: "Twitter",
        social: true
      },
      amazon: {
        css: "amazon",
        title: "Amazon",
        social: true
      },
      vkontakte: {
        css: "vk",
        title: "vKontakte",
        social: true
      },
      yandex: {
        css: "yandex",
        title: "Yandex",
        social: true
      },
      office365: {
        css: "office365",
        title: "Office365",
        social: false
      },
      waad: {
        css: "waad",
        title: "Windows Azure AD",
        social: false
      },
      adfs: {
        css: "windows",
        title: "ADFS",
        social: false
      },
      samlp: {
        css: "guest",
        title: "SAML",
        social: false
      },
      pingfederate: {
        css: "guest",
        title: "Ping Federate",
        social: false
      },
      ip: {
        css: "guest",
        title: "IP Address",
        social: false
      },
      mscrm: {
        css: "guest",
        title: "Dynamics CRM",
        social: false
      },
      ad: {
        css: "windows",
        title: "AD / LDAP",
        social: false,
        userAndPass: true
      },
      custom: {
        css: "guest",
        title: "Custom Auth",
        social: false
      },
      auth0: {
        css: "guest",
        title: "Auth0",
        social: false,
        userAndPass: true
      },
      "auth0-adldap": {
        css: "guest",
        title: "AD/LDAP",
        social: false,
        userAndPass: true
      },
      thirtysevensignals: {
        css: "thirtysevensignals",
        title: "37 Signals",
        social: true
      },
      box: {
        css: "box",
        title: "Box",
        social: true,
        imageicon: true
      },
      salesforce: {
        css: "salesforce",
        title: "Salesforce",
        social: true
      },
      "salesforce-sandbox": {
        css: "salesforce",
        title: "Salesforce (sandbox)",
        social: true
      },
      fitbit: {
        css: "fitbit",
        title: "Fitbit",
        social: true
      },
      baidu: {
        css: "baidu",
        title: "百度",
        social: true
      },
      renren: {
        css: "renren",
        title: "人人",
        social: true
      },
      yahoo: {
        css: "yahoo",
        title: "Yahoo!",
        social: true
      },
      aol: {
        css: "aol",
        title: "Aol",
        social: true
      },
      yammer: {
        css: "yammer",
        title: "Yammer",
        social: true
      },
      wordpress: {
        css: "wordpress",
        title: "Wordpress",
        social: true
      },
      dwolla: {
        css: "dwolla",
        title: "Dwolla",
        social: true
      },
      shopify: {
        css: "shopify",
        title: "Shopify",
        social: true
      },
      miicard: {
        css: "miicard",
        title: "miiCard",
        social: true
      },
      soundcloud: {
        css: "soundcloud",
        title: "Soundcloud",
        social: true
      },
      ebay: {
        css: "ebay",
        title: "ebay",
        social: true
      },
      evernote: {
        css: "evernote",
        title: "Evernote",
        social: true
      },
      "evernote-sandbox": {
        css: "evernote",
        title: "Evernote (sandbox)",
        social: true
      },
      sharepoint: {
        css: "sharepoint",
        title: "SharePoint Apps",
        social: false
      },
      weibo: {
        css: "weibo",
        title: "新浪微博",
        social: true
      },
      instagram: {
        css: "instagram",
        title: "Instagram",
        social: true
      },
      thecity: {
        css: "thecity",
        title: "The City",
        social: true
      },
      "thecity-sandbox": {
        css: "thecity",
        title: "The City (sandbox)",
        social: true
      },
      planningcenter: {
        css: "planningcenter",
        title: "Planning Center",
        social: true
      }
    };
  }, {} ],
  46: [ function(require, module, exports) {
    var _ = require("underscore");
    var prefixes = [ "Webkit", "Moz", "O", "ms", "Khtml", "" ];
    var animationEndNames = {
      Animation: "animationend",
      OAnimation: "oAnimationEnd",
      MozAnimation: "animationend",
      WebkitAnimation: "webkitAnimationEnd"
    };
    module.exports = function() {
      return _.chain(prefixes).map(function(prefix) {
        return prefix + "Animation";
      }).filter(function(s) {
        return typeof document.body.style[s] !== "undefined";
      }).map(function(supportedAnimation) {
        return animationEndNames[supportedAnimation];
      }).first().value();
    };
  }, {
    underscore: 78
  } ],
  47: [ function(require, module, exports) {
    function placeholderIsSupported() {
      var test = document.createElement("input");
      return "placeholder" in test;
    }
    module.exports = placeholderIsSupported();
  }, {} ],
  48: [ function(require, module, exports) {
    var _ = require("underscore");
    module.exports = {
      parseUrl: function(url) {
        var parser = document.createElement("a");
        parser.href = url;
        return parser;
      },
      endsWith: function(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
      },
      extract: function(obj, props) {
        var pre = _.pick(obj, props);
        return _.chain(_.pairs(pre)).filter(function(pair) {
          return typeof pair[1] !== "undefined";
        }).reduce(function(r, current) {
          r[current[0]] = current[1];
          return r;
        }, {}).value();
      }
    };
  }, {
    underscore: 78
  } ],
  49: [ function(require, module, exports) {
    var json_parse = require("./json-parse");
    module.exports = LoginError;
    function LoginError(status, details) {
      var obj;
      if (typeof details == "string") {
        try {
          obj = json_parse(details);
        } catch (er) {
          obj = {
            message: details
          };
        }
      } else {
        obj = details || {
          description: "server error"
        };
      }
      if (obj && !obj.code) {
        obj.code = obj.error;
      }
      var err = Error.call(this, obj.description || obj.message || obj.error);
      err.status = status;
      err.name = obj.code;
      err.code = obj.code;
      err.details = obj;
      if (status === 0) {
        err.code = "Unknown";
        err.message = "Unknown error.";
      }
      return err;
    }
    if (Object && Object.create) {
      LoginError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: LoginError
        }
      });
    }
  }, {
    "./json-parse": 54
  } ],
  50: [ function(require, module, exports) {
    module.exports = required;
    function required(obj, prop) {
      if (!obj[prop]) {
        throw new Error(prop + " is required.");
      }
    }
  }, {} ],
  51: [ function(require, module, exports) {
    var Base64 = require("Base64");
    module.exports = base64_url_decode;
    function base64_url_decode(str) {
      var output = str.replace("-", "+").replace("_", "/");
      switch (output.length % 4) {
       case 0:
        break;

       case 2:
        output += "==";
        break;

       case 3:
        output += "=";
        break;

       default:
        throw "Illegal base64url string!";
      }
      return decodeURIComponent(escape(Base64.atob(output)));
    }
  }, {
    Base64: 56
  } ],
  52: [ function(require, module, exports) {
    (function(global) {
      var assert_required = require("./assert_required");
      var base64_url_decode = require("./base64_url_decode");
      var is_array = require("./is-array");
      var qs = require("qs");
      var xtend = require("xtend");
      var trim = require("trim");
      var reqwest = require("reqwest");
      var WinChan = require("winchan");
      var jsonp = require("jsonp");
      var jsonpOpts = {
        param: "cbx",
        timeout: 8e3,
        prefix: "__auth0jp"
      };
      var use_jsonp = require("./use_jsonp");
      var LoginError = require("./LoginError");
      var json_parse = require("./json-parse");
      function Auth0(options) {
        if (!(this instanceof Auth0)) {
          return new Auth0(options);
        }
        assert_required(options, "clientID");
        assert_required(options, "domain");
        this._useJSONP = options.forceJSONP || use_jsonp();
        this._clientID = options.clientID;
        this._callbackURL = options.callbackURL || document.location.href;
        this._domain = options.domain;
        this._callbackOnLocationHash = false || options.callbackOnLocationHash;
      }
      Auth0.version = "5.0.1";
      Auth0.prototype._redirect = function(url) {
        global.window.location = url;
      };
      Auth0.prototype._renderAndSubmitWSFedForm = function(options, formHtml) {
        var div = document.createElement("div");
        div.innerHTML = formHtml;
        var form = document.body.appendChild(div).children[0];
        if (options.popup && !this._callbackOnLocationHash) {
          form.target = "auth0_signup_popup";
        }
        form.submit();
      };
      Auth0.prototype._getMode = function() {
        return {
          scope: "openid",
          response_type: this._callbackOnLocationHash ? "token" : "code"
        };
      };
      Auth0.prototype._configureOfflineMode = function(options) {
        if (options.scope && options.scope.indexOf("offline_access") >= 0) {
          options.device = options.device || "Browser";
        }
      };
      Auth0.prototype._getUserInfo = function(profile, id_token, callback) {
        if (profile && !profile.user_id) {
          var self = this;
          var url = "https://" + self._domain + "/tokeninfo?";
          function fail(status, description) {
            var error = new Error(status + ": " + (description || ""));
            error.error = status;
            error.error_description = description;
            callback(error);
          }
          if (this._useJSONP) {
            return jsonp(url + qs.stringify({
              id_token: id_token
            }), jsonpOpts, function(err, resp) {
              if (err) {
                return fail(0, err.toString());
              }
              return resp.status === 200 ? callback(null, resp.user) : fail(resp.status, resp.error);
            });
          }
          return reqwest({
            url: url,
            method: "post",
            type: "json",
            crossOrigin: true,
            data: {
              id_token: id_token
            }
          }).fail(function(err) {
            fail(err.status, err.responseText);
          }).then(function(userinfo) {
            callback(null, userinfo);
          });
        }
        callback(null, profile);
      };
      Auth0.prototype.getProfile = function(id_token, callback) {
        if (!id_token || typeof id_token !== "string") {
          return callback(new Error("Invalid token"));
        }
        this._getUserInfo(this.decodeJwt(id_token), id_token, callback);
      };
      Auth0.prototype.validateUser = function(options, callback) {
        var endpoint = "https://" + this._domain + "/public/api/users/validate_userpassword";
        var query = xtend(options, {
          client_id: this._clientID,
          username: trim(options.username || options.email || "")
        });
        if (this._useJSONP) {
          return jsonp(endpoint + "?" + qs.stringify(query), jsonpOpts, function(err, resp) {
            if (err) {
              return callback(err);
            }
            if ("error" in resp && resp.status !== 404) {
              return callback(new Error(resp.error));
            }
            callback(null, resp.status === 200);
          });
        }
        reqwest({
          url: endpoint,
          method: "post",
          type: "text",
          data: query,
          crossOrigin: true,
          error: function(err) {
            if (err.status !== 404) {
              return callback(new Error(err.responseText));
            }
            callback(null, false);
          },
          success: function(resp) {
            callback(null, resp.status === 200);
          }
        });
      };
      Auth0.prototype.decodeJwt = function(jwt) {
        var encoded = jwt && jwt.split(".")[1];
        return json_parse(base64_url_decode(encoded));
      };
      Auth0.prototype.parseHash = function(hash) {
        hash = hash || window.location.hash;
        if (hash.match(/error/)) {
          hash = hash.substr(1).replace(/^\//, "");
          var parsed_qs = qs.parse(hash);
          var err = {
            error: parsed_qs.error,
            error_description: parsed_qs.error_description
          };
          return err;
        }
        if (!hash.match(/access_token/)) {
          return null;
        }
        hash = hash.substr(1).replace(/^\//, "");
        var parsed_qs = qs.parse(hash);
        var id_token = parsed_qs.id_token;
        var refresh_token = parsed_qs.refresh_token;
        var prof = this.decodeJwt(id_token);
        var invalidJwt = function(error) {
          var err = {
            error: "invalid_token",
            error_description: error
          };
          return err;
        };
        if (prof.aud !== this._clientID) {
          return invalidJwt("The clientID configured (" + this._clientID + ") does not match with the clientID set in the token (" + prof.aud + ").");
        }
        if (prof.iss && prof.iss !== "https://" + this._domain + "/") {
          return invalidJwt("The domain configured (https://" + this._domain + "/) does not match with the domain set in the token (" + prof.iss + ").");
        }
        return {
          profile: prof,
          id_token: id_token,
          access_token: parsed_qs.access_token,
          state: parsed_qs.state,
          refresh_token: refresh_token
        };
      };
      Auth0.prototype.signup = function(options, callback) {
        var self = this;
        var query = xtend(this._getMode(), options, {
          client_id: this._clientID,
          redirect_uri: this._callbackURL,
          email: trim(options.username || options.email || ""),
          tenant: this._domain.split(".")[0]
        });
        this._configureOfflineMode(query);
        var popup;
        if (options.popup && !this._callbackOnLocationHash) {
          popup = this._buildPopupWindow(options);
        }
        function success() {
          if ("auto_login" in options && !options.auto_login) {
            if (callback) {
              callback();
            }
            return;
          }
          self.login(options, callback);
        }
        function fail(status, resp) {
          var error = new LoginError(status, resp);
          if (popup) {
            popup.kill();
          }
          if (callback) {
            return callback(error);
          }
          throw error;
        }
        if (this._useJSONP) {
          return jsonp("https://" + this._domain + "/dbconnections/signup?" + qs.stringify(query), jsonpOpts, function(err, resp) {
            if (err) {
              return fail(0, err);
            }
            return resp.status == 200 ? success() : fail(resp.status, resp.err);
          });
        }
        reqwest({
          url: "https://" + this._domain + "/dbconnections/signup",
          method: "post",
          type: "html",
          data: query,
          success: success,
          crossOrigin: true,
          error: function(err) {
            fail(err.status, err.responseText);
          }
        });
      };
      Auth0.prototype.changePassword = function(options, callback) {
        var self = this;
        var query = {
          tenant: this._domain.split(".")[0],
          client_id: this._clientID,
          connection: options.connection,
          email: trim(options.username || options.email || ""),
          password: options.password
        };
        function fail(status, resp) {
          var error = new LoginError(status, resp);
          if (callback) return callback(error);
        }
        if (this._useJSONP) {
          return jsonp("https://" + this._domain + "/dbconnections/change_password?" + qs.stringify(query), jsonpOpts, function(err, resp) {
            if (err) {
              return fail(0, err);
            }
            return resp.status == 200 ? callback(null, resp.message) : fail(resp.status, resp.err);
          });
        }
        reqwest({
          url: "https://" + this._domain + "/dbconnections/change_password",
          method: "post",
          type: "html",
          data: query,
          crossOrigin: true,
          error: function(err) {
            fail(err.status, err.responseText);
          },
          success: function(r) {
            callback(null, r);
          }
        });
      };
      Auth0.prototype._buildAuthorizeQueryString = function(args, blacklist) {
        var query = xtend.apply(null, args);
        this._configureOfflineMode(query);
        blacklist = blacklist || [ "popup", "popupOptions" ];
        var i, key;
        for (i = 0; i < blacklist.length; i++) {
          key = blacklist[i];
          delete query[key];
        }
        if (query.connection_scope && is_array(query.connection_scope)) {
          query.connection_scope = query.connection_scope.join(",");
        }
        return qs.stringify(query);
      };
      Auth0.prototype.login = Auth0.prototype.signin = function(options, callback) {
        if (typeof options.username !== "undefined" || typeof options.email !== "undefined") {
          return this.loginWithUsernamePassword(options, callback);
        }
        if (!!window.cordova) {
          return this.loginPhonegap(options, callback);
        }
        if (!!options.popup && this._callbackOnLocationHash) {
          return this.loginWithPopup(options, callback);
        }
        var query = this._buildAuthorizeQueryString([ this._getMode(), options, {
          client_id: this._clientID,
          redirect_uri: this._callbackURL
        } ]);
        var url = "https://" + this._domain + "/authorize?" + query;
        if (options.popup) {
          this._buildPopupWindow(options, url);
        } else {
          this._redirect(url);
        }
      };
      Auth0.prototype._computePopupPosition = function(options) {
        var width = options.width;
        var height = options.height;
        var screenX = typeof window.screenX !== "undefined" ? window.screenX : window.screenLeft;
        var screenY = typeof window.screenY !== "undefined" ? window.screenY : window.screenTop;
        var outerWidth = typeof window.outerWidth !== "undefined" ? window.outerWidth : document.body.clientWidth;
        var outerHeight = typeof window.outerHeight !== "undefined" ? window.outerHeight : document.body.clientHeight - 22;
        var left = screenX + (outerWidth - width) / 2;
        var top = screenY + (outerHeight - height) / 2;
        return {
          width: width,
          height: height,
          left: left,
          top: top
        };
      };
      Auth0.prototype.loginPhonegap = function(options, callback) {
        var mobileCallbackURL = "https://" + this._domain + "/mobile";
        var self = this;
        var query = this._buildAuthorizeQueryString([ this._getMode(), options, {
          client_id: this._clientID,
          redirect_uri: mobileCallbackURL
        } ]);
        var popupUrl = "https://" + this._domain + "/authorize?" + query;
        var popupOptions = xtend({
          location: "yes"
        }, options.popupOptions);
        delete popupOptions.width;
        delete popupOptions.height;
        var ref = window.open(popupUrl, "_blank", stringifyPopupSettings(popupOptions));
        var answered = false;
        function errorHandler(event) {
          if (answered) {
            return;
          }
          callback(new Error(event.message), null, null, null, null);
          answered = true;
          return ref.close();
        }
        function startHandler(event) {
          if (answered) {
            return;
          }
          if (event.url && !(event.url.indexOf(mobileCallbackURL + "#") === 0 || event.url.indexOf(mobileCallbackURL + "?") === 0)) {
            return;
          }
          var result = self.parseHash(event.url.slice(mobileCallbackURL.length));
          if (!result) {
            callback(new Error("Error parsing hash"), null, null, null, null);
            answered = true;
            return ref.close();
          }
          if (result.id_token) {
            self.getProfile(result.id_token, function(err, profile) {
              callback(err, profile, result.id_token, result.access_token, result.state, result.refresh_token);
            });
            answered = true;
            return ref.close();
          }
          callback(new Error(result.err || result.error || "Something went wrong"), null, null, null, null);
          answered = true;
          return ref.close();
        }
        function exitHandler() {
          if (answered) {
            return;
          }
          callback(new Error("Browser window closed"), null, null, null, null);
          ref.removeEventListener("loaderror", errorHandler);
          ref.removeEventListener("loadstart", startHandler);
          ref.removeEventListener("exit", exitHandler);
        }
        ref.addEventListener("loaderror", errorHandler);
        ref.addEventListener("loadstart", startHandler);
        ref.addEventListener("exit", exitHandler);
      };
      Auth0.prototype.loginWithPopup = function(options, callback) {
        var self = this;
        if (!callback) {
          throw new Error("popup mode should receive a mandatory callback");
        }
        var query = this._buildAuthorizeQueryString([ this._getMode(), options, {
          client_id: this._clientID,
          owp: true
        } ]);
        var popupUrl = "https://" + this._domain + "/authorize?" + query;
        var popupOptions = xtend(self._computePopupPosition({
          width: options.popupOptions && options.popupOptions.width || 500,
          height: options.popupOptions && options.popupOptions.height || 600
        }), options.popupOptions);
        var popup = WinChan.open({
          url: popupUrl,
          relay_url: "https://" + this._domain + "/relay.html",
          window_features: stringifyPopupSettings(popupOptions)
        }, function(err, result) {
          if (err) {
            return callback(new Error(err), null, null, null, null, null);
          }
          if (result && result.id_token) {
            return self.getProfile(result.id_token, function(err, profile) {
              callback(err, profile, result.id_token, result.access_token, result.state, result.refresh_token);
            });
          }
          return callback(new Error(result ? result.err : "Something went wrong"), null, null, null, null, null);
        });
        popup.focus();
      };
      function stringifyPopupSettings(popupOptions) {
        var settings = "";
        for (var key in popupOptions) {
          settings += key + "=" + popupOptions[key] + ",";
        }
        return settings.slice(0, -1);
      }
      Auth0.prototype.loginWithResourceOwner = function(options, callback) {
        var self = this;
        var query = xtend(this._getMode(), options, {
          client_id: this._clientID,
          username: trim(options.username || options.email || ""),
          grant_type: "password"
        });
        this._configureOfflineMode(query);
        var endpoint = "/oauth/ro";
        function enrichGetProfile(resp, callback) {
          self.getProfile(resp.id_token, function(err, profile) {
            callback(err, profile, resp.id_token, resp.access_token, resp.state, resp.refresh_token);
          });
        }
        if (this._useJSONP) {
          return jsonp("https://" + this._domain + endpoint + "?" + qs.stringify(query), jsonpOpts, function(err, resp) {
            if (err) {
              return callback(err);
            }
            if ("error" in resp) {
              var error = new LoginError(resp.status, resp.error);
              return callback(error);
            }
            enrichGetProfile(resp, callback);
          });
        }
        reqwest({
          url: "https://" + this._domain + endpoint,
          method: "post",
          type: "json",
          data: query,
          crossOrigin: true,
          success: function(resp) {
            enrichGetProfile(resp, callback);
          },
          error: function(err) {
            var er = err;
            if (!er.status || er.status === 0) {
              er = {};
              er.status = 401;
              er.responseText = {
                code: "invalid_user_password"
              };
            } else {
              er.responseText = err;
            }
            var error = new LoginError(er.status, er.responseText);
            callback(error);
          }
        });
      };
      Auth0.prototype._buildPopupWindow = function(options, url) {
        if (this._current_popup) {
          return this._current_popup;
        }
        var popupOptions = stringifyPopupSettings(xtend({
          width: 500,
          height: 600
        }, options.popupOptions || {}));
        this._current_popup = window.open(url || "about:blank", "auth0_signup_popup", popupOptions);
        var self = this;
        this._current_popup.kill = function() {
          this.close();
          delete self._current_popup;
        };
        return this._current_popup;
      };
      Auth0.prototype.loginWithUsernamePassword = function(options, callback) {
        if (callback && callback.length > 1) {
          return this.loginWithResourceOwner(options, callback);
        }
        var self = this;
        var popup;
        if (options.popup && !this._callbackOnLocationHash) {
          popup = this._buildPopupWindow(options);
        }
        var query = xtend(this._getMode(), options, {
          client_id: this._clientID,
          redirect_uri: this._callbackURL,
          username: trim(options.username || options.email || ""),
          tenant: this._domain.split(".")[0]
        });
        this._configureOfflineMode(query);
        var endpoint = "/usernamepassword/login";
        if (this._useJSONP) {
          return jsonp("https://" + this._domain + endpoint + "?" + qs.stringify(query), jsonpOpts, function(err, resp) {
            if (err) {
              if (popup) {
                popup.kill();
              }
              return callback(err);
            }
            if ("error" in resp) {
              if (popup) {
                popup.kill();
              }
              var error = new LoginError(resp.status, resp.error);
              return callback(error);
            }
            self._renderAndSubmitWSFedForm(options, resp.form);
          });
        }
        function return_error(error) {
          if (callback) {
            return callback(error);
          }
          throw error;
        }
        reqwest({
          url: "https://" + this._domain + endpoint,
          method: "post",
          type: "html",
          data: query,
          crossOrigin: true,
          success: function(resp) {
            self._renderAndSubmitWSFedForm(options, resp);
          },
          error: function(err) {
            var er = err;
            if (popup) {
              popup.kill();
            }
            if (!er.status || er.status === 0) {
              er = {};
              er.status = 401;
              er.responseText = {
                code: "invalid_user_password"
              };
            }
            var error = new LoginError(er.status, er.responseText);
            return return_error(error);
          }
        });
      };
      Auth0.prototype.renewIdToken = function(id_token, callback) {
        this.getDelegationToken({
          id_token: id_token,
          scope: "passthrough",
          api: "auth0"
        }, callback);
      };
      Auth0.prototype.refreshToken = function(refresh_token, callback) {
        this.getDelegationToken({
          refresh_token: refresh_token,
          api: "auth0"
        }, callback);
      };
      Auth0.prototype.getDelegationToken = function(options, callback) {
        options = options || {};
        if (!options.id_token && !options.refresh_token) {
          throw new Error("You must send either an id_token or a refresh_token to get a delegation token.");
        }
        var query = xtend({
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          client_id: this._clientID,
          target: options.targetClientId || this._clientID,
          api_type: options.api
        }, options);
        delete query.hasOwnProperty;
        delete query.targetClientId;
        delete query.api;
        var endpoint = "/delegation";
        if (this._useJSONP) {
          return jsonp("https://" + this._domain + endpoint + "?" + qs.stringify(query), jsonpOpts, function(err, resp) {
            if (err) {
              return callback(err);
            }
            if ("error" in resp) {
              var error = new LoginError(resp.status, resp.error_description || resp.error);
              return callback(error);
            }
            callback(null, resp);
          });
        }
        reqwest({
          url: "https://" + this._domain + endpoint,
          method: "post",
          type: "json",
          data: query,
          crossOrigin: true,
          success: function(resp) {
            callback(null, resp);
          },
          error: function(err) {
            try {
              callback(JSON.parse(err.responseText));
            } catch (e) {
              var er = err;
              if (!er.status || er.status === 0) {
                er = {};
                er.status = 401;
                er.responseText = {
                  code: "invalid_operation"
                };
              }
              callback(new LoginError(er.status, er.responseText));
            }
          }
        });
      };
      Auth0.prototype.logout = function(query) {
        var url = "https://" + this._domain + "/logout";
        if (query) {
          url += "?" + qs.stringify(query);
        }
        this._redirect(url);
      };
      Auth0.prototype.getSSOData = function(withActiveDirectories, callback) {
        if (typeof withActiveDirectories === "function") {
          callback = withActiveDirectories;
          withActiveDirectories = false;
        }
        var url = "https://" + this._domain + "/user/ssodata";
        if (withActiveDirectories) {
          url += "?" + qs.stringify({
            ldaps: 1,
            client_id: this._clientID
          });
        }
        var jsonpOptions = xtend({}, jsonpOpts, {
          timeout: 3e3
        });
        return jsonp(url, jsonpOptions, function(err, resp) {
          callback(null, err ? {
            sso: false
          } : resp);
        });
      };
      Auth0.prototype.getConnections = function(callback) {
        return jsonp("https://" + this._domain + "/public/api/" + this._clientID + "/connections", jsonpOpts, callback);
      };
      module.exports = Auth0;
    }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {
    "./LoginError": 49,
    "./assert_required": 50,
    "./base64_url_decode": 51,
    "./is-array": 53,
    "./json-parse": 54,
    "./use_jsonp": 55,
    jsonp: 61,
    qs: 62,
    reqwest: 63,
    trim: 77,
    winchan: 64,
    xtend: 66
  } ],
  53: [ function(require, module, exports) {
    var toString = Object.prototype.toString;
    module.exports = null != Array.isArray ? Array.isArray : isArray;
    function isArray(array) {
      return toString.call(array) === "[object Array]";
    }
  }, {} ],
  54: [ function(require, module, exports) {
    module.exports = "undefined" === typeof window.JSON ? require("json-fallback").parse : window.JSON.parse;
  }, {
    "json-fallback": 60
  } ],
  55: [ function(require, module, exports) {
    module.exports = use_jsonp;
    function use_jsonp() {
      var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : null;
      if (xhr && "withCredentials" in xhr) {
        return false;
      }
      return true;
    }
  }, {} ],
  56: [ function(require, module, exports) {
    (function() {
      var object = typeof exports != "undefined" ? exports : this, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", INVALID_CHARACTER_ERR = function() {
        try {
          document.createElement("$");
        } catch (error) {
          return error;
        }
      }();
      object.btoa || (object.btoa = function(input) {
        for (var block, charCode, idx = 0, map = chars, output = ""; input.charAt(idx | 0) || (map = "=", 
        idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
          charCode = input.charCodeAt(idx += 3 / 4);
          if (charCode > 255) throw INVALID_CHARACTER_ERR;
          block = block << 8 | charCode;
        }
        return output;
      });
      object.atob || (object.atob = function(input) {
        input = input.replace(/=+$/, "");
        if (input.length % 4 == 1) throw INVALID_CHARACTER_ERR;
        for (var bc = 0, bs, buffer, idx = 0, output = ""; buffer = input.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, 
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
          buffer = chars.indexOf(buffer);
        }
        return output;
      });
    })();
  }, {} ],
  57: [ function(require, module, exports) {
    exports = module.exports = require("./debug");
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [ "lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson" ];
    function useColors() {
      return "WebkitAppearance" in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
    }
    exports.formatters.j = function(v) {
      return JSON.stringify(v);
    };
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors) return args;
      var c = "color: " + this.color;
      args = [ args[0], c, "color: inherit" ].concat(Array.prototype.slice.call(args, 1));
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-z%]/g, function(match) {
        if ("%%" === match) return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
      return args;
    }
    function log() {
      return "object" == typeof console && "function" == typeof console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          localStorage.removeItem("debug");
        } else {
          localStorage.debug = namespaces;
        }
      } catch (e) {}
    }
    function load() {
      var r;
      try {
        r = localStorage.debug;
      } catch (e) {}
      return r;
    }
    exports.enable(load());
  }, {
    "./debug": 58
  } ],
  58: [ function(require, module, exports) {
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require("ms");
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevColor = 0;
    var prevTime;
    function selectColor() {
      return exports.colors[prevColor++ % exports.colors.length];
    }
    function debug(namespace) {
      function disabled() {}
      disabled.enabled = false;
      function enabled() {
        var self = enabled;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        if (null == self.useColors) self.useColors = exports.useColors();
        if (null == self.color && self.useColors) self.color = selectColor();
        var args = Array.prototype.slice.call(arguments);
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args = [ "%o" ].concat(args);
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
          if (match === "%%") return match;
          index++;
          var formatter = exports.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        if ("function" === typeof exports.formatArgs) {
          args = exports.formatArgs.apply(self, args);
        }
        var logFn = enabled.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      enabled.enabled = true;
      var fn = exports.enabled(namespace) ? enabled : disabled;
      fn.namespace = namespace;
      return fn;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      var split = (namespaces || "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  }, {
    ms: 59
  } ],
  59: [ function(require, module, exports) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      if ("string" == typeof val) return parse(val);
      return options.long ? long(val) : short(val);
    };
    function parse(str) {
      var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
      if (!match) return;
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
       case "years":
       case "year":
       case "y":
        return n * y;

       case "days":
       case "day":
       case "d":
        return n * d;

       case "hours":
       case "hour":
       case "h":
        return n * h;

       case "minutes":
       case "minute":
       case "m":
        return n * m;

       case "seconds":
       case "second":
       case "s":
        return n * s;

       case "ms":
        return n;
      }
    }
    function short(ms) {
      if (ms >= d) return Math.round(ms / d) + "d";
      if (ms >= h) return Math.round(ms / h) + "h";
      if (ms >= m) return Math.round(ms / m) + "m";
      if (ms >= s) return Math.round(ms / s) + "s";
      return ms + "ms";
    }
    function long(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) return;
      if (ms < n * 1.5) return Math.floor(ms / n) + " " + name;
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }, {} ],
  60: [ function(require, module, exports) {
    var JSON = {};
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      if (typeof Date.prototype.toJSON !== "function") {
        Date.prototype.toJSON = function(key) {
          return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
        };
        String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function(key) {
          return this.valueOf();
        };
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key];
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
         case "string":
          return quote(value);

         case "number":
          return isFinite(value) ? String(value) : "null";

         case "boolean":
         case "null":
          return String(value);

         case "object":
          if (!value) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i = 0; i < length; i += 1) {
              partial[i] = str(i, value) || "null";
            }
            v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i = 0; i < length; i += 1) {
              if (typeof rep[i] === "string") {
                k = rep[i];
                v = str(k, value);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          } else {
            for (k in value) {
              if (Object.prototype.hasOwnProperty.call(value, k)) {
                v = str(k, value);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          }
          v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v;
        }
      }
      if (typeof JSON.stringify !== "function") {
        JSON.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", {
            "": value
          });
        };
      }
      if (typeof JSON.parse !== "function") {
        JSON.parse = function(text, reviver) {
          var j;
          function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && typeof value === "object") {
              for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                  v = walk(value, k);
                  if (v !== undefined) {
                    value[k] = v;
                  } else {
                    delete value[k];
                  }
                }
              }
            }
            return reviver.call(holder, key, value);
          }
          text = String(text);
          cx.lastIndex = 0;
          if (cx.test(text)) {
            text = text.replace(cx, function(a) {
              return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            });
          }
          if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) {
            j = eval("(" + text + ")");
            return typeof reviver === "function" ? walk({
              "": j
            }, "") : j;
          }
          throw new SyntaxError("JSON.parse");
        };
      }
    })();
    module.exports = JSON;
  }, {} ],
  61: [ function(require, module, exports) {
    var debug = require("debug")("jsonp");
    module.exports = jsonp;
    var count = 0;
    function noop() {}
    function jsonp(url, opts, fn) {
      if ("function" == typeof opts) {
        fn = opts;
        opts = {};
      }
      if (!opts) opts = {};
      var prefix = opts.prefix || "__jp";
      var param = opts.param || "callback";
      var timeout = null != opts.timeout ? opts.timeout : 6e4;
      var enc = encodeURIComponent;
      var target = document.getElementsByTagName("script")[0] || document.head;
      var script;
      var timer;
      var id = prefix + count++;
      if (timeout) {
        timer = setTimeout(function() {
          cleanup();
          if (fn) fn(new Error("Timeout"));
        }, timeout);
      }
      function cleanup() {
        script.parentNode.removeChild(script);
        window[id] = noop;
      }
      window[id] = function(data) {
        debug("jsonp got", data);
        if (timer) clearTimeout(timer);
        cleanup();
        if (fn) fn(null, data);
      };
      url += (~url.indexOf("?") ? "&" : "?") + param + "=" + enc(id);
      url = url.replace("?&", "?");
      debug('jsonp req "%s"', url);
      script = document.createElement("script");
      script.src = url;
      target.parentNode.insertBefore(script, target);
    }
  }, {
    debug: 57
  } ],
  62: [ function(require, module, exports) {
    var toString = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var indexOf = typeof Array.prototype.indexOf === "function" ? function(arr, el) {
      return arr.indexOf(el);
    } : function(arr, el) {
      if (typeof arr == "string" && typeof "a"[0] == "undefined") {
        arr = arr.split("");
      }
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };
    var isArray = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    var objectKeys = Object.keys || function(obj) {
      var ret = [];
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          ret.push(key);
        }
      }
      return ret;
    };
    var forEach = typeof Array.prototype.forEach === "function" ? function(arr, fn) {
      return arr.forEach(fn);
    } : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };
    var reduce = function(arr, fn, initial) {
      if (typeof arr.reduce === "function") return arr.reduce(fn, initial);
      var res = initial;
      for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
      return res;
    };
    var isint = /^[0-9]+$/;
    function promote(parent, key) {
      if (parent[key].length == 0) return parent[key] = {};
      var t = {};
      for (var i in parent[key]) {
        if (hasOwnProperty.call(parent[key], i)) {
          t[i] = parent[key][i];
        }
      }
      parent[key] = t;
      return t;
    }
    function parse(parts, parent, key, val) {
      var part = parts.shift();
      if (hasOwnProperty.call(Object.prototype, key)) return;
      if (!part) {
        if (isArray(parent[key])) {
          parent[key].push(val);
        } else if ("object" == typeof parent[key]) {
          parent[key] = val;
        } else if ("undefined" == typeof parent[key]) {
          parent[key] = val;
        } else {
          parent[key] = [ parent[key], val ];
        }
      } else {
        var obj = parent[key] = parent[key] || [];
        if ("]" == part) {
          if (isArray(obj)) {
            if ("" != val) obj.push(val);
          } else if ("object" == typeof obj) {
            obj[objectKeys(obj).length] = val;
          } else {
            obj = parent[key] = [ parent[key], val ];
          }
        } else if (~indexOf(part, "]")) {
          part = part.substr(0, part.length - 1);
          if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
          parse(parts, obj, part, val);
        } else {
          if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
          parse(parts, obj, part, val);
        }
      }
    }
    function merge(parent, key, val) {
      if (~indexOf(key, "]")) {
        var parts = key.split("["), len = parts.length, last = len - 1;
        parse(parts, parent, "base", val);
      } else {
        if (!isint.test(key) && isArray(parent.base)) {
          var t = {};
          for (var k in parent.base) t[k] = parent.base[k];
          parent.base = t;
        }
        set(parent.base, key, val);
      }
      return parent;
    }
    function compact(obj) {
      if ("object" != typeof obj) return obj;
      if (isArray(obj)) {
        var ret = [];
        for (var i in obj) {
          if (hasOwnProperty.call(obj, i)) {
            ret.push(obj[i]);
          }
        }
        return ret;
      }
      for (var key in obj) {
        obj[key] = compact(obj[key]);
      }
      return obj;
    }
    function parseObject(obj) {
      var ret = {
        base: {}
      };
      forEach(objectKeys(obj), function(name) {
        merge(ret, name, obj[name]);
      });
      return compact(ret.base);
    }
    function parseString(str, options) {
      var ret = reduce(String(str).split(options.separator), function(ret, pair) {
        var eql = indexOf(pair, "="), brace = lastBraceInKey(pair), key = pair.substr(0, brace || eql), val = pair.substr(brace || eql, pair.length), val = val.substr(indexOf(val, "=") + 1, val.length);
        if ("" == key) key = pair, val = "";
        if ("" == key) return ret;
        return merge(ret, decode(key), decode(val));
      }, {
        base: {}
      }).base;
      return compact(ret);
    }
    exports.parse = function(str, options) {
      if (null == str || "" == str) return {};
      options = options || {};
      options.separator = options.separator || "&";
      return "object" == typeof str ? parseObject(str) : parseString(str, options);
    };
    var stringify = exports.stringify = function(obj, prefix) {
      if (isArray(obj)) {
        return stringifyArray(obj, prefix);
      } else if ("[object Object]" == toString.call(obj)) {
        return stringifyObject(obj, prefix);
      } else if ("string" == typeof obj) {
        return stringifyString(obj, prefix);
      } else {
        return prefix + "=" + encodeURIComponent(String(obj));
      }
    };
    function stringifyString(str, prefix) {
      if (!prefix) throw new TypeError("stringify expects an object");
      return prefix + "=" + encodeURIComponent(str);
    }
    function stringifyArray(arr, prefix) {
      var ret = [];
      if (!prefix) throw new TypeError("stringify expects an object");
      for (var i = 0; i < arr.length; i++) {
        ret.push(stringify(arr[i], prefix + "[" + i + "]"));
      }
      return ret.join("&");
    }
    function stringifyObject(obj, prefix) {
      var ret = [], keys = objectKeys(obj), key;
      for (var i = 0, len = keys.length; i < len; ++i) {
        key = keys[i];
        if ("" == key) continue;
        if (null == obj[key]) {
          ret.push(encodeURIComponent(key) + "=");
        } else {
          ret.push(stringify(obj[key], prefix ? prefix + "[" + encodeURIComponent(key) + "]" : encodeURIComponent(key)));
        }
      }
      return ret.join("&");
    }
    function set(obj, key, val) {
      var v = obj[key];
      if (hasOwnProperty.call(Object.prototype, key)) return;
      if (undefined === v) {
        obj[key] = val;
      } else if (isArray(v)) {
        v.push(val);
      } else {
        obj[key] = [ v, val ];
      }
    }
    function lastBraceInKey(str) {
      var len = str.length, brace, c;
      for (var i = 0; i < len; ++i) {
        c = str[i];
        if ("]" == c) brace = false;
        if ("[" == c) brace = true;
        if ("=" == c && !brace) return i;
      }
    }
    function decode(str) {
      try {
        return decodeURIComponent(str.replace(/\+/g, " "));
      } catch (err) {
        return str;
      }
    }
  }, {} ],
  63: [ function(require, module, exports) {
    !function(name, context, definition) {
      if (typeof module != "undefined" && module.exports) module.exports = definition(); else if (typeof define == "function" && define.amd) define(definition); else context[name] = definition();
    }("reqwest", this, function() {
      var win = window, doc = document, httpsRe = /^http/, protocolRe = /(^\w+):\/\//, twoHundo = /^(20\d|1223)$/, byTag = "getElementsByTagName", readyState = "readyState", contentType = "Content-Type", requestedWith = "X-Requested-With", head = doc[byTag]("head")[0], uniqid = 0, callbackPrefix = "reqwest_" + +new Date(), lastValue, xmlHttpRequest = "XMLHttpRequest", xDomainRequest = "XDomainRequest", noop = function() {}, isArray = typeof Array.isArray == "function" ? Array.isArray : function(a) {
        return a instanceof Array;
      }, defaultHeaders = {
        contentType: "application/x-www-form-urlencoded",
        requestedWith: xmlHttpRequest,
        accept: {
          "*": "text/javascript, text/html, application/xml, text/xml, */*",
          xml: "application/xml, text/xml",
          html: "text/html",
          text: "text/plain",
          json: "application/json, text/javascript",
          js: "application/javascript, text/javascript"
        }
      }, xhr = function(o) {
        if (o["crossOrigin"] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null;
          if (xhr && "withCredentials" in xhr) {
            return xhr;
          } else if (win[xDomainRequest]) {
            return new XDomainRequest();
          } else {
            throw new Error("Browser does not support cross-origin requests");
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest();
        } else {
          return new ActiveXObject("Microsoft.XMLHTTP");
        }
      }, globalSetupOptions = {
        dataFilter: function(data) {
          return data;
        }
      };
      function succeed(r) {
        var protocol = protocolRe.exec(r.url);
        protocol = protocol && protocol[1] || window.location.protocol;
        return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response;
      }
      function handleReadyState(r, success, error) {
        return function() {
          if (r._aborted) return error(r.request);
          if (r.request && r.request[readyState] == 4) {
            r.request.onreadystatechange = noop;
            if (succeed(r)) success(r.request); else error(r.request);
          }
        };
      }
      function setHeaders(http, o) {
        var headers = o["headers"] || {}, h;
        headers["Accept"] = headers["Accept"] || defaultHeaders["accept"][o["type"]] || defaultHeaders["accept"]["*"];
        var isAFormData = typeof FormData === "function" && o["data"] instanceof FormData;
        if (!o["crossOrigin"] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders["requestedWith"];
        if (!headers[contentType] && !isAFormData) headers[contentType] = o["contentType"] || defaultHeaders["contentType"];
        for (h in headers) headers.hasOwnProperty(h) && "setRequestHeader" in http && http.setRequestHeader(h, headers[h]);
      }
      function setCredentials(http, o) {
        if (typeof o["withCredentials"] !== "undefined" && typeof http.withCredentials !== "undefined") {
          http.withCredentials = !!o["withCredentials"];
        }
      }
      function generalCallback(data) {
        lastValue = data;
      }
      function urlappend(url, s) {
        return url + (/\?/.test(url) ? "&" : "?") + s;
      }
      function handleJsonp(o, fn, err, url) {
        var reqId = uniqid++, cbkey = o["jsonpCallback"] || "callback", cbval = o["jsonpCallbackName"] || reqwest.getcallbackPrefix(reqId), cbreg = new RegExp("((^|\\?|&)" + cbkey + ")=([^&]+)"), match = url.match(cbreg), script = doc.createElement("script"), loaded = 0, isIE10 = navigator.userAgent.indexOf("MSIE 10.0") !== -1;
        if (match) {
          if (match[3] === "?") {
            url = url.replace(cbreg, "$1=" + cbval);
          } else {
            cbval = match[3];
          }
        } else {
          url = urlappend(url, cbkey + "=" + cbval);
        }
        win[cbval] = generalCallback;
        script.type = "text/javascript";
        script.src = url;
        script.async = true;
        if (typeof script.onreadystatechange !== "undefined" && !isIE10) {
          script.htmlFor = script.id = "_reqwest_" + reqId;
        }
        script.onload = script.onreadystatechange = function() {
          if (script[readyState] && script[readyState] !== "complete" && script[readyState] !== "loaded" || loaded) {
            return false;
          }
          script.onload = script.onreadystatechange = null;
          script.onclick && script.onclick();
          fn(lastValue);
          lastValue = undefined;
          head.removeChild(script);
          loaded = 1;
        };
        head.appendChild(script);
        return {
          abort: function() {
            script.onload = script.onreadystatechange = null;
            err({}, "Request is aborted: timeout", {});
            lastValue = undefined;
            head.removeChild(script);
            loaded = 1;
          }
        };
      }
      function getRequest(fn, err) {
        var o = this.o, method = (o["method"] || "GET").toUpperCase(), url = typeof o === "string" ? o : o["url"], data = o["processData"] !== false && o["data"] && typeof o["data"] !== "string" ? reqwest.toQueryString(o["data"]) : o["data"] || null, http, sendWait = false;
        if ((o["type"] == "jsonp" || method == "GET") && data) {
          url = urlappend(url, data);
          data = null;
        }
        if (o["type"] == "jsonp") return handleJsonp(o, fn, err, url);
        http = o.xhr && o.xhr(o) || xhr(o);
        http.open(method, url, o["async"] === false ? false : true);
        setHeaders(http, o);
        setCredentials(http, o);
        if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
          http.onload = fn;
          http.onerror = err;
          http.onprogress = function() {};
          sendWait = true;
        } else {
          http.onreadystatechange = handleReadyState(this, fn, err);
        }
        o["before"] && o["before"](http);
        if (sendWait) {
          setTimeout(function() {
            http.send(data);
          }, 200);
        } else {
          http.send(data);
        }
        return http;
      }
      function Reqwest(o, fn) {
        this.o = o;
        this.fn = fn;
        init.apply(this, arguments);
      }
      function setType(header) {
        if (header.match("json")) return "json";
        if (header.match("javascript")) return "js";
        if (header.match("text")) return "html";
        if (header.match("xml")) return "xml";
      }
      function init(o, fn) {
        this.url = typeof o == "string" ? o : o["url"];
        this.timeout = null;
        this._fulfilled = false;
        this._successHandler = function() {};
        this._fulfillmentHandlers = [];
        this._errorHandlers = [];
        this._completeHandlers = [];
        this._erred = false;
        this._responseArgs = {};
        var self = this;
        fn = fn || function() {};
        if (o["timeout"]) {
          this.timeout = setTimeout(function() {
            self.abort();
          }, o["timeout"]);
        }
        if (o["success"]) {
          this._successHandler = function() {
            o["success"].apply(o, arguments);
          };
        }
        if (o["error"]) {
          this._errorHandlers.push(function() {
            o["error"].apply(o, arguments);
          });
        }
        if (o["complete"]) {
          this._completeHandlers.push(function() {
            o["complete"].apply(o, arguments);
          });
        }
        function complete(resp) {
          o["timeout"] && clearTimeout(self.timeout);
          self.timeout = null;
          while (self._completeHandlers.length > 0) {
            self._completeHandlers.shift()(resp);
          }
        }
        function success(resp) {
          var type = o["type"] || resp && setType(resp.getResponseHeader("Content-Type"));
          resp = type !== "jsonp" ? self.request : resp;
          var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type), r = filteredResponse;
          try {
            resp.responseText = r;
          } catch (e) {}
          if (r) {
            switch (type) {
             case "json":
              try {
                resp = win.JSON ? win.JSON.parse(r) : eval("(" + r + ")");
              } catch (err) {
                return error(resp, "Could not parse JSON in response", err);
              }
              break;

             case "js":
              resp = eval(r);
              break;

             case "html":
              resp = r;
              break;

             case "xml":
              resp = resp.responseXML && resp.responseXML.parseError && resp.responseXML.parseError.errorCode && resp.responseXML.parseError.reason ? null : resp.responseXML;
              break;
            }
          }
          self._responseArgs.resp = resp;
          self._fulfilled = true;
          fn(resp);
          self._successHandler(resp);
          while (self._fulfillmentHandlers.length > 0) {
            resp = self._fulfillmentHandlers.shift()(resp);
          }
          complete(resp);
        }
        function error(resp, msg, t) {
          resp = self.request;
          self._responseArgs.resp = resp;
          self._responseArgs.msg = msg;
          self._responseArgs.t = t;
          self._erred = true;
          while (self._errorHandlers.length > 0) {
            self._errorHandlers.shift()(resp, msg, t);
          }
          complete(resp);
        }
        this.request = getRequest.call(this, success, error);
      }
      Reqwest.prototype = {
        abort: function() {
          this._aborted = true;
          this.request.abort();
        },
        retry: function() {
          init.call(this, this.o, this.fn);
        },
        then: function(success, fail) {
          success = success || function() {};
          fail = fail || function() {};
          if (this._fulfilled) {
            this._responseArgs.resp = success(this._responseArgs.resp);
          } else if (this._erred) {
            fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
          } else {
            this._fulfillmentHandlers.push(success);
            this._errorHandlers.push(fail);
          }
          return this;
        },
        always: function(fn) {
          if (this._fulfilled || this._erred) {
            fn(this._responseArgs.resp);
          } else {
            this._completeHandlers.push(fn);
          }
          return this;
        },
        fail: function(fn) {
          if (this._erred) {
            fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t);
          } else {
            this._errorHandlers.push(fn);
          }
          return this;
        },
        "catch": function(fn) {
          return this.fail(fn);
        }
      };
      function reqwest(o, fn) {
        return new Reqwest(o, fn);
      }
      function normalize(s) {
        return s ? s.replace(/\r?\n/g, "\r\n") : "";
      }
      function serial(el, cb) {
        var n = el.name, t = el.tagName.toLowerCase(), optCb = function(o) {
          if (o && !o["disabled"]) cb(n, normalize(o["attributes"]["value"] && o["attributes"]["value"]["specified"] ? o["value"] : o["text"]));
        }, ch, ra, val, i;
        if (el.disabled || !n) return;
        switch (t) {
         case "input":
          if (!/reset|button|image|file/i.test(el.type)) {
            ch = /checkbox/i.test(el.type);
            ra = /radio/i.test(el.type);
            val = el.value;
            (!(ch || ra) || el.checked) && cb(n, normalize(ch && val === "" ? "on" : val));
          }
          break;

         case "textarea":
          cb(n, normalize(el.value));
          break;

         case "select":
          if (el.type.toLowerCase() === "select-one") {
            optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null);
          } else {
            for (i = 0; el.length && i < el.length; i++) {
              el.options[i].selected && optCb(el.options[i]);
            }
          }
          break;
        }
      }
      function eachFormElement() {
        var cb = this, e, i, serializeSubtags = function(e, tags) {
          var i, j, fa;
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i]);
            for (j = 0; j < fa.length; j++) serial(fa[j], cb);
          }
        };
        for (i = 0; i < arguments.length; i++) {
          e = arguments[i];
          if (/input|select|textarea/i.test(e.tagName)) serial(e, cb);
          serializeSubtags(e, [ "input", "select", "textarea" ]);
        }
      }
      function serializeQueryString() {
        return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments));
      }
      function serializeHash() {
        var hash = {};
        eachFormElement.apply(function(name, value) {
          if (name in hash) {
            hash[name] && !isArray(hash[name]) && (hash[name] = [ hash[name] ]);
            hash[name].push(value);
          } else hash[name] = value;
        }, arguments);
        return hash;
      }
      reqwest.serializeArray = function() {
        var arr = [];
        eachFormElement.apply(function(name, value) {
          arr.push({
            name: name,
            value: value
          });
        }, arguments);
        return arr;
      };
      reqwest.serialize = function() {
        if (arguments.length === 0) return "";
        var opt, fn, args = Array.prototype.slice.call(arguments, 0);
        opt = args.pop();
        opt && opt.nodeType && args.push(opt) && (opt = null);
        opt && (opt = opt.type);
        if (opt == "map") fn = serializeHash; else if (opt == "array") fn = reqwest.serializeArray; else fn = serializeQueryString;
        return fn.apply(null, args);
      };
      reqwest.toQueryString = function(o, trad) {
        var prefix, i, traditional = trad || false, s = [], enc = encodeURIComponent, add = function(key, value) {
          value = "function" === typeof value ? value() : value == null ? "" : value;
          s[s.length] = enc(key) + "=" + enc(value);
        };
        if (isArray(o)) {
          for (i = 0; o && i < o.length; i++) add(o[i]["name"], o[i]["value"]);
        } else {
          for (prefix in o) {
            if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add);
          }
        }
        return s.join("&").replace(/%20/g, "+");
      };
      function buildParams(prefix, obj, traditional, add) {
        var name, i, v, rbracket = /\[\]$/;
        if (isArray(obj)) {
          for (i = 0; obj && i < obj.length; i++) {
            v = obj[i];
            if (traditional || rbracket.test(prefix)) {
              add(prefix, v);
            } else {
              buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
            }
          }
        } else if (obj && obj.toString() === "[object Object]") {
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
          }
        } else {
          add(prefix, obj);
        }
      }
      reqwest.getcallbackPrefix = function() {
        return callbackPrefix;
      };
      reqwest.compat = function(o, fn) {
        if (o) {
          o["type"] && (o["method"] = o["type"]) && delete o["type"];
          o["dataType"] && (o["type"] = o["dataType"]);
          o["jsonpCallback"] && (o["jsonpCallbackName"] = o["jsonpCallback"]) && delete o["jsonpCallback"];
          o["jsonp"] && (o["jsonpCallback"] = o["jsonp"]);
        }
        return new Reqwest(o, fn);
      };
      reqwest.ajaxSetup = function(options) {
        options = options || {};
        for (var k in options) {
          globalSetupOptions[k] = options[k];
        }
      };
      return reqwest;
    });
  }, {} ],
  64: [ function(require, module, exports) {
    var WinChan = function() {
      var RELAY_FRAME_NAME = "__winchan_relay_frame";
      var CLOSE_CMD = "die";
      function addListener(w, event, cb) {
        if (w.attachEvent) w.attachEvent("on" + event, cb); else if (w.addEventListener) w.addEventListener(event, cb, false);
      }
      function removeListener(w, event, cb) {
        if (w.detachEvent) w.detachEvent("on" + event, cb); else if (w.removeEventListener) w.removeEventListener(event, cb, false);
      }
      function isInternetExplorer() {
        var rv = -1;
        var ua = navigator.userAgent;
        if (navigator.appName === "Microsoft Internet Explorer") {
          var re = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
          if (re.exec(ua) != null) rv = parseFloat(RegExp.$1);
        } else if (ua.indexOf("Trident") > -1) {
          var re = new RegExp("rv:([0-9]{2,2}[.0-9]{0,})");
          if (re.exec(ua) !== null) {
            rv = parseFloat(RegExp.$1);
          }
        }
        return rv >= 8;
      }
      function isFennec() {
        try {
          var userAgent = navigator.userAgent;
          return userAgent.indexOf("Fennec/") != -1 || userAgent.indexOf("Firefox/") != -1 && userAgent.indexOf("Android") != -1;
        } catch (e) {}
        return false;
      }
      function isSupported() {
        return window.JSON && window.JSON.stringify && window.JSON.parse && window.postMessage;
      }
      function extractOrigin(url) {
        if (!/^https?:\/\//.test(url)) url = window.location.href;
        var m = /^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec(url);
        if (m) return m[1];
        return url;
      }
      function findRelay() {
        var loc = window.location;
        var frames = window.opener.frames;
        for (var i = frames.length - 1; i >= 0; i--) {
          try {
            if (frames[i].location.protocol === window.location.protocol && frames[i].location.host === window.location.host && frames[i].name === RELAY_FRAME_NAME) {
              return frames[i];
            }
          } catch (e) {}
        }
        return;
      }
      var isIE = isInternetExplorer();
      if (isSupported()) {
        return {
          open: function(opts, cb) {
            if (!cb) throw "missing required callback argument";
            var err;
            if (!opts.url) err = "missing required 'url' parameter";
            if (!opts.relay_url) err = "missing required 'relay_url' parameter";
            if (err) setTimeout(function() {
              cb(err);
            }, 0);
            if (!opts.window_name) opts.window_name = null;
            if (!opts.window_features || isFennec()) opts.window_features = undefined;
            var iframe;
            var origin = extractOrigin(opts.url);
            if (origin !== extractOrigin(opts.relay_url)) {
              return setTimeout(function() {
                cb("invalid arguments: origin of url and relay_url must match");
              }, 0);
            }
            var messageTarget;
            if (isIE) {
              iframe = document.createElement("iframe");
              iframe.setAttribute("src", opts.relay_url);
              iframe.style.display = "none";
              iframe.setAttribute("name", RELAY_FRAME_NAME);
              document.body.appendChild(iframe);
              messageTarget = iframe.contentWindow;
            }
            var w = window.open(opts.url, opts.window_name, opts.window_features);
            if (!messageTarget) messageTarget = w;
            var closeInterval = setInterval(function() {
              if (w && w.closed) {
                cleanup();
                if (cb) {
                  cb("User closed the popup window");
                  cb = null;
                }
              }
            }, 500);
            var req = JSON.stringify({
              a: "request",
              d: opts.params
            });
            function cleanup() {
              if (iframe) document.body.removeChild(iframe);
              iframe = undefined;
              if (closeInterval) closeInterval = clearInterval(closeInterval);
              removeListener(window, "message", onMessage);
              removeListener(window, "unload", cleanup);
              if (w) {
                try {
                  w.close();
                } catch (securityViolation) {
                  messageTarget.postMessage(CLOSE_CMD, origin);
                }
              }
              w = messageTarget = undefined;
            }
            addListener(window, "unload", cleanup);
            function onMessage(e) {
              if (e.origin !== origin) {
                return;
              }
              try {
                var d = JSON.parse(e.data);
                if (d.a === "ready") messageTarget.postMessage(req, origin); else if (d.a === "error") {
                  cleanup();
                  if (cb) {
                    cb(d.d);
                    cb = null;
                  }
                } else if (d.a === "response") {
                  cleanup();
                  if (cb) {
                    cb(null, d.d);
                    cb = null;
                  }
                }
              } catch (err) {}
            }
            addListener(window, "message", onMessage);
            return {
              close: cleanup,
              focus: function() {
                if (w) {
                  try {
                    w.focus();
                  } catch (e) {}
                }
              }
            };
          },
          onOpen: function(cb) {
            var o = "*";
            var msgTarget = isIE ? findRelay() : window.opener;
            if (!msgTarget) throw "can't find relay frame";
            function doPost(msg) {
              msg = JSON.stringify(msg);
              if (isIE) msgTarget.doPost(msg, o); else msgTarget.postMessage(msg, o);
            }
            function onMessage(e) {
              var d;
              try {
                d = JSON.parse(e.data);
              } catch (err) {}
              if (!d || d.a !== "request") return;
              removeListener(window, "message", onMessage);
              o = e.origin;
              if (cb) {
                setTimeout(function() {
                  cb(o, d.d, function(r) {
                    cb = undefined;
                    doPost({
                      a: "response",
                      d: r
                    });
                  });
                }, 0);
              }
            }
            function onDie(e) {
              if (e.data === CLOSE_CMD) {
                try {
                  window.close();
                } catch (o_O) {}
              }
            }
            addListener(isIE ? msgTarget : window, "message", onMessage);
            addListener(isIE ? msgTarget : window, "message", onDie);
            try {
              doPost({
                a: "ready"
              });
            } catch (e) {
              addListener(msgTarget, "load", function(e) {
                doPost({
                  a: "ready"
                });
              });
            }
            var onUnload = function() {
              try {
                removeListener(isIE ? msgTarget : window, "message", onDie);
              } catch (ohWell) {}
              if (cb) doPost({
                a: "error",
                d: "client closed window"
              });
              cb = undefined;
              try {
                window.close();
              } catch (e) {}
            };
            addListener(window, "unload", onUnload);
            return {
              detach: function() {
                removeListener(window, "unload", onUnload);
              }
            };
          }
        };
      } else {
        return {
          open: function(url, winopts, arg, cb) {
            setTimeout(function() {
              cb("unsupported browser");
            }, 0);
          },
          onOpen: function(cb) {
            setTimeout(function() {
              cb("unsupported browser");
            }, 0);
          }
        };
      }
    }();
    if (typeof module !== "undefined" && module.exports) {
      module.exports = WinChan;
    }
  }, {} ],
  65: [ function(require, module, exports) {
    module.exports = hasKeys;
    function hasKeys(source) {
      return source !== null && (typeof source === "object" || typeof source === "function");
    }
  }, {} ],
  66: [ function(require, module, exports) {
    var Keys = require("object-keys");
    var hasKeys = require("./has-keys");
    module.exports = extend;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        if (!hasKeys(source)) {
          continue;
        }
        var keys = Keys(source);
        for (var j = 0; j < keys.length; j++) {
          var name = keys[j];
          target[name] = source[name];
        }
      }
      return target;
    }
  }, {
    "./has-keys": 65,
    "object-keys": 68
  } ],
  67: [ function(require, module, exports) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    var isFunction = function(fn) {
      var isFunc = typeof fn === "function" && !(fn instanceof RegExp) || toString.call(fn) === "[object Function]";
      if (!isFunc && typeof window !== "undefined") {
        isFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;
      }
      return isFunc;
    };
    module.exports = function forEach(obj, fn) {
      if (!isFunction(fn)) {
        throw new TypeError("iterator must be a function");
      }
      var i, k, isString = typeof obj === "string", l = obj.length, context = arguments.length > 2 ? arguments[2] : null;
      if (l === +l) {
        for (i = 0; i < l; i++) {
          if (context === null) {
            fn(isString ? obj.charAt(i) : obj[i], i, obj);
          } else {
            fn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);
          }
        }
      } else {
        for (k in obj) {
          if (hasOwn.call(obj, k)) {
            if (context === null) {
              fn(obj[k], k, obj);
            } else {
              fn.call(context, obj[k], k, obj);
            }
          }
        }
      }
    };
  }, {} ],
  68: [ function(require, module, exports) {
    module.exports = Object.keys || require("./shim");
  }, {
    "./shim": 70
  } ],
  69: [ function(require, module, exports) {
    var toString = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toString.call(value);
      var isArguments = str === "[object Arguments]";
      if (!isArguments) {
        isArguments = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toString.call(value.callee) === "[object Function]";
      }
      return isArguments;
    };
  }, {} ],
  70: [ function(require, module, exports) {
    (function() {
      "use strict";
      var has = Object.prototype.hasOwnProperty, toString = Object.prototype.toString, forEach = require("./foreach"), isArgs = require("./isArguments"), hasDontEnumBug = !{
        toString: null
      }.propertyIsEnumerable("toString"), hasProtoEnumBug = function() {}.propertyIsEnumerable("prototype"), dontEnums = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor" ], keysShim;
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object", isFunction = toString.call(object) === "[object Function]", isArguments = isArgs(object), theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        if (isArguments) {
          forEach(object, function(value) {
            theKeys.push(value);
          });
        } else {
          var name, skipProto = hasProtoEnumBug && isFunction;
          for (name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(name);
            }
          }
        }
        if (hasDontEnumBug) {
          var ctor = object.constructor, skipConstructor = ctor && ctor.prototype === object;
          forEach(dontEnums, function(dontEnum) {
            if (!(skipConstructor && dontEnum === "constructor") && has.call(object, dontEnum)) {
              theKeys.push(dontEnum);
            }
          });
        }
        return theKeys;
      };
      module.exports = keysShim;
    })();
  }, {
    "./foreach": 67,
    "./isArguments": 69
  } ],
  71: [ function(require, module, exports) {
    (function(name, context, definition) {
      if (typeof module != "undefined" && module.exports) module.exports = definition(); else if (typeof define == "function" && define.amd) define(definition); else context[name] = definition();
    })("bean", this, function(name, context) {
      name = name || "bean";
      context = context || this;
      var win = window, old = context[name], namespaceRegex = /[^\.]*(?=\..*)\.|.*/, nameRegex = /\..*/, addEvent = "addEventListener", removeEvent = "removeEventListener", doc = document || {}, root = doc.documentElement || {}, W3C_MODEL = root[addEvent], eventSupport = W3C_MODEL ? addEvent : "attachEvent", ONE = {}, slice = Array.prototype.slice, str2arr = function(s, d) {
        return s.split(d || " ");
      }, isString = function(o) {
        return typeof o == "string";
      }, isFunction = function(o) {
        return typeof o == "function";
      }, standardNativeEvents = "click dblclick mouseup mousedown contextmenu " + "mousewheel mousemultiwheel DOMMouseScroll " + "mouseover mouseout mousemove selectstart selectend " + "keydown keypress keyup " + "orientationchange " + "focus blur change reset select submit " + "load unload beforeunload resize move DOMContentLoaded " + "readystatechange message " + "error abort scroll ", w3cNativeEvents = "show " + "input invalid " + "touchstart touchmove touchend touchcancel " + "gesturestart gesturechange gestureend " + "textinput " + "readystatechange pageshow pagehide popstate " + "hashchange offline online " + "afterprint beforeprint " + "dragstart dragenter dragover dragleave drag drop dragend " + "loadstart progress suspend emptied stalled loadmetadata " + "loadeddata canplay canplaythrough playing waiting seeking " + "seeked ended durationchange timeupdate play pause ratechange " + "volumechange cuechange " + "checking noupdate downloading cached updateready obsolete ", nativeEvents = function(hash, events, i) {
        for (i = 0; i < events.length; i++) events[i] && (hash[events[i]] = 1);
        return hash;
      }({}, str2arr(standardNativeEvents + (W3C_MODEL ? w3cNativeEvents : ""))), customEvents = function() {
        var isAncestor = "compareDocumentPosition" in root ? function(element, container) {
          return container.compareDocumentPosition && (container.compareDocumentPosition(element) & 16) === 16;
        } : "contains" in root ? function(element, container) {
          container = container.nodeType === 9 || container === window ? root : container;
          return container !== element && container.contains(element);
        } : function(element, container) {
          while (element = element.parentNode) if (element === container) return 1;
          return 0;
        }, check = function(event) {
          var related = event.relatedTarget;
          return !related ? related == null : related !== this && related.prefix !== "xul" && !/document/.test(this.toString()) && !isAncestor(related, this);
        };
        return {
          mouseenter: {
            base: "mouseover",
            condition: check
          },
          mouseleave: {
            base: "mouseout",
            condition: check
          },
          mousewheel: {
            base: /Firefox/.test(navigator.userAgent) ? "DOMMouseScroll" : "mousewheel"
          }
        };
      }(), Event = function() {
        var commonProps = str2arr("altKey attrChange attrName bubbles cancelable ctrlKey currentTarget " + "detail eventPhase getModifierState isTrusted metaKey relatedNode relatedTarget shiftKey " + "srcElement target timeStamp type view which propertyName"), mouseProps = commonProps.concat(str2arr("button buttons clientX clientY dataTransfer " + "fromElement offsetX offsetY pageX pageY screenX screenY toElement")), mouseWheelProps = mouseProps.concat(str2arr("wheelDelta wheelDeltaX wheelDeltaY wheelDeltaZ " + "axis")), keyProps = commonProps.concat(str2arr("char charCode key keyCode keyIdentifier " + "keyLocation location")), textProps = commonProps.concat(str2arr("data")), touchProps = commonProps.concat(str2arr("touches targetTouches changedTouches scale rotation")), messageProps = commonProps.concat(str2arr("data origin source")), stateProps = commonProps.concat(str2arr("state")), overOutRegex = /over|out/, typeFixers = [ {
          reg: /key/i,
          fix: function(event, newEvent) {
            newEvent.keyCode = event.keyCode || event.which;
            return keyProps;
          }
        }, {
          reg: /click|mouse(?!(.*wheel|scroll))|menu|drag|drop/i,
          fix: function(event, newEvent, type) {
            newEvent.rightClick = event.which === 3 || event.button === 2;
            newEvent.pos = {
              x: 0,
              y: 0
            };
            if (event.pageX || event.pageY) {
              newEvent.clientX = event.pageX;
              newEvent.clientY = event.pageY;
            } else if (event.clientX || event.clientY) {
              newEvent.clientX = event.clientX + doc.body.scrollLeft + root.scrollLeft;
              newEvent.clientY = event.clientY + doc.body.scrollTop + root.scrollTop;
            }
            if (overOutRegex.test(type)) {
              newEvent.relatedTarget = event.relatedTarget || event[(type == "mouseover" ? "from" : "to") + "Element"];
            }
            return mouseProps;
          }
        }, {
          reg: /mouse.*(wheel|scroll)/i,
          fix: function() {
            return mouseWheelProps;
          }
        }, {
          reg: /^text/i,
          fix: function() {
            return textProps;
          }
        }, {
          reg: /^touch|^gesture/i,
          fix: function() {
            return touchProps;
          }
        }, {
          reg: /^message$/i,
          fix: function() {
            return messageProps;
          }
        }, {
          reg: /^popstate$/i,
          fix: function() {
            return stateProps;
          }
        }, {
          reg: /.*/,
          fix: function() {
            return commonProps;
          }
        } ], typeFixerMap = {}, Event = function(event, element, isNative) {
          if (!arguments.length) return;
          event = event || ((element.ownerDocument || element.document || element).parentWindow || win).event;
          this.originalEvent = event;
          this.isNative = isNative;
          this.isBean = true;
          if (!event) return;
          var type = event.type, target = event.target || event.srcElement, i, l, p, props, fixer;
          this.target = target && target.nodeType === 3 ? target.parentNode : target;
          if (isNative) {
            fixer = typeFixerMap[type];
            if (!fixer) {
              for (i = 0, l = typeFixers.length; i < l; i++) {
                if (typeFixers[i].reg.test(type)) {
                  typeFixerMap[type] = fixer = typeFixers[i].fix;
                  break;
                }
              }
            }
            props = fixer(event, this, type);
            for (i = props.length; i--; ) {
              if (!((p = props[i]) in this) && p in event) this[p] = event[p];
            }
          }
        };
        Event.prototype.preventDefault = function() {
          if (this.originalEvent.preventDefault) this.originalEvent.preventDefault(); else this.originalEvent.returnValue = false;
        };
        Event.prototype.stopPropagation = function() {
          if (this.originalEvent.stopPropagation) this.originalEvent.stopPropagation(); else this.originalEvent.cancelBubble = true;
        };
        Event.prototype.stop = function() {
          this.preventDefault();
          this.stopPropagation();
          this.stopped = true;
        };
        Event.prototype.stopImmediatePropagation = function() {
          if (this.originalEvent.stopImmediatePropagation) this.originalEvent.stopImmediatePropagation();
          this.isImmediatePropagationStopped = function() {
            return true;
          };
        };
        Event.prototype.isImmediatePropagationStopped = function() {
          return this.originalEvent.isImmediatePropagationStopped && this.originalEvent.isImmediatePropagationStopped();
        };
        Event.prototype.clone = function(currentTarget) {
          var ne = new Event(this, this.element, this.isNative);
          ne.currentTarget = currentTarget;
          return ne;
        };
        return Event;
      }(), targetElement = function(element, isNative) {
        return !W3C_MODEL && !isNative && (element === doc || element === win) ? root : element;
      }, RegEntry = function() {
        var wrappedHandler = function(element, fn, condition, args) {
          var call = function(event, eargs) {
            return fn.apply(element, args ? slice.call(eargs, event ? 0 : 1).concat(args) : eargs);
          }, findTarget = function(event, eventElement) {
            return fn.__beanDel ? fn.__beanDel.ft(event.target, element) : eventElement;
          }, handler = condition ? function(event) {
            var target = findTarget(event, this);
            if (condition.apply(target, arguments)) {
              if (event) event.currentTarget = target;
              return call(event, arguments);
            }
          } : function(event) {
            if (fn.__beanDel) event = event.clone(findTarget(event));
            return call(event, arguments);
          };
          handler.__beanDel = fn.__beanDel;
          return handler;
        }, RegEntry = function(element, type, handler, original, namespaces, args, root) {
          var customType = customEvents[type], isNative;
          if (type == "unload") {
            handler = once(removeListener, element, type, handler, original);
          }
          if (customType) {
            if (customType.condition) {
              handler = wrappedHandler(element, handler, customType.condition, args);
            }
            type = customType.base || type;
          }
          this.isNative = isNative = nativeEvents[type] && !!element[eventSupport];
          this.customType = !W3C_MODEL && !isNative && type;
          this.element = element;
          this.type = type;
          this.original = original;
          this.namespaces = namespaces;
          this.eventType = W3C_MODEL || isNative ? type : "propertychange";
          this.target = targetElement(element, isNative);
          this[eventSupport] = !!this.target[eventSupport];
          this.root = root;
          this.handler = wrappedHandler(element, handler, null, args);
        };
        RegEntry.prototype.inNamespaces = function(checkNamespaces) {
          var i, j, c = 0;
          if (!checkNamespaces) return true;
          if (!this.namespaces) return false;
          for (i = checkNamespaces.length; i--; ) {
            for (j = this.namespaces.length; j--; ) {
              if (checkNamespaces[i] == this.namespaces[j]) c++;
            }
          }
          return checkNamespaces.length === c;
        };
        RegEntry.prototype.matches = function(checkElement, checkOriginal, checkHandler) {
          return this.element === checkElement && (!checkOriginal || this.original === checkOriginal) && (!checkHandler || this.handler === checkHandler);
        };
        return RegEntry;
      }(), registry = function() {
        var map = {}, forAll = function(element, type, original, handler, root, fn) {
          var pfx = root ? "r" : "$";
          if (!type || type == "*") {
            for (var t in map) {
              if (t.charAt(0) == pfx) {
                forAll(element, t.substr(1), original, handler, root, fn);
              }
            }
          } else {
            var i = 0, l, list = map[pfx + type], all = element == "*";
            if (!list) return;
            for (l = list.length; i < l; i++) {
              if ((all || list[i].matches(element, original, handler)) && !fn(list[i], list, i, type)) return;
            }
          }
        }, has = function(element, type, original, root) {
          var i, list = map[(root ? "r" : "$") + type];
          if (list) {
            for (i = list.length; i--; ) {
              if (!list[i].root && list[i].matches(element, original, null)) return true;
            }
          }
          return false;
        }, get = function(element, type, original, root) {
          var entries = [];
          forAll(element, type, original, null, root, function(entry) {
            return entries.push(entry);
          });
          return entries;
        }, put = function(entry) {
          var has = !entry.root && !this.has(entry.element, entry.type, null, false), key = (entry.root ? "r" : "$") + entry.type;
          (map[key] || (map[key] = [])).push(entry);
          return has;
        }, del = function(entry) {
          forAll(entry.element, entry.type, null, entry.handler, entry.root, function(entry, list, i) {
            list.splice(i, 1);
            entry.removed = true;
            if (list.length === 0) delete map[(entry.root ? "r" : "$") + entry.type];
            return false;
          });
        }, entries = function() {
          var t, entries = [];
          for (t in map) {
            if (t.charAt(0) == "$") entries = entries.concat(map[t]);
          }
          return entries;
        };
        return {
          has: has,
          get: get,
          put: put,
          del: del,
          entries: entries
        };
      }(), selectorEngine, setSelectorEngine = function(e) {
        if (!arguments.length) {
          selectorEngine = doc.querySelectorAll ? function(s, r) {
            return r.querySelectorAll(s);
          } : function() {
            throw new Error("Bean: No selector engine installed");
          };
        } else {
          selectorEngine = e;
        }
      }, rootListener = function(event, type) {
        if (!W3C_MODEL && type && event && event.propertyName != "_on" + type) return;
        var listeners = registry.get(this, type || event.type, null, false), l = listeners.length, i = 0;
        event = new Event(event, this, true);
        if (type) event.type = type;
        for (;i < l && !event.isImmediatePropagationStopped(); i++) {
          if (!listeners[i].removed) listeners[i].handler.call(this, event);
        }
      }, listener = W3C_MODEL ? function(element, type, add) {
        element[add ? addEvent : removeEvent](type, rootListener, false);
      } : function(element, type, add, custom) {
        var entry;
        if (add) {
          registry.put(entry = new RegEntry(element, custom || type, function(event) {
            rootListener.call(element, event, custom);
          }, rootListener, null, null, true));
          if (custom && element["_on" + custom] == null) element["_on" + custom] = 0;
          entry.target.attachEvent("on" + entry.eventType, entry.handler);
        } else {
          entry = registry.get(element, custom || type, rootListener, true)[0];
          if (entry) {
            entry.target.detachEvent("on" + entry.eventType, entry.handler);
            registry.del(entry);
          }
        }
      }, once = function(rm, element, type, fn, originalFn) {
        return function() {
          fn.apply(this, arguments);
          rm(element, type, originalFn);
        };
      }, removeListener = function(element, orgType, handler, namespaces) {
        var type = orgType && orgType.replace(nameRegex, ""), handlers = registry.get(element, type, null, false), removed = {}, i, l;
        for (i = 0, l = handlers.length; i < l; i++) {
          if ((!handler || handlers[i].original === handler) && handlers[i].inNamespaces(namespaces)) {
            registry.del(handlers[i]);
            if (!removed[handlers[i].eventType] && handlers[i][eventSupport]) removed[handlers[i].eventType] = {
              t: handlers[i].eventType,
              c: handlers[i].type
            };
          }
        }
        for (i in removed) {
          if (!registry.has(element, removed[i].t, null, false)) {
            listener(element, removed[i].t, false, removed[i].c);
          }
        }
      }, delegate = function(selector, fn) {
        var findTarget = function(target, root) {
          var i, array = isString(selector) ? selectorEngine(selector, root) : selector;
          for (;target && target !== root; target = target.parentNode) {
            for (i = array.length; i--; ) {
              if (array[i] === target) return target;
            }
          }
        }, handler = function(e) {
          var match = findTarget(e.target, this);
          if (match) fn.apply(match, arguments);
        };
        handler.__beanDel = {
          ft: findTarget,
          selector: selector
        };
        return handler;
      }, fireListener = W3C_MODEL ? function(isNative, type, element) {
        var evt = doc.createEvent(isNative ? "HTMLEvents" : "UIEvents");
        evt[isNative ? "initEvent" : "initUIEvent"](type, true, true, win, 1);
        element.dispatchEvent(evt);
      } : function(isNative, type, element) {
        element = targetElement(element, isNative);
        isNative ? element.fireEvent("on" + type, doc.createEventObject()) : element["_on" + type]++;
      }, off = function(element, typeSpec, fn) {
        var isTypeStr = isString(typeSpec), k, type, namespaces, i;
        if (isTypeStr && typeSpec.indexOf(" ") > 0) {
          typeSpec = str2arr(typeSpec);
          for (i = typeSpec.length; i--; ) off(element, typeSpec[i], fn);
          return element;
        }
        type = isTypeStr && typeSpec.replace(nameRegex, "");
        if (type && customEvents[type]) type = customEvents[type].base;
        if (!typeSpec || isTypeStr) {
          if (namespaces = isTypeStr && typeSpec.replace(namespaceRegex, "")) namespaces = str2arr(namespaces, ".");
          removeListener(element, type, fn, namespaces);
        } else if (isFunction(typeSpec)) {
          removeListener(element, null, typeSpec);
        } else {
          for (k in typeSpec) {
            if (typeSpec.hasOwnProperty(k)) off(element, k, typeSpec[k]);
          }
        }
        return element;
      }, on = function(element, events, selector, fn) {
        var originalFn, type, types, i, args, entry, first;
        if (selector === undefined && typeof events == "object") {
          for (type in events) {
            if (events.hasOwnProperty(type)) {
              on.call(this, element, type, events[type]);
            }
          }
          return;
        }
        if (!isFunction(selector)) {
          originalFn = fn;
          args = slice.call(arguments, 4);
          fn = delegate(selector, originalFn, selectorEngine);
        } else {
          args = slice.call(arguments, 3);
          fn = originalFn = selector;
        }
        types = str2arr(events);
        if (this === ONE) {
          fn = once(off, element, events, fn, originalFn);
        }
        for (i = types.length; i--; ) {
          first = registry.put(entry = new RegEntry(element, types[i].replace(nameRegex, ""), fn, originalFn, str2arr(types[i].replace(namespaceRegex, ""), "."), args, false));
          if (entry[eventSupport] && first) {
            listener(element, entry.eventType, true, entry.customType);
          }
        }
        return element;
      }, add = function(element, events, fn, delfn) {
        return on.apply(null, !isString(fn) ? slice.call(arguments) : [ element, fn, events, delfn ].concat(arguments.length > 3 ? slice.call(arguments, 5) : []));
      }, one = function() {
        return on.apply(ONE, arguments);
      }, fire = function(element, type, args) {
        var types = str2arr(type), i, j, l, names, handlers;
        for (i = types.length; i--; ) {
          type = types[i].replace(nameRegex, "");
          if (names = types[i].replace(namespaceRegex, "")) names = str2arr(names, ".");
          if (!names && !args && element[eventSupport]) {
            fireListener(nativeEvents[type], type, element);
          } else {
            handlers = registry.get(element, type, null, false);
            args = [ false ].concat(args);
            for (j = 0, l = handlers.length; j < l; j++) {
              if (handlers[j].inNamespaces(names)) {
                handlers[j].handler.apply(element, args);
              }
            }
          }
        }
        return element;
      }, clone = function(element, from, type) {
        var handlers = registry.get(from, type, null, false), l = handlers.length, i = 0, args, beanDel;
        for (;i < l; i++) {
          if (handlers[i].original) {
            args = [ element, handlers[i].type ];
            if (beanDel = handlers[i].handler.__beanDel) args.push(beanDel.selector);
            args.push(handlers[i].original);
            on.apply(null, args);
          }
        }
        return element;
      }, bean = {
        on: on,
        add: add,
        one: one,
        off: off,
        remove: off,
        clone: clone,
        fire: fire,
        Event: Event,
        setSelectorEngine: setSelectorEngine,
        noConflict: function() {
          context[name] = old;
          return this;
        }
      };
      if (win.attachEvent) {
        var cleanup = function() {
          var i, entries = registry.entries();
          for (i in entries) {
            if (entries[i].type && entries[i].type !== "unload") off(entries[i].element, entries[i].type);
          }
          win.detachEvent("onunload", cleanup);
          win.CollectGarbage && win.CollectGarbage();
        };
        win.attachEvent("onunload", cleanup);
      }
      setSelectorEngine();
      return bean;
    });
  }, {} ],
  72: [ function(require, module, exports) {
    (function($) {
      "use strict";
      function safe_add(x, y) {
        var lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      }
      function bit_rol(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      }
      function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
      }
      function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn(b & c | ~b & d, a, b, x, s, t);
      }
      function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn(b & d | c & ~d, a, b, x, s, t);
      }
      function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
      }
      function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
      }
      function binl_md5(x, len) {
        x[len >> 5] |= 128 << len % 32;
        x[(len + 64 >>> 9 << 4) + 14] = len;
        var i, olda, oldb, oldc, oldd, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
        for (i = 0; i < x.length; i += 16) {
          olda = a;
          oldb = b;
          oldc = c;
          oldd = d;
          a = md5_ff(a, b, c, d, x[i], 7, -680876936);
          d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
          c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
          b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
          a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
          d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
          c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
          b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
          a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
          d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
          c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
          b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
          a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
          d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
          c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
          b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
          a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
          d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
          c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
          b = md5_gg(b, c, d, a, x[i], 20, -373897302);
          a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
          d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
          c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
          b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
          a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
          d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
          c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
          b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
          a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
          d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
          c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
          b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
          a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
          d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
          c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
          b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
          a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
          d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
          c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
          b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
          a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
          d = md5_hh(d, a, b, c, x[i], 11, -358537222);
          c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
          b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
          a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
          d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
          c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
          b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
          a = md5_ii(a, b, c, d, x[i], 6, -198630844);
          d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
          c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
          b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
          a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
          d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
          c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
          b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
          a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
          d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
          c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
          b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
          a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
          d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
          c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
          b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
          a = safe_add(a, olda);
          b = safe_add(b, oldb);
          c = safe_add(c, oldc);
          d = safe_add(d, oldd);
        }
        return [ a, b, c, d ];
      }
      function binl2rstr(input) {
        var i, output = "";
        for (i = 0; i < input.length * 32; i += 8) {
          output += String.fromCharCode(input[i >> 5] >>> i % 32 & 255);
        }
        return output;
      }
      function rstr2binl(input) {
        var i, output = [];
        output[(input.length >> 2) - 1] = undefined;
        for (i = 0; i < output.length; i += 1) {
          output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
          output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << i % 32;
        }
        return output;
      }
      function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
      }
      function rstr_hmac_md5(key, data) {
        var i, bkey = rstr2binl(key), ipad = [], opad = [], hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) {
          bkey = binl_md5(bkey, key.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
          ipad[i] = bkey[i] ^ 909522486;
          opad[i] = bkey[i] ^ 1549556828;
        }
        hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
      }
      function rstr2hex(input) {
        var hex_tab = "0123456789abcdef", output = "", x, i;
        for (i = 0; i < input.length; i += 1) {
          x = input.charCodeAt(i);
          output += hex_tab.charAt(x >>> 4 & 15) + hex_tab.charAt(x & 15);
        }
        return output;
      }
      function str2rstr_utf8(input) {
        return unescape(encodeURIComponent(input));
      }
      function raw_md5(s) {
        return rstr_md5(str2rstr_utf8(s));
      }
      function hex_md5(s) {
        return rstr2hex(raw_md5(s));
      }
      function raw_hmac_md5(k, d) {
        return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
      }
      function hex_hmac_md5(k, d) {
        return rstr2hex(raw_hmac_md5(k, d));
      }
      function md5(string, key, raw) {
        if (!key) {
          if (!raw) {
            return hex_md5(string);
          }
          return raw_md5(string);
        }
        if (!raw) {
          return hex_hmac_md5(key, string);
        }
        return raw_hmac_md5(key, string);
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return md5;
        });
      } else {
        $.md5 = md5;
      }
    })(this);
  }, {} ],
  73: [ function(require, module, exports) {
    (function(name, context, definition) {
      if (typeof module != "undefined" && module.exports) module.exports = definition(); else if (typeof define == "function" && define.amd) define(definition); else context[name] = definition();
    })("bonzo", this, function() {
      var win = window, doc = win.document, html = doc.documentElement, parentNode = "parentNode", specialAttributes = /^(checked|value|selected|disabled)$/i, specialTags = /^(select|fieldset|table|tbody|tfoot|td|tr|colgroup)$/i, simpleScriptTagRe = /\s*<script +src=['"]([^'"]+)['"]>/, table = [ "<table>", "</table>", 1 ], td = [ "<table><tbody><tr>", "</tr></tbody></table>", 3 ], option = [ "<select>", "</select>", 1 ], noscope = [ "_", "", 0, 1 ], tagMap = {
        thead: table,
        tbody: table,
        tfoot: table,
        colgroup: table,
        caption: table,
        tr: [ "<table><tbody>", "</tbody></table>", 2 ],
        th: td,
        td: td,
        col: [ "<table><colgroup>", "</colgroup></table>", 2 ],
        fieldset: [ "<form>", "</form>", 1 ],
        legend: [ "<form><fieldset>", "</fieldset></form>", 2 ],
        option: option,
        optgroup: option,
        script: noscope,
        style: noscope,
        link: noscope,
        param: noscope,
        base: noscope
      }, stateAttributes = /^(checked|selected|disabled)$/, ie = /msie/i.test(navigator.userAgent), hasClass, addClass, removeClass, uidMap = {}, uuids = 0, digit = /^-?[\d\.]+$/, dattr = /^data-(.+)$/, px = "px", setAttribute = "setAttribute", getAttribute = "getAttribute", byTag = "getElementsByTagName", features = function() {
        var e = doc.createElement("p");
        e.innerHTML = '<a href="#x">x</a><table style="float:left;"></table>';
        return {
          hrefExtended: e[byTag]("a")[0][getAttribute]("href") != "#x",
          autoTbody: e[byTag]("tbody").length !== 0,
          computedStyle: doc.defaultView && doc.defaultView.getComputedStyle,
          cssFloat: e[byTag]("table")[0].style.styleFloat ? "styleFloat" : "cssFloat",
          transform: function() {
            var props = [ "transform", "webkitTransform", "MozTransform", "OTransform", "msTransform" ], i;
            for (i = 0; i < props.length; i++) {
              if (props[i] in e.style) return props[i];
            }
          }(),
          classList: "classList" in e,
          opasity: function() {
            return typeof doc.createElement("a").style.opacity !== "undefined";
          }()
        };
      }(), trimReplace = /(^\s*|\s*$)/g, whitespaceRegex = /\s+/, toString = String.prototype.toString, unitless = {
        lineHeight: 1,
        zoom: 1,
        zIndex: 1,
        opacity: 1,
        boxFlex: 1,
        WebkitBoxFlex: 1,
        MozBoxFlex: 1
      }, query = doc.querySelectorAll && function(selector) {
        return doc.querySelectorAll(selector);
      }, trim = String.prototype.trim ? function(s) {
        return s.trim();
      } : function(s) {
        return s.replace(trimReplace, "");
      }, getStyle = features.computedStyle ? function(el, property) {
        var value = null, computed = doc.defaultView.getComputedStyle(el, "");
        computed && (value = computed[property]);
        return el.style[property] || value;
      } : !(ie && html.currentStyle) ? function(el, property) {
        return el.style[property];
      } : function(el, property) {
        var val, value;
        if (property == "opacity" && !features.opasity) {
          val = 100;
          try {
            val = el["filters"]["DXImageTransform.Microsoft.Alpha"].opacity;
          } catch (e1) {
            try {
              val = el["filters"]("alpha").opacity;
            } catch (e2) {}
          }
          return val / 100;
        }
        value = el.currentStyle ? el.currentStyle[property] : null;
        return el.style[property] || value;
      };
      function isNode(node) {
        return node && node.nodeName && (node.nodeType == 1 || node.nodeType == 11);
      }
      function normalize(node, host, clone) {
        var i, l, ret;
        if (typeof node == "string") return bonzo.create(node);
        if (isNode(node)) node = [ node ];
        if (clone) {
          ret = [];
          for (i = 0, l = node.length; i < l; i++) ret[i] = cloneNode(host, node[i]);
          return ret;
        }
        return node;
      }
      function classReg(c) {
        return new RegExp("(^|\\s+)" + c + "(\\s+|$)");
      }
      function each(ar, fn, opt_scope, opt_rev) {
        var ind, i = 0, l = ar.length;
        for (;i < l; i++) {
          ind = opt_rev ? ar.length - i - 1 : i;
          fn.call(opt_scope || ar[ind], ar[ind], ind, ar);
        }
        return ar;
      }
      function deepEach(ar, fn, opt_scope) {
        for (var i = 0, l = ar.length; i < l; i++) {
          if (isNode(ar[i])) {
            deepEach(ar[i].childNodes, fn, opt_scope);
            fn.call(opt_scope || ar[i], ar[i], i, ar);
          }
        }
        return ar;
      }
      function camelize(s) {
        return s.replace(/-(.)/g, function(m, m1) {
          return m1.toUpperCase();
        });
      }
      function decamelize(s) {
        return s ? s.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() : s;
      }
      function data(el) {
        el[getAttribute]("data-node-uid") || el[setAttribute]("data-node-uid", ++uuids);
        var uid = el[getAttribute]("data-node-uid");
        return uidMap[uid] || (uidMap[uid] = {});
      }
      function clearData(el) {
        var uid = el[getAttribute]("data-node-uid");
        if (uid) delete uidMap[uid];
      }
      function dataValue(d) {
        var f;
        try {
          return d === null || d === undefined ? undefined : d === "true" ? true : d === "false" ? false : d === "null" ? null : (f = parseFloat(d)) == d ? f : d;
        } catch (e) {}
        return undefined;
      }
      function some(ar, fn, opt_scope) {
        for (var i = 0, j = ar.length; i < j; ++i) if (fn.call(opt_scope || null, ar[i], i, ar)) return true;
        return false;
      }
      function styleProperty(p) {
        p == "transform" && (p = features.transform) || /^transform-?[Oo]rigin$/.test(p) && (p = features.transform + "Origin") || p == "float" && (p = features.cssFloat);
        return p ? camelize(p) : null;
      }
      function insert(target, host, fn, rev) {
        var i = 0, self = host || this, r = [], nodes = query && typeof target == "string" && target.charAt(0) != "<" ? query(target) : target;
        each(normalize(nodes), function(t, j) {
          each(self, function(el) {
            fn(t, r[i++] = j > 0 ? cloneNode(self, el) : el);
          }, null, rev);
        }, this, rev);
        self.length = i;
        each(r, function(e) {
          self[--i] = e;
        }, null, !rev);
        return self;
      }
      function xy(el, x, y) {
        var $el = bonzo(el), style = $el.css("position"), offset = $el.offset(), rel = "relative", isRel = style == rel, delta = [ parseInt($el.css("left"), 10), parseInt($el.css("top"), 10) ];
        if (style == "static") {
          $el.css("position", rel);
          style = rel;
        }
        isNaN(delta[0]) && (delta[0] = isRel ? 0 : el.offsetLeft);
        isNaN(delta[1]) && (delta[1] = isRel ? 0 : el.offsetTop);
        x != null && (el.style.left = x - offset.left + delta[0] + px);
        y != null && (el.style.top = y - offset.top + delta[1] + px);
      }
      if (features.classList) {
        hasClass = function(el, c) {
          return el.classList.contains(c);
        };
        addClass = function(el, c) {
          el.classList.add(c);
        };
        removeClass = function(el, c) {
          el.classList.remove(c);
        };
      } else {
        hasClass = function(el, c) {
          return classReg(c).test(el.className);
        };
        addClass = function(el, c) {
          el.className = trim(el.className + " " + c);
        };
        removeClass = function(el, c) {
          el.className = trim(el.className.replace(classReg(c), " "));
        };
      }
      function setter(el, v) {
        return typeof v == "function" ? v(el) : v;
      }
      function scroll(x, y, type) {
        var el = this[0];
        if (!el) return this;
        if (x == null && y == null) {
          return (isBody(el) ? getWindowScroll() : {
            x: el.scrollLeft,
            y: el.scrollTop
          })[type];
        }
        if (isBody(el)) {
          win.scrollTo(x, y);
        } else {
          x != null && (el.scrollLeft = x);
          y != null && (el.scrollTop = y);
        }
        return this;
      }
      function Bonzo(elements) {
        this.length = 0;
        if (elements) {
          elements = typeof elements !== "string" && !elements.nodeType && typeof elements.length !== "undefined" ? elements : [ elements ];
          this.length = elements.length;
          for (var i = 0; i < elements.length; i++) this[i] = elements[i];
        }
      }
      Bonzo.prototype = {
        get: function(index) {
          return this[index] || null;
        },
        each: function(fn, opt_scope) {
          return each(this, fn, opt_scope);
        },
        deepEach: function(fn, opt_scope) {
          return deepEach(this, fn, opt_scope);
        },
        map: function(fn, opt_reject) {
          var m = [], n, i;
          for (i = 0; i < this.length; i++) {
            n = fn.call(this, this[i], i);
            opt_reject ? opt_reject(n) && m.push(n) : m.push(n);
          }
          return m;
        },
        html: function(h, opt_text) {
          var method = opt_text ? html.textContent === undefined ? "innerText" : "textContent" : "innerHTML", that = this, append = function(el, i) {
            each(normalize(h, that, i), function(node) {
              el.appendChild(node);
            });
          }, updateElement = function(el, i) {
            try {
              if (opt_text || typeof h == "string" && !specialTags.test(el.tagName)) {
                return el[method] = h;
              }
            } catch (e) {}
            append(el, i);
          };
          return typeof h != "undefined" ? this.empty().each(updateElement) : this[0] ? this[0][method] : "";
        },
        text: function(opt_text) {
          return this.html(opt_text, true);
        },
        append: function(node) {
          var that = this;
          return this.each(function(el, i) {
            each(normalize(node, that, i), function(i) {
              el.appendChild(i);
            });
          });
        },
        prepend: function(node) {
          var that = this;
          return this.each(function(el, i) {
            var first = el.firstChild;
            each(normalize(node, that, i), function(i) {
              el.insertBefore(i, first);
            });
          });
        },
        appendTo: function(target, opt_host) {
          return insert.call(this, target, opt_host, function(t, el) {
            t.appendChild(el);
          });
        },
        prependTo: function(target, opt_host) {
          return insert.call(this, target, opt_host, function(t, el) {
            t.insertBefore(el, t.firstChild);
          }, 1);
        },
        before: function(node) {
          var that = this;
          return this.each(function(el, i) {
            each(normalize(node, that, i), function(i) {
              el[parentNode].insertBefore(i, el);
            });
          });
        },
        after: function(node) {
          var that = this;
          return this.each(function(el, i) {
            each(normalize(node, that, i), function(i) {
              el[parentNode].insertBefore(i, el.nextSibling);
            }, null, 1);
          });
        },
        insertBefore: function(target, opt_host) {
          return insert.call(this, target, opt_host, function(t, el) {
            t[parentNode].insertBefore(el, t);
          });
        },
        insertAfter: function(target, opt_host) {
          return insert.call(this, target, opt_host, function(t, el) {
            var sibling = t.nextSibling;
            sibling ? t[parentNode].insertBefore(el, sibling) : t[parentNode].appendChild(el);
          }, 1);
        },
        replaceWith: function(node) {
          return bonzo(this[0].parentNode.replaceChild(bonzo(normalize(node))[0], this[0]));
        },
        clone: function(opt_host) {
          var ret = [], l, i;
          for (i = 0, l = this.length; i < l; i++) ret[i] = cloneNode(opt_host || this, this[i]);
          return bonzo(ret);
        },
        addClass: function(c) {
          c = toString.call(c).split(whitespaceRegex);
          return this.each(function(el) {
            each(c, function(c) {
              if (c && !hasClass(el, setter(el, c))) addClass(el, setter(el, c));
            });
          });
        },
        removeClass: function(c) {
          c = toString.call(c).split(whitespaceRegex);
          return this.each(function(el) {
            each(c, function(c) {
              if (c && hasClass(el, setter(el, c))) removeClass(el, setter(el, c));
            });
          });
        },
        hasClass: function(c) {
          c = toString.call(c).split(whitespaceRegex);
          return some(this, function(el) {
            return some(c, function(c) {
              return c && hasClass(el, c);
            });
          });
        },
        toggleClass: function(c, opt_condition) {
          c = toString.call(c).split(whitespaceRegex);
          return this.each(function(el) {
            each(c, function(c) {
              if (c) {
                typeof opt_condition !== "undefined" ? opt_condition ? !hasClass(el, c) && addClass(el, c) : removeClass(el, c) : hasClass(el, c) ? removeClass(el, c) : addClass(el, c);
              }
            });
          });
        },
        show: function(opt_type) {
          opt_type = typeof opt_type == "string" ? opt_type : "";
          return this.each(function(el) {
            el.style.display = opt_type;
          });
        },
        hide: function() {
          return this.each(function(el) {
            el.style.display = "none";
          });
        },
        toggle: function(opt_callback, opt_type) {
          opt_type = typeof opt_type == "string" ? opt_type : "";
          typeof opt_callback != "function" && (opt_callback = null);
          return this.each(function(el) {
            el.style.display = el.offsetWidth || el.offsetHeight ? "none" : opt_type;
            opt_callback && opt_callback.call(el);
          });
        },
        first: function() {
          return bonzo(this.length ? this[0] : []);
        },
        last: function() {
          return bonzo(this.length ? this[this.length - 1] : []);
        },
        next: function() {
          return this.related("nextSibling");
        },
        previous: function() {
          return this.related("previousSibling");
        },
        parent: function() {
          return this.related(parentNode);
        },
        related: function(method) {
          return bonzo(this.map(function(el) {
            el = el[method];
            while (el && el.nodeType !== 1) {
              el = el[method];
            }
            return el || 0;
          }, function(el) {
            return el;
          }));
        },
        focus: function() {
          this.length && this[0].focus();
          return this;
        },
        blur: function() {
          this.length && this[0].blur();
          return this;
        },
        css: function(o, opt_v) {
          var p, iter = o;
          if (opt_v === undefined && typeof o == "string") {
            opt_v = this[0];
            if (!opt_v) return null;
            if (opt_v === doc || opt_v === win) {
              p = opt_v === doc ? bonzo.doc() : bonzo.viewport();
              return o == "width" ? p.width : o == "height" ? p.height : "";
            }
            return (o = styleProperty(o)) ? getStyle(opt_v, o) : null;
          }
          if (typeof o == "string") {
            iter = {};
            iter[o] = opt_v;
          }
          if (!features.opasity && "opacity" in iter) {
            iter.filter = iter.opacity != null && iter.opacity !== "" ? "alpha(opacity=" + iter.opacity * 100 + ")" : "";
            iter.zoom = o.zoom || 1;
            delete iter.opacity;
          }
          function fn(el, p, v) {
            for (var k in iter) {
              if (iter.hasOwnProperty(k)) {
                v = iter[k];
                (p = styleProperty(k)) && digit.test(v) && !(p in unitless) && (v += px);
                try {
                  el.style[p] = setter(el, v);
                } catch (e) {}
              }
            }
          }
          return this.each(fn);
        },
        offset: function(opt_x, opt_y) {
          if (opt_x && typeof opt_x == "object" && (typeof opt_x.top == "number" || typeof opt_x.left == "number")) {
            return this.each(function(el) {
              xy(el, opt_x.left, opt_x.top);
            });
          } else if (typeof opt_x == "number" || typeof opt_y == "number") {
            return this.each(function(el) {
              xy(el, opt_x, opt_y);
            });
          }
          if (!this[0]) return {
            top: 0,
            left: 0,
            height: 0,
            width: 0
          };
          var el = this[0], de = el.ownerDocument.documentElement, bcr = el.getBoundingClientRect(), scroll = getWindowScroll(), width = el.offsetWidth, height = el.offsetHeight, top = bcr.top + scroll.y - Math.max(0, de && de.clientTop, doc.body.clientTop), left = bcr.left + scroll.x - Math.max(0, de && de.clientLeft, doc.body.clientLeft);
          return {
            top: top,
            left: left,
            height: height,
            width: width
          };
        },
        dim: function() {
          if (!this.length) return {
            height: 0,
            width: 0
          };
          var el = this[0], de = el.nodeType == 9 && el.documentElement, orig = !de && !!el.style && !el.offsetWidth && !el.offsetHeight ? function(t) {
            var s = {
              position: el.style.position || "",
              visibility: el.style.visibility || "",
              display: el.style.display || ""
            };
            t.first().css({
              position: "absolute",
              visibility: "hidden",
              display: "block"
            });
            return s;
          }(this) : null, width = de ? Math.max(el.body.scrollWidth, el.body.offsetWidth, de.scrollWidth, de.offsetWidth, de.clientWidth) : el.offsetWidth, height = de ? Math.max(el.body.scrollHeight, el.body.offsetHeight, de.scrollHeight, de.offsetHeight, de.clientHeight) : el.offsetHeight;
          orig && this.first().css(orig);
          return {
            height: height,
            width: width
          };
        },
        attr: function(k, opt_v) {
          var el = this[0], n;
          if (typeof k != "string" && !(k instanceof String)) {
            for (n in k) {
              k.hasOwnProperty(n) && this.attr(n, k[n]);
            }
            return this;
          }
          return typeof opt_v == "undefined" ? !el ? null : specialAttributes.test(k) ? stateAttributes.test(k) && typeof el[k] == "string" ? true : el[k] : (k == "href" || k == "src") && features.hrefExtended ? el[getAttribute](k, 2) : el[getAttribute](k) : this.each(function(el) {
            specialAttributes.test(k) ? el[k] = setter(el, opt_v) : el[setAttribute](k, setter(el, opt_v));
          });
        },
        removeAttr: function(k) {
          return this.each(function(el) {
            stateAttributes.test(k) ? el[k] = false : el.removeAttribute(k);
          });
        },
        val: function(s) {
          return typeof s == "string" || typeof s == "number" ? this.attr("value", s) : this.length ? this[0].value : null;
        },
        data: function(opt_k, opt_v) {
          var el = this[0], o, m;
          if (typeof opt_v === "undefined") {
            if (!el) return null;
            o = data(el);
            if (typeof opt_k === "undefined") {
              each(el.attributes, function(a) {
                (m = ("" + a.name).match(dattr)) && (o[camelize(m[1])] = dataValue(a.value));
              });
              return o;
            } else {
              if (typeof o[opt_k] === "undefined") o[opt_k] = dataValue(this.attr("data-" + decamelize(opt_k)));
              return o[opt_k];
            }
          } else {
            return this.each(function(el) {
              data(el)[opt_k] = opt_v;
            });
          }
        },
        remove: function() {
          this.deepEach(clearData);
          return this.detach();
        },
        empty: function() {
          return this.each(function(el) {
            deepEach(el.childNodes, clearData);
            while (el.firstChild) {
              el.removeChild(el.firstChild);
            }
          });
        },
        detach: function() {
          return this.each(function(el) {
            el[parentNode] && el[parentNode].removeChild(el);
          });
        },
        scrollTop: function(y) {
          return scroll.call(this, null, y, "y");
        },
        scrollLeft: function(x) {
          return scroll.call(this, x, null, "x");
        }
      };
      function cloneNode(host, el) {
        var c = el.cloneNode(true), cloneElems, elElems, i;
        if (host.$ && typeof host.cloneEvents == "function") {
          host.$(c).cloneEvents(el);
          cloneElems = host.$(c).find("*");
          elElems = host.$(el).find("*");
          for (i = 0; i < elElems.length; i++) host.$(cloneElems[i]).cloneEvents(elElems[i]);
        }
        return c;
      }
      function isBody(element) {
        return element === win || /^(?:body|html)$/i.test(element.tagName);
      }
      function getWindowScroll() {
        return {
          x: win.pageXOffset || html.scrollLeft,
          y: win.pageYOffset || html.scrollTop
        };
      }
      function createScriptFromHtml(html) {
        var scriptEl = document.createElement("script"), matches = html.match(simpleScriptTagRe);
        scriptEl.src = matches[1];
        return scriptEl;
      }
      function bonzo(els) {
        return new Bonzo(els);
      }
      bonzo.setQueryEngine = function(q) {
        query = q;
        delete bonzo.setQueryEngine;
      };
      bonzo.aug = function(o, target) {
        for (var k in o) {
          o.hasOwnProperty(k) && ((target || Bonzo.prototype)[k] = o[k]);
        }
      };
      bonzo.create = function(node) {
        return typeof node == "string" && node !== "" ? function() {
          if (simpleScriptTagRe.test(node)) return [ createScriptFromHtml(node) ];
          var tag = node.match(/^\s*<([^\s>]+)/), el = doc.createElement("div"), els = [], p = tag ? tagMap[tag[1].toLowerCase()] : null, dep = p ? p[2] + 1 : 1, ns = p && p[3], pn = parentNode, tb = features.autoTbody && p && p[0] == "<table>" && !/<tbody/i.test(node);
          el.innerHTML = p ? p[0] + node + p[1] : node;
          while (dep--) el = el.firstChild;
          if (ns && el && el.nodeType !== 1) el = el.nextSibling;
          do {
            if ((!tag || el.nodeType == 1) && (!tb || el.tagName && el.tagName != "TBODY")) {
              els.push(el);
            }
          } while (el = el.nextSibling);
          each(els, function(el) {
            el[pn] && el[pn].removeChild(el);
          });
          return els;
        }() : isNode(node) ? [ node.cloneNode(true) ] : [];
      };
      bonzo.doc = function() {
        var vp = bonzo.viewport();
        return {
          width: Math.max(doc.body.scrollWidth, html.scrollWidth, vp.width),
          height: Math.max(doc.body.scrollHeight, html.scrollHeight, vp.height)
        };
      };
      bonzo.firstChild = function(el) {
        for (var c = el.childNodes, i = 0, j = c && c.length || 0, e; i < j; i++) {
          if (c[i].nodeType === 1) e = c[j = i];
        }
        return e;
      };
      bonzo.viewport = function() {
        return {
          width: ie ? html.clientWidth : win.innerWidth,
          height: ie ? html.clientHeight : win.innerHeight
        };
      };
      bonzo.isAncestor = "compareDocumentPosition" in html ? function(container, element) {
        return (container.compareDocumentPosition(element) & 16) == 16;
      } : "contains" in html ? function(container, element) {
        return container !== element && container.contains(element);
      } : function(container, element) {
        while (element = element[parentNode]) {
          if (element === container) {
            return true;
          }
        }
        return false;
      };
      return bonzo;
    });
  }, {} ],
  74: [ function(require, module, exports) {}, {} ],
  75: [ function(require, module, exports) {
    function EventEmitter() {
      this._events = this._events || {};
      this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError("n must be a positive number");
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.emit = function(type) {
      var er, handler, len, args, i, listeners;
      if (!this._events) this._events = {};
      if (type === "error") {
        if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
          er = arguments[1];
          if (er instanceof Error) {
            throw er;
          }
          throw TypeError('Uncaught, unspecified "error" event.');
        }
      }
      handler = this._events[type];
      if (isUndefined(handler)) return false;
      if (isFunction(handler)) {
        switch (arguments.length) {
         case 1:
          handler.call(this);
          break;

         case 2:
          handler.call(this, arguments[1]);
          break;

         case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;

         default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++) args[i - 1] = arguments[i];
          handler.apply(this, args);
        }
      } else if (isObject(handler)) {
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++) args[i - 1] = arguments[i];
        listeners = handler.slice();
        len = listeners.length;
        for (i = 0; i < len; i++) listeners[i].apply(this, args);
      }
      return true;
    };
    EventEmitter.prototype.addListener = function(type, listener) {
      var m;
      if (!isFunction(listener)) throw TypeError("listener must be a function");
      if (!this._events) this._events = {};
      if (this._events.newListener) this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
      if (!this._events[type]) this._events[type] = listener; else if (isObject(this._events[type])) this._events[type].push(listener); else this._events[type] = [ this._events[type], listener ];
      if (isObject(this._events[type]) && !this._events[type].warned) {
        var m;
        if (!isUndefined(this._maxListeners)) {
          m = this._maxListeners;
        } else {
          m = EventEmitter.defaultMaxListeners;
        }
        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true;
          console.error("(node) warning: possible EventEmitter memory " + "leak detected. %d listeners added. " + "Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
          if (typeof console.trace === "function") {
            console.trace();
          }
        }
      }
      return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function(type, listener) {
      if (!isFunction(listener)) throw TypeError("listener must be a function");
      var fired = false;
      function g() {
        this.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(this, arguments);
        }
      }
      g.listener = listener;
      this.on(type, g);
      return this;
    };
    EventEmitter.prototype.removeListener = function(type, listener) {
      var list, position, length, i;
      if (!isFunction(listener)) throw TypeError("listener must be a function");
      if (!this._events || !this._events[type]) return this;
      list = this._events[type];
      length = list.length;
      position = -1;
      if (list === listener || isFunction(list.listener) && list.listener === listener) {
        delete this._events[type];
        if (this._events.removeListener) this.emit("removeListener", type, listener);
      } else if (isObject(list)) {
        for (i = length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            position = i;
            break;
          }
        }
        if (position < 0) return this;
        if (list.length === 1) {
          list.length = 0;
          delete this._events[type];
        } else {
          list.splice(position, 1);
        }
        if (this._events.removeListener) this.emit("removeListener", type, listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type) {
      var key, listeners;
      if (!this._events) return this;
      if (!this._events.removeListener) {
        if (arguments.length === 0) this._events = {}; else if (this._events[type]) delete this._events[type];
        return this;
      }
      if (arguments.length === 0) {
        for (key in this._events) {
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = {};
        return this;
      }
      listeners = this._events[type];
      if (isFunction(listeners)) {
        this.removeListener(type, listeners);
      } else {
        while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
      }
      delete this._events[type];
      return this;
    };
    EventEmitter.prototype.listeners = function(type) {
      var ret;
      if (!this._events || !this._events[type]) ret = []; else if (isFunction(this._events[type])) ret = [ this._events[type] ]; else ret = this._events[type].slice();
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      var ret;
      if (!emitter._events || !emitter._events[type]) ret = 0; else if (isFunction(emitter._events[type])) ret = 1; else ret = emitter._events[type].length;
      return ret;
    };
    function isFunction(arg) {
      return typeof arg === "function";
    }
    function isNumber(arg) {
      return typeof arg === "number";
    }
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    function isUndefined(arg) {
      return arg === void 0;
    }
  }, {} ],
  76: [ function(require, module, exports) {
    (function(window) {
      var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
        if (a === b) {
          hasDuplicate = true;
        }
        return 0;
      }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function(elem) {
        var i = 0, len = this.length;
        for (;i < len; i++) {
          if (this[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)", rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
        ID: new RegExp("^#(" + identifier + ")"),
        CLASS: new RegExp("^\\.(" + identifier + ")"),
        TAG: new RegExp("^(" + identifier + "|[*])"),
        ATTR: new RegExp("^" + attributes),
        PSEUDO: new RegExp("^" + pseudos),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + booleans + ")$", "i"),
        needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
      }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
        var high = "0x" + escaped - 65536;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      };
      try {
        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length ? function(target, els) {
            push_native.apply(target, slice.call(els));
          } : function(target, els) {
            var j = target.length, i = 0;
            while (target[j++] = els[i++]) {}
            target.length = j - 1;
          }
        };
      }
      function Sizzle(selector, context, results, seed) {
        var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        results = results || [];
        if (!selector || typeof selector !== "string") {
          return results;
        }
        if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
          return [];
        }
        if (documentIsHTML && !seed) {
          if (match = rquickExpr.exec(selector)) {
            if (m = match[1]) {
              if (nodeType === 9) {
                elem = context.getElementById(m);
                if (elem && elem.parentNode) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            nid = old = expando;
            newContext = context;
            newSelector = nodeType === 9 && selector;
            if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
              groups = tokenize(selector);
              if (old = context.getAttribute("id")) {
                nid = old.replace(rescape, "\\$&");
              } else {
                context.setAttribute("id", nid);
              }
              nid = "[id='" + nid + "'] ";
              i = groups.length;
              while (i--) {
                groups[i] = nid + toSelector(groups[i]);
              }
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              newSelector = groups.join(",");
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (!old) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }
      function createCache() {
        var keys = [];
        function cache(key, value) {
          if (keys.push(key + " ") > Expr.cacheLength) {
            delete cache[keys.shift()];
          }
          return cache[key + " "] = value;
        }
        return cache;
      }
      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }
      function assert(fn) {
        var div = document.createElement("div");
        try {
          return !!fn(div);
        } catch (e) {
          return false;
        } finally {
          if (div.parentNode) {
            div.parentNode.removeChild(div);
          }
          div = null;
        }
      }
      function addHandle(attrs, handler) {
        var arr = attrs.split("|"), i = attrs.length;
        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }
      function siblingCheck(a, b) {
        var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
        if (diff) {
          return diff;
        }
        if (cur) {
          while (cur = cur.nextSibling) {
            if (cur === b) {
              return -1;
            }
          }
        }
        return a ? 1 : -1;
      }
      function createInputPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
        };
      }
      function createButtonPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") && elem.type === type;
        };
      }
      function createPositionalPseudo(fn) {
        return markFunction(function(argument) {
          argument = +argument;
          return markFunction(function(seed, matches) {
            var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
            while (i--) {
              if (seed[j = matchIndexes[i]]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }
      function testContext(context) {
        return context && typeof context.getElementsByTagName !== strundefined && context;
      }
      support = Sizzle.support = {};
      isXML = Sizzle.isXML = function(elem) {
        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
      };
      setDocument = Sizzle.setDocument = function(node) {
        var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        }
        document = doc;
        docElem = doc.documentElement;
        documentIsHTML = !isXML(doc);
        if (parent && parent !== parent.top) {
          if (parent.addEventListener) {
            parent.addEventListener("unload", function() {
              setDocument();
            }, false);
          } else if (parent.attachEvent) {
            parent.attachEvent("onunload", function() {
              setDocument();
            });
          }
        }
        support.attributes = assert(function(div) {
          div.className = "i";
          return !div.getAttribute("className");
        });
        support.getElementsByTagName = assert(function(div) {
          div.appendChild(doc.createComment(""));
          return !div.getElementsByTagName("*").length;
        });
        support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
        support.getById = assert(function(div) {
          docElem.appendChild(div).id = expando;
          return !doc.getElementsByName || !doc.getElementsByName(expando).length;
        });
        if (support.getById) {
          Expr.find["ID"] = function(id, context) {
            if (typeof context.getElementById !== strundefined && documentIsHTML) {
              var m = context.getElementById(id);
              return m && m.parentNode ? [ m ] : [];
            }
          };
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
        } else {
          delete Expr.find["ID"];
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          };
        }
        Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
          if (typeof context.getElementsByTagName !== strundefined) {
            return context.getElementsByTagName(tag);
          }
        } : function(tag, context) {
          var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
          if (tag === "*") {
            while (elem = results[i++]) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }
            return tmp;
          }
          return results;
        };
        Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
          if (documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        rbuggyMatches = [];
        rbuggyQSA = [];
        if (support.qsa = rnative.test(doc.querySelectorAll)) {
          assert(function(div) {
            div.innerHTML = "<select msallowcapture=''><option selected=''></option></select>";
            if (div.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            }
            if (!div.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!div.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
          });
          assert(function(div) {
            var input = doc.createElement("input");
            input.setAttribute("type", "hidden");
            div.appendChild(input).setAttribute("name", "D");
            if (div.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            }
            if (!div.querySelectorAll(":enabled").length) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            div.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }
        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
          assert(function(div) {
            support.disconnectedMatch = matches.call(div, "div");
            matches.call(div, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }
        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
        hasCompare = rnative.test(docElem.compareDocumentPosition);
        contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
          var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        } : function(a, b) {
          if (b) {
            while (b = b.parentNode) {
              if (b === a) {
                return true;
              }
            }
          }
          return false;
        };
        sortOrder = hasCompare ? function(a, b) {
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }
          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
          if (compare) {
            return compare;
          }
          compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
              return -1;
            }
            if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
              return 1;
            }
            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        } : function(a, b) {
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }
          var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
          if (!aup || !bup) {
            return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
          } else if (aup === bup) {
            return siblingCheck(a, b);
          }
          cur = a;
          while (cur = cur.parentNode) {
            ap.unshift(cur);
          }
          cur = b;
          while (cur = cur.parentNode) {
            bp.unshift(cur);
          }
          while (ap[i] === bp[i]) {
            i++;
          }
          return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
        };
        return doc;
      };
      Sizzle.matches = function(expr, elements) {
        return Sizzle(expr, null, null, elements);
      };
      Sizzle.matchesSelector = function(elem, expr) {
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }
        expr = expr.replace(rattributeQuotes, "='$1']");
        if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr);
            if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {}
        }
        return Sizzle(expr, document, null, [ elem ]).length > 0;
      };
      Sizzle.contains = function(context, elem) {
        if ((context.ownerDocument || context) !== document) {
          setDocument(context);
        }
        return contains(context, elem);
      };
      Sizzle.attr = function(elem, name) {
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }
        var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      };
      Sizzle.error = function(msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      Sizzle.uniqueSort = function(results) {
        var elem, duplicates = [], j = 0, i = 0;
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);
        if (hasDuplicate) {
          while (elem = results[i++]) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }
          while (j--) {
            results.splice(duplicates[j], 1);
          }
        }
        sortInput = null;
        return results;
      };
      getText = Sizzle.getText = function(elem) {
        var node, ret = "", i = 0, nodeType = elem.nodeType;
        if (!nodeType) {
          while (node = elem[i++]) {
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        return ret;
      };
      Expr = Sizzle.selectors = {
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          ">": {
            dir: "parentNode",
            first: true
          },
          " ": {
            dir: "parentNode"
          },
          "+": {
            dir: "previousSibling",
            first: true
          },
          "~": {
            dir: "previousSibling"
          }
        },
        preFilter: {
          ATTR: function(match) {
            match[1] = match[1].replace(runescape, funescape);
            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }
            return match.slice(0, 4);
          },
          CHILD: function(match) {
            match[1] = match[1].toLowerCase();
            if (match[1].slice(0, 3) === "nth") {
              if (!match[3]) {
                Sizzle.error(match[0]);
              }
              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +(match[7] + match[8] || match[3] === "odd");
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }
            return match;
          },
          PSEUDO: function(match) {
            var excess, unquoted = !match[6] && match[2];
            if (matchExpr["CHILD"].test(match[0])) {
              return null;
            }
            if (match[3]) {
              match[2] = match[4] || match[5] || "";
            } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            }
            return match.slice(0, 3);
          }
        },
        filter: {
          TAG: function(nodeNameSelector) {
            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ? function() {
              return true;
            } : function(elem) {
              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
            };
          },
          CLASS: function(className) {
            var pattern = classCache[className + " "];
            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
            });
          },
          ATTR: function(name, operator, check) {
            return function(elem) {
              var result = Sizzle.attr(elem, name);
              if (result == null) {
                return operator === "!=";
              }
              if (!operator) {
                return true;
              }
              result += "";
              return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            };
          },
          CHILD: function(type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
            return first === 1 && last === 0 ? function(elem) {
              return !!elem.parentNode;
            } : function(elem, context, xml) {
              var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
              if (parent) {
                if (simple) {
                  while (dir) {
                    node = elem;
                    while (node = node[dir]) {
                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                        return false;
                      }
                    }
                    start = dir = type === "only" && !start && "nextSibling";
                  }
                  return true;
                }
                start = [ forward ? parent.firstChild : parent.lastChild ];
                if (forward && useCache) {
                  outerCache = parent[expando] || (parent[expando] = {});
                  cache = outerCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = cache[0] === dirruns && cache[2];
                  node = nodeIndex && parent.childNodes[nodeIndex];
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if (node.nodeType === 1 && ++diff && node === elem) {
                      outerCache[type] = [ dirruns, nodeIndex, diff ];
                      break;
                    }
                  }
                } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                  diff = cache[1];
                } else {
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        (node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
                diff -= last;
                return diff === first || diff % first === 0 && diff / first >= 0;
              }
            };
          },
          PSEUDO: function(pseudo, argument) {
            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
            if (fn[expando]) {
              return fn(argument);
            }
            if (fn.length > 1) {
              args = [ pseudo, pseudo, "", argument ];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                var idx, matched = fn(seed, argument), i = matched.length;
                while (i--) {
                  idx = indexOf.call(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) : function(elem) {
                return fn(elem, 0, args);
              };
            }
            return fn;
          }
        },
        pseudos: {
          not: markFunction(function(selector) {
            var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
            return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
              var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
              while (i--) {
                if (elem = unmatched[i]) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) : function(elem, context, xml) {
              input[0] = elem;
              matcher(input, null, xml, results);
              return !results.pop();
            };
          }),
          has: markFunction(function(selector) {
            return function(elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),
          contains: markFunction(function(text) {
            text = text.replace(runescape, funescape);
            return function(elem) {
              return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
            };
          }),
          lang: markFunction(function(lang) {
            if (!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function(elem) {
              var elemLang;
              do {
                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),
          target: function(elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          root: function(elem) {
            return elem === docElem;
          },
          focus: function(elem) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          enabled: function(elem) {
            return elem.disabled === false;
          },
          disabled: function(elem) {
            return elem.disabled === true;
          },
          checked: function(elem) {
            var nodeName = elem.nodeName.toLowerCase();
            return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
          },
          selected: function(elem) {
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }
            return elem.selected === true;
          },
          empty: function(elem) {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },
          parent: function(elem) {
            return !Expr.pseudos["empty"](elem);
          },
          header: function(elem) {
            return rheader.test(elem.nodeName);
          },
          input: function(elem) {
            return rinputs.test(elem.nodeName);
          },
          button: function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
          },
          text: function(elem) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
          },
          first: createPositionalPseudo(function() {
            return [ 0 ];
          }),
          last: createPositionalPseudo(function(matchIndexes, length) {
            return [ length - 1 ];
          }),
          eq: createPositionalPseudo(function(matchIndexes, length, argument) {
            return [ argument < 0 ? argument + length : argument ];
          }),
          even: createPositionalPseudo(function(matchIndexes, length) {
            var i = 0;
            for (;i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          odd: createPositionalPseudo(function(matchIndexes, length) {
            var i = 1;
            for (;i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          lt: createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (;--i >= 0; ) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),
          gt: createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (;++i < length; ) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          })
        }
      };
      Expr.pseudos["nth"] = Expr.pseudos["eq"];
      for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for (i in {
        submit: true,
        reset: true
      }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }
      function setFilters() {}
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();
      tokenize = Sizzle.tokenize = function(selector, parseOnly) {
        var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }
        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;
        while (soFar) {
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              soFar = soFar.slice(match[0].length) || soFar;
            }
            groups.push(tokens = []);
          }
          matched = false;
          if (match = rcombinators.exec(soFar)) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: match[0].replace(rtrim, " ")
            });
            soFar = soFar.slice(matched.length);
          }
          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }
          if (!matched) {
            break;
          }
        }
        return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
      };
      function toSelector(tokens) {
        var i = 0, len = tokens.length, selector = "";
        for (;i < len; i++) {
          selector += tokens[i].value;
        }
        return selector;
      }
      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
        return combinator.first ? function(elem, context, xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml);
            }
          }
        } : function(elem, context, xml) {
          var oldCache, outerCache, newCache = [ dirruns, doneName ];
          if (xml) {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {});
                if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  return newCache[2] = oldCache[2];
                } else {
                  outerCache[dir] = newCache;
                  if (newCache[2] = matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            }
          }
        };
      }
      function elementMatcher(matchers) {
        return matchers.length > 1 ? function(elem, context, xml) {
          var i = matchers.length;
          while (i--) {
            if (!matchers[i](elem, context, xml)) {
              return false;
            }
          }
          return true;
        } : matchers[0];
      }
      function multipleContexts(selector, contexts, results) {
        var i = 0, len = contexts.length;
        for (;i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }
        return results;
      }
      function condense(unmatched, map, filter, context, xml) {
        var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
        for (;i < len; i++) {
          if (elem = unmatched[i]) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);
              if (mapped) {
                map.push(i);
              }
            }
          }
        }
        return newUnmatched;
      }
      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function(seed, results, context, xml) {
          var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          }
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml);
            i = temp.length;
            while (i--) {
              if (elem = temp[i]) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }
          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                temp = [];
                i = matcherOut.length;
                while (i--) {
                  if (elem = matcherOut[i]) {
                    temp.push(matcherIn[i] = elem);
                  }
                }
                postFinder(null, matcherOut = [], temp, xml);
              }
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            }
          } else {
            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }
      function matcherFromTokens(tokens) {
        var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
          return indexOf.call(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [ function(elem, context, xml) {
          return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
        } ];
        for (;i < len; i++) {
          if (matcher = Expr.relative[tokens[i].type]) {
            matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
            if (matcher[expando]) {
              j = ++i;
              for (;j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                value: tokens[i - 2].type === " " ? "*" : ""
              })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
            }
            matchers.push(matcher);
          }
        }
        return elementMatcher(matchers);
      }
      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
          var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
          if (outermost) {
            outermostContext = context !== document && context;
          }
          for (;i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
        return bySet ? markFunction(superMatcher) : superMatcher;
      }
      compile = Sizzle.compile = function(selector, match) {
        var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
        if (!cached) {
          if (!match) {
            match = tokenize(selector);
          }
          i = match.length;
          while (i--) {
            cached = matcherFromTokens(match[i]);
            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }
          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
          cached.selector = selector;
        }
        return cached;
      };
      select = Sizzle.select = function(selector, context, results, seed) {
        var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
        results = results || [];
        if (match.length === 1) {
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            } else if (compiled) {
              context = context.parentNode;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find = Expr.find[type]) {
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
        return results;
      };
      support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
      support.detectDuplicates = !!hasDuplicate;
      setDocument();
      support.sortDetached = assert(function(div1) {
        return div1.compareDocumentPosition(document.createElement("div")) & 1;
      });
      if (!assert(function(div) {
        div.innerHTML = "<a href='#'></a>";
        return div.firstChild.getAttribute("href") === "#";
      })) {
        addHandle("type|href|height|width", function(elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
          }
        });
      }
      if (!support.attributes || !assert(function(div) {
        div.innerHTML = "<input/>";
        div.firstChild.setAttribute("value", "");
        return div.firstChild.getAttribute("value") === "";
      })) {
        addHandle("value", function(elem, name, isXML) {
          if (!isXML && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      }
      if (!assert(function(div) {
        return div.getAttribute("disabled") == null;
      })) {
        addHandle(booleans, function(elem, name, isXML) {
          var val;
          if (!isXML) {
            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          }
        });
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Sizzle;
        });
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = Sizzle;
      } else {
        window.Sizzle = Sizzle;
      }
    })(window);
  }, {} ],
  77: [ function(require, module, exports) {
    exports = module.exports = trim;
    function trim(str) {
      return str.replace(/^\s*|\s*$/g, "");
    }
    exports.left = function(str) {
      return str.replace(/^\s*/, "");
    };
    exports.right = function(str) {
      return str.replace(/\s*$/, "");
    };
  }, {} ],
  78: [ function(require, module, exports) {
    (function() {
      var root = this;
      var previousUnderscore = root._;
      var breaker = {};
      var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
      var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
      var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
      var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
      };
      if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
          exports = module.exports = _;
        }
        exports._ = _;
      } else {
        root._ = _;
      }
      _.VERSION = "1.5.2";
      var each = _.each = _.forEach = function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, length = obj.length; i < length; i++) {
            if (iterator.call(context, obj[i], i, obj) === breaker) return;
          }
        } else {
          var keys = _.keys(obj);
          for (var i = 0, length = keys.length; i < length; i++) {
            if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
          }
        }
      };
      _.map = _.collect = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
        each(obj, function(value, index, list) {
          results.push(iterator.call(context, value, index, list));
        });
        return results;
      };
      var reduceError = "Reduce of empty array with no initial value";
      _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduce && obj.reduce === nativeReduce) {
          if (context) iterator = _.bind(iterator, context);
          return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }
        each(obj, function(value, index, list) {
          if (!initial) {
            memo = value;
            initial = true;
          } else {
            memo = iterator.call(context, memo, value, index, list);
          }
        });
        if (!initial) throw new TypeError(reduceError);
        return memo;
      };
      _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
          if (context) iterator = _.bind(iterator, context);
          return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
        }
        var length = obj.length;
        if (length !== +length) {
          var keys = _.keys(obj);
          length = keys.length;
        }
        each(obj, function(value, index, list) {
          index = keys ? keys[--length] : --length;
          if (!initial) {
            memo = obj[index];
            initial = true;
          } else {
            memo = iterator.call(context, memo, obj[index], index, list);
          }
        });
        if (!initial) throw new TypeError(reduceError);
        return memo;
      };
      _.find = _.detect = function(obj, iterator, context) {
        var result;
        any(obj, function(value, index, list) {
          if (iterator.call(context, value, index, list)) {
            result = value;
            return true;
          }
        });
        return result;
      };
      _.filter = _.select = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
        each(obj, function(value, index, list) {
          if (iterator.call(context, value, index, list)) results.push(value);
        });
        return results;
      };
      _.reject = function(obj, iterator, context) {
        return _.filter(obj, function(value, index, list) {
          return !iterator.call(context, value, index, list);
        }, context);
      };
      _.every = _.all = function(obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = true;
        if (obj == null) return result;
        if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
        each(obj, function(value, index, list) {
          if (!(result = result && iterator.call(context, value, index, list))) return breaker;
        });
        return !!result;
      };
      var any = _.some = _.any = function(obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = false;
        if (obj == null) return result;
        if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
        each(obj, function(value, index, list) {
          if (result || (result = iterator.call(context, value, index, list))) return breaker;
        });
        return !!result;
      };
      _.contains = _.include = function(obj, target) {
        if (obj == null) return false;
        if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
        return any(obj, function(value) {
          return value === target;
        });
      };
      _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
          return (isFunc ? method : value[method]).apply(value, args);
        });
      };
      _.pluck = function(obj, key) {
        return _.map(obj, function(value) {
          return value[key];
        });
      };
      _.where = function(obj, attrs, first) {
        if (_.isEmpty(attrs)) return first ? void 0 : [];
        return _[first ? "find" : "filter"](obj, function(value) {
          for (var key in attrs) {
            if (attrs[key] !== value[key]) return false;
          }
          return true;
        });
      };
      _.findWhere = function(obj, attrs) {
        return _.where(obj, attrs, true);
      };
      _.max = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
          return Math.max.apply(Math, obj);
        }
        if (!iterator && _.isEmpty(obj)) return -Infinity;
        var result = {
          computed: -Infinity,
          value: -Infinity
        };
        each(obj, function(value, index, list) {
          var computed = iterator ? iterator.call(context, value, index, list) : value;
          computed > result.computed && (result = {
            value: value,
            computed: computed
          });
        });
        return result.value;
      };
      _.min = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
          return Math.min.apply(Math, obj);
        }
        if (!iterator && _.isEmpty(obj)) return Infinity;
        var result = {
          computed: Infinity,
          value: Infinity
        };
        each(obj, function(value, index, list) {
          var computed = iterator ? iterator.call(context, value, index, list) : value;
          computed < result.computed && (result = {
            value: value,
            computed: computed
          });
        });
        return result.value;
      };
      _.shuffle = function(obj) {
        var rand;
        var index = 0;
        var shuffled = [];
        each(obj, function(value) {
          rand = _.random(index++);
          shuffled[index - 1] = shuffled[rand];
          shuffled[rand] = value;
        });
        return shuffled;
      };
      _.sample = function(obj, n, guard) {
        if (arguments.length < 2 || guard) {
          return obj[_.random(obj.length - 1)];
        }
        return _.shuffle(obj).slice(0, Math.max(0, n));
      };
      var lookupIterator = function(value) {
        return _.isFunction(value) ? value : function(obj) {
          return obj[value];
        };
      };
      _.sortBy = function(obj, value, context) {
        var iterator = lookupIterator(value);
        return _.pluck(_.map(obj, function(value, index, list) {
          return {
            value: value,
            index: index,
            criteria: iterator.call(context, value, index, list)
          };
        }).sort(function(left, right) {
          var a = left.criteria;
          var b = right.criteria;
          if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
          }
          return left.index - right.index;
        }), "value");
      };
      var group = function(behavior) {
        return function(obj, value, context) {
          var result = {};
          var iterator = value == null ? _.identity : lookupIterator(value);
          each(obj, function(value, index) {
            var key = iterator.call(context, value, index, obj);
            behavior(result, key, value);
          });
          return result;
        };
      };
      _.groupBy = group(function(result, key, value) {
        (_.has(result, key) ? result[key] : result[key] = []).push(value);
      });
      _.indexBy = group(function(result, key, value) {
        result[key] = value;
      });
      _.countBy = group(function(result, key) {
        _.has(result, key) ? result[key]++ : result[key] = 1;
      });
      _.sortedIndex = function(array, obj, iterator, context) {
        iterator = iterator == null ? _.identity : lookupIterator(iterator);
        var value = iterator.call(context, obj);
        var low = 0, high = array.length;
        while (low < high) {
          var mid = low + high >>> 1;
          iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
      };
      _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (obj.length === +obj.length) return _.map(obj, _.identity);
        return _.values(obj);
      };
      _.size = function(obj) {
        if (obj == null) return 0;
        return obj.length === +obj.length ? obj.length : _.keys(obj).length;
      };
      _.first = _.head = _.take = function(array, n, guard) {
        if (array == null) return void 0;
        return n == null || guard ? array[0] : slice.call(array, 0, n);
      };
      _.initial = function(array, n, guard) {
        return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
      };
      _.last = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) {
          return array[array.length - 1];
        } else {
          return slice.call(array, Math.max(array.length - n, 0));
        }
      };
      _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
      };
      _.compact = function(array) {
        return _.filter(array, _.identity);
      };
      var flatten = function(input, shallow, output) {
        if (shallow && _.every(input, _.isArray)) {
          return concat.apply(output, input);
        }
        each(input, function(value) {
          if (_.isArray(value) || _.isArguments(value)) {
            shallow ? push.apply(output, value) : flatten(value, shallow, output);
          } else {
            output.push(value);
          }
        });
        return output;
      };
      _.flatten = function(array, shallow) {
        return flatten(array, shallow, []);
      };
      _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
      };
      _.uniq = _.unique = function(array, isSorted, iterator, context) {
        if (_.isFunction(isSorted)) {
          context = iterator;
          iterator = isSorted;
          isSorted = false;
        }
        var initial = iterator ? _.map(array, iterator, context) : array;
        var results = [];
        var seen = [];
        each(initial, function(value, index) {
          if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
            seen.push(value);
            results.push(array[index]);
          }
        });
        return results;
      };
      _.union = function() {
        return _.uniq(_.flatten(arguments, true));
      };
      _.intersection = function(array) {
        var rest = slice.call(arguments, 1);
        return _.filter(_.uniq(array), function(item) {
          return _.every(rest, function(other) {
            return _.indexOf(other, item) >= 0;
          });
        });
      };
      _.difference = function(array) {
        var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
        return _.filter(array, function(value) {
          return !_.contains(rest, value);
        });
      };
      _.zip = function() {
        var length = _.max(_.pluck(arguments, "length").concat(0));
        var results = new Array(length);
        for (var i = 0; i < length; i++) {
          results[i] = _.pluck(arguments, "" + i);
        }
        return results;
      };
      _.object = function(list, values) {
        if (list == null) return {};
        var result = {};
        for (var i = 0, length = list.length; i < length; i++) {
          if (values) {
            result[list[i]] = values[i];
          } else {
            result[list[i][0]] = list[i][1];
          }
        }
        return result;
      };
      _.indexOf = function(array, item, isSorted) {
        if (array == null) return -1;
        var i = 0, length = array.length;
        if (isSorted) {
          if (typeof isSorted == "number") {
            i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
          } else {
            i = _.sortedIndex(array, item);
            return array[i] === item ? i : -1;
          }
        }
        if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
        for (;i < length; i++) if (array[i] === item) return i;
        return -1;
      };
      _.lastIndexOf = function(array, item, from) {
        if (array == null) return -1;
        var hasIndex = from != null;
        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
          return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
        }
        var i = hasIndex ? from : array.length;
        while (i--) if (array[i] === item) return i;
        return -1;
      };
      _.range = function(start, stop, step) {
        if (arguments.length <= 1) {
          stop = start || 0;
          start = 0;
        }
        step = arguments[2] || 1;
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(length);
        while (idx < length) {
          range[idx++] = start;
          start += step;
        }
        return range;
      };
      var ctor = function() {};
      _.bind = function(func, context) {
        var args, bound;
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError();
        args = slice.call(arguments, 2);
        return bound = function() {
          if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
          ctor.prototype = func.prototype;
          var self = new ctor();
          ctor.prototype = null;
          var result = func.apply(self, args.concat(slice.call(arguments)));
          if (Object(result) === result) return result;
          return self;
        };
      };
      _.partial = function(func) {
        var args = slice.call(arguments, 1);
        return function() {
          return func.apply(this, args.concat(slice.call(arguments)));
        };
      };
      _.bindAll = function(obj) {
        var funcs = slice.call(arguments, 1);
        if (funcs.length === 0) throw new Error("bindAll must be passed function names");
        each(funcs, function(f) {
          obj[f] = _.bind(obj[f], obj);
        });
        return obj;
      };
      _.memoize = function(func, hasher) {
        var memo = {};
        hasher || (hasher = _.identity);
        return function() {
          var key = hasher.apply(this, arguments);
          return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
        };
      };
      _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function() {
          return func.apply(null, args);
        }, wait);
      };
      _.defer = function(func) {
        return _.delay.apply(_, [ func, 1 ].concat(slice.call(arguments, 1)));
      };
      _.throttle = function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        options || (options = {});
        var later = function() {
          previous = options.leading === false ? 0 : new Date();
          timeout = null;
          result = func.apply(context, args);
        };
        return function() {
          var now = new Date();
          if (!previous && options.leading === false) previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0) {
            clearTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
      };
      _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        return function() {
          context = this;
          args = arguments;
          timestamp = new Date();
          var later = function() {
            var last = new Date() - timestamp;
            if (last < wait) {
              timeout = setTimeout(later, wait - last);
            } else {
              timeout = null;
              if (!immediate) result = func.apply(context, args);
            }
          };
          var callNow = immediate && !timeout;
          if (!timeout) {
            timeout = setTimeout(later, wait);
          }
          if (callNow) result = func.apply(context, args);
          return result;
        };
      };
      _.once = function(func) {
        var ran = false, memo;
        return function() {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      };
      _.wrap = function(func, wrapper) {
        return function() {
          var args = [ func ];
          push.apply(args, arguments);
          return wrapper.apply(this, args);
        };
      };
      _.compose = function() {
        var funcs = arguments;
        return function() {
          var args = arguments;
          for (var i = funcs.length - 1; i >= 0; i--) {
            args = [ funcs[i].apply(this, args) ];
          }
          return args[0];
        };
      };
      _.after = function(times, func) {
        return function() {
          if (--times < 1) {
            return func.apply(this, arguments);
          }
        };
      };
      _.keys = nativeKeys || function(obj) {
        if (obj !== Object(obj)) throw new TypeError("Invalid object");
        var keys = [];
        for (var key in obj) if (_.has(obj, key)) keys.push(key);
        return keys;
      };
      _.values = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = new Array(length);
        for (var i = 0; i < length; i++) {
          values[i] = obj[keys[i]];
        }
        return values;
      };
      _.pairs = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = new Array(length);
        for (var i = 0; i < length; i++) {
          pairs[i] = [ keys[i], obj[keys[i]] ];
        }
        return pairs;
      };
      _.invert = function(obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          result[obj[keys[i]]] = keys[i];
        }
        return result;
      };
      _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
          if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
      };
      _.extend = function(obj) {
        each(slice.call(arguments, 1), function(source) {
          if (source) {
            for (var prop in source) {
              obj[prop] = source[prop];
            }
          }
        });
        return obj;
      };
      _.pick = function(obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        each(keys, function(key) {
          if (key in obj) copy[key] = obj[key];
        });
        return copy;
      };
      _.omit = function(obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        for (var key in obj) {
          if (!_.contains(keys, key)) copy[key] = obj[key];
        }
        return copy;
      };
      _.defaults = function(obj) {
        each(slice.call(arguments, 1), function(source) {
          if (source) {
            for (var prop in source) {
              if (obj[prop] === void 0) obj[prop] = source[prop];
            }
          }
        });
        return obj;
      };
      _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
      };
      _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
      };
      var eq = function(a, b, aStack, bStack) {
        if (a === b) return a !== 0 || 1 / a == 1 / b;
        if (a == null || b == null) return a === b;
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        var className = toString.call(a);
        if (className != toString.call(b)) return false;
        switch (className) {
         case "[object String]":
          return a == String(b);

         case "[object Number]":
          return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

         case "[object Date]":
         case "[object Boolean]":
          return +a == +b;

         case "[object RegExp]":
          return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
        }
        if (typeof a != "object" || typeof b != "object") return false;
        var length = aStack.length;
        while (length--) {
          if (aStack[length] == a) return bStack[length] == b;
        }
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) {
          return false;
        }
        aStack.push(a);
        bStack.push(b);
        var size = 0, result = true;
        if (className == "[object Array]") {
          size = a.length;
          result = size == b.length;
          if (result) {
            while (size--) {
              if (!(result = eq(a[size], b[size], aStack, bStack))) break;
            }
          }
        } else {
          for (var key in a) {
            if (_.has(a, key)) {
              size++;
              if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
            }
          }
          if (result) {
            for (key in b) {
              if (_.has(b, key) && !size--) break;
            }
            result = !size;
          }
        }
        aStack.pop();
        bStack.pop();
        return result;
      };
      _.isEqual = function(a, b) {
        return eq(a, b, [], []);
      };
      _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
        for (var key in obj) if (_.has(obj, key)) return false;
        return true;
      };
      _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
      };
      _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) == "[object Array]";
      };
      _.isObject = function(obj) {
        return obj === Object(obj);
      };
      each([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(name) {
        _["is" + name] = function(obj) {
          return toString.call(obj) == "[object " + name + "]";
        };
      });
      if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
          return !!(obj && _.has(obj, "callee"));
        };
      }
      if (typeof /./ !== "function") {
        _.isFunction = function(obj) {
          return typeof obj === "function";
        };
      }
      _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
      };
      _.isNaN = function(obj) {
        return _.isNumber(obj) && obj != +obj;
      };
      _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) == "[object Boolean]";
      };
      _.isNull = function(obj) {
        return obj === null;
      };
      _.isUndefined = function(obj) {
        return obj === void 0;
      };
      _.has = function(obj, key) {
        return hasOwnProperty.call(obj, key);
      };
      _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
      };
      _.identity = function(value) {
        return value;
      };
      _.times = function(n, iterator, context) {
        var accum = Array(Math.max(0, n));
        for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
        return accum;
      };
      _.random = function(min, max) {
        if (max == null) {
          max = min;
          min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
      };
      var entityMap = {
        escape: {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#x27;"
        }
      };
      entityMap.unescape = _.invert(entityMap.escape);
      var entityRegexes = {
        escape: new RegExp("[" + _.keys(entityMap.escape).join("") + "]", "g"),
        unescape: new RegExp("(" + _.keys(entityMap.unescape).join("|") + ")", "g")
      };
      _.each([ "escape", "unescape" ], function(method) {
        _[method] = function(string) {
          if (string == null) return "";
          return ("" + string).replace(entityRegexes[method], function(match) {
            return entityMap[method][match];
          });
        };
      });
      _.result = function(object, property) {
        if (object == null) return void 0;
        var value = object[property];
        return _.isFunction(value) ? value.call(object) : value;
      };
      _.mixin = function(obj) {
        each(_.functions(obj), function(name) {
          var func = _[name] = obj[name];
          _.prototype[name] = function() {
            var args = [ this._wrapped ];
            push.apply(args, arguments);
            return result.call(this, func.apply(_, args));
          };
        });
      };
      var idCounter = 0;
      _.uniqueId = function(prefix) {
        var id = ++idCounter + "";
        return prefix ? prefix + id : id;
      };
      _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
      };
      var noMatch = /(.)^/;
      var escapes = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
      _.template = function(text, data, settings) {
        var render;
        settings = _.defaults({}, settings, _.templateSettings);
        var matcher = new RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g");
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
          source += text.slice(index, offset).replace(escaper, function(match) {
            return "\\" + escapes[match];
          });
          if (escape) {
            source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
          }
          if (interpolate) {
            source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
          }
          if (evaluate) {
            source += "';\n" + evaluate + "\n__p+='";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        if (!settings.variable) source = "with(obj||{}){\n" + source + "}\n";
        source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
        try {
          render = new Function(settings.variable || "obj", "_", source);
        } catch (e) {
          e.source = source;
          throw e;
        }
        if (data) return render(data, _);
        var template = function(data) {
          return render.call(this, data, _);
        };
        template.source = "function(" + (settings.variable || "obj") + "){\n" + source + "}";
        return template;
      };
      _.chain = function(obj) {
        return _(obj).chain();
      };
      var result = function(obj) {
        return this._chain ? _(obj).chain() : obj;
      };
      _.mixin(_);
      each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          var obj = this._wrapped;
          method.apply(obj, arguments);
          if ((name == "shift" || name == "splice") && obj.length === 0) delete obj[0];
          return result.call(this, obj);
        };
      });
      each([ "concat", "join", "slice" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
          return result.call(this, method.apply(this._wrapped, arguments));
        };
      });
      _.extend(_.prototype, {
        chain: function() {
          this._chain = true;
          return this;
        },
        value: function() {
          return this._wrapped;
        }
      });
    }).call(this);
  }, {} ],
  79: [ function(require, module, exports) {
    (function(global) {
      var Auth0Lock = require("./");
      if (typeof global.window.define == "function" && global.window.define.amd) {
        global.window.define("auth0-lock", function() {
          return Auth0Lock;
        });
      } else if (global.window) {
        global.window.Auth0Lock = Auth0Lock;
      }
    }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {
    "./": 16
  } ]
}, {}, [ 79 ]);
(function() {
  angular.module("angular-storage", [ "angular-storage.store" ]);
  angular.module("angular-storage.internalStore", [ "angular-storage.storage" ]).factory("InternalStore", [ "storage", function(storage) {
    function InternalStore(namespace, delimiter) {
      this.namespace = namespace || null;
      this.delimiter = delimiter || ".";
      this.inMemoryCache = {};
    }
    InternalStore.prototype.getNamespacedKey = function(key) {
      if (!this.namespace) {
        return key;
      } else {
        return [ this.namespace, key ].join(this.delimiter);
      }
    };
    InternalStore.prototype.set = function(name, elem) {
      this.inMemoryCache[name] = elem;
      storage.set(this.getNamespacedKey(name), JSON.stringify(elem));
    };
    InternalStore.prototype.get = function(name) {
      if (name in this.inMemoryCache) {
        return this.inMemoryCache[name];
      }
      var saved = storage.get(this.getNamespacedKey(name));
      var obj = saved ? JSON.parse(saved) : null;
      this.inMemoryCache[name] = obj;
      return obj;
    };
    InternalStore.prototype.remove = function(name) {
      this.inMemoryCache[name] = null;
      storage.remove(this.getNamespacedKey(name));
    };
    return InternalStore;
  } ]);
  angular.module("angular-storage.storage", []).service("storage", [ "$window", function($window) {
    if ($window.localStorage) {
      this.set = function(what, value) {
        return $window.localStorage.setItem(what, value);
      };
      this.get = function(what) {
        return $window.localStorage.getItem(what);
      };
      this.remove = function(what) {
        return $window.localStorage.removeItem(what);
      };
    } else {
      var $cookieStore = $injector.get("$cookieStore");
      this.set = function(what, value) {
        return $cookieStore.put(what, value);
      };
      this.get = function(what) {
        return $cookieStore.get(what);
      };
      this.remove = function(what) {
        return $cookieStore.remove(what);
      };
    }
  } ]);
  angular.module("angular-storage.store", [ "angular-storage.internalStore" ]).factory("store", [ "InternalStore", function(InternalStore) {
    var store = new InternalStore();
    store.getNamespacedStore = function(namespace, key) {
      return new InternalStore(namespace, key);
    };
    return store;
  } ]);
})();
(function() {
  angular.module("angular-jwt", [ "angular-jwt.interceptor", "angular-jwt.jwt" ]);
  angular.module("angular-jwt.interceptor", []).provider("jwtInterceptor", function() {
    this.authHeader = "Authorization";
    this.authPrefix = "Bearer ";
    this.tokenGetter = function() {
      return null;
    };
    var config = this;
    this.$get = [ "$q", "$injector", "$rootScope", function($q, $injector, $rootScope) {
      return {
        request: function(request) {
          if (request.skipAuthorization) {
            return request;
          }
          request.headers = request.headers || {};
          if (request.headers[config.authHeader]) {
            return request;
          }
          var tokenPromise = $q.when($injector.invoke(config.tokenGetter, this, {
            config: request
          }));
          return tokenPromise.then(function(token) {
            if (token) {
              request.headers[config.authHeader] = config.authPrefix + token;
            }
            return request;
          });
        },
        responseError: function(response) {
          if (response.status === 401) {
            $rootScope.$broadcast("unauthenticated", response);
          }
          return $q.reject(response);
        }
      };
    } ];
  });
  angular.module("angular-jwt.jwt", []).service("jwtHelper", function() {
    this.urlBase64Decode = function(str) {
      var output = str.replace("-", "+").replace("_", "/");
      switch (output.length % 4) {
       case 0:
        {
          break;
        }

       case 2:
        {
          output += "==";
          break;
        }

       case 3:
        {
          output += "=";
          break;
        }

       default:
        {
          throw "Illegal base64url string!";
        }
      }
      return window.atob(output);
    };
    this.decodeToken = function(token) {
      var parts = token.split(".");
      if (parts.length !== 3) {
        throw new Error("JWT must have 3 parts");
      }
      var decoded = this.urlBase64Decode(parts[1]);
      if (!decoded) {
        throw new Error("Cannot decode the token");
      }
      return JSON.parse(decoded);
    };
    this.getTokenExpirationDate = function(token) {
      var decoded;
      decoded = this.decodeToken(token);
      if (!decoded.exp) {
        return null;
      }
      var d = new Date(0);
      d.setUTCSeconds(decoded.exp);
      return d;
    };
    this.isTokenExpired = function(token) {
      var d = this.getTokenExpirationDate(token);
      if (!d) {
        return false;
      }
      return !(d.valueOf() > new Date().valueOf());
    };
  });
})();
(function() {
  var define, requireModule, require, requirejs;
  (function() {
    var registry = {}, seen = {};
    define = function(name, deps, callback) {
      registry[name] = {
        deps: deps,
        callback: callback
      };
    };
    requirejs = require = requireModule = function(name) {
      requirejs._eak_seen = registry;
      if (seen[name]) {
        return seen[name];
      }
      seen[name] = {};
      if (!registry[name]) {
        throw new Error("Could not find module " + name);
      }
      var mod = registry[name], deps = mod.deps, callback = mod.callback, reified = [], exports;
      for (var i = 0, l = deps.length; i < l; i++) {
        if (deps[i] === "exports") {
          reified.push(exports = {});
        } else {
          reified.push(requireModule(resolve(deps[i])));
        }
      }
      var value = callback.apply(this, reified);
      return seen[name] = exports || value;
      function resolve(child) {
        if (child.charAt(0) !== ".") {
          return child;
        }
        var parts = child.split("/");
        var parentBase = name.split("/").slice(0, -1);
        for (var i = 0, l = parts.length; i < l; i++) {
          var part = parts[i];
          if (part === "..") {
            parentBase.pop();
          } else if (part === ".") {
            continue;
          } else {
            parentBase.push(part);
          }
        }
        return parentBase.join("/");
      }
    };
  })();
  define("promise/all", [ "./utils", "exports" ], function(__dependency1__, __exports__) {
    "use strict";
    var isArray = __dependency1__.isArray;
    var isFunction = __dependency1__.isFunction;
    function all(promises) {
      var Promise = this;
      if (!isArray(promises)) {
        throw new TypeError("You must pass an array to all.");
      }
      return new Promise(function(resolve, reject) {
        var results = [], remaining = promises.length, promise;
        if (remaining === 0) {
          resolve([]);
        }
        function resolver(index) {
          return function(value) {
            resolveAll(index, value);
          };
        }
        function resolveAll(index, value) {
          results[index] = value;
          if (--remaining === 0) {
            resolve(results);
          }
        }
        for (var i = 0; i < promises.length; i++) {
          promise = promises[i];
          if (promise && isFunction(promise.then)) {
            promise.then(resolver(i), reject);
          } else {
            resolveAll(i, promise);
          }
        }
      });
    }
    __exports__.all = all;
  });
  define("promise/asap", [ "exports" ], function(__exports__) {
    "use strict";
    var browserGlobal = typeof window !== "undefined" ? window : {};
    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
    var local = typeof global !== "undefined" ? global : this === undefined ? window : this;
    function useNextTick() {
      return function() {
        process.nextTick(flush);
      };
    }
    function useMutationObserver() {
      var iterations = 0;
      var observer = new BrowserMutationObserver(flush);
      var node = document.createTextNode("");
      observer.observe(node, {
        characterData: true
      });
      return function() {
        node.data = iterations = ++iterations % 2;
      };
    }
    function useSetTimeout() {
      return function() {
        local.setTimeout(flush, 1);
      };
    }
    var queue = [];
    function flush() {
      for (var i = 0; i < queue.length; i++) {
        var tuple = queue[i];
        var callback = tuple[0], arg = tuple[1];
        callback(arg);
      }
      queue = [];
    }
    var scheduleFlush;
    if (typeof process !== "undefined" && {}.toString.call(process) === "[object process]") {
      scheduleFlush = useNextTick();
    } else if (BrowserMutationObserver) {
      scheduleFlush = useMutationObserver();
    } else {
      scheduleFlush = useSetTimeout();
    }
    function asap(callback, arg) {
      var length = queue.push([ callback, arg ]);
      if (length === 1) {
        scheduleFlush();
      }
    }
    __exports__.asap = asap;
  });
  define("promise/config", [ "exports" ], function(__exports__) {
    "use strict";
    var config = {
      instrument: false
    };
    function configure(name, value) {
      if (arguments.length === 2) {
        config[name] = value;
      } else {
        return config[name];
      }
    }
    __exports__.config = config;
    __exports__.configure = configure;
  });
  define("promise/polyfill", [ "./promise", "./utils", "exports" ], function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RSVPPromise = __dependency1__.Promise;
    var isFunction = __dependency2__.isFunction;
    function polyfill() {
      var local;
      if (typeof global !== "undefined") {
        local = global;
      } else if (typeof window !== "undefined" && window.document) {
        local = window;
      } else {
        local = self;
      }
      var es6PromiseSupport = "Promise" in local && "resolve" in local.Promise && "reject" in local.Promise && "all" in local.Promise && "race" in local.Promise && function() {
        var resolve;
        new local.Promise(function(r) {
          resolve = r;
        });
        return isFunction(resolve);
      }();
      if (!es6PromiseSupport) {
        local.Promise = RSVPPromise;
      }
    }
    __exports__.polyfill = polyfill;
  });
  define("promise/promise", [ "./config", "./utils", "./all", "./race", "./resolve", "./reject", "./asap", "exports" ], function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
    "use strict";
    var config = __dependency1__.config;
    var configure = __dependency1__.configure;
    var objectOrFunction = __dependency2__.objectOrFunction;
    var isFunction = __dependency2__.isFunction;
    var now = __dependency2__.now;
    var all = __dependency3__.all;
    var race = __dependency4__.race;
    var staticResolve = __dependency5__.resolve;
    var staticReject = __dependency6__.reject;
    var asap = __dependency7__.asap;
    var counter = 0;
    config.async = asap;
    function Promise(resolver) {
      if (!isFunction(resolver)) {
        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
      }
      if (!(this instanceof Promise)) {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      this._subscribers = [];
      invokeResolver(resolver, this);
    }
    function invokeResolver(resolver, promise) {
      function resolvePromise(value) {
        resolve(promise, value);
      }
      function rejectPromise(reason) {
        reject(promise, reason);
      }
      try {
        resolver(resolvePromise, rejectPromise);
      } catch (e) {
        rejectPromise(e);
      }
    }
    function invokeCallback(settled, promise, callback, detail) {
      var hasCallback = isFunction(callback), value, error, succeeded, failed;
      if (hasCallback) {
        try {
          value = callback(detail);
          succeeded = true;
        } catch (e) {
          failed = true;
          error = e;
        }
      } else {
        value = detail;
        succeeded = true;
      }
      if (handleThenable(promise, value)) {
        return;
      } else if (hasCallback && succeeded) {
        resolve(promise, value);
      } else if (failed) {
        reject(promise, error);
      } else if (settled === FULFILLED) {
        resolve(promise, value);
      } else if (settled === REJECTED) {
        reject(promise, value);
      }
    }
    var PENDING = void 0;
    var SEALED = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    function subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;
      subscribers[length] = child;
      subscribers[length + FULFILLED] = onFulfillment;
      subscribers[length + REJECTED] = onRejection;
    }
    function publish(promise, settled) {
      var child, callback, subscribers = promise._subscribers, detail = promise._detail;
      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];
        invokeCallback(settled, child, callback, detail);
      }
      promise._subscribers = null;
    }
    Promise.prototype = {
      constructor: Promise,
      _state: undefined,
      _detail: undefined,
      _subscribers: undefined,
      then: function(onFulfillment, onRejection) {
        var promise = this;
        var thenPromise = new this.constructor(function() {});
        if (this._state) {
          var callbacks = arguments;
          config.async(function invokePromiseCallback() {
            invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
          });
        } else {
          subscribe(this, thenPromise, onFulfillment, onRejection);
        }
        return thenPromise;
      },
      "catch": function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    Promise.all = all;
    Promise.race = race;
    Promise.resolve = staticResolve;
    Promise.reject = staticReject;
    function handleThenable(promise, value) {
      var then = null, resolved;
      try {
        if (promise === value) {
          throw new TypeError("A promises callback cannot return that same promise.");
        }
        if (objectOrFunction(value)) {
          then = value.then;
          if (isFunction(then)) {
            then.call(value, function(val) {
              if (resolved) {
                return true;
              }
              resolved = true;
              if (value !== val) {
                resolve(promise, val);
              } else {
                fulfill(promise, val);
              }
            }, function(val) {
              if (resolved) {
                return true;
              }
              resolved = true;
              reject(promise, val);
            });
            return true;
          }
        }
      } catch (error) {
        if (resolved) {
          return true;
        }
        reject(promise, error);
        return true;
      }
      return false;
    }
    function resolve(promise, value) {
      if (promise === value) {
        fulfill(promise, value);
      } else if (!handleThenable(promise, value)) {
        fulfill(promise, value);
      }
    }
    function fulfill(promise, value) {
      if (promise._state !== PENDING) {
        return;
      }
      promise._state = SEALED;
      promise._detail = value;
      config.async(publishFulfillment, promise);
    }
    function reject(promise, reason) {
      if (promise._state !== PENDING) {
        return;
      }
      promise._state = SEALED;
      promise._detail = reason;
      config.async(publishRejection, promise);
    }
    function publishFulfillment(promise) {
      publish(promise, promise._state = FULFILLED);
    }
    function publishRejection(promise) {
      publish(promise, promise._state = REJECTED);
    }
    __exports__.Promise = Promise;
  });
  define("promise/race", [ "./utils", "exports" ], function(__dependency1__, __exports__) {
    "use strict";
    var isArray = __dependency1__.isArray;
    function race(promises) {
      var Promise = this;
      if (!isArray(promises)) {
        throw new TypeError("You must pass an array to race.");
      }
      return new Promise(function(resolve, reject) {
        var results = [], promise;
        for (var i = 0; i < promises.length; i++) {
          promise = promises[i];
          if (promise && typeof promise.then === "function") {
            promise.then(resolve, reject);
          } else {
            resolve(promise);
          }
        }
      });
    }
    __exports__.race = race;
  });
  define("promise/reject", [ "exports" ], function(__exports__) {
    "use strict";
    function reject(reason) {
      var Promise = this;
      return new Promise(function(resolve, reject) {
        reject(reason);
      });
    }
    __exports__.reject = reject;
  });
  define("promise/resolve", [ "exports" ], function(__exports__) {
    "use strict";
    function resolve(value) {
      if (value && typeof value === "object" && value.constructor === this) {
        return value;
      }
      var Promise = this;
      return new Promise(function(resolve) {
        resolve(value);
      });
    }
    __exports__.resolve = resolve;
  });
  define("promise/utils", [ "exports" ], function(__exports__) {
    "use strict";
    function objectOrFunction(x) {
      return isFunction(x) || typeof x === "object" && x !== null;
    }
    function isFunction(x) {
      return typeof x === "function";
    }
    function isArray(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    }
    var now = Date.now || function() {
      return new Date().getTime();
    };
    __exports__.objectOrFunction = objectOrFunction;
    __exports__.isFunction = isFunction;
    __exports__.isArray = isArray;
    __exports__.now = now;
  });
  requireModule("promise/polyfill").polyfill();
})();

(function() {
  "use strict";
  var Promise = typeof module !== "undefined" && module.exports ? require("promise") : this.Promise;
  var indexedDB = indexedDB || this.indexedDB || this.webkitIndexedDB || this.mozIndexedDB || this.OIndexedDB || this.msIndexedDB;
  if (!indexedDB) {
    return;
  }
  function _initStorage(options) {
    var self = this;
    var dbInfo = {
      db: null
    };
    if (options) {
      for (var i in options) {
        dbInfo[i] = options[i];
      }
    }
    return new Promise(function(resolve, reject) {
      var openreq = indexedDB.open(dbInfo.name, dbInfo.version);
      openreq.onerror = function() {
        reject(openreq.error);
      };
      openreq.onupgradeneeded = function() {
        openreq.result.createObjectStore(dbInfo.storeName);
      };
      openreq.onsuccess = function() {
        dbInfo.db = openreq.result;
        self._dbInfo = dbInfo;
        resolve();
      };
    });
  }
  function getItem(key, callback) {
    var self = this;
    if (typeof key !== "string") {
      window.console.warn(key + " used as a key, but it is not a string.");
      key = String(key);
    }
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        var store = dbInfo.db.transaction(dbInfo.storeName, "readonly").objectStore(dbInfo.storeName);
        var req = store.get(key);
        req.onsuccess = function() {
          var value = req.result;
          if (value === undefined) {
            value = null;
          }
          resolve(value);
        };
        req.onerror = function() {
          reject(req.error);
        };
      })["catch"](reject);
    });
    executeDeferedCallback(promise, callback);
    return promise;
  }
  function setItem(key, value, callback) {
    var self = this;
    if (typeof key !== "string") {
      window.console.warn(key + " used as a key, but it is not a string.");
      key = String(key);
    }
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        var store = dbInfo.db.transaction(dbInfo.storeName, "readwrite").objectStore(dbInfo.storeName);
        if (value === null) {
          value = undefined;
        }
        var req = store.put(value, key);
        req.onsuccess = function() {
          if (value === undefined) {
            value = null;
          }
          resolve(value);
        };
        req.onerror = function() {
          reject(req.error);
        };
      })["catch"](reject);
    });
    executeDeferedCallback(promise, callback);
    return promise;
  }
  function removeItem(key, callback) {
    var self = this;
    if (typeof key !== "string") {
      window.console.warn(key + " used as a key, but it is not a string.");
      key = String(key);
    }
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        var store = dbInfo.db.transaction(dbInfo.storeName, "readwrite").objectStore(dbInfo.storeName);
        var req = store["delete"](key);
        req.onsuccess = function() {
          resolve();
        };
        req.onerror = function() {
          reject(req.error);
        };
        req.onabort = function(event) {
          var error = event.target.error;
          if (error === "QuotaExceededError") {
            reject(error);
          }
        };
      })["catch"](reject);
    });
    executeDeferedCallback(promise, callback);
    return promise;
  }
  function clear(callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        var store = dbInfo.db.transaction(dbInfo.storeName, "readwrite").objectStore(dbInfo.storeName);
        var req = store.clear();
        req.onsuccess = function() {
          resolve();
        };
        req.onerror = function() {
          reject(req.error);
        };
      })["catch"](reject);
    });
    executeDeferedCallback(promise, callback);
    return promise;
  }
  function length(callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        var store = dbInfo.db.transaction(dbInfo.storeName, "readonly").objectStore(dbInfo.storeName);
        var req = store.count();
        req.onsuccess = function() {
          resolve(req.result);
        };
        req.onerror = function() {
          reject(req.error);
        };
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function key(n, callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      if (n < 0) {
        resolve(null);
        return;
      }
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        var store = dbInfo.db.transaction(dbInfo.storeName, "readonly").objectStore(dbInfo.storeName);
        var advanced = false;
        var req = store.openCursor();
        req.onsuccess = function() {
          var cursor = req.result;
          if (!cursor) {
            resolve(null);
            return;
          }
          if (n === 0) {
            resolve(cursor.key);
          } else {
            if (!advanced) {
              advanced = true;
              cursor.advance(n);
            } else {
              resolve(cursor.key);
            }
          }
        };
        req.onerror = function() {
          reject(req.error);
        };
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function keys(callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        var store = dbInfo.db.transaction(dbInfo.storeName, "readonly").objectStore(dbInfo.storeName);
        var req = store.openCursor();
        var keys = [];
        req.onsuccess = function() {
          var cursor = req.result;
          if (!cursor) {
            resolve(keys);
            return;
          }
          keys.push(cursor.key);
          cursor["continue"]();
        };
        req.onerror = function() {
          reject(req.error);
        };
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function executeCallback(promise, callback) {
    if (callback) {
      promise.then(function(result) {
        callback(null, result);
      }, function(error) {
        callback(error);
      });
    }
  }
  function executeDeferedCallback(promise, callback) {
    if (callback) {
      promise.then(function(result) {
        deferCallback(callback, result);
      }, function(error) {
        callback(error);
      });
    }
  }
  function deferCallback(callback, result) {
    if (callback) {
      return setTimeout(function() {
        return callback(null, result);
      }, 0);
    }
  }
  var asyncStorage = {
    _driver: "asyncStorage",
    _initStorage: _initStorage,
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key,
    keys: keys
  };
  if (typeof define === "function" && define.amd) {
    define("asyncStorage", function() {
      return asyncStorage;
    });
  } else if (typeof module !== "undefined" && module.exports) {
    module.exports = asyncStorage;
  } else {
    this.asyncStorage = asyncStorage;
  }
}).call(window);

(function() {
  "use strict";
  var Promise = typeof module !== "undefined" && module.exports ? require("promise") : this.Promise;
  var localStorage = null;
  try {
    if (!this.localStorage || !("setItem" in this.localStorage)) {
      return;
    }
    localStorage = this.localStorage;
  } catch (e) {
    return;
  }
  function _initStorage(options) {
    var self = this;
    var dbInfo = {};
    if (options) {
      for (var i in options) {
        dbInfo[i] = options[i];
      }
    }
    dbInfo.keyPrefix = dbInfo.name + "/";
    self._dbInfo = dbInfo;
    return Promise.resolve();
  }
  var SERIALIZED_MARKER = "__lfsc__:";
  var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
  var TYPE_ARRAYBUFFER = "arbf";
  var TYPE_BLOB = "blob";
  var TYPE_INT8ARRAY = "si08";
  var TYPE_UINT8ARRAY = "ui08";
  var TYPE_UINT8CLAMPEDARRAY = "uic8";
  var TYPE_INT16ARRAY = "si16";
  var TYPE_INT32ARRAY = "si32";
  var TYPE_UINT16ARRAY = "ur16";
  var TYPE_UINT32ARRAY = "ui32";
  var TYPE_FLOAT32ARRAY = "fl32";
  var TYPE_FLOAT64ARRAY = "fl64";
  var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
  function clear(callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var keyPrefix = self._dbInfo.keyPrefix;
        for (var i = localStorage.length - 1; i >= 0; i--) {
          var key = localStorage.key(i);
          if (key.indexOf(keyPrefix) === 0) {
            localStorage.removeItem(key);
          }
        }
        resolve();
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function getItem(key, callback) {
    var self = this;
    if (typeof key !== "string") {
      window.console.warn(key + " used as a key, but it is not a string.");
      key = String(key);
    }
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        try {
          var dbInfo = self._dbInfo;
          var result = localStorage.getItem(dbInfo.keyPrefix + key);
          if (result) {
            result = _deserialize(result);
          }
          resolve(result);
        } catch (e) {
          reject(e);
        }
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function key(n, callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        var result;
        try {
          result = localStorage.key(n);
        } catch (error) {
          result = null;
        }
        if (result) {
          result = result.substring(dbInfo.keyPrefix.length);
        }
        resolve(result);
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function keys(callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        var length = localStorage.length;
        var keys = [];
        for (var i = 0; i < length; i++) {
          if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {
            keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));
          }
        }
        resolve(keys);
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function length(callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.keys().then(function(keys) {
        resolve(keys.length);
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function removeItem(key, callback) {
    var self = this;
    if (typeof key !== "string") {
      window.console.warn(key + " used as a key, but it is not a string.");
      key = String(key);
    }
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        localStorage.removeItem(dbInfo.keyPrefix + key);
        resolve();
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function _deserialize(value) {
    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
      return JSON.parse(value);
    }
    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
    var buffer = new ArrayBuffer(serializedString.length * 2);
    var bufferView = new Uint16Array(buffer);
    for (var i = serializedString.length - 1; i >= 0; i--) {
      bufferView[i] = serializedString.charCodeAt(i);
    }
    switch (type) {
     case TYPE_ARRAYBUFFER:
      return buffer;

     case TYPE_BLOB:
      return new Blob([ buffer ]);

     case TYPE_INT8ARRAY:
      return new Int8Array(buffer);

     case TYPE_UINT8ARRAY:
      return new Uint8Array(buffer);

     case TYPE_UINT8CLAMPEDARRAY:
      return new Uint8ClampedArray(buffer);

     case TYPE_INT16ARRAY:
      return new Int16Array(buffer);

     case TYPE_UINT16ARRAY:
      return new Uint16Array(buffer);

     case TYPE_INT32ARRAY:
      return new Int32Array(buffer);

     case TYPE_UINT32ARRAY:
      return new Uint32Array(buffer);

     case TYPE_FLOAT32ARRAY:
      return new Float32Array(buffer);

     case TYPE_FLOAT64ARRAY:
      return new Float64Array(buffer);

     default:
      throw new Error("Unkown type: " + type);
    }
  }
  function _bufferToString(buffer) {
    var str = "";
    var uint16Array = new Uint16Array(buffer);
    try {
      str = String.fromCharCode.apply(null, uint16Array);
    } catch (e) {
      for (var i = 0; i < uint16Array.length; i++) {
        str += String.fromCharCode(uint16Array[i]);
      }
    }
    return str;
  }
  function _serialize(value, callback) {
    var valueString = "";
    if (value) {
      valueString = value.toString();
    }
    if (value && (value.toString() === "[object ArrayBuffer]" || value.buffer && value.buffer.toString() === "[object ArrayBuffer]")) {
      var buffer;
      var marker = SERIALIZED_MARKER;
      if (value instanceof ArrayBuffer) {
        buffer = value;
        marker += TYPE_ARRAYBUFFER;
      } else {
        buffer = value.buffer;
        if (valueString === "[object Int8Array]") {
          marker += TYPE_INT8ARRAY;
        } else if (valueString === "[object Uint8Array]") {
          marker += TYPE_UINT8ARRAY;
        } else if (valueString === "[object Uint8ClampedArray]") {
          marker += TYPE_UINT8CLAMPEDARRAY;
        } else if (valueString === "[object Int16Array]") {
          marker += TYPE_INT16ARRAY;
        } else if (valueString === "[object Uint16Array]") {
          marker += TYPE_UINT16ARRAY;
        } else if (valueString === "[object Int32Array]") {
          marker += TYPE_INT32ARRAY;
        } else if (valueString === "[object Uint32Array]") {
          marker += TYPE_UINT32ARRAY;
        } else if (valueString === "[object Float32Array]") {
          marker += TYPE_FLOAT32ARRAY;
        } else if (valueString === "[object Float64Array]") {
          marker += TYPE_FLOAT64ARRAY;
        } else {
          callback(new Error("Failed to get type for BinaryArray"));
        }
      }
      callback(marker + _bufferToString(buffer));
    } else if (valueString === "[object Blob]") {
      var fileReader = new FileReader();
      fileReader.onload = function() {
        var str = _bufferToString(this.result);
        callback(SERIALIZED_MARKER + TYPE_BLOB + str);
      };
      fileReader.readAsArrayBuffer(value);
    } else {
      try {
        callback(JSON.stringify(value));
      } catch (e) {
        window.console.error("Couldn't convert value into a JSON " + "string: ", value);
        callback(e);
      }
    }
  }
  function setItem(key, value, callback) {
    var self = this;
    if (typeof key !== "string") {
      window.console.warn(key + " used as a key, but it is not a string.");
      key = String(key);
    }
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        if (value === undefined) {
          value = null;
        }
        var originalValue = value;
        _serialize(value, function(value, error) {
          if (error) {
            reject(error);
          } else {
            try {
              var dbInfo = self._dbInfo;
              localStorage.setItem(dbInfo.keyPrefix + key, value);
            } catch (e) {
              if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                reject(e);
              }
            }
            resolve(originalValue);
          }
        });
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function executeCallback(promise, callback) {
    if (callback) {
      promise.then(function(result) {
        callback(null, result);
      }, function(error) {
        callback(error);
      });
    }
  }
  var localStorageWrapper = {
    _driver: "localStorageWrapper",
    _initStorage: _initStorage,
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key,
    keys: keys
  };
  if (typeof define === "function" && define.amd) {
    define("localStorageWrapper", function() {
      return localStorageWrapper;
    });
  } else if (typeof module !== "undefined" && module.exports) {
    module.exports = localStorageWrapper;
  } else {
    this.localStorageWrapper = localStorageWrapper;
  }
}).call(window);

(function() {
  "use strict";
  var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var Promise = typeof module !== "undefined" && module.exports ? require("promise") : this.Promise;
  var openDatabase = this.openDatabase;
  var SERIALIZED_MARKER = "__lfsc__:";
  var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
  var TYPE_ARRAYBUFFER = "arbf";
  var TYPE_BLOB = "blob";
  var TYPE_INT8ARRAY = "si08";
  var TYPE_UINT8ARRAY = "ui08";
  var TYPE_UINT8CLAMPEDARRAY = "uic8";
  var TYPE_INT16ARRAY = "si16";
  var TYPE_INT32ARRAY = "si32";
  var TYPE_UINT16ARRAY = "ur16";
  var TYPE_UINT32ARRAY = "ui32";
  var TYPE_FLOAT32ARRAY = "fl32";
  var TYPE_FLOAT64ARRAY = "fl64";
  var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
  if (!openDatabase) {
    return;
  }
  function _initStorage(options) {
    var self = this;
    var dbInfo = {
      db: null
    };
    if (options) {
      for (var i in options) {
        dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
      }
    }
    return new Promise(function(resolve, reject) {
      try {
        dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
      } catch (e) {
        return self.setDriver("localStorageWrapper").then(function() {
          return self._initStorage(options);
        }).then(resolve)["catch"](reject);
      }
      dbInfo.db.transaction(function(t) {
        t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], function() {
          self._dbInfo = dbInfo;
          resolve();
        }, function(t, error) {
          reject(error);
        });
      });
    });
  }
  function getItem(key, callback) {
    var self = this;
    if (typeof key !== "string") {
      window.console.warn(key + " used as a key, but it is not a string.");
      key = String(key);
    }
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        dbInfo.db.transaction(function(t) {
          t.executeSql("SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [ key ], function(t, results) {
            var result = results.rows.length ? results.rows.item(0).value : null;
            if (result) {
              result = _deserialize(result);
            }
            resolve(result);
          }, function(t, error) {
            reject(error);
          });
        });
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function setItem(key, value, callback) {
    var self = this;
    if (typeof key !== "string") {
      window.console.warn(key + " used as a key, but it is not a string.");
      key = String(key);
    }
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        if (value === undefined) {
          value = null;
        }
        var originalValue = value;
        _serialize(value, function(value, error) {
          if (error) {
            reject(error);
          } else {
            var dbInfo = self._dbInfo;
            dbInfo.db.transaction(function(t) {
              t.executeSql("INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [ key, value ], function() {
                resolve(originalValue);
              }, function(t, error) {
                reject(error);
              });
            }, function(sqlError) {
              if (sqlError.code === sqlError.QUOTA_ERR) {
                reject(sqlError);
              }
            });
          }
        });
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function removeItem(key, callback) {
    var self = this;
    if (typeof key !== "string") {
      window.console.warn(key + " used as a key, but it is not a string.");
      key = String(key);
    }
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        dbInfo.db.transaction(function(t) {
          t.executeSql("DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [ key ], function() {
            resolve();
          }, function(t, error) {
            reject(error);
          });
        });
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function clear(callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        dbInfo.db.transaction(function(t) {
          t.executeSql("DELETE FROM " + dbInfo.storeName, [], function() {
            resolve();
          }, function(t, error) {
            reject(error);
          });
        });
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function length(callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        dbInfo.db.transaction(function(t) {
          t.executeSql("SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t, results) {
            var result = results.rows.item(0).c;
            resolve(result);
          }, function(t, error) {
            reject(error);
          });
        });
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function key(n, callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        dbInfo.db.transaction(function(t) {
          t.executeSql("SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [ n + 1 ], function(t, results) {
            var result = results.rows.length ? results.rows.item(0).key : null;
            resolve(result);
          }, function(t, error) {
            reject(error);
          });
        });
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function keys(callback) {
    var self = this;
    var promise = new Promise(function(resolve, reject) {
      self.ready().then(function() {
        var dbInfo = self._dbInfo;
        dbInfo.db.transaction(function(t) {
          t.executeSql("SELECT key FROM " + dbInfo.storeName, [], function(t, results) {
            var keys = [];
            for (var i = 0; i < results.rows.length; i++) {
              keys.push(results.rows.item(i).key);
            }
            resolve(keys);
          }, function(t, error) {
            reject(error);
          });
        });
      })["catch"](reject);
    });
    executeCallback(promise, callback);
    return promise;
  }
  function _bufferToString(buffer) {
    var bytes = new Uint8Array(buffer);
    var i;
    var base64String = "";
    for (i = 0; i < bytes.length; i += 3) {
      base64String += BASE_CHARS[bytes[i] >> 2];
      base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
      base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
      base64String += BASE_CHARS[bytes[i + 2] & 63];
    }
    if (bytes.length % 3 === 2) {
      base64String = base64String.substring(0, base64String.length - 1) + "=";
    } else if (bytes.length % 3 === 1) {
      base64String = base64String.substring(0, base64String.length - 2) + "==";
    }
    return base64String;
  }
  function _deserialize(value) {
    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
      return JSON.parse(value);
    }
    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
    var bufferLength = serializedString.length * .75;
    var len = serializedString.length;
    var i;
    var p = 0;
    var encoded1, encoded2, encoded3, encoded4;
    if (serializedString[serializedString.length - 1] === "=") {
      bufferLength--;
      if (serializedString[serializedString.length - 2] === "=") {
        bufferLength--;
      }
    }
    var buffer = new ArrayBuffer(bufferLength);
    var bytes = new Uint8Array(buffer);
    for (i = 0; i < len; i += 4) {
      encoded1 = BASE_CHARS.indexOf(serializedString[i]);
      encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
      encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
      encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
      bytes[p++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    switch (type) {
     case TYPE_ARRAYBUFFER:
      return buffer;

     case TYPE_BLOB:
      return new Blob([ buffer ]);

     case TYPE_INT8ARRAY:
      return new Int8Array(buffer);

     case TYPE_UINT8ARRAY:
      return new Uint8Array(buffer);

     case TYPE_UINT8CLAMPEDARRAY:
      return new Uint8ClampedArray(buffer);

     case TYPE_INT16ARRAY:
      return new Int16Array(buffer);

     case TYPE_UINT16ARRAY:
      return new Uint16Array(buffer);

     case TYPE_INT32ARRAY:
      return new Int32Array(buffer);

     case TYPE_UINT32ARRAY:
      return new Uint32Array(buffer);

     case TYPE_FLOAT32ARRAY:
      return new Float32Array(buffer);

     case TYPE_FLOAT64ARRAY:
      return new Float64Array(buffer);

     default:
      throw new Error("Unkown type: " + type);
    }
  }
  function _serialize(value, callback) {
    var valueString = "";
    if (value) {
      valueString = value.toString();
    }
    if (value && (value.toString() === "[object ArrayBuffer]" || value.buffer && value.buffer.toString() === "[object ArrayBuffer]")) {
      var buffer;
      var marker = SERIALIZED_MARKER;
      if (value instanceof ArrayBuffer) {
        buffer = value;
        marker += TYPE_ARRAYBUFFER;
      } else {
        buffer = value.buffer;
        if (valueString === "[object Int8Array]") {
          marker += TYPE_INT8ARRAY;
        } else if (valueString === "[object Uint8Array]") {
          marker += TYPE_UINT8ARRAY;
        } else if (valueString === "[object Uint8ClampedArray]") {
          marker += TYPE_UINT8CLAMPEDARRAY;
        } else if (valueString === "[object Int16Array]") {
          marker += TYPE_INT16ARRAY;
        } else if (valueString === "[object Uint16Array]") {
          marker += TYPE_UINT16ARRAY;
        } else if (valueString === "[object Int32Array]") {
          marker += TYPE_INT32ARRAY;
        } else if (valueString === "[object Uint32Array]") {
          marker += TYPE_UINT32ARRAY;
        } else if (valueString === "[object Float32Array]") {
          marker += TYPE_FLOAT32ARRAY;
        } else if (valueString === "[object Float64Array]") {
          marker += TYPE_FLOAT64ARRAY;
        } else {
          callback(new Error("Failed to get type for BinaryArray"));
        }
      }
      callback(marker + _bufferToString(buffer));
    } else if (valueString === "[object Blob]") {
      var fileReader = new FileReader();
      fileReader.onload = function() {
        var str = _bufferToString(this.result);
        callback(SERIALIZED_MARKER + TYPE_BLOB + str);
      };
      fileReader.readAsArrayBuffer(value);
    } else {
      try {
        callback(JSON.stringify(value));
      } catch (e) {
        window.console.error("Couldn't convert value into a JSON " + "string: ", value);
        callback(null, e);
      }
    }
  }
  function executeCallback(promise, callback) {
    if (callback) {
      promise.then(function(result) {
        callback(null, result);
      }, function(error) {
        callback(error);
      });
    }
  }
  var webSQLStorage = {
    _driver: "webSQLStorage",
    _initStorage: _initStorage,
    getItem: getItem,
    setItem: setItem,
    removeItem: removeItem,
    clear: clear,
    length: length,
    key: key,
    keys: keys
  };
  if (typeof define === "function" && define.amd) {
    define("webSQLStorage", function() {
      return webSQLStorage;
    });
  } else if (typeof module !== "undefined" && module.exports) {
    module.exports = webSQLStorage;
  } else {
    this.webSQLStorage = webSQLStorage;
  }
}).call(window);

(function() {
  "use strict";
  var Promise = typeof module !== "undefined" && module.exports ? require("promise") : this.Promise;
  var DriverType = {
    INDEXEDDB: "asyncStorage",
    LOCALSTORAGE: "localStorageWrapper",
    WEBSQL: "webSQLStorage"
  };
  var DefaultDriverOrder = [ DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE ];
  var LibraryMethods = [ "clear", "getItem", "key", "keys", "length", "removeItem", "setItem" ];
  var ModuleType = {
    DEFINE: 1,
    EXPORT: 2,
    WINDOW: 3
  };
  var DefaultConfig = {
    description: "",
    driver: DefaultDriverOrder.slice(),
    name: "localforage",
    size: 4980736,
    storeName: "keyvaluepairs",
    version: 1
  };
  var moduleType = ModuleType.WINDOW;
  if (typeof define === "function" && define.amd) {
    moduleType = ModuleType.DEFINE;
  } else if (typeof module !== "undefined" && module.exports) {
    moduleType = ModuleType.EXPORT;
  }
  var driverSupport = function(self) {
    var indexedDB = indexedDB || self.indexedDB || self.webkitIndexedDB || self.mozIndexedDB || self.OIndexedDB || self.msIndexedDB;
    var result = {};
    result[DriverType.WEBSQL] = !!self.openDatabase;
    result[DriverType.INDEXEDDB] = !!function() {
      if (typeof self.openDatabase !== "undefined" && self.navigator && self.navigator.userAgent && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)) {
        return false;
      }
      try {
        return indexedDB && typeof indexedDB.open === "function" && typeof IDBKeyRange === "function";
      } catch (e) {
        return false;
      }
    }();
    result[DriverType.LOCALSTORAGE] = !!function() {
      try {
        return localStorage && "setItem" in localStorage && localStorage.setItem;
      } catch (e) {
        return false;
      }
    }();
    return result;
  }(this);
  var isArray = Array.isArray || function(arg) {
    return Object.prototype.toString.call(arg) === "[object Array]";
  };
  function extend() {
    for (var i = 1; i < arguments.length; i++) {
      var arg = arguments[i];
      if (arg) {
        for (var key in arg) {
          if (arg.hasOwnProperty(key)) {
            if (isArray(arg[key])) {
              arguments[0][key] = arg[key].slice();
            } else {
              arguments[0][key] = arg[key];
            }
          }
        }
      }
    }
    return arguments[0];
  }
  function callWhenReady(localForageInstance, libraryMethod) {
    localForageInstance[libraryMethod] = function() {
      var _args = arguments;
      return localForageInstance.ready().then(function() {
        return localForageInstance[libraryMethod].apply(localForageInstance, _args);
      });
    };
  }
  var globalObject = this;
  function LocalForage(options) {
    this._config = extend({}, DefaultConfig, options);
    this._driverSet = null;
    this._ready = false;
    this._dbInfo = null;
    for (var i = 0; i < LibraryMethods.length; i++) {
      callWhenReady(this, LibraryMethods[i]);
    }
    this.setDriver(this._config.driver);
  }
  LocalForage.prototype.INDEXEDDB = DriverType.INDEXEDDB;
  LocalForage.prototype.LOCALSTORAGE = DriverType.LOCALSTORAGE;
  LocalForage.prototype.WEBSQL = DriverType.WEBSQL;
  LocalForage.prototype.config = function(options) {
    if (typeof options === "object") {
      if (this._ready) {
        return new Error("Can't call config() after localforage " + "has been used.");
      }
      for (var i in options) {
        if (i === "storeName") {
          options[i] = options[i].replace(/\W/g, "_");
        }
        this._config[i] = options[i];
      }
      if ("driver" in options && options.driver) {
        this.setDriver(this._config.driver);
      }
      return true;
    } else if (typeof options === "string") {
      return this._config[options];
    } else {
      return this._config;
    }
  };
  LocalForage.prototype.driver = function() {
    return this._driver || null;
  };
  LocalForage.prototype.ready = function(callback) {
    var self = this;
    var ready = new Promise(function(resolve, reject) {
      self._driverSet.then(function() {
        if (self._ready === null) {
          self._ready = self._initStorage(self._config);
        }
        self._ready.then(resolve, reject);
      })["catch"](reject);
    });
    ready.then(callback, callback);
    return ready;
  };
  LocalForage.prototype.setDriver = function(drivers, callback, errorCallback) {
    var self = this;
    if (typeof drivers === "string") {
      drivers = [ drivers ];
    }
    this._driverSet = new Promise(function(resolve, reject) {
      var driverName = self._getFirstSupportedDriver(drivers);
      if (!driverName) {
        var error = new Error("No available storage method found.");
        self._driverSet = Promise.reject(error);
        reject(error);
        return;
      }
      self._dbInfo = null;
      self._ready = null;
      if (moduleType === ModuleType.DEFINE) {
        require([ driverName ], function(lib) {
          self._extend(lib);
          resolve();
        });
        return;
      } else if (moduleType === ModuleType.EXPORT) {
        var driver;
        switch (driverName) {
         case self.INDEXEDDB:
          driver = require("./drivers/indexeddb");
          break;

         case self.LOCALSTORAGE:
          driver = require("./drivers/localstorage");
          break;

         case self.WEBSQL:
          driver = require("./drivers/websql");
        }
        self._extend(driver);
      } else {
        self._extend(globalObject[driverName]);
      }
      resolve();
    });
    function setDriverToConfig() {
      self._config.driver = self.driver();
    }
    this._driverSet.then(setDriverToConfig, setDriverToConfig);
    this._driverSet.then(callback, errorCallback);
    return this._driverSet;
  };
  LocalForage.prototype.supports = function(driverName) {
    return !!driverSupport[driverName];
  };
  LocalForage.prototype._extend = function(libraryMethodsAndProperties) {
    extend(this, libraryMethodsAndProperties);
  };
  LocalForage.prototype._getFirstSupportedDriver = function(drivers) {
    if (drivers && isArray(drivers)) {
      for (var i = 0; i < drivers.length; i++) {
        var driver = drivers[i];
        if (this.supports(driver)) {
          return driver;
        }
      }
    }
    return null;
  };
  LocalForage.prototype.createInstance = function(options) {
    return new LocalForage(options);
  };
  var localForage = new LocalForage();
  if (moduleType === ModuleType.DEFINE) {
    define("localforage", function() {
      return localForage;
    });
  } else if (moduleType === ModuleType.EXPORT) {
    module.exports = localForage;
  } else {
    this.localforage = localForage;
  }
}).call(window);
(function() {
  var module = angular.module("restangular", []);
  module.provider("Restangular", function() {
    var Configurer = {};
    Configurer.init = function(object, config) {
      object.configuration = config;
      var safeMethods = [ "get", "head", "options", "trace", "getlist" ];
      config.isSafe = function(operation) {
        return _.contains(safeMethods, operation.toLowerCase());
      };
      var absolutePattern = /^https?:\/\//i;
      config.isAbsoluteUrl = function(string) {
        return _.isUndefined(config.absoluteUrl) || _.isNull(config.absoluteUrl) ? string && absolutePattern.test(string) : config.absoluteUrl;
      };
      config.absoluteUrl = _.isUndefined(config.absoluteUrl) ? true : config.absoluteUrl;
      object.setSelfLinkAbsoluteUrl = function(value) {
        config.absoluteUrl = value;
      };
      config.baseUrl = _.isUndefined(config.baseUrl) ? "" : config.baseUrl;
      object.setBaseUrl = function(newBaseUrl) {
        config.baseUrl = /\/$/.test(newBaseUrl) ? newBaseUrl.substring(0, newBaseUrl.length - 1) : newBaseUrl;
        return this;
      };
      config.extraFields = config.extraFields || [];
      object.setExtraFields = function(newExtraFields) {
        config.extraFields = newExtraFields;
        return this;
      };
      config.defaultHttpFields = config.defaultHttpFields || {};
      object.setDefaultHttpFields = function(values) {
        config.defaultHttpFields = values;
        return this;
      };
      config.withHttpValues = function(httpLocalConfig, obj) {
        return _.defaults(obj, httpLocalConfig, config.defaultHttpFields);
      };
      config.encodeIds = _.isUndefined(config.encodeIds) ? true : config.encodeIds;
      object.setEncodeIds = function(encode) {
        config.encodeIds = encode;
      };
      config.defaultRequestParams = config.defaultRequestParams || {
        get: {},
        post: {},
        put: {},
        remove: {},
        common: {}
      };
      object.setDefaultRequestParams = function(param1, param2) {
        var methods = [], params = param2 || param1;
        if (!_.isUndefined(param2)) {
          if (_.isArray(param1)) {
            methods = param1;
          } else {
            methods.push(param1);
          }
        } else {
          methods.push("common");
        }
        _.each(methods, function(method) {
          config.defaultRequestParams[method] = params;
        });
        return this;
      };
      object.requestParams = config.defaultRequestParams;
      config.defaultHeaders = config.defaultHeaders || {};
      object.setDefaultHeaders = function(headers) {
        config.defaultHeaders = headers;
        object.defaultHeaders = config.defaultHeaders;
        return this;
      };
      object.defaultHeaders = config.defaultHeaders;
      config.methodOverriders = config.methodOverriders || [];
      object.setMethodOverriders = function(values) {
        var overriders = _.extend([], values);
        if (config.isOverridenMethod("delete", overriders)) {
          overriders.push("remove");
        }
        config.methodOverriders = overriders;
        return this;
      };
      config.jsonp = _.isUndefined(config.jsonp) ? false : config.jsonp;
      object.setJsonp = function(active) {
        config.jsonp = active;
      };
      config.isOverridenMethod = function(method, values) {
        var search = values || config.methodOverriders;
        return !_.isUndefined(_.find(search, function(one) {
          return one.toLowerCase() === method.toLowerCase();
        }));
      };
      config.urlCreator = config.urlCreator || "path";
      object.setUrlCreator = function(name) {
        if (!_.has(config.urlCreatorFactory, name)) {
          throw new Error("URL Path selected isn't valid");
        }
        config.urlCreator = name;
        return this;
      };
      config.restangularFields = config.restangularFields || {
        id: "id",
        route: "route",
        parentResource: "parentResource",
        restangularCollection: "restangularCollection",
        cannonicalId: "__cannonicalId",
        etag: "restangularEtag",
        selfLink: "href",
        get: "get",
        getList: "getList",
        put: "put",
        post: "post",
        remove: "remove",
        head: "head",
        trace: "trace",
        options: "options",
        patch: "patch",
        getRestangularUrl: "getRestangularUrl",
        getRequestedUrl: "getRequestedUrl",
        putElement: "putElement",
        addRestangularMethod: "addRestangularMethod",
        getParentList: "getParentList",
        clone: "clone",
        ids: "ids",
        httpConfig: "_$httpConfig",
        reqParams: "reqParams",
        one: "one",
        all: "all",
        several: "several",
        oneUrl: "oneUrl",
        allUrl: "allUrl",
        customPUT: "customPUT",
        customPOST: "customPOST",
        customDELETE: "customDELETE",
        customGET: "customGET",
        customGETLIST: "customGETLIST",
        customOperation: "customOperation",
        doPUT: "doPUT",
        doPOST: "doPOST",
        doDELETE: "doDELETE",
        doGET: "doGET",
        doGETLIST: "doGETLIST",
        fromServer: "fromServer",
        withConfig: "withConfig",
        withHttpConfig: "withHttpConfig",
        singleOne: "singleOne",
        plain: "plain",
        save: "save"
      };
      object.setRestangularFields = function(resFields) {
        config.restangularFields = _.extend(config.restangularFields, resFields);
        return this;
      };
      config.isRestangularized = function(obj) {
        return !!obj[config.restangularFields.one] || !!obj[config.restangularFields.all];
      };
      config.setFieldToElem = function(field, elem, value) {
        var properties = field.split(".");
        var idValue = elem;
        _.each(_.initial(properties), function(prop) {
          idValue[prop] = {};
          idValue = idValue[prop];
        });
        idValue[_.last(properties)] = value;
        return this;
      };
      config.getFieldFromElem = function(field, elem) {
        var properties = field.split(".");
        var idValue = elem;
        _.each(properties, function(prop) {
          if (idValue) {
            idValue = idValue[prop];
          }
        });
        return angular.copy(idValue);
      };
      config.setIdToElem = function(elem, id) {
        config.setFieldToElem(config.restangularFields.id, elem, id);
        return this;
      };
      config.getIdFromElem = function(elem) {
        return config.getFieldFromElem(config.restangularFields.id, elem);
      };
      config.isValidId = function(elemId) {
        return "" !== elemId && !_.isUndefined(elemId) && !_.isNull(elemId);
      };
      config.setUrlToElem = function(elem, url, route) {
        config.setFieldToElem(config.restangularFields.selfLink, elem, url);
        return this;
      };
      config.getUrlFromElem = function(elem) {
        return config.getFieldFromElem(config.restangularFields.selfLink, elem);
      };
      config.useCannonicalId = _.isUndefined(config.useCannonicalId) ? false : config.useCannonicalId;
      object.setUseCannonicalId = function(value) {
        config.useCannonicalId = value;
        return this;
      };
      config.getCannonicalIdFromElem = function(elem) {
        var cannonicalId = elem[config.restangularFields.cannonicalId];
        var actualId = config.isValidId(cannonicalId) ? cannonicalId : config.getIdFromElem(elem);
        return actualId;
      };
      config.responseInterceptors = config.responseInterceptors || [];
      config.defaultResponseInterceptor = function(data, operation, what, url, response, deferred) {
        return data;
      };
      config.responseExtractor = function(data, operation, what, url, response, deferred) {
        var interceptors = angular.copy(config.responseInterceptors);
        interceptors.push(config.defaultResponseInterceptor);
        var theData = data;
        _.each(interceptors, function(interceptor) {
          theData = interceptor(theData, operation, what, url, response, deferred);
        });
        return theData;
      };
      object.addResponseInterceptor = function(extractor) {
        config.responseInterceptors.push(extractor);
        return this;
      };
      object.setResponseInterceptor = object.addResponseInterceptor;
      object.setResponseExtractor = object.addResponseInterceptor;
      config.requestInterceptors = config.requestInterceptors || [];
      config.defaultInterceptor = function(element, operation, path, url, headers, params, httpConfig) {
        return {
          element: element,
          headers: headers,
          params: params,
          httpConfig: httpConfig
        };
      };
      config.fullRequestInterceptor = function(element, operation, path, url, headers, params, httpConfig) {
        var interceptors = angular.copy(config.requestInterceptors);
        var defaultRequest = config.defaultInterceptor(element, operation, path, url, headers, params, httpConfig);
        return _.reduce(interceptors, function(request, interceptor) {
          return _.extend(request, interceptor(request.element, operation, path, url, request.headers, request.params, request.httpConfig));
        }, defaultRequest);
      };
      object.addRequestInterceptor = function(interceptor) {
        config.requestInterceptors.push(function(elem, operation, path, url, headers, params, httpConfig) {
          return {
            headers: headers,
            params: params,
            element: interceptor(elem, operation, path, url),
            httpConfig: httpConfig
          };
        });
        return this;
      };
      object.setRequestInterceptor = object.addRequestInterceptor;
      object.addFullRequestInterceptor = function(interceptor) {
        config.requestInterceptors.push(interceptor);
        return this;
      };
      object.setFullRequestInterceptor = object.addFullRequestInterceptor;
      config.errorInterceptor = config.errorInterceptor || function() {};
      object.setErrorInterceptor = function(interceptor) {
        config.errorInterceptor = interceptor;
        return this;
      };
      config.onBeforeElemRestangularized = config.onBeforeElemRestangularized || function(elem) {
        return elem;
      };
      object.setOnBeforeElemRestangularized = function(post) {
        config.onBeforeElemRestangularized = post;
        return this;
      };
      config.onElemRestangularized = config.onElemRestangularized || function(elem) {
        return elem;
      };
      object.setOnElemRestangularized = function(post) {
        config.onElemRestangularized = post;
        return this;
      };
      config.shouldSaveParent = config.shouldSaveParent || function() {
        return true;
      };
      object.setParentless = function(values) {
        if (_.isArray(values)) {
          config.shouldSaveParent = function(route) {
            return !_.contains(values, route);
          };
        } else if (_.isBoolean(values)) {
          config.shouldSaveParent = function() {
            return !values;
          };
        }
        return this;
      };
      config.suffix = _.isUndefined(config.suffix) ? null : config.suffix;
      object.setRequestSuffix = function(newSuffix) {
        config.suffix = newSuffix;
        return this;
      };
      config.transformers = config.transformers || {};
      object.addElementTransformer = function(type, secondArg, thirdArg) {
        var isCollection = null;
        var transformer = null;
        if (arguments.length === 2) {
          transformer = secondArg;
        } else {
          transformer = thirdArg;
          isCollection = secondArg;
        }
        var typeTransformers = config.transformers[type];
        if (!typeTransformers) {
          typeTransformers = config.transformers[type] = [];
        }
        typeTransformers.push(function(coll, elem) {
          if (_.isNull(isCollection) || coll == isCollection) {
            return transformer(elem);
          }
          return elem;
        });
        return object;
      };
      object.extendCollection = function(route, fn) {
        return object.addElementTransformer(route, true, fn);
      };
      object.extendModel = function(route, fn) {
        return object.addElementTransformer(route, false, fn);
      };
      config.transformElem = function(elem, isCollection, route, Restangular, force) {
        if (!force && !config.transformLocalElements && !elem[config.restangularFields.fromServer]) {
          return elem;
        }
        var typeTransformers = config.transformers[route];
        var changedElem = elem;
        if (typeTransformers) {
          _.each(typeTransformers, function(transformer) {
            changedElem = transformer(isCollection, changedElem);
          });
        }
        return config.onElemRestangularized(changedElem, isCollection, route, Restangular);
      };
      config.transformLocalElements = _.isUndefined(config.transformLocalElements) ? false : config.transformLocalElements;
      object.setTransformOnlyServerElements = function(active) {
        config.transformLocalElements = !active;
      };
      config.fullResponse = _.isUndefined(config.fullResponse) ? false : config.fullResponse;
      object.setFullResponse = function(full) {
        config.fullResponse = full;
        return this;
      };
      config.urlCreatorFactory = {};
      var BaseCreator = function() {};
      BaseCreator.prototype.setConfig = function(config) {
        this.config = config;
        return this;
      };
      BaseCreator.prototype.parentsArray = function(current) {
        var parents = [];
        while (current) {
          parents.push(current);
          current = current[this.config.restangularFields.parentResource];
        }
        return parents.reverse();
      };
      function RestangularResource(config, $http, url, configurer) {
        var resource = {};
        _.each(_.keys(configurer), function(key) {
          var value = configurer[key];
          value.params = _.extend({}, value.params, config.defaultRequestParams[value.method.toLowerCase()]);
          if (_.isEmpty(value.params)) {
            delete value.params;
          }
          if (config.isSafe(value.method)) {
            resource[key] = function() {
              return $http(_.extend(value, {
                url: url
              }));
            };
          } else {
            resource[key] = function(data) {
              return $http(_.extend(value, {
                url: url,
                data: data
              }));
            };
          }
        });
        return resource;
      }
      BaseCreator.prototype.resource = function(current, $http, localHttpConfig, callHeaders, callParams, what, etag, operation) {
        var params = _.defaults(callParams || {}, this.config.defaultRequestParams.common);
        var headers = _.defaults(callHeaders || {}, this.config.defaultHeaders);
        if (etag) {
          if (!config.isSafe(operation)) {
            headers["If-Match"] = etag;
          } else {
            headers["If-None-Match"] = etag;
          }
        }
        var url = this.base(current);
        if (what) {
          var add = "";
          if (!/\/$/.test(url)) {
            add += "/";
          }
          add += what;
          url += add;
        }
        if (this.config.suffix && url.indexOf(this.config.suffix, url.length - this.config.suffix.length) === -1 && !this.config.getUrlFromElem(current)) {
          url += this.config.suffix;
        }
        current[this.config.restangularFields.httpConfig] = undefined;
        return RestangularResource(this.config, $http, url, {
          getList: this.config.withHttpValues(localHttpConfig, {
            method: "GET",
            params: params,
            headers: headers
          }),
          get: this.config.withHttpValues(localHttpConfig, {
            method: "GET",
            params: params,
            headers: headers
          }),
          jsonp: this.config.withHttpValues(localHttpConfig, {
            method: "jsonp",
            params: params,
            headers: headers
          }),
          put: this.config.withHttpValues(localHttpConfig, {
            method: "PUT",
            params: params,
            headers: headers
          }),
          post: this.config.withHttpValues(localHttpConfig, {
            method: "POST",
            params: params,
            headers: headers
          }),
          remove: this.config.withHttpValues(localHttpConfig, {
            method: "DELETE",
            params: params,
            headers: headers
          }),
          head: this.config.withHttpValues(localHttpConfig, {
            method: "HEAD",
            params: params,
            headers: headers
          }),
          trace: this.config.withHttpValues(localHttpConfig, {
            method: "TRACE",
            params: params,
            headers: headers
          }),
          options: this.config.withHttpValues(localHttpConfig, {
            method: "OPTIONS",
            params: params,
            headers: headers
          }),
          patch: this.config.withHttpValues(localHttpConfig, {
            method: "PATCH",
            params: params,
            headers: headers
          })
        });
      };
      var Path = function() {};
      Path.prototype = new BaseCreator();
      Path.prototype.base = function(current) {
        var __this = this;
        return _.reduce(this.parentsArray(current), function(acum, elem) {
          var elemUrl;
          var elemSelfLink = __this.config.getUrlFromElem(elem);
          if (elemSelfLink) {
            if (__this.config.isAbsoluteUrl(elemSelfLink)) {
              return elemSelfLink;
            } else {
              elemUrl = elemSelfLink;
            }
          } else {
            elemUrl = elem[__this.config.restangularFields.route];
            if (elem[__this.config.restangularFields.restangularCollection]) {
              var ids = elem[__this.config.restangularFields.ids];
              if (ids) {
                elemUrl += "/" + ids.join(",");
              }
            } else {
              var elemId;
              if (__this.config.useCannonicalId) {
                elemId = __this.config.getCannonicalIdFromElem(elem);
              } else {
                elemId = __this.config.getIdFromElem(elem);
              }
              if (config.isValidId(elemId) && !elem.singleOne) {
                elemUrl += "/" + (__this.config.encodeIds ? encodeURIComponent(elemId) : elemId);
              }
            }
          }
          return acum.replace(/\/$/, "") + "/" + elemUrl;
        }, this.config.baseUrl);
      };
      Path.prototype.fetchUrl = function(current, what) {
        var baseUrl = this.base(current);
        if (what) {
          baseUrl += "/" + what;
        }
        return baseUrl;
      };
      Path.prototype.fetchRequestedUrl = function(current, what) {
        var url = this.fetchUrl(current, what);
        var params = current[config.restangularFields.reqParams];
        function sortedKeys(obj) {
          var keys = [];
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              keys.push(key);
            }
          }
          return keys.sort();
        }
        function forEachSorted(obj, iterator, context) {
          var keys = sortedKeys(obj);
          for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
          }
          return keys;
        }
        function encodeUriQuery(val, pctEncodeSpaces) {
          return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
        }
        if (!params) return url;
        var parts = [];
        forEachSorted(params, function(value, key) {
          if (value == null || value == undefined) return;
          if (!angular.isArray(value)) value = [ value ];
          angular.forEach(value, function(v) {
            if (angular.isObject(v)) {
              v = angular.toJson(v);
            }
            parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
          });
        });
        return url + (this.config.suffix || "") + (url.indexOf("?") === -1 ? "?" : "&") + parts.join("&");
      };
      config.urlCreatorFactory.path = Path;
    };
    var globalConfiguration = {};
    Configurer.init(this, globalConfiguration);
    this.$get = [ "$http", "$q", function($http, $q) {
      function createServiceForConfiguration(config) {
        var service = {};
        var urlHandler = new config.urlCreatorFactory[config.urlCreator]();
        urlHandler.setConfig(config);
        function restangularizeBase(parent, elem, route, reqParams, fromServer) {
          elem[config.restangularFields.route] = route;
          elem[config.restangularFields.getRestangularUrl] = _.bind(urlHandler.fetchUrl, urlHandler, elem);
          elem[config.restangularFields.getRequestedUrl] = _.bind(urlHandler.fetchRequestedUrl, urlHandler, elem);
          elem[config.restangularFields.addRestangularMethod] = _.bind(addRestangularMethodFunction, elem);
          elem[config.restangularFields.clone] = _.bind(copyRestangularizedElement, elem, elem);
          elem[config.restangularFields.reqParams] = _.isEmpty(reqParams) ? null : reqParams;
          elem[config.restangularFields.withHttpConfig] = _.bind(withHttpConfig, elem);
          elem[config.restangularFields.plain] = _.bind(stripRestangular, elem, elem);
          elem[config.restangularFields.one] = _.bind(one, elem, elem);
          elem[config.restangularFields.all] = _.bind(all, elem, elem);
          elem[config.restangularFields.several] = _.bind(several, elem, elem);
          elem[config.restangularFields.oneUrl] = _.bind(oneUrl, elem, elem);
          elem[config.restangularFields.allUrl] = _.bind(allUrl, elem, elem);
          elem[config.restangularFields.fromServer] = !!fromServer;
          if (parent && config.shouldSaveParent(route)) {
            var parentId = config.getIdFromElem(parent);
            var parentUrl = config.getUrlFromElem(parent);
            var restangularFieldsForParent = _.union(_.values(_.pick(config.restangularFields, [ "route", "singleOne", "parentResource" ])), config.extraFields);
            var parentResource = _.pick(parent, restangularFieldsForParent);
            if (config.isValidId(parentId)) {
              config.setIdToElem(parentResource, parentId);
            }
            if (config.isValidId(parentUrl)) {
              config.setUrlToElem(parentResource, parentUrl);
            }
            elem[config.restangularFields.parentResource] = parentResource;
          } else {
            elem[config.restangularFields.parentResource] = null;
          }
          return elem;
        }
        function one(parent, route, id, singleOne) {
          if (_.isNumber(route) || _.isNumber(parent)) {
            var error = "You're creating a Restangular entity with the number ";
            error += "instead of the route or the parent. You can't call .one(12)";
            throw new Error(error);
          }
          var elem = {};
          config.setIdToElem(elem, id);
          config.setFieldToElem(config.restangularFields.singleOne, elem, singleOne);
          return restangularizeElem(parent, elem, route, false);
        }
        function all(parent, route) {
          return restangularizeCollection(parent, [], route, false);
        }
        function several(parent, route, ids) {
          var collection = [];
          collection[config.restangularFields.ids] = Array.prototype.splice.call(arguments, 2);
          return restangularizeCollection(parent, collection, route, false);
        }
        function oneUrl(parent, route, url) {
          if (!route) {
            throw new Error("Route is mandatory when creating new Restangular objects.");
          }
          var elem = {};
          config.setUrlToElem(elem, url, route);
          return restangularizeElem(parent, elem, route, false);
        }
        function allUrl(parent, route, url) {
          if (!route) {
            throw new Error("Route is mandatory when creating new Restangular objects.");
          }
          var elem = {};
          config.setUrlToElem(elem, url, route);
          return restangularizeCollection(parent, elem, route, false);
        }
        function restangularizePromise(promise, isCollection, valueToFill) {
          promise.call = _.bind(promiseCall, promise);
          promise.get = _.bind(promiseGet, promise);
          promise[config.restangularFields.restangularCollection] = isCollection;
          if (isCollection) {
            promise.push = _.bind(promiseCall, promise, "push");
          }
          promise.$object = valueToFill;
          return promise;
        }
        function promiseCall(method) {
          var deferred = $q.defer();
          var callArgs = arguments;
          var filledValue = {};
          this.then(function(val) {
            var params = Array.prototype.slice.call(callArgs, 1);
            var func = val[method];
            func.apply(val, params);
            filledValue = val;
            deferred.resolve(val);
          });
          return restangularizePromise(deferred.promise, this[config.restangularFields.restangularCollection], filledValue);
        }
        function promiseGet(what) {
          var deferred = $q.defer();
          var filledValue = {};
          this.then(function(val) {
            filledValue = val[what];
            deferred.resolve(filledValue);
          });
          return restangularizePromise(deferred.promise, this[config.restangularFields.restangularCollection], filledValue);
        }
        function resolvePromise(deferred, response, data, filledValue) {
          _.extend(filledValue, data);
          if (config.fullResponse) {
            return deferred.resolve(_.extend(response, {
              data: data
            }));
          } else {
            deferred.resolve(data);
          }
        }
        function stripRestangular(elem) {
          if (_.isArray(elem)) {
            var array = [];
            _.each(elem, function(value) {
              array.push(stripRestangular(value));
            });
            return array;
          } else {
            return _.omit(elem, _.values(_.omit(config.restangularFields, "id")));
          }
        }
        function addCustomOperation(elem) {
          elem[config.restangularFields.customOperation] = _.bind(customFunction, elem);
          _.each([ "put", "post", "get", "delete" ], function(oper) {
            _.each([ "do", "custom" ], function(alias) {
              var callOperation = oper === "delete" ? "remove" : oper;
              var name = alias + oper.toUpperCase();
              var callFunction;
              if (callOperation !== "put" && callOperation !== "post") {
                callFunction = customFunction;
              } else {
                callFunction = function(operation, elem, path, params, headers) {
                  return _.bind(customFunction, this)(operation, path, params, headers, elem);
                };
              }
              elem[name] = _.bind(callFunction, elem, callOperation);
            });
          });
          elem[config.restangularFields.customGETLIST] = _.bind(fetchFunction, elem);
          elem[config.restangularFields.doGETLIST] = elem[config.restangularFields.customGETLIST];
        }
        function copyRestangularizedElement(fromElement, toElement) {
          var copiedElement = angular.copy(fromElement, toElement);
          return restangularizeElem(copiedElement[config.restangularFields.parentResource], copiedElement, copiedElement[config.restangularFields.route], true);
        }
        function restangularizeElem(parent, element, route, fromServer, collection, reqParams) {
          var elem = config.onBeforeElemRestangularized(element, false, route);
          var localElem = restangularizeBase(parent, elem, route, reqParams, fromServer);
          if (config.useCannonicalId) {
            localElem[config.restangularFields.cannonicalId] = config.getIdFromElem(localElem);
          }
          if (collection) {
            localElem[config.restangularFields.getParentList] = function() {
              return collection;
            };
          }
          localElem[config.restangularFields.restangularCollection] = false;
          localElem[config.restangularFields.get] = _.bind(getFunction, localElem);
          localElem[config.restangularFields.getList] = _.bind(fetchFunction, localElem);
          localElem[config.restangularFields.put] = _.bind(putFunction, localElem);
          localElem[config.restangularFields.post] = _.bind(postFunction, localElem);
          localElem[config.restangularFields.remove] = _.bind(deleteFunction, localElem);
          localElem[config.restangularFields.head] = _.bind(headFunction, localElem);
          localElem[config.restangularFields.trace] = _.bind(traceFunction, localElem);
          localElem[config.restangularFields.options] = _.bind(optionsFunction, localElem);
          localElem[config.restangularFields.patch] = _.bind(patchFunction, localElem);
          localElem[config.restangularFields.save] = _.bind(save, localElem);
          addCustomOperation(localElem);
          return config.transformElem(localElem, false, route, service, true);
        }
        function restangularizeCollection(parent, element, route, fromServer, reqParams) {
          var elem = config.onBeforeElemRestangularized(element, true, route);
          var localElem = restangularizeBase(parent, elem, route, reqParams, fromServer);
          localElem[config.restangularFields.restangularCollection] = true;
          localElem[config.restangularFields.post] = _.bind(postFunction, localElem, null);
          localElem[config.restangularFields.remove] = _.bind(deleteFunction, localElem);
          localElem[config.restangularFields.head] = _.bind(headFunction, localElem);
          localElem[config.restangularFields.trace] = _.bind(traceFunction, localElem);
          localElem[config.restangularFields.putElement] = _.bind(putElementFunction, localElem);
          localElem[config.restangularFields.options] = _.bind(optionsFunction, localElem);
          localElem[config.restangularFields.patch] = _.bind(patchFunction, localElem);
          localElem[config.restangularFields.get] = _.bind(getById, localElem);
          localElem[config.restangularFields.getList] = _.bind(fetchFunction, localElem, null);
          addCustomOperation(localElem);
          return config.transformElem(localElem, true, route, service, true);
        }
        function restangularizeCollectionAndElements(parent, element, route) {
          var collection = restangularizeCollection(parent, element, route, false);
          _.each(collection, function(elem) {
            restangularizeElem(parent, elem, route, false);
          });
          return collection;
        }
        function getById(id, reqParams, headers) {
          return this.customGET(id.toString(), reqParams, headers);
        }
        function putElementFunction(idx, params, headers) {
          var __this = this;
          var elemToPut = this[idx];
          var deferred = $q.defer();
          var filledArray = [];
          filledArray = config.transformElem(filledArray, true, elemToPut[config.restangularFields.route], service);
          elemToPut.put(params, headers).then(function(serverElem) {
            var newArray = copyRestangularizedElement(__this);
            newArray[idx] = serverElem;
            filledArray = newArray;
            deferred.resolve(newArray);
          }, function(response) {
            deferred.reject(response);
          });
          return restangularizePromise(deferred.promise, true, filledArray);
        }
        function parseResponse(resData, operation, route, fetchUrl, response, deferred) {
          var data = config.responseExtractor(resData, operation, route, fetchUrl, response, deferred);
          var etag = response.headers("ETag");
          if (data && etag) {
            data[config.restangularFields.etag] = etag;
          }
          return data;
        }
        function fetchFunction(what, reqParams, headers) {
          var __this = this;
          var deferred = $q.defer();
          var operation = "getList";
          var url = urlHandler.fetchUrl(this, what);
          var whatFetched = what || __this[config.restangularFields.route];
          var request = config.fullRequestInterceptor(null, operation, whatFetched, url, headers || {}, reqParams || {}, this[config.restangularFields.httpConfig] || {});
          var filledArray = [];
          filledArray = config.transformElem(filledArray, true, whatFetched, service);
          var method = "getList";
          if (config.jsonp) {
            method = "jsonp";
          }
          urlHandler.resource(this, $http, request.httpConfig, request.headers, request.params, what, this[config.restangularFields.etag], operation)[method]().then(function(response) {
            var resData = response.data;
            var fullParams = response.config.params;
            var data = parseResponse(resData, operation, whatFetched, url, response, deferred);
            if (_.isUndefined(data) || "" === data) {
              data = [];
            }
            if (!_.isArray(data)) {
              throw new Error("Response for getList SHOULD be an array and not an object or something else");
            }
            var processedData = _.map(data, function(elem) {
              if (!__this[config.restangularFields.restangularCollection]) {
                return restangularizeElem(__this, elem, what, true, data);
              } else {
                return restangularizeElem(__this[config.restangularFields.parentResource], elem, __this[config.restangularFields.route], true, data);
              }
            });
            processedData = _.extend(data, processedData);
            if (!__this[config.restangularFields.restangularCollection]) {
              resolvePromise(deferred, response, restangularizeCollection(__this, processedData, what, true, fullParams), filledArray);
            } else {
              resolvePromise(deferred, response, restangularizeCollection(__this[config.restangularFields.parentResource], processedData, __this[config.restangularFields.route], true, fullParams), filledArray);
            }
          }, function error(response) {
            if (response.status === 304 && __this[config.restangularFields.restangularCollection]) {
              resolvePromise(deferred, response, __this, filledArray);
            } else if (config.errorInterceptor(response, deferred) !== false) {
              deferred.reject(response);
            }
          });
          return restangularizePromise(deferred.promise, true, filledArray);
        }
        function withHttpConfig(httpConfig) {
          this[config.restangularFields.httpConfig] = httpConfig;
          return this;
        }
        function save(params, headers) {
          if (this[config.restangularFields.fromServer]) {
            return this[config.restangularFields.put](params, headers);
          } else {
            return _.bind(elemFunction, this)("post", undefined, params, undefined, headers);
          }
        }
        function elemFunction(operation, what, params, obj, headers) {
          var __this = this;
          var deferred = $q.defer();
          var resParams = params || {};
          var route = what || this[config.restangularFields.route];
          var fetchUrl = urlHandler.fetchUrl(this, what);
          var callObj = obj || this;
          var etag = callObj[config.restangularFields.etag] || (operation != "post" ? this[config.restangularFields.etag] : null);
          if (_.isObject(callObj) && config.isRestangularized(callObj)) {
            callObj = stripRestangular(callObj);
          }
          var request = config.fullRequestInterceptor(callObj, operation, route, fetchUrl, headers || {}, resParams || {}, this[config.restangularFields.httpConfig] || {});
          var filledObject = {};
          filledObject = config.transformElem(filledObject, false, route, service);
          var okCallback = function(response) {
            var resData = response.data;
            var fullParams = response.config.params;
            var elem = parseResponse(resData, operation, route, fetchUrl, response, deferred);
            if (elem) {
              if (operation === "post" && !__this[config.restangularFields.restangularCollection]) {
                resolvePromise(deferred, response, restangularizeElem(__this, elem, what, true, null, fullParams), filledObject);
              } else {
                data = restangularizeElem(__this[config.restangularFields.parentResource], elem, __this[config.restangularFields.route], true, null, fullParams);
                data[config.restangularFields.singleOne] = __this[config.restangularFields.singleOne];
                resolvePromise(deferred, response, data, filledObject);
              }
            } else {
              resolvePromise(deferred, response, undefined, filledObject);
            }
          };
          var errorCallback = function(response) {
            if (response.status === 304 && config.isSafe(operation)) {
              resolvePromise(deferred, response, __this, filledObject);
            } else if (config.errorInterceptor(response, deferred) !== false) {
              deferred.reject(response);
            }
          };
          var callOperation = operation;
          var callHeaders = _.extend({}, request.headers);
          var isOverrideOperation = config.isOverridenMethod(operation);
          if (isOverrideOperation) {
            callOperation = "post";
            callHeaders = _.extend(callHeaders, {
              "X-HTTP-Method-Override": operation === "remove" ? "DELETE" : operation
            });
          } else if (config.jsonp && callOperation === "get") {
            callOperation = "jsonp";
          }
          if (config.isSafe(operation)) {
            if (isOverrideOperation) {
              urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation]({}).then(okCallback, errorCallback);
            } else {
              urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation]().then(okCallback, errorCallback);
            }
          } else {
            urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation](request.element).then(okCallback, errorCallback);
          }
          return restangularizePromise(deferred.promise, false, filledObject);
        }
        function getFunction(params, headers) {
          return _.bind(elemFunction, this)("get", undefined, params, undefined, headers);
        }
        function deleteFunction(params, headers) {
          return _.bind(elemFunction, this)("remove", undefined, params, undefined, headers);
        }
        function putFunction(params, headers) {
          return _.bind(elemFunction, this)("put", undefined, params, undefined, headers);
        }
        function postFunction(what, elem, params, headers) {
          return _.bind(elemFunction, this)("post", what, params, elem, headers);
        }
        function headFunction(params, headers) {
          return _.bind(elemFunction, this)("head", undefined, params, undefined, headers);
        }
        function traceFunction(params, headers) {
          return _.bind(elemFunction, this)("trace", undefined, params, undefined, headers);
        }
        function optionsFunction(params, headers) {
          return _.bind(elemFunction, this)("options", undefined, params, undefined, headers);
        }
        function patchFunction(elem, params, headers) {
          return _.bind(elemFunction, this)("patch", undefined, params, elem, headers);
        }
        function customFunction(operation, path, params, headers, elem) {
          return _.bind(elemFunction, this)(operation, path, params, elem, headers);
        }
        function addRestangularMethodFunction(name, operation, path, defaultParams, defaultHeaders, defaultElem) {
          var bindedFunction;
          if (operation === "getList") {
            bindedFunction = _.bind(fetchFunction, this, path);
          } else {
            bindedFunction = _.bind(customFunction, this, operation, path);
          }
          var createdFunction = function(params, headers, elem) {
            var callParams = _.defaults({
              params: params,
              headers: headers,
              elem: elem
            }, {
              params: defaultParams,
              headers: defaultHeaders,
              elem: defaultElem
            });
            return bindedFunction(callParams.params, callParams.headers, callParams.elem);
          };
          if (config.isSafe(operation)) {
            this[name] = createdFunction;
          } else {
            this[name] = function(elem, params, headers) {
              return createdFunction(params, headers, elem);
            };
          }
        }
        function withConfigurationFunction(configurer) {
          var newConfig = angular.copy(_.omit(config, "configuration"));
          Configurer.init(newConfig, newConfig);
          configurer(newConfig);
          return createServiceForConfiguration(newConfig);
        }
        function toService(route, parent) {
          var serv = {};
          var collection = (parent || service).all(route);
          serv.one = _.bind(one, parent || service, parent, route);
          serv.post = _.bind(collection.post, collection);
          serv.getList = _.bind(collection.getList, collection);
          return serv;
        }
        Configurer.init(service, config);
        service.copy = _.bind(copyRestangularizedElement, service);
        service.service = _.bind(toService, service);
        service.withConfig = _.bind(withConfigurationFunction, service);
        service.one = _.bind(one, service, null);
        service.all = _.bind(all, service, null);
        service.several = _.bind(several, service, null);
        service.oneUrl = _.bind(oneUrl, service, null);
        service.allUrl = _.bind(allUrl, service, null);
        service.stripRestangular = _.bind(stripRestangular, service);
        service.restangularizeElement = _.bind(restangularizeElem, service);
        service.restangularizeCollection = _.bind(restangularizeCollectionAndElements, service);
        return service;
      }
      return createServiceForConfiguration(globalConfiguration);
    } ];
  });
})();
(function() {
  window.ionic = window.ionic || {};
  window.ionic.views = {};
  window.ionic.version = "1.0.0-beta.13";
  (function(window, document, ionic) {
    var readyCallbacks = [];
    var isDomReady = document.readyState === "complete" || document.readyState === "interactive";
    function domReady() {
      isDomReady = true;
      for (var x = 0; x < readyCallbacks.length; x++) {
        ionic.requestAnimationFrame(readyCallbacks[x]);
      }
      readyCallbacks = [];
      document.removeEventListener("DOMContentLoaded", domReady);
    }
    if (!isDomReady) {
      document.addEventListener("DOMContentLoaded", domReady);
    }
    window._rAF = function() {
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
        window.setTimeout(callback, 16);
      };
    }();
    var cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;
    ionic.DomUtil = {
      requestAnimationFrame: function(cb) {
        return window._rAF(cb);
      },
      cancelAnimationFrame: function(requestId) {
        cancelAnimationFrame(requestId);
      },
      animationFrameThrottle: function(cb) {
        var args, isQueued, context;
        return function() {
          args = arguments;
          context = this;
          if (!isQueued) {
            isQueued = true;
            ionic.requestAnimationFrame(function() {
              cb.apply(context, args);
              isQueued = false;
            });
          }
        };
      },
      getPositionInParent: function(el) {
        return {
          left: el.offsetLeft,
          top: el.offsetTop
        };
      },
      ready: function(cb) {
        if (isDomReady) {
          ionic.requestAnimationFrame(cb);
        } else {
          readyCallbacks.push(cb);
        }
      },
      getTextBounds: function(textNode) {
        if (document.createRange) {
          var range = document.createRange();
          range.selectNodeContents(textNode);
          if (range.getBoundingClientRect) {
            var rect = range.getBoundingClientRect();
            if (rect) {
              var sx = window.scrollX;
              var sy = window.scrollY;
              return {
                top: rect.top + sy,
                left: rect.left + sx,
                right: rect.left + sx + rect.width,
                bottom: rect.top + sy + rect.height,
                width: rect.width,
                height: rect.height
              };
            }
          }
        }
        return null;
      },
      getChildIndex: function(element, type) {
        if (type) {
          var ch = element.parentNode.children;
          var c;
          for (var i = 0, k = 0, j = ch.length; i < j; i++) {
            c = ch[i];
            if (c.nodeName && c.nodeName.toLowerCase() == type) {
              if (c == element) {
                return k;
              }
              k++;
            }
          }
        }
        return Array.prototype.slice.call(element.parentNode.children).indexOf(element);
      },
      swapNodes: function(src, dest) {
        dest.parentNode.insertBefore(src, dest);
      },
      elementIsDescendant: function(el, parent, stopAt) {
        var current = el;
        do {
          if (current === parent) return true;
          current = current.parentNode;
        } while (current && current !== stopAt);
        return false;
      },
      getParentWithClass: function(e, className, depth) {
        depth = depth || 10;
        while (e.parentNode && depth--) {
          if (e.parentNode.classList && e.parentNode.classList.contains(className)) {
            return e.parentNode;
          }
          e = e.parentNode;
        }
        return null;
      },
      getParentOrSelfWithClass: function(e, className, depth) {
        depth = depth || 10;
        while (e && depth--) {
          if (e.classList && e.classList.contains(className)) {
            return e;
          }
          e = e.parentNode;
        }
        return null;
      },
      rectContains: function(x, y, x1, y1, x2, y2) {
        if (x < x1 || x > x2) return false;
        if (y < y1 || y > y2) return false;
        return true;
      }
    };
    ionic.requestAnimationFrame = ionic.DomUtil.requestAnimationFrame;
    ionic.cancelAnimationFrame = ionic.DomUtil.cancelAnimationFrame;
    ionic.animationFrameThrottle = ionic.DomUtil.animationFrameThrottle;
  })(window, document, ionic);
  (function(ionic) {
    ionic.CustomEvent = function() {
      if (typeof window.CustomEvent === "function") return CustomEvent;
      var customEvent = function(event, params) {
        var evt;
        params = params || {
          bubbles: false,
          cancelable: false,
          detail: undefined
        };
        try {
          evt = document.createEvent("CustomEvent");
          evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        } catch (error) {
          evt = document.createEvent("Event");
          for (var param in params) {
            evt[param] = params[param];
          }
          evt.initEvent(event, params.bubbles, params.cancelable);
        }
        return evt;
      };
      customEvent.prototype = window.Event.prototype;
      return customEvent;
    }();
    ionic.EventController = {
      VIRTUALIZED_EVENTS: [ "tap", "swipe", "swiperight", "swipeleft", "drag", "hold", "release" ],
      trigger: function(eventType, data, bubbles, cancelable) {
        var event = new ionic.CustomEvent(eventType, {
          detail: data,
          bubbles: !!bubbles,
          cancelable: !!cancelable
        });
        data && data.target && data.target.dispatchEvent && data.target.dispatchEvent(event) || window.dispatchEvent(event);
      },
      on: function(type, callback, element) {
        var e = element || window;
        for (var i = 0, j = this.VIRTUALIZED_EVENTS.length; i < j; i++) {
          if (type == this.VIRTUALIZED_EVENTS[i]) {
            var gesture = new ionic.Gesture(element);
            gesture.on(type, callback);
            return gesture;
          }
        }
        e.addEventListener(type, callback);
      },
      off: function(type, callback, element) {
        element.removeEventListener(type, callback);
      },
      onGesture: function(type, callback, element, options) {
        var gesture = new ionic.Gesture(element, options);
        gesture.on(type, callback);
        return gesture;
      },
      offGesture: function(gesture, type, callback) {
        gesture.off(type, callback);
      },
      handlePopState: function(event) {}
    };
    ionic.on = function() {
      ionic.EventController.on.apply(ionic.EventController, arguments);
    };
    ionic.off = function() {
      ionic.EventController.off.apply(ionic.EventController, arguments);
    };
    ionic.trigger = ionic.EventController.trigger;
    ionic.onGesture = function() {
      return ionic.EventController.onGesture.apply(ionic.EventController.onGesture, arguments);
    };
    ionic.offGesture = function() {
      return ionic.EventController.offGesture.apply(ionic.EventController.offGesture, arguments);
    };
  })(window.ionic);
  (function(ionic) {
    ionic.Gesture = function(element, options) {
      return new ionic.Gestures.Instance(element, options || {});
    };
    ionic.Gestures = {};
    ionic.Gestures.defaults = {
      stop_browser_behavior: "disable-user-behavior"
    };
    ionic.Gestures.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;
    ionic.Gestures.HAS_TOUCHEVENTS = "ontouchstart" in window;
    ionic.Gestures.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;
    ionic.Gestures.NO_MOUSEEVENTS = ionic.Gestures.HAS_TOUCHEVENTS && window.navigator.userAgent.match(ionic.Gestures.MOBILE_REGEX);
    ionic.Gestures.EVENT_TYPES = {};
    ionic.Gestures.DIRECTION_DOWN = "down";
    ionic.Gestures.DIRECTION_LEFT = "left";
    ionic.Gestures.DIRECTION_UP = "up";
    ionic.Gestures.DIRECTION_RIGHT = "right";
    ionic.Gestures.POINTER_MOUSE = "mouse";
    ionic.Gestures.POINTER_TOUCH = "touch";
    ionic.Gestures.POINTER_PEN = "pen";
    ionic.Gestures.EVENT_START = "start";
    ionic.Gestures.EVENT_MOVE = "move";
    ionic.Gestures.EVENT_END = "end";
    ionic.Gestures.DOCUMENT = window.document;
    ionic.Gestures.plugins = {};
    ionic.Gestures.READY = false;
    function setup() {
      if (ionic.Gestures.READY) {
        return;
      }
      ionic.Gestures.event.determineEventTypes();
      for (var name in ionic.Gestures.gestures) {
        if (ionic.Gestures.gestures.hasOwnProperty(name)) {
          ionic.Gestures.detection.register(ionic.Gestures.gestures[name]);
        }
      }
      ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_MOVE, ionic.Gestures.detection.detect);
      ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_END, ionic.Gestures.detection.detect);
      ionic.Gestures.READY = true;
    }
    ionic.Gestures.Instance = function(element, options) {
      var self = this;
      if (element === null) {
        void 0;
        return;
      }
      setup();
      this.element = element;
      this.enabled = true;
      this.options = ionic.Gestures.utils.extend(ionic.Gestures.utils.extend({}, ionic.Gestures.defaults), options || {});
      if (this.options.stop_browser_behavior) {
        ionic.Gestures.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
      }
      ionic.Gestures.event.onTouch(element, ionic.Gestures.EVENT_START, function(ev) {
        if (self.enabled) {
          ionic.Gestures.detection.startDetect(self, ev);
        }
      });
      return this;
    };
    ionic.Gestures.Instance.prototype = {
      on: function onEvent(gesture, handler) {
        var gestures = gesture.split(" ");
        for (var t = 0; t < gestures.length; t++) {
          this.element.addEventListener(gestures[t], handler, false);
        }
        return this;
      },
      off: function offEvent(gesture, handler) {
        var gestures = gesture.split(" ");
        for (var t = 0; t < gestures.length; t++) {
          this.element.removeEventListener(gestures[t], handler, false);
        }
        return this;
      },
      trigger: function triggerEvent(gesture, eventData) {
        var event = ionic.Gestures.DOCUMENT.createEvent("Event");
        event.initEvent(gesture, true, true);
        event.gesture = eventData;
        var element = this.element;
        if (ionic.Gestures.utils.hasParent(eventData.target, element)) {
          element = eventData.target;
        }
        element.dispatchEvent(event);
        return this;
      },
      enable: function enable(state) {
        this.enabled = state;
        return this;
      }
    };
    var last_move_event = null;
    var enable_detect = false;
    var touch_triggered = false;
    ionic.Gestures.event = {
      bindDom: function(element, type, handler) {
        var types = type.split(" ");
        for (var t = 0; t < types.length; t++) {
          element.addEventListener(types[t], handler, false);
        }
      },
      onTouch: function onTouch(element, eventType, handler) {
        var self = this;
        this.bindDom(element, ionic.Gestures.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
          var sourceEventType = ev.type.toLowerCase();
          if (sourceEventType.match(/mouse/) && touch_triggered) {
            return;
          } else if (sourceEventType.match(/touch/) || sourceEventType.match(/pointerdown/) || sourceEventType.match(/mouse/) && ev.which === 1) {
            enable_detect = true;
          } else if (sourceEventType.match(/mouse/) && ev.which !== 1) {
            enable_detect = false;
          }
          if (sourceEventType.match(/touch|pointer/)) {
            touch_triggered = true;
          }
          var count_touches = 0;
          if (enable_detect) {
            if (ionic.Gestures.HAS_POINTEREVENTS && eventType != ionic.Gestures.EVENT_END) {
              count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
            } else if (sourceEventType.match(/touch/)) {
              count_touches = ev.touches.length;
            } else if (!touch_triggered) {
              count_touches = sourceEventType.match(/up/) ? 0 : 1;
            }
            if (count_touches > 0 && eventType == ionic.Gestures.EVENT_END) {
              eventType = ionic.Gestures.EVENT_MOVE;
            } else if (!count_touches) {
              eventType = ionic.Gestures.EVENT_END;
            }
            if (count_touches || last_move_event === null) {
              last_move_event = ev;
            }
            handler.call(ionic.Gestures.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev));
            if (ionic.Gestures.HAS_POINTEREVENTS && eventType == ionic.Gestures.EVENT_END) {
              count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
            }
          }
          if (!count_touches) {
            last_move_event = null;
            enable_detect = false;
            touch_triggered = false;
            ionic.Gestures.PointerEvent.reset();
          }
        });
      },
      determineEventTypes: function determineEventTypes() {
        var types;
        if (ionic.Gestures.HAS_POINTEREVENTS) {
          types = ionic.Gestures.PointerEvent.getEvents();
        } else if (ionic.Gestures.NO_MOUSEEVENTS) {
          types = [ "touchstart", "touchmove", "touchend touchcancel" ];
        } else {
          types = [ "touchstart mousedown", "touchmove mousemove", "touchend touchcancel mouseup" ];
        }
        ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_START] = types[0];
        ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_MOVE] = types[1];
        ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_END] = types[2];
      },
      getTouchList: function getTouchList(ev) {
        if (ionic.Gestures.HAS_POINTEREVENTS) {
          return ionic.Gestures.PointerEvent.getTouchList();
        } else if (ev.touches) {
          return ev.touches;
        } else {
          ev.identifier = 1;
          return [ ev ];
        }
      },
      collectEventData: function collectEventData(element, eventType, touches, ev) {
        var pointerType = ionic.Gestures.POINTER_TOUCH;
        if (ev.type.match(/mouse/) || ionic.Gestures.PointerEvent.matchType(ionic.Gestures.POINTER_MOUSE, ev)) {
          pointerType = ionic.Gestures.POINTER_MOUSE;
        }
        return {
          center: ionic.Gestures.utils.getCenter(touches),
          timeStamp: new Date().getTime(),
          target: ev.target,
          touches: touches,
          eventType: eventType,
          pointerType: pointerType,
          srcEvent: ev,
          preventDefault: function() {
            if (this.srcEvent.preventManipulation) {
              this.srcEvent.preventManipulation();
            }
            if (this.srcEvent.preventDefault) {}
          },
          stopPropagation: function() {
            this.srcEvent.stopPropagation();
          },
          stopDetect: function() {
            return ionic.Gestures.detection.stopDetect();
          }
        };
      }
    };
    ionic.Gestures.PointerEvent = {
      pointers: {},
      getTouchList: function() {
        var self = this;
        var touchlist = [];
        Object.keys(self.pointers).sort().forEach(function(id) {
          touchlist.push(self.pointers[id]);
        });
        return touchlist;
      },
      updatePointer: function(type, pointerEvent) {
        if (type == ionic.Gestures.EVENT_END) {
          this.pointers = {};
        } else {
          pointerEvent.identifier = pointerEvent.pointerId;
          this.pointers[pointerEvent.pointerId] = pointerEvent;
        }
        return Object.keys(this.pointers).length;
      },
      matchType: function(pointerType, ev) {
        if (!ev.pointerType) {
          return false;
        }
        var types = {};
        types[ionic.Gestures.POINTER_MOUSE] = ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == ionic.Gestures.POINTER_MOUSE;
        types[ionic.Gestures.POINTER_TOUCH] = ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == ionic.Gestures.POINTER_TOUCH;
        types[ionic.Gestures.POINTER_PEN] = ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == ionic.Gestures.POINTER_PEN;
        return types[pointerType];
      },
      getEvents: function() {
        return [ "pointerdown MSPointerDown", "pointermove MSPointerMove", "pointerup pointercancel MSPointerUp MSPointerCancel" ];
      },
      reset: function() {
        this.pointers = {};
      }
    };
    ionic.Gestures.utils = {
      extend: function extend(dest, src, merge) {
        for (var key in src) {
          if (dest[key] !== undefined && merge) {
            continue;
          }
          dest[key] = src[key];
        }
        return dest;
      },
      hasParent: function(node, parent) {
        while (node) {
          if (node == parent) {
            return true;
          }
          node = node.parentNode;
        }
        return false;
      },
      getCenter: function getCenter(touches) {
        var valuesX = [], valuesY = [];
        for (var t = 0, len = touches.length; t < len; t++) {
          valuesX.push(touches[t].pageX);
          valuesY.push(touches[t].pageY);
        }
        return {
          pageX: (Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2,
          pageY: (Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2
        };
      },
      getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
        return {
          x: Math.abs(delta_x / delta_time) || 0,
          y: Math.abs(delta_y / delta_time) || 0
        };
      },
      getAngle: function getAngle(touch1, touch2) {
        var y = touch2.pageY - touch1.pageY, x = touch2.pageX - touch1.pageX;
        return Math.atan2(y, x) * 180 / Math.PI;
      },
      getDirection: function getDirection(touch1, touch2) {
        var x = Math.abs(touch1.pageX - touch2.pageX), y = Math.abs(touch1.pageY - touch2.pageY);
        if (x >= y) {
          return touch1.pageX - touch2.pageX > 0 ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
        } else {
          return touch1.pageY - touch2.pageY > 0 ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
        }
      },
      getDistance: function getDistance(touch1, touch2) {
        var x = touch2.pageX - touch1.pageX, y = touch2.pageY - touch1.pageY;
        return Math.sqrt(x * x + y * y);
      },
      getScale: function getScale(start, end) {
        if (start.length >= 2 && end.length >= 2) {
          return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
        }
        return 1;
      },
      getRotation: function getRotation(start, end) {
        if (start.length >= 2 && end.length >= 2) {
          return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
        }
        return 0;
      },
      isVertical: function isVertical(direction) {
        return direction == ionic.Gestures.DIRECTION_UP || direction == ionic.Gestures.DIRECTION_DOWN;
      },
      stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_class) {
        if (element && element.classList) {
          element.classList.add(css_class);
          element.onselectstart = function() {
            return false;
          };
        }
      }
    };
    ionic.Gestures.detection = {
      gestures: [],
      current: null,
      previous: null,
      stopped: false,
      startDetect: function startDetect(inst, eventData) {
        if (this.current) {
          return;
        }
        this.stopped = false;
        this.current = {
          inst: inst,
          startEvent: ionic.Gestures.utils.extend({}, eventData),
          lastEvent: false,
          name: ""
        };
        this.detect(eventData);
      },
      detect: function detect(eventData) {
        if (!this.current || this.stopped) {
          return;
        }
        eventData = this.extendEventData(eventData);
        var inst_options = this.current.inst.options;
        for (var g = 0, len = this.gestures.length; g < len; g++) {
          var gesture = this.gestures[g];
          if (!this.stopped && inst_options[gesture.name] !== false) {
            if (gesture.handler.call(gesture, eventData, this.current.inst) === false) {
              this.stopDetect();
              break;
            }
          }
        }
        if (this.current) {
          this.current.lastEvent = eventData;
        }
        if (eventData.eventType == ionic.Gestures.EVENT_END && !eventData.touches.length - 1) {
          this.stopDetect();
        }
        return eventData;
      },
      stopDetect: function stopDetect() {
        this.previous = ionic.Gestures.utils.extend({}, this.current);
        this.current = null;
        this.stopped = true;
      },
      extendEventData: function extendEventData(ev) {
        var startEv = this.current.startEvent;
        if (startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
          startEv.touches = [];
          for (var i = 0, len = ev.touches.length; i < len; i++) {
            startEv.touches.push(ionic.Gestures.utils.extend({}, ev.touches[i]));
          }
        }
        var delta_time = ev.timeStamp - startEv.timeStamp, delta_x = ev.center.pageX - startEv.center.pageX, delta_y = ev.center.pageY - startEv.center.pageY, velocity = ionic.Gestures.utils.getVelocity(delta_time, delta_x, delta_y);
        ionic.Gestures.utils.extend(ev, {
          deltaTime: delta_time,
          deltaX: delta_x,
          deltaY: delta_y,
          velocityX: velocity.x,
          velocityY: velocity.y,
          distance: ionic.Gestures.utils.getDistance(startEv.center, ev.center),
          angle: ionic.Gestures.utils.getAngle(startEv.center, ev.center),
          direction: ionic.Gestures.utils.getDirection(startEv.center, ev.center),
          scale: ionic.Gestures.utils.getScale(startEv.touches, ev.touches),
          rotation: ionic.Gestures.utils.getRotation(startEv.touches, ev.touches),
          startEvent: startEv
        });
        return ev;
      },
      register: function register(gesture) {
        var options = gesture.defaults || {};
        if (options[gesture.name] === undefined) {
          options[gesture.name] = true;
        }
        ionic.Gestures.utils.extend(ionic.Gestures.defaults, options, true);
        gesture.index = gesture.index || 1e3;
        this.gestures.push(gesture);
        this.gestures.sort(function(a, b) {
          if (a.index < b.index) {
            return -1;
          }
          if (a.index > b.index) {
            return 1;
          }
          return 0;
        });
        return this.gestures;
      }
    };
    ionic.Gestures.gestures = ionic.Gestures.gestures || {};
    ionic.Gestures.gestures.Hold = {
      name: "hold",
      index: 10,
      defaults: {
        hold_timeout: 500,
        hold_threshold: 1
      },
      timer: null,
      handler: function holdGesture(ev, inst) {
        switch (ev.eventType) {
         case ionic.Gestures.EVENT_START:
          clearTimeout(this.timer);
          ionic.Gestures.detection.current.name = this.name;
          this.timer = setTimeout(function() {
            if (ionic.Gestures.detection.current.name == "hold") {
              ionic.tap.cancelClick();
              inst.trigger("hold", ev);
            }
          }, inst.options.hold_timeout);
          break;

         case ionic.Gestures.EVENT_MOVE:
          if (ev.distance > inst.options.hold_threshold) {
            clearTimeout(this.timer);
          }
          break;

         case ionic.Gestures.EVENT_END:
          clearTimeout(this.timer);
          break;
        }
      }
    };
    ionic.Gestures.gestures.Tap = {
      name: "tap",
      index: 100,
      defaults: {
        tap_max_touchtime: 250,
        tap_max_distance: 10,
        tap_always: true,
        doubletap_distance: 20,
        doubletap_interval: 300
      },
      handler: function tapGesture(ev, inst) {
        if (ev.eventType == ionic.Gestures.EVENT_END && ev.srcEvent.type != "touchcancel") {
          var prev = ionic.Gestures.detection.previous, did_doubletap = false;
          if (ev.deltaTime > inst.options.tap_max_touchtime || ev.distance > inst.options.tap_max_distance) {
            return;
          }
          if (prev && prev.name == "tap" && ev.timeStamp - prev.lastEvent.timeStamp < inst.options.doubletap_interval && ev.distance < inst.options.doubletap_distance) {
            inst.trigger("doubletap", ev);
            did_doubletap = true;
          }
          if (!did_doubletap || inst.options.tap_always) {
            ionic.Gestures.detection.current.name = "tap";
            inst.trigger("tap", ev);
          }
        }
      }
    };
    ionic.Gestures.gestures.Swipe = {
      name: "swipe",
      index: 40,
      defaults: {
        swipe_max_touches: 1,
        swipe_velocity: .7
      },
      handler: function swipeGesture(ev, inst) {
        if (ev.eventType == ionic.Gestures.EVENT_END) {
          if (inst.options.swipe_max_touches > 0 && ev.touches.length > inst.options.swipe_max_touches) {
            return;
          }
          if (ev.velocityX > inst.options.swipe_velocity || ev.velocityY > inst.options.swipe_velocity) {
            inst.trigger(this.name, ev);
            inst.trigger(this.name + ev.direction, ev);
          }
        }
      }
    };
    ionic.Gestures.gestures.Drag = {
      name: "drag",
      index: 50,
      defaults: {
        drag_min_distance: 10,
        correct_for_drag_min_distance: true,
        drag_max_touches: 1,
        drag_block_horizontal: true,
        drag_block_vertical: true,
        drag_lock_to_axis: false,
        drag_lock_min_distance: 25
      },
      triggered: false,
      handler: function dragGesture(ev, inst) {
        if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
          inst.trigger(this.name + "end", ev);
          this.triggered = false;
          return;
        }
        if (inst.options.drag_max_touches > 0 && ev.touches.length > inst.options.drag_max_touches) {
          return;
        }
        switch (ev.eventType) {
         case ionic.Gestures.EVENT_START:
          this.triggered = false;
          break;

         case ionic.Gestures.EVENT_MOVE:
          if (ev.distance < inst.options.drag_min_distance && ionic.Gestures.detection.current.name != this.name) {
            return;
          }
          if (ionic.Gestures.detection.current.name != this.name) {
            ionic.Gestures.detection.current.name = this.name;
            if (inst.options.correct_for_drag_min_distance) {
              var factor = Math.abs(inst.options.drag_min_distance / ev.distance);
              ionic.Gestures.detection.current.startEvent.center.pageX += ev.deltaX * factor;
              ionic.Gestures.detection.current.startEvent.center.pageY += ev.deltaY * factor;
              ev = ionic.Gestures.detection.extendEventData(ev);
            }
          }
          if (ionic.Gestures.detection.current.lastEvent.drag_locked_to_axis || inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance) {
            ev.drag_locked_to_axis = true;
          }
          var last_direction = ionic.Gestures.detection.current.lastEvent.direction;
          if (ev.drag_locked_to_axis && last_direction !== ev.direction) {
            if (ionic.Gestures.utils.isVertical(last_direction)) {
              ev.direction = ev.deltaY < 0 ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
            } else {
              ev.direction = ev.deltaX < 0 ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
            }
          }
          if (!this.triggered) {
            inst.trigger(this.name + "start", ev);
            this.triggered = true;
          }
          inst.trigger(this.name, ev);
          inst.trigger(this.name + ev.direction, ev);
          if (inst.options.drag_block_vertical && ionic.Gestures.utils.isVertical(ev.direction) || inst.options.drag_block_horizontal && !ionic.Gestures.utils.isVertical(ev.direction)) {
            ev.preventDefault();
          }
          break;

         case ionic.Gestures.EVENT_END:
          if (this.triggered) {
            inst.trigger(this.name + "end", ev);
          }
          this.triggered = false;
          break;
        }
      }
    };
    ionic.Gestures.gestures.Transform = {
      name: "transform",
      index: 45,
      defaults: {
        transform_min_scale: .01,
        transform_min_rotation: 1,
        transform_always_block: false
      },
      triggered: false,
      handler: function transformGesture(ev, inst) {
        if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
          inst.trigger(this.name + "end", ev);
          this.triggered = false;
          return;
        }
        if (ev.touches.length < 2) {
          return;
        }
        if (inst.options.transform_always_block) {
          ev.preventDefault();
        }
        switch (ev.eventType) {
         case ionic.Gestures.EVENT_START:
          this.triggered = false;
          break;

         case ionic.Gestures.EVENT_MOVE:
          var scale_threshold = Math.abs(1 - ev.scale);
          var rotation_threshold = Math.abs(ev.rotation);
          if (scale_threshold < inst.options.transform_min_scale && rotation_threshold < inst.options.transform_min_rotation) {
            return;
          }
          ionic.Gestures.detection.current.name = this.name;
          if (!this.triggered) {
            inst.trigger(this.name + "start", ev);
            this.triggered = true;
          }
          inst.trigger(this.name, ev);
          if (rotation_threshold > inst.options.transform_min_rotation) {
            inst.trigger("rotate", ev);
          }
          if (scale_threshold > inst.options.transform_min_scale) {
            inst.trigger("pinch", ev);
            inst.trigger("pinch" + (ev.scale < 1 ? "in" : "out"), ev);
          }
          break;

         case ionic.Gestures.EVENT_END:
          if (this.triggered) {
            inst.trigger(this.name + "end", ev);
          }
          this.triggered = false;
          break;
        }
      }
    };
    ionic.Gestures.gestures.Touch = {
      name: "touch",
      index: -Infinity,
      defaults: {
        prevent_default: false,
        prevent_mouseevents: false
      },
      handler: function touchGesture(ev, inst) {
        if (inst.options.prevent_mouseevents && ev.pointerType == ionic.Gestures.POINTER_MOUSE) {
          ev.stopDetect();
          return;
        }
        if (inst.options.prevent_default) {
          ev.preventDefault();
        }
        if (ev.eventType == ionic.Gestures.EVENT_START) {
          inst.trigger(this.name, ev);
        }
      }
    };
    ionic.Gestures.gestures.Release = {
      name: "release",
      index: Infinity,
      handler: function releaseGesture(ev, inst) {
        if (ev.eventType == ionic.Gestures.EVENT_END) {
          inst.trigger(this.name, ev);
        }
      }
    };
  })(window.ionic);
  (function(window, document, ionic) {
    var IOS = "ios";
    var ANDROID = "android";
    var WINDOWS_PHONE = "windowsphone";
    ionic.Platform = {
      navigator: window.navigator,
      isReady: false,
      isFullScreen: false,
      platforms: null,
      grade: null,
      ua: navigator.userAgent,
      ready: function(cb) {
        if (this.isReady) {
          cb();
        } else {
          readyCallbacks.push(cb);
        }
      },
      detect: function() {
        ionic.Platform._checkPlatforms();
        ionic.requestAnimationFrame(function() {
          for (var i = 0; i < ionic.Platform.platforms.length; i++) {
            document.body.classList.add("platform-" + ionic.Platform.platforms[i]);
          }
        });
      },
      setGrade: function(grade) {
        var oldGrade = this.grade;
        this.grade = grade;
        ionic.requestAnimationFrame(function() {
          if (oldGrade) {
            document.body.classList.remove("grade-" + oldGrade);
          }
          document.body.classList.add("grade-" + grade);
        });
      },
      device: function() {
        return window.device || {};
      },
      _checkPlatforms: function(platforms) {
        this.platforms = [];
        var grade = "a";
        if (this.isWebView()) {
          this.platforms.push("webview");
          this.platforms.push("cordova");
        } else {
          this.platforms.push("browser");
        }
        if (this.isIPad()) this.platforms.push("ipad");
        var platform = this.platform();
        if (platform) {
          this.platforms.push(platform);
          var version = this.version();
          if (version) {
            var v = version.toString();
            if (v.indexOf(".") > 0) {
              v = v.replace(".", "_");
            } else {
              v += "_0";
            }
            this.platforms.push(platform + v.split("_")[0]);
            this.platforms.push(platform + v);
            if (this.isAndroid() && version < 4.4) {
              grade = version < 4 ? "c" : "b";
            } else if (this.isWindowsPhone()) {
              grade = "b";
            }
          }
        }
        this.setGrade(grade);
      },
      isWebView: function() {
        return !(!window.cordova && !window.PhoneGap && !window.phonegap);
      },
      isIPad: function() {
        if (/iPad/i.test(ionic.Platform.navigator.platform)) {
          return true;
        }
        return /iPad/i.test(this.ua);
      },
      isIOS: function() {
        return this.is(IOS);
      },
      isAndroid: function() {
        return this.is(ANDROID);
      },
      isWindowsPhone: function() {
        return this.is(WINDOWS_PHONE);
      },
      platform: function() {
        if (platformName === null) this.setPlatform(this.device().platform);
        return platformName;
      },
      setPlatform: function(n) {
        if (typeof n != "undefined" && n !== null && n.length) {
          platformName = n.toLowerCase();
        } else if (this.ua.indexOf("Android") > 0) {
          platformName = ANDROID;
        } else if (this.ua.indexOf("iPhone") > -1 || this.ua.indexOf("iPad") > -1 || this.ua.indexOf("iPod") > -1) {
          platformName = IOS;
        } else if (this.ua.indexOf("Windows Phone") > -1) {
          platformName = WINDOWS_PHONE;
        } else {
          platformName = ionic.Platform.navigator.platform && navigator.platform.toLowerCase().split(" ")[0] || "";
        }
      },
      version: function() {
        if (platformVersion === null) this.setVersion(this.device().version);
        return platformVersion;
      },
      setVersion: function(v) {
        if (typeof v != "undefined" && v !== null) {
          v = v.split(".");
          v = parseFloat(v[0] + "." + (v.length > 1 ? v[1] : 0));
          if (!isNaN(v)) {
            platformVersion = v;
            return;
          }
        }
        platformVersion = 0;
        var pName = this.platform();
        var versionMatch = {
          android: /Android (\d+).(\d+)?/,
          ios: /OS (\d+)_(\d+)?/,
          windowsphone: /Windows Phone (\d+).(\d+)?/
        };
        if (versionMatch[pName]) {
          v = this.ua.match(versionMatch[pName]);
          if (v && v.length > 2) {
            platformVersion = parseFloat(v[1] + "." + v[2]);
          }
        }
      },
      is: function(type) {
        type = type.toLowerCase();
        if (this.platforms) {
          for (var x = 0; x < this.platforms.length; x++) {
            if (this.platforms[x] === type) return true;
          }
        }
        var pName = this.platform();
        if (pName) {
          return pName === type.toLowerCase();
        }
        return this.ua.toLowerCase().indexOf(type) >= 0;
      },
      exitApp: function() {
        this.ready(function() {
          navigator.app && navigator.app.exitApp && navigator.app.exitApp();
        });
      },
      showStatusBar: function(val) {
        this._showStatusBar = val;
        this.ready(function() {
          ionic.requestAnimationFrame(function() {
            if (ionic.Platform._showStatusBar) {
              window.StatusBar && window.StatusBar.show();
              document.body.classList.remove("status-bar-hide");
            } else {
              window.StatusBar && window.StatusBar.hide();
              document.body.classList.add("status-bar-hide");
            }
          });
        });
      },
      fullScreen: function(showFullScreen, showStatusBar) {
        this.isFullScreen = showFullScreen !== false;
        ionic.DomUtil.ready(function() {
          ionic.requestAnimationFrame(function() {
            panes = document.getElementsByClassName("pane");
            for (var i = 0; i < panes.length; i++) {
              panes[i].style.height = panes[i].offsetHeight + "px";
            }
            if (ionic.Platform.isFullScreen) {
              document.body.classList.add("fullscreen");
            } else {
              document.body.classList.remove("fullscreen");
            }
          });
          ionic.Platform.showStatusBar(showStatusBar === true);
        });
      }
    };
    var platformName = null, platformVersion = null, readyCallbacks = [], windowLoadListenderAttached;
    function onWindowLoad() {
      if (ionic.Platform.isWebView()) {
        document.addEventListener("deviceready", onPlatformReady, false);
      } else {
        onPlatformReady();
      }
      if (windowLoadListenderAttached) {
        window.removeEventListener("load", onWindowLoad, false);
      }
    }
    if (document.readyState === "complete") {
      onWindowLoad();
    } else {
      windowLoadListenderAttached = true;
      window.addEventListener("load", onWindowLoad, false);
    }
    window.addEventListener("load", onWindowLoad, false);
    function onPlatformReady() {
      ionic.Platform.isReady = true;
      ionic.Platform.detect();
      for (var x = 0; x < readyCallbacks.length; x++) {
        readyCallbacks[x]();
      }
      readyCallbacks = [];
      ionic.trigger("platformready", {
        target: document
      });
      ionic.requestAnimationFrame(function() {
        document.body.classList.add("platform-ready");
      });
    }
  })(this, document, ionic);
  (function(document, ionic) {
    "use strict";
    ionic.CSS = {};
    (function() {
      var i, keys = [ "webkitTransform", "transform", "-webkit-transform", "webkit-transform", "-moz-transform", "moz-transform", "MozTransform", "mozTransform", "msTransform" ];
      for (i = 0; i < keys.length; i++) {
        if (document.documentElement.style[keys[i]] !== undefined) {
          ionic.CSS.TRANSFORM = keys[i];
          break;
        }
      }
      keys = [ "webkitTransition", "mozTransition", "msTransition", "transition" ];
      for (i = 0; i < keys.length; i++) {
        if (document.documentElement.style[keys[i]] !== undefined) {
          ionic.CSS.TRANSITION = keys[i];
          break;
        }
      }
    })();
    if (!("classList" in document.documentElement) && Object.defineProperty && typeof HTMLElement !== "undefined") {
      Object.defineProperty(HTMLElement.prototype, "classList", {
        get: function() {
          var self = this;
          function update(fn) {
            return function() {
              var x, classes = self.className.split(/\s+/);
              for (x = 0; x < arguments.length; x++) {
                fn(classes, classes.indexOf(arguments[x]), arguments[x]);
              }
              self.className = classes.join(" ");
            };
          }
          return {
            add: update(function(classes, index, value) {
              ~index || classes.push(value);
            }),
            remove: update(function(classes, index) {
              ~index && classes.splice(index, 1);
            }),
            toggle: update(function(classes, index, value) {
              ~index ? classes.splice(index, 1) : classes.push(value);
            }),
            contains: function(value) {
              return !!~self.className.split(/\s+/).indexOf(value);
            },
            item: function(i) {
              return self.className.split(/\s+/)[i] || null;
            }
          };
        }
      });
    }
  })(document, ionic);
  var tapDoc;
  var tapActiveEle;
  var tapEnabledTouchEvents;
  var tapMouseResetTimer;
  var tapPointerMoved;
  var tapPointerStart;
  var tapTouchFocusedInput;
  var tapLastTouchTarget;
  var tapTouchMoveListener = "touchmove";
  var TAP_RELEASE_TOLERANCE = 6;
  var TAP_RELEASE_BUTTON_TOLERANCE = 50;
  var tapEventListeners = {
    click: tapClickGateKeeper,
    mousedown: tapMouseDown,
    mouseup: tapMouseUp,
    mousemove: tapMouseMove,
    touchstart: tapTouchStart,
    touchend: tapTouchEnd,
    touchcancel: tapTouchCancel,
    touchmove: tapTouchMove,
    pointerdown: tapTouchStart,
    pointerup: tapTouchEnd,
    pointercancel: tapTouchCancel,
    pointermove: tapTouchMove,
    MSPointerDown: tapTouchStart,
    MSPointerUp: tapTouchEnd,
    MSPointerCancel: tapTouchCancel,
    MSPointerMove: tapTouchMove,
    focusin: tapFocusIn,
    focusout: tapFocusOut
  };
  ionic.tap = {
    register: function(ele) {
      tapDoc = ele;
      tapEventListener("click", true, true);
      tapEventListener("mouseup");
      tapEventListener("mousedown");
      if (window.navigator.pointerEnabled) {
        tapEventListener("pointerdown");
        tapEventListener("pointerup");
        tapEventListener("pointcancel");
        tapTouchMoveListener = "pointermove";
      } else if (window.navigator.msPointerEnabled) {
        tapEventListener("MSPointerDown");
        tapEventListener("MSPointerUp");
        tapEventListener("MSPointerCancel");
        tapTouchMoveListener = "MSPointerMove";
      } else {
        tapEventListener("touchstart");
        tapEventListener("touchend");
        tapEventListener("touchcancel");
      }
      tapEventListener("focusin");
      tapEventListener("focusout");
      return function() {
        for (var type in tapEventListeners) {
          tapEventListener(type, false);
        }
        tapDoc = null;
        tapActiveEle = null;
        tapEnabledTouchEvents = false;
        tapPointerMoved = false;
        tapPointerStart = null;
      };
    },
    ignoreScrollStart: function(e) {
      return e.defaultPrevented || /^(file|range)$/i.test(e.target.type) || (e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute("data-prevent-scroll")) == "true" || !!/^(object|embed)$/i.test(e.target.tagName) || ionic.tap.isElementTapDisabled(e.target);
    },
    isTextInput: function(ele) {
      return !!ele && (ele.tagName == "TEXTAREA" || ele.contentEditable === "true" || ele.tagName == "INPUT" && !/^(radio|checkbox|range|file|submit|reset)$/i.test(ele.type));
    },
    isDateInput: function(ele) {
      return !!ele && (ele.tagName == "INPUT" && /^(date|time|datetime-local|month|week)$/i.test(ele.type));
    },
    isLabelWithTextInput: function(ele) {
      var container = tapContainingElement(ele, false);
      return !!container && ionic.tap.isTextInput(tapTargetElement(container));
    },
    containsOrIsTextInput: function(ele) {
      return ionic.tap.isTextInput(ele) || ionic.tap.isLabelWithTextInput(ele);
    },
    cloneFocusedInput: function(container, scrollIntance) {
      if (ionic.tap.hasCheckedClone) return;
      ionic.tap.hasCheckedClone = true;
      ionic.requestAnimationFrame(function() {
        var focusInput = container.querySelector(":focus");
        if (ionic.tap.isTextInput(focusInput)) {
          var clonedInput = focusInput.parentElement.querySelector(".cloned-text-input");
          if (!clonedInput) {
            clonedInput = document.createElement(focusInput.tagName);
            clonedInput.placeholder = focusInput.placeholder;
            clonedInput.type = focusInput.type;
            clonedInput.value = focusInput.value;
            clonedInput.style = focusInput.style;
            clonedInput.className = focusInput.className;
            clonedInput.classList.add("cloned-text-input");
            clonedInput.readOnly = true;
            if (focusInput.isContentEditable) {
              clonedInput.contentEditable = focusInput.contentEditable;
              clonedInput.innerHTML = focusInput.innerHTML;
            }
            focusInput.parentElement.insertBefore(clonedInput, focusInput);
            focusInput.style.top = focusInput.offsetTop;
            focusInput.classList.add("previous-input-focus");
          }
        }
      });
    },
    hasCheckedClone: false,
    removeClonedInputs: function(container, scrollIntance) {
      ionic.tap.hasCheckedClone = false;
      ionic.requestAnimationFrame(function() {
        var clonedInputs = container.querySelectorAll(".cloned-text-input");
        var previousInputFocus = container.querySelectorAll(".previous-input-focus");
        var x;
        for (x = 0; x < clonedInputs.length; x++) {
          clonedInputs[x].parentElement.removeChild(clonedInputs[x]);
        }
        for (x = 0; x < previousInputFocus.length; x++) {
          previousInputFocus[x].classList.remove("previous-input-focus");
          previousInputFocus[x].style.top = "";
          previousInputFocus[x].focus();
        }
      });
    },
    requiresNativeClick: function(ele) {
      if (!ele || ele.disabled || /^(file|range)$/i.test(ele.type) || /^(object|video)$/i.test(ele.tagName) || ionic.tap.isLabelContainingFileInput(ele)) {
        return true;
      }
      return ionic.tap.isElementTapDisabled(ele);
    },
    isLabelContainingFileInput: function(ele) {
      var lbl = tapContainingElement(ele);
      if (lbl.tagName !== "LABEL") return false;
      var fileInput = lbl.querySelector("input[type=file]");
      if (fileInput && fileInput.disabled === false) return true;
      return false;
    },
    isElementTapDisabled: function(ele) {
      if (ele && ele.nodeType === 1) {
        var element = ele;
        while (element) {
          if ((element.dataset ? element.dataset.tapDisabled : element.getAttribute("data-tap-disabled")) == "true") {
            return true;
          }
          element = element.parentElement;
        }
      }
      return false;
    },
    setTolerance: function(releaseTolerance, releaseButtonTolerance) {
      TAP_RELEASE_TOLERANCE = releaseTolerance;
      TAP_RELEASE_BUTTON_TOLERANCE = releaseButtonTolerance;
    },
    cancelClick: function() {
      tapPointerMoved = true;
    },
    pointerCoord: function(event) {
      var c = {
        x: 0,
        y: 0
      };
      if (event) {
        var touches = event.touches && event.touches.length ? event.touches : [ event ];
        var e = event.changedTouches && event.changedTouches[0] || touches[0];
        if (e) {
          c.x = e.clientX || e.pageX || 0;
          c.y = e.clientY || e.pageY || 0;
        }
      }
      return c;
    }
  };
  function tapEventListener(type, enable, useCapture) {
    if (enable !== false) {
      tapDoc.addEventListener(type, tapEventListeners[type], useCapture);
    } else {
      tapDoc.removeEventListener(type, tapEventListeners[type]);
    }
  }
  function tapClick(e) {
    var container = tapContainingElement(e.target);
    var ele = tapTargetElement(container);
    if (ionic.tap.requiresNativeClick(ele) || tapPointerMoved) return false;
    var c = ionic.tap.pointerCoord(e);
    void 0;
    triggerMouseEvent("click", ele, c.x, c.y);
    tapHandleFocus(ele);
  }
  function triggerMouseEvent(type, ele, x, y) {
    var clickEvent = document.createEvent("MouseEvents");
    clickEvent.initMouseEvent(type, true, true, window, 1, 0, 0, x, y, false, false, false, false, 0, null);
    clickEvent.isIonicTap = true;
    ele.dispatchEvent(clickEvent);
  }
  function tapClickGateKeeper(e) {
    if (e.target.type == "submit" && e.detail === 0) {
      return;
    }
    if (ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target) || !e.isIonicTap && !ionic.tap.requiresNativeClick(e.target)) {
      void 0;
      e.stopPropagation();
      if (!ionic.tap.isLabelWithTextInput(e.target)) {
        e.preventDefault();
      }
      return false;
    }
  }
  function tapMouseDown(e) {
    if (e.isIonicTap || tapIgnoreEvent(e)) return;
    if (tapEnabledTouchEvents) {
      void 0;
      e.stopPropagation();
      if ((!ionic.tap.isTextInput(e.target) || tapLastTouchTarget !== e.target) && !/^(select|option)$/i.test(e.target.tagName)) {
        e.preventDefault();
      }
      return false;
    }
    tapPointerMoved = false;
    tapPointerStart = ionic.tap.pointerCoord(e);
    tapEventListener("mousemove");
    ionic.activator.start(e);
  }
  function tapMouseUp(e) {
    if (tapEnabledTouchEvents) {
      e.stopPropagation();
      e.preventDefault();
      return false;
    }
    if (tapIgnoreEvent(e) || /^(select|option)$/i.test(e.target.tagName)) return false;
    if (!tapHasPointerMoved(e)) {
      tapClick(e);
    }
    tapEventListener("mousemove", false);
    ionic.activator.end();
    tapPointerMoved = false;
  }
  function tapMouseMove(e) {
    if (tapHasPointerMoved(e)) {
      tapEventListener("mousemove", false);
      ionic.activator.end();
      tapPointerMoved = true;
      return false;
    }
  }
  function tapTouchStart(e) {
    if (tapIgnoreEvent(e)) return;
    tapPointerMoved = false;
    tapEnableTouchEvents();
    tapPointerStart = ionic.tap.pointerCoord(e);
    tapEventListener(tapTouchMoveListener);
    ionic.activator.start(e);
    if (ionic.Platform.isIOS() && ionic.tap.isLabelWithTextInput(e.target)) {
      var textInput = tapTargetElement(tapContainingElement(e.target));
      if (textInput !== tapActiveEle) {
        e.preventDefault();
      }
    }
  }
  function tapTouchEnd(e) {
    if (tapIgnoreEvent(e)) return;
    tapEnableTouchEvents();
    if (!tapHasPointerMoved(e)) {
      tapClick(e);
      if (/^(select|option)$/i.test(e.target.tagName)) {
        e.preventDefault();
      }
    }
    tapLastTouchTarget = e.target;
    tapTouchCancel();
  }
  function tapTouchMove(e) {
    if (tapHasPointerMoved(e)) {
      tapPointerMoved = true;
      tapEventListener(tapTouchMoveListener, false);
      ionic.activator.end();
      return false;
    }
  }
  function tapTouchCancel(e) {
    tapEventListener(tapTouchMoveListener, false);
    ionic.activator.end();
    tapPointerMoved = false;
  }
  function tapEnableTouchEvents() {
    tapEnabledTouchEvents = true;
    clearTimeout(tapMouseResetTimer);
    tapMouseResetTimer = setTimeout(function() {
      tapEnabledTouchEvents = false;
    }, 2e3);
  }
  function tapIgnoreEvent(e) {
    if (e.isTapHandled) return true;
    e.isTapHandled = true;
    if (ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) {
      e.preventDefault();
      return true;
    }
  }
  function tapHandleFocus(ele) {
    tapTouchFocusedInput = null;
    var triggerFocusIn = false;
    if (ele.tagName == "SELECT") {
      triggerMouseEvent("mousedown", ele, 0, 0);
      ele.focus && ele.focus();
      triggerFocusIn = true;
    } else if (tapActiveElement() === ele) {
      triggerFocusIn = true;
    } else if (/^(input|textarea)$/i.test(ele.tagName) || ele.isContentEditable) {
      triggerFocusIn = true;
      ele.focus && ele.focus();
      ele.value = ele.value;
      if (tapEnabledTouchEvents) {
        tapTouchFocusedInput = ele;
      }
    } else {
      tapFocusOutActive();
    }
    if (triggerFocusIn) {
      tapActiveElement(ele);
      ionic.trigger("ionic.focusin", {
        target: ele
      }, true);
    }
  }
  function tapFocusOutActive() {
    var ele = tapActiveElement();
    if (ele && (/^(input|textarea|select)$/i.test(ele.tagName) || ele.isContentEditable)) {
      void 0;
      ele.blur();
    }
    tapActiveElement(null);
  }
  function tapFocusIn(e) {
    if (tapEnabledTouchEvents && ionic.tap.isTextInput(tapActiveElement()) && ionic.tap.isTextInput(tapTouchFocusedInput) && tapTouchFocusedInput !== e.target) {
      void 0;
      tapTouchFocusedInput.focus();
      tapTouchFocusedInput = null;
    }
    ionic.scroll.isScrolling = false;
  }
  function tapFocusOut() {
    tapActiveElement(null);
  }
  function tapActiveElement(ele) {
    if (arguments.length) {
      tapActiveEle = ele;
    }
    return tapActiveEle || document.activeElement;
  }
  function tapHasPointerMoved(endEvent) {
    if (!endEvent || endEvent.target.nodeType !== 1 || !tapPointerStart || tapPointerStart.x === 0 && tapPointerStart.y === 0) {
      return false;
    }
    var endCoordinates = ionic.tap.pointerCoord(endEvent);
    var hasClassList = !!(endEvent.target.classList && endEvent.target.classList.contains);
    var releaseTolerance = hasClassList & endEvent.target.classList.contains("button") ? TAP_RELEASE_BUTTON_TOLERANCE : TAP_RELEASE_TOLERANCE;
    return Math.abs(tapPointerStart.x - endCoordinates.x) > releaseTolerance || Math.abs(tapPointerStart.y - endCoordinates.y) > releaseTolerance;
  }
  function tapContainingElement(ele, allowSelf) {
    var climbEle = ele;
    for (var x = 0; x < 6; x++) {
      if (!climbEle) break;
      if (climbEle.tagName === "LABEL") return climbEle;
      climbEle = climbEle.parentElement;
    }
    if (allowSelf !== false) return ele;
  }
  function tapTargetElement(ele) {
    if (ele && ele.tagName === "LABEL") {
      if (ele.control) return ele.control;
      if (ele.querySelector) {
        var control = ele.querySelector("input,textarea,select");
        if (control) return control;
      }
    }
    return ele;
  }
  ionic.DomUtil.ready(function() {
    var ng = typeof angular !== "undefined" ? angular : null;
    if (!ng || ng && !ng.scenario) {
      ionic.tap.register(document);
    }
  });
  (function(document, ionic) {
    "use strict";
    var queueElements = {};
    var activeElements = {};
    var keyId = 0;
    var ACTIVATED_CLASS = "activated";
    ionic.activator = {
      start: function(e) {
        var self = this;
        ionic.requestAnimationFrame(function() {
          if (ionic.tap.requiresNativeClick(e.target)) return;
          var ele = e.target;
          var eleToActivate;
          for (var x = 0; x < 6; x++) {
            if (!ele || ele.nodeType !== 1) break;
            if (eleToActivate && ele.classList.contains("item")) {
              eleToActivate = ele;
              break;
            }
            if (ele.tagName == "A" || ele.tagName == "BUTTON" || ele.hasAttribute("ng-click")) {
              eleToActivate = ele;
              break;
            }
            if (ele.classList.contains("button")) {
              eleToActivate = ele;
              break;
            }
            if (ele.classList.contains("pane") || ele.tagName == "BODY" || ele.tagName == "ION-CONTENT") {
              break;
            }
            ele = ele.parentElement;
          }
          if (eleToActivate) {
            queueElements[keyId] = eleToActivate;
            if (e.type === "touchstart") {
              self._activateTimeout = setTimeout(activateElements, 80);
            } else {
              ionic.requestAnimationFrame(activateElements);
            }
            keyId = keyId > 19 ? 0 : keyId + 1;
          }
        });
      },
      end: function() {
        clearTimeout(this._activateTimeout);
        setTimeout(clear, 200);
      }
    };
    function clear() {
      queueElements = {};
      ionic.requestAnimationFrame(deactivateElements);
    }
    function activateElements() {
      for (var key in queueElements) {
        if (queueElements[key]) {
          queueElements[key].classList.add(ACTIVATED_CLASS);
          activeElements[key] = queueElements[key];
        }
      }
      queueElements = {};
    }
    function deactivateElements() {
      for (var key in activeElements) {
        if (activeElements[key]) {
          activeElements[key].classList.remove(ACTIVATED_CLASS);
          delete activeElements[key];
        }
      }
    }
  })(document, ionic);
  (function(ionic) {
    var uid = [ "0", "0", "0" ];
    ionic.Utils = {
      arrayMove: function(arr, old_index, new_index) {
        if (new_index >= arr.length) {
          var k = new_index - arr.length;
          while (k-- + 1) {
            arr.push(undefined);
          }
        }
        arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);
        return arr;
      },
      proxy: function(func, context) {
        var args = Array.prototype.slice.call(arguments, 2);
        return function() {
          return func.apply(context, args.concat(Array.prototype.slice.call(arguments)));
        };
      },
      debounce: function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        return function() {
          context = this;
          args = arguments;
          timestamp = new Date();
          var later = function() {
            var last = new Date() - timestamp;
            if (last < wait) {
              timeout = setTimeout(later, wait - last);
            } else {
              timeout = null;
              if (!immediate) result = func.apply(context, args);
            }
          };
          var callNow = immediate && !timeout;
          if (!timeout) {
            timeout = setTimeout(later, wait);
          }
          if (callNow) result = func.apply(context, args);
          return result;
        };
      },
      throttle: function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        options || (options = {});
        var later = function() {
          previous = options.leading === false ? 0 : Date.now();
          timeout = null;
          result = func.apply(context, args);
        };
        return function() {
          var now = Date.now();
          if (!previous && options.leading === false) previous = now;
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0) {
            clearTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
      },
      inherit: function(protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && protoProps.hasOwnProperty("constructor")) {
          child = protoProps.constructor;
        } else {
          child = function() {
            return parent.apply(this, arguments);
          };
        }
        ionic.extend(child, parent, staticProps);
        var Surrogate = function() {
          this.constructor = child;
        };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate();
        if (protoProps) ionic.extend(child.prototype, protoProps);
        child.__super__ = parent.prototype;
        return child;
      },
      extend: function(obj) {
        var args = Array.prototype.slice.call(arguments, 1);
        for (var i = 0; i < args.length; i++) {
          var source = args[i];
          if (source) {
            for (var prop in source) {
              obj[prop] = source[prop];
            }
          }
        }
        return obj;
      },
      nextUid: function() {
        var index = uid.length;
        var digit;
        while (index) {
          index--;
          digit = uid[index].charCodeAt(0);
          if (digit == 57) {
            uid[index] = "A";
            return uid.join("");
          }
          if (digit == 90) {
            uid[index] = "0";
          } else {
            uid[index] = String.fromCharCode(digit + 1);
            return uid.join("");
          }
        }
        uid.unshift("0");
        return uid.join("");
      }
    };
    ionic.inherit = ionic.Utils.inherit;
    ionic.extend = ionic.Utils.extend;
    ionic.throttle = ionic.Utils.throttle;
    ionic.proxy = ionic.Utils.proxy;
    ionic.debounce = ionic.Utils.debounce;
  })(window.ionic);
  var keyboardViewportHeight = getViewportHeight();
  var keyboardIsOpen;
  var keyboardActiveElement;
  var keyboardFocusOutTimer;
  var keyboardFocusInTimer;
  var keyboardPollHeightTimer;
  var keyboardLastShow = 0;
  var KEYBOARD_OPEN_CSS = "keyboard-open";
  var SCROLL_CONTAINER_CSS = "scroll";
  ionic.keyboard = {
    isOpen: false,
    height: null,
    landscape: false,
    hide: function() {
      clearTimeout(keyboardFocusInTimer);
      clearTimeout(keyboardFocusOutTimer);
      clearTimeout(keyboardPollHeightTimer);
      ionic.keyboard.isOpen = false;
      ionic.trigger("resetScrollView", {
        target: keyboardActiveElement
      }, true);
      ionic.requestAnimationFrame(function() {
        document.body.classList.remove(KEYBOARD_OPEN_CSS);
      });
      if (window.navigator.msPointerEnabled) {
        document.removeEventListener("MSPointerMove", keyboardPreventDefault);
      } else {
        document.removeEventListener("touchmove", keyboardPreventDefault);
      }
      document.removeEventListener("keydown", keyboardOnKeyDown);
      if (keyboardHasPlugin()) {
        cordova.plugins.Keyboard.close();
      }
    },
    show: function() {
      if (keyboardHasPlugin()) {
        cordova.plugins.Keyboard.show();
      }
    }
  };
  function keyboardInit() {
    if (keyboardHasPlugin()) {
      window.addEventListener("native.keyboardshow", keyboardNativeShow);
      window.addEventListener("native.keyboardhide", keyboardFocusOut);
      window.addEventListener("native.showkeyboard", keyboardNativeShow);
      window.addEventListener("native.hidekeyboard", keyboardFocusOut);
    } else {
      document.body.addEventListener("focusout", keyboardFocusOut);
    }
    document.body.addEventListener("ionic.focusin", keyboardBrowserFocusIn);
    document.body.addEventListener("focusin", keyboardBrowserFocusIn);
    document.body.addEventListener("orientationchange", keyboardOrientationChange);
    if (window.navigator.msPointerEnabled) {
      document.removeEventListener("MSPointerDown", keyboardInit);
    } else {
      document.removeEventListener("touchstart", keyboardInit);
    }
  }
  function keyboardNativeShow(e) {
    clearTimeout(keyboardFocusOutTimer);
    ionic.keyboard.height = e.keyboardHeight;
  }
  function keyboardBrowserFocusIn(e) {
    if (!e.target || !ionic.tap.isTextInput(e.target) || ionic.tap.isDateInput(e.target) || !keyboardIsWithinScroll(e.target)) return;
    document.addEventListener("keydown", keyboardOnKeyDown, false);
    document.body.scrollTop = 0;
    document.body.querySelector(".scroll-content").scrollTop = 0;
    keyboardActiveElement = e.target;
    keyboardSetShow(e);
  }
  function keyboardSetShow(e) {
    clearTimeout(keyboardFocusInTimer);
    clearTimeout(keyboardFocusOutTimer);
    keyboardFocusInTimer = setTimeout(function() {
      if (keyboardLastShow + 350 > Date.now()) return;
      void 0;
      keyboardLastShow = Date.now();
      var keyboardHeight;
      var elementBounds = keyboardActiveElement.getBoundingClientRect();
      var count = 0;
      keyboardPollHeightTimer = setInterval(function() {
        keyboardHeight = keyboardGetHeight();
        if (count > 10) {
          clearInterval(keyboardPollHeightTimer);
          keyboardHeight = 275;
        }
        if (keyboardHeight) {
          clearInterval(keyboardPollHeightTimer);
          keyboardShow(e.target, elementBounds.top, elementBounds.bottom, keyboardViewportHeight, keyboardHeight);
        }
        count++;
      }, 100);
    }, 32);
  }
  function keyboardShow(element, elementTop, elementBottom, viewportHeight, keyboardHeight) {
    var details = {
      target: element,
      elementTop: Math.round(elementTop),
      elementBottom: Math.round(elementBottom),
      keyboardHeight: keyboardHeight,
      viewportHeight: viewportHeight
    };
    details.hasPlugin = keyboardHasPlugin();
    details.contentHeight = viewportHeight - keyboardHeight;
    void 0;
    details.isElementUnderKeyboard = details.elementBottom > details.contentHeight;
    ionic.keyboard.isOpen = true;
    keyboardActiveElement = element;
    ionic.trigger("scrollChildIntoView", details, true);
    ionic.requestAnimationFrame(function() {
      document.body.classList.add(KEYBOARD_OPEN_CSS);
    });
    if (window.navigator.msPointerEnabled) {
      document.addEventListener("MSPointerMove", keyboardPreventDefault, false);
    } else {
      document.addEventListener("touchmove", keyboardPreventDefault, false);
    }
    return details;
  }
  function keyboardFocusOut(e) {
    clearTimeout(keyboardFocusOutTimer);
    keyboardFocusOutTimer = setTimeout(ionic.keyboard.hide, 350);
  }
  function keyboardUpdateViewportHeight() {
    if (getViewportHeight() > keyboardViewportHeight) {
      keyboardViewportHeight = getViewportHeight();
    }
  }
  function keyboardOnKeyDown(e) {
    if (ionic.scroll.isScrolling) {
      keyboardPreventDefault(e);
    }
  }
  function keyboardPreventDefault(e) {
    if (e.target.tagName !== "TEXTAREA") {
      e.preventDefault();
    }
  }
  function keyboardOrientationChange() {
    var updatedViewportHeight = getViewportHeight();
    if (updatedViewportHeight === keyboardViewportHeight) {
      var count = 0;
      var pollViewportHeight = setInterval(function() {
        if (count > 10) {
          clearInterval(pollViewportHeight);
        }
        updatedViewportHeight = getViewportHeight();
        if (updatedViewportHeight !== keyboardViewportHeight) {
          if (updatedViewportHeight < keyboardViewportHeight) {
            ionic.keyboard.landscape = true;
          } else {
            ionic.keyboard.landscape = false;
          }
          keyboardViewportHeight = updatedViewportHeight;
          clearInterval(pollViewportHeight);
        }
        count++;
      }, 50);
    } else {
      keyboardViewportHeight = updatedViewportHeight;
    }
  }
  function keyboardGetHeight() {
    if (ionic.keyboard.height) {
      return ionic.keyboard.height;
    }
    if (ionic.Platform.isAndroid()) {
      if (ionic.Platform.isFullScreen) {
        return 275;
      }
      if (getViewportHeight() < keyboardViewportHeight) {
        return keyboardViewportHeight - getViewportHeight();
      } else {
        return 0;
      }
    }
    if (ionic.Platform.isIOS()) {
      if (ionic.keyboard.landscape) {
        return 206;
      }
      if (!ionic.Platform.isWebView()) {
        return 216;
      }
      return 260;
    }
    return 275;
  }
  function getViewportHeight() {
    return window.innerHeight || screen.height;
  }
  function keyboardIsWithinScroll(ele) {
    while (ele) {
      if (ele.classList.contains(SCROLL_CONTAINER_CSS)) {
        return true;
      }
      ele = ele.parentElement;
    }
    return false;
  }
  function keyboardHasPlugin() {
    return !!(window.cordova && cordova.plugins && cordova.plugins.Keyboard);
  }
  ionic.Platform.ready(function() {
    keyboardUpdateViewportHeight();
    setTimeout(keyboardUpdateViewportHeight, 999);
    if (window.navigator.msPointerEnabled) {
      document.addEventListener("MSPointerDown", keyboardInit, false);
    } else {
      document.addEventListener("touchstart", keyboardInit, false);
    }
  });
  var viewportTag;
  var viewportProperties = {};
  ionic.viewport = {
    orientation: function() {
      return window.innerWidth > window.innerHeight ? 90 : 0;
    }
  };
  function viewportLoadTag() {
    var x;
    for (x = 0; x < document.head.children.length; x++) {
      if (document.head.children[x].name == "viewport") {
        viewportTag = document.head.children[x];
        break;
      }
    }
    if (viewportTag) {
      var props = viewportTag.content.toLowerCase().replace(/\s+/g, "").split(",");
      var keyValue;
      for (x = 0; x < props.length; x++) {
        if (props[x]) {
          keyValue = props[x].split("=");
          viewportProperties[keyValue[0]] = keyValue.length > 1 ? keyValue[1] : "_";
        }
      }
      viewportUpdate();
    }
  }
  function viewportUpdate() {
    var initWidth = viewportProperties.width;
    var initHeight = viewportProperties.height;
    var p = ionic.Platform;
    var version = p.version();
    var DEVICE_WIDTH = "device-width";
    var DEVICE_HEIGHT = "device-height";
    var orientation = ionic.viewport.orientation();
    delete viewportProperties.height;
    viewportProperties.width = DEVICE_WIDTH;
    if (p.isIPad()) {
      if (version > 7) {
        delete viewportProperties.width;
      } else {
        if (p.isWebView()) {
          if (orientation == 90) {
            viewportProperties.height = "0";
          } else if (version == 7) {
            viewportProperties.height = DEVICE_HEIGHT;
          }
        } else {
          if (version < 7) {
            viewportProperties.height = "0";
          }
        }
      }
    } else if (p.isIOS()) {
      if (p.isWebView()) {
        if (version > 7) {
          delete viewportProperties.width;
        } else if (version < 7) {
          if (initHeight) viewportProperties.height = "0";
        } else if (version == 7) {
          viewportProperties.height = DEVICE_HEIGHT;
        }
      } else {
        if (version < 7) {
          if (initHeight) viewportProperties.height = "0";
        }
      }
    }
    if (initWidth !== viewportProperties.width || initHeight !== viewportProperties.height) {
      viewportTagUpdate();
    }
  }
  function viewportTagUpdate() {
    var key, props = [];
    for (key in viewportProperties) {
      if (viewportProperties[key]) {
        props.push(key + (viewportProperties[key] == "_" ? "" : "=" + viewportProperties[key]));
      }
    }
    viewportTag.content = props.join(", ");
  }
  ionic.Platform.ready(function() {
    viewportLoadTag();
    window.addEventListener("orientationchange", function() {
      setTimeout(viewportUpdate, 1e3);
    }, false);
  });
  (function(ionic) {
    "use strict";
    ionic.views.View = function() {
      this.initialize.apply(this, arguments);
    };
    ionic.views.View.inherit = ionic.inherit;
    ionic.extend(ionic.views.View.prototype, {
      initialize: function() {}
    });
  })(window.ionic);
  var zyngaCore = {
    effect: {}
  };
  (function(global) {
    var time = Date.now || function() {
      return +new Date();
    };
    var desiredFrames = 60;
    var millisecondsPerSecond = 1e3;
    var running = {};
    var counter = 1;
    zyngaCore.effect.Animate = {
      requestAnimationFrame: function() {
        var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;
        var isNative = !!requestFrame;
        if (requestFrame && !/requestAnimationFrame\(\)\s*\{\s*\[native code\]\s*\}/i.test(requestFrame.toString())) {
          isNative = false;
        }
        if (isNative) {
          return function(callback, root) {
            requestFrame(callback, root);
          };
        }
        var TARGET_FPS = 60;
        var requests = {};
        var requestCount = 0;
        var rafHandle = 1;
        var intervalHandle = null;
        var lastActive = +new Date();
        return function(callback, root) {
          var callbackHandle = rafHandle++;
          requests[callbackHandle] = callback;
          requestCount++;
          if (intervalHandle === null) {
            intervalHandle = setInterval(function() {
              var time = +new Date();
              var currentRequests = requests;
              requests = {};
              requestCount = 0;
              for (var key in currentRequests) {
                if (currentRequests.hasOwnProperty(key)) {
                  currentRequests[key](time);
                  lastActive = time;
                }
              }
              if (time - lastActive > 2500) {
                clearInterval(intervalHandle);
                intervalHandle = null;
              }
            }, 1e3 / TARGET_FPS);
          }
          return callbackHandle;
        };
      }(),
      stop: function(id) {
        var cleared = running[id] != null;
        if (cleared) {
          running[id] = null;
        }
        return cleared;
      },
      isRunning: function(id) {
        return running[id] != null;
      },
      start: function(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {
        var start = time();
        var lastFrame = start;
        var percent = 0;
        var dropCounter = 0;
        var id = counter++;
        if (!root) {
          root = document.body;
        }
        if (id % 20 === 0) {
          var newRunning = {};
          for (var usedId in running) {
            newRunning[usedId] = true;
          }
          running = newRunning;
        }
        var step = function(virtual) {
          var render = virtual !== true;
          var now = time();
          if (!running[id] || verifyCallback && !verifyCallback(id)) {
            running[id] = null;
            completedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, false);
            return;
          }
          if (render) {
            var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;
            for (var j = 0; j < Math.min(droppedFrames, 4); j++) {
              step(true);
              dropCounter++;
            }
          }
          if (duration) {
            percent = (now - start) / duration;
            if (percent > 1) {
              percent = 1;
            }
          }
          var value = easingMethod ? easingMethod(percent) : percent;
          if ((stepCallback(value, now, render) === false || percent === 1) && render) {
            running[id] = null;
            completedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, percent === 1 || duration == null);
          } else if (render) {
            lastFrame = now;
            zyngaCore.effect.Animate.requestAnimationFrame(step, root);
          }
        };
        running[id] = true;
        zyngaCore.effect.Animate.requestAnimationFrame(step, root);
        return id;
      }
    };
  })(this);
  var Scroller;
  (function(ionic) {
    var NOOP = function() {};
    var easeOutCubic = function(pos) {
      return Math.pow(pos - 1, 3) + 1;
    };
    var easeInOutCubic = function(pos) {
      if ((pos /= .5) < 1) {
        return .5 * Math.pow(pos, 3);
      }
      return .5 * (Math.pow(pos - 2, 3) + 2);
    };
    ionic.views.Scroll = ionic.views.View.inherit({
      initialize: function(options) {
        var self = this;
        this.__container = options.el;
        this.__content = options.el.firstElementChild;
        setTimeout(function() {
          if (self.__container && self.__content) {
            self.__container.scrollTop = 0;
            self.__content.scrollTop = 0;
          }
        });
        this.options = {
          scrollingX: false,
          scrollbarX: true,
          scrollingY: true,
          scrollbarY: true,
          startX: 0,
          startY: 0,
          wheelDampen: 6,
          minScrollbarSizeX: 5,
          minScrollbarSizeY: 5,
          scrollbarsFade: true,
          scrollbarFadeDelay: 300,
          scrollbarResizeFadeDelay: 1e3,
          animating: true,
          animationDuration: 250,
          bouncing: true,
          locking: true,
          paging: false,
          snapping: false,
          zooming: false,
          minZoom: .5,
          maxZoom: 3,
          speedMultiplier: 1,
          deceleration: .97,
          scrollingComplete: NOOP,
          penetrationDeceleration: .03,
          penetrationAcceleration: .08,
          scrollEventInterval: 10,
          getContentWidth: function() {
            return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
          },
          getContentHeight: function() {
            return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + self.__content.offsetTop * 2);
          }
        };
        for (var key in options) {
          this.options[key] = options[key];
        }
        this.hintResize = ionic.debounce(function() {
          self.resize();
        }, 1e3, true);
        this.onScroll = function() {
          if (!ionic.scroll.isScrolling) {
            setTimeout(self.setScrollStart, 50);
          } else {
            clearTimeout(self.scrollTimer);
            self.scrollTimer = setTimeout(self.setScrollStop, 80);
          }
        };
        this.setScrollStart = function() {
          ionic.scroll.isScrolling = Math.abs(ionic.scroll.lastTop - self.__scrollTop) > 1;
          clearTimeout(self.scrollTimer);
          self.scrollTimer = setTimeout(self.setScrollStop, 80);
        };
        this.setScrollStop = function() {
          ionic.scroll.isScrolling = false;
          ionic.scroll.lastTop = self.__scrollTop;
        };
        this.triggerScrollEvent = ionic.throttle(function() {
          self.onScroll();
          ionic.trigger("scroll", {
            scrollTop: self.__scrollTop,
            scrollLeft: self.__scrollLeft,
            target: self.__container
          });
        }, this.options.scrollEventInterval);
        this.triggerScrollEndEvent = function() {
          ionic.trigger("scrollend", {
            scrollTop: self.__scrollTop,
            scrollLeft: self.__scrollLeft,
            target: self.__container
          });
        };
        this.__scrollLeft = this.options.startX;
        this.__scrollTop = this.options.startY;
        this.__callback = this.getRenderFn();
        this.__initEventHandlers();
        this.__createScrollbars();
      },
      run: function() {
        this.resize();
        this.__fadeScrollbars("out", this.options.scrollbarResizeFadeDelay);
      },
      __isSingleTouch: false,
      __isTracking: false,
      __didDecelerationComplete: false,
      __isGesturing: false,
      __isDragging: false,
      __isDecelerating: false,
      __isAnimating: false,
      __clientLeft: 0,
      __clientTop: 0,
      __clientWidth: 0,
      __clientHeight: 0,
      __contentWidth: 0,
      __contentHeight: 0,
      __snapWidth: 100,
      __snapHeight: 100,
      __refreshHeight: null,
      __refreshActive: false,
      __refreshActivate: null,
      __refreshDeactivate: null,
      __refreshStart: null,
      __zoomLevel: 1,
      __scrollLeft: 0,
      __scrollTop: 0,
      __maxScrollLeft: 0,
      __maxScrollTop: 0,
      __scheduledLeft: 0,
      __scheduledTop: 0,
      __scheduledZoom: 0,
      __lastTouchLeft: null,
      __lastTouchTop: null,
      __lastTouchMove: null,
      __positions: null,
      __minDecelerationScrollLeft: null,
      __minDecelerationScrollTop: null,
      __maxDecelerationScrollLeft: null,
      __maxDecelerationScrollTop: null,
      __decelerationVelocityX: null,
      __decelerationVelocityY: null,
      __transformProperty: null,
      __perspectiveProperty: null,
      __indicatorX: null,
      __indicatorY: null,
      __scrollbarFadeTimeout: null,
      __didWaitForSize: null,
      __sizerTimeout: null,
      __initEventHandlers: function() {
        var self = this;
        var container = this.__container;
        self.scrollChildIntoView = function(e) {
          var scrollBottomOffsetToTop;
          if (!self.isScrolledIntoView) {
            if (ionic.Platform.isIOS() || ionic.Platform.isFullScreen) {
              scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
              var scrollBottomOffsetToBottom = e.detail.viewportHeight - scrollBottomOffsetToTop;
              var keyboardOffset = Math.max(0, e.detail.keyboardHeight - scrollBottomOffsetToBottom);
              container.style.height = container.clientHeight - keyboardOffset + "px";
              container.style.overflow = "visible";
              self.resize();
            }
            self.isScrolledIntoView = true;
          }
          if (e.detail.isElementUnderKeyboard) {
            var delay;
            if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
              if (ionic.Platform.version() < 4.4) {
                delay = 500;
              } else {
                delay = 350;
              }
            } else {
              delay = 80;
            }
            ionic.scroll.isScrolling = true;
            setTimeout(function() {
              var scrollMidpointOffset = container.clientHeight * .5;
              scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
              var elementTopOffsetToScrollBottom = e.detail.elementTop - scrollBottomOffsetToTop;
              var scrollTop = elementTopOffsetToScrollBottom + scrollMidpointOffset;
              if (scrollTop > 0) {
                ionic.tap.cloneFocusedInput(container, self);
                self.scrollBy(0, scrollTop, true);
                self.onScroll();
              }
            }, delay);
          }
          e.stopPropagation();
        };
        self.resetScrollView = function(e) {
          if (self.isScrolledIntoView) {
            self.isScrolledIntoView = false;
            container.style.height = "";
            container.style.overflow = "";
            self.resize();
            ionic.scroll.isScrolling = false;
          }
        };
        container.addEventListener("scrollChildIntoView", self.scrollChildIntoView);
        container.addEventListener("resetScrollView", self.resetScrollView);
        function getEventTouches(e) {
          return e.touches && e.touches.length ? e.touches : [ {
            pageX: e.pageX,
            pageY: e.pageY
          } ];
        }
        self.touchStart = function(e) {
          self.startCoordinates = ionic.tap.pointerCoord(e);
          if (ionic.tap.ignoreScrollStart(e)) {
            return;
          }
          self.__isDown = true;
          if (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === "SELECT") {
            self.__hasStarted = false;
            return;
          }
          self.__isSelectable = true;
          self.__enableScrollY = true;
          self.__hasStarted = true;
          self.doTouchStart(getEventTouches(e), e.timeStamp);
          e.preventDefault();
        };
        self.touchMove = function(e) {
          if (!self.__isDown || e.defaultPrevented || e.target.tagName === "TEXTAREA" && e.target.parentElement.querySelector(":focus")) {
            return;
          }
          if (!self.__hasStarted && (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === "SELECT")) {
            self.__hasStarted = true;
            self.doTouchStart(getEventTouches(e), e.timeStamp);
            e.preventDefault();
            return;
          }
          if (self.startCoordinates) {
            var currentCoordinates = ionic.tap.pointerCoord(e);
            if (self.__isSelectable && ionic.tap.isTextInput(e.target) && Math.abs(self.startCoordinates.x - currentCoordinates.x) > 20) {
              self.__enableScrollY = false;
              self.__isSelectable = true;
            }
            if (self.__enableScrollY && Math.abs(self.startCoordinates.y - currentCoordinates.y) > 10) {
              self.__isSelectable = false;
              ionic.tap.cloneFocusedInput(container, self);
            }
          }
          self.doTouchMove(getEventTouches(e), e.timeStamp, e.scale);
          self.__isDown = true;
        };
        self.touchEnd = function(e) {
          if (!self.__isDown) return;
          self.doTouchEnd(e.timeStamp);
          self.__isDown = false;
          self.__hasStarted = false;
          self.__isSelectable = true;
          self.__enableScrollY = true;
          if (!self.__isDragging && !self.__isDecelerating && !self.__isAnimating) {
            ionic.tap.removeClonedInputs(container, self);
          }
        };
        if ("ontouchstart" in window) {
          container.addEventListener("touchstart", self.touchStart, false);
          document.addEventListener("touchmove", self.touchMove, false);
          document.addEventListener("touchend", self.touchEnd, false);
          document.addEventListener("touchcancel", self.touchEnd, false);
        } else if (window.navigator.pointerEnabled) {
          container.addEventListener("pointerdown", self.touchStart, false);
          document.addEventListener("pointermove", self.touchMove, false);
          document.addEventListener("pointerup", self.touchEnd, false);
          document.addEventListener("pointercancel", self.touchEnd, false);
        } else if (window.navigator.msPointerEnabled) {
          container.addEventListener("MSPointerDown", self.touchStart, false);
          document.addEventListener("MSPointerMove", self.touchMove, false);
          document.addEventListener("MSPointerUp", self.touchEnd, false);
          document.addEventListener("MSPointerCancel", self.touchEnd, false);
        } else {
          var mousedown = false;
          self.mouseDown = function(e) {
            if (ionic.tap.ignoreScrollStart(e) || e.target.tagName === "SELECT") {
              return;
            }
            self.doTouchStart(getEventTouches(e), e.timeStamp);
            if (!ionic.tap.isTextInput(e.target)) {
              e.preventDefault();
            }
            mousedown = true;
          };
          self.mouseMove = function(e) {
            if (!mousedown || e.defaultPrevented) {
              return;
            }
            self.doTouchMove(getEventTouches(e), e.timeStamp);
            mousedown = true;
          };
          self.mouseUp = function(e) {
            if (!mousedown) {
              return;
            }
            self.doTouchEnd(e.timeStamp);
            mousedown = false;
          };
          self.mouseWheel = ionic.animationFrameThrottle(function(e) {
            var scrollParent = ionic.DomUtil.getParentOrSelfWithClass(e.target, "ionic-scroll");
            if (scrollParent === self.__container) {
              self.hintResize();
              self.scrollBy(e.wheelDeltaX / self.options.wheelDampen, -e.wheelDeltaY / self.options.wheelDampen);
              self.__fadeScrollbars("in");
              clearTimeout(self.__wheelHideBarTimeout);
              self.__wheelHideBarTimeout = setTimeout(function() {
                self.__fadeScrollbars("out");
              }, 100);
            }
          });
          container.addEventListener("mousedown", self.mouseDown, false);
          document.addEventListener("mousemove", self.mouseMove, false);
          document.addEventListener("mouseup", self.mouseUp, false);
          document.addEventListener("mousewheel", self.mouseWheel, false);
        }
      },
      __cleanup: function() {
        var container = this.__container;
        var self = this;
        container.removeEventListener("touchstart", self.touchStart);
        document.removeEventListener("touchmove", self.touchMove);
        document.removeEventListener("touchend", self.touchEnd);
        document.removeEventListener("touchcancel", self.touchCancel);
        container.removeEventListener("pointerdown", self.touchStart);
        document.removeEventListener("pointermove", self.touchMove);
        document.removeEventListener("pointerup", self.touchEnd);
        document.removeEventListener("pointercancel", self.touchEnd);
        container.removeEventListener("MSPointerDown", self.touchStart);
        document.removeEventListener("MSPointerMove", self.touchMove);
        document.removeEventListener("MSPointerUp", self.touchEnd);
        document.removeEventListener("MSPointerCancel", self.touchEnd);
        container.removeEventListener("mousedown", self.mouseDown);
        document.removeEventListener("mousemove", self.mouseMove);
        document.removeEventListener("mouseup", self.mouseUp);
        document.removeEventListener("mousewheel", self.mouseWheel);
        container.removeEventListener("scrollChildIntoView", self.scrollChildIntoView);
        container.removeEventListener("resetScrollView", self.resetScrollView);
        ionic.tap.removeClonedInputs(container, self);
        delete this.__container;
        delete this.__content;
        delete this.__indicatorX;
        delete this.__indicatorY;
        delete this.options.el;
        this.__callback = this.scrollChildIntoView = this.resetScrollView = angular.noop;
        this.mouseMove = this.mouseDown = this.mouseUp = this.mouseWheel = this.touchStart = this.touchMove = this.touchEnd = this.touchCancel = angular.noop;
        this.resize = this.scrollTo = this.zoomTo = this.__scrollingComplete = angular.noop;
        container = null;
      },
      __createScrollbar: function(direction) {
        var bar = document.createElement("div"), indicator = document.createElement("div");
        indicator.className = "scroll-bar-indicator scroll-bar-fade-out";
        if (direction == "h") {
          bar.className = "scroll-bar scroll-bar-h";
        } else {
          bar.className = "scroll-bar scroll-bar-v";
        }
        bar.appendChild(indicator);
        return bar;
      },
      __createScrollbars: function() {
        var indicatorX, indicatorY;
        if (this.options.scrollingX) {
          indicatorX = {
            el: this.__createScrollbar("h"),
            sizeRatio: 1
          };
          indicatorX.indicator = indicatorX.el.children[0];
          if (this.options.scrollbarX) {
            this.__container.appendChild(indicatorX.el);
          }
          this.__indicatorX = indicatorX;
        }
        if (this.options.scrollingY) {
          indicatorY = {
            el: this.__createScrollbar("v"),
            sizeRatio: 1
          };
          indicatorY.indicator = indicatorY.el.children[0];
          if (this.options.scrollbarY) {
            this.__container.appendChild(indicatorY.el);
          }
          this.__indicatorY = indicatorY;
        }
      },
      __resizeScrollbars: function() {
        var self = this;
        if (self.__indicatorX) {
          var width = Math.max(Math.round(self.__clientWidth * self.__clientWidth / self.__contentWidth), 20);
          if (width > self.__contentWidth) {
            width = 0;
          }
          self.__indicatorX.size = width;
          self.__indicatorX.minScale = this.options.minScrollbarSizeX / width;
          self.__indicatorX.indicator.style.width = width + "px";
          self.__indicatorX.maxPos = self.__clientWidth - width;
          self.__indicatorX.sizeRatio = self.__maxScrollLeft ? self.__indicatorX.maxPos / self.__maxScrollLeft : 1;
        }
        if (self.__indicatorY) {
          var height = Math.max(Math.round(self.__clientHeight * self.__clientHeight / self.__contentHeight), 20);
          if (height > self.__contentHeight) {
            height = 0;
          }
          self.__indicatorY.size = height;
          self.__indicatorY.minScale = this.options.minScrollbarSizeY / height;
          self.__indicatorY.maxPos = self.__clientHeight - height;
          self.__indicatorY.indicator.style.height = height + "px";
          self.__indicatorY.sizeRatio = self.__maxScrollTop ? self.__indicatorY.maxPos / self.__maxScrollTop : 1;
        }
      },
      __repositionScrollbars: function() {
        var self = this, width, heightScale, widthDiff, heightDiff, x, y, xstop = 0, ystop = 0;
        if (self.__indicatorX) {
          if (self.__indicatorY) xstop = 10;
          x = Math.round(self.__indicatorX.sizeRatio * self.__scrollLeft) || 0, widthDiff = self.__scrollLeft - (self.__maxScrollLeft - xstop);
          if (self.__scrollLeft < 0) {
            widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - Math.abs(self.__scrollLeft)) / self.__indicatorX.size);
            x = 0;
            self.__indicatorX.indicator.style[self.__transformOriginProperty] = "left center";
          } else if (widthDiff > 0) {
            widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - widthDiff) / self.__indicatorX.size);
            x = self.__indicatorX.maxPos - xstop;
            self.__indicatorX.indicator.style[self.__transformOriginProperty] = "right center";
          } else {
            x = Math.min(self.__maxScrollLeft, Math.max(0, x));
            widthScale = 1;
          }
          self.__indicatorX.indicator.style[self.__transformProperty] = "translate3d(" + x + "px, 0, 0) scaleX(" + widthScale + ")";
        }
        if (self.__indicatorY) {
          y = Math.round(self.__indicatorY.sizeRatio * self.__scrollTop) || 0;
          if (self.__indicatorX) ystop = 10;
          heightDiff = self.__scrollTop - (self.__maxScrollTop - ystop);
          if (self.__scrollTop < 0) {
            heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - Math.abs(self.__scrollTop)) / self.__indicatorY.size);
            y = 0;
            self.__indicatorY.indicator.style[self.__transformOriginProperty] = "center top";
          } else if (heightDiff > 0) {
            heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - heightDiff) / self.__indicatorY.size);
            y = self.__indicatorY.maxPos - ystop;
            self.__indicatorY.indicator.style[self.__transformOriginProperty] = "center bottom";
          } else {
            y = Math.min(self.__maxScrollTop, Math.max(0, y));
            heightScale = 1;
          }
          self.__indicatorY.indicator.style[self.__transformProperty] = "translate3d(0," + y + "px, 0) scaleY(" + heightScale + ")";
        }
      },
      __fadeScrollbars: function(direction, delay) {
        var self = this;
        if (!this.options.scrollbarsFade) {
          return;
        }
        var className = "scroll-bar-fade-out";
        if (self.options.scrollbarsFade === true) {
          clearTimeout(self.__scrollbarFadeTimeout);
          if (direction == "in") {
            if (self.__indicatorX) {
              self.__indicatorX.indicator.classList.remove(className);
            }
            if (self.__indicatorY) {
              self.__indicatorY.indicator.classList.remove(className);
            }
          } else {
            self.__scrollbarFadeTimeout = setTimeout(function() {
              if (self.__indicatorX) {
                self.__indicatorX.indicator.classList.add(className);
              }
              if (self.__indicatorY) {
                self.__indicatorY.indicator.classList.add(className);
              }
            }, delay || self.options.scrollbarFadeDelay);
          }
        }
      },
      __scrollingComplete: function() {
        var self = this;
        self.options.scrollingComplete();
        ionic.tap.removeClonedInputs(self.__container, self);
        self.__fadeScrollbars("out");
      },
      resize: function() {
        if (!this.__container || !this.options) return;
        this.setDimensions(this.__container.clientWidth, this.__container.clientHeight, this.options.getContentWidth(), this.options.getContentHeight());
      },
      getRenderFn: function() {
        var self = this;
        var content = this.__content;
        var docStyle = document.documentElement.style;
        var engine;
        if ("MozAppearance" in docStyle) {
          engine = "gecko";
        } else if ("WebkitAppearance" in docStyle) {
          engine = "webkit";
        } else if (typeof navigator.cpuClass === "string") {
          engine = "trident";
        }
        var vendorPrefix = {
          trident: "ms",
          gecko: "Moz",
          webkit: "Webkit",
          presto: "O"
        }[engine];
        var helperElem = document.createElement("div");
        var undef;
        var perspectiveProperty = vendorPrefix + "Perspective";
        var transformProperty = vendorPrefix + "Transform";
        var transformOriginProperty = vendorPrefix + "TransformOrigin";
        self.__perspectiveProperty = transformProperty;
        self.__transformProperty = transformProperty;
        self.__transformOriginProperty = transformOriginProperty;
        if (helperElem.style[perspectiveProperty] !== undef) {
          return function(left, top, zoom, wasResize) {
            content.style[transformProperty] = "translate3d(" + -left + "px," + -top + "px,0) scale(" + zoom + ")";
            self.__repositionScrollbars();
            if (!wasResize) {
              self.triggerScrollEvent();
            }
          };
        } else if (helperElem.style[transformProperty] !== undef) {
          return function(left, top, zoom, wasResize) {
            content.style[transformProperty] = "translate(" + -left + "px," + -top + "px) scale(" + zoom + ")";
            self.__repositionScrollbars();
            if (!wasResize) {
              self.triggerScrollEvent();
            }
          };
        } else {
          return function(left, top, zoom, wasResize) {
            content.style.marginLeft = left ? -left / zoom + "px" : "";
            content.style.marginTop = top ? -top / zoom + "px" : "";
            content.style.zoom = zoom || "";
            self.__repositionScrollbars();
            if (!wasResize) {
              self.triggerScrollEvent();
            }
          };
        }
      },
      setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {
        var self = this;
        if (clientWidth === +clientWidth) {
          self.__clientWidth = clientWidth;
        }
        if (clientHeight === +clientHeight) {
          self.__clientHeight = clientHeight;
        }
        if (contentWidth === +contentWidth) {
          self.__contentWidth = contentWidth;
        }
        if (contentHeight === +contentHeight) {
          self.__contentHeight = contentHeight;
        }
        self.__computeScrollMax();
        self.__resizeScrollbars();
        self.scrollTo(self.__scrollLeft, self.__scrollTop, true, null, true);
      },
      setPosition: function(left, top) {
        var self = this;
        self.__clientLeft = left || 0;
        self.__clientTop = top || 0;
      },
      setSnapSize: function(width, height) {
        var self = this;
        self.__snapWidth = width;
        self.__snapHeight = height;
      },
      activatePullToRefresh: function(height, activateCallback, deactivateCallback, startCallback, showCallback, hideCallback, tailCallback) {
        var self = this;
        self.__refreshHeight = height;
        self.__refreshActivate = function() {
          ionic.requestAnimationFrame(activateCallback);
        };
        self.__refreshDeactivate = function() {
          ionic.requestAnimationFrame(deactivateCallback);
        };
        self.__refreshStart = function() {
          ionic.requestAnimationFrame(startCallback);
        };
        self.__refreshShow = function() {
          ionic.requestAnimationFrame(showCallback);
        };
        self.__refreshHide = function() {
          ionic.requestAnimationFrame(hideCallback);
        };
        self.__refreshTail = function() {
          ionic.requestAnimationFrame(tailCallback);
        };
        self.__refreshTailTime = 100;
        self.__minSpinTime = 600;
      },
      triggerPullToRefresh: function() {
        this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);
        var d = new Date();
        self.refreshStartTime = d.getTime();
        if (this.__refreshStart) {
          this.__refreshStart();
        }
      },
      finishPullToRefresh: function() {
        var self = this;
        var d = new Date();
        var delay = 0;
        if (self.refreshStartTime + self.__minSpinTime > d.getTime()) {
          delay = self.refreshStartTime + self.__minSpinTime - d.getTime();
        }
        setTimeout(function() {
          if (self.__refreshTail) {
            self.__refreshTail();
          }
          setTimeout(function() {
            self.__refreshActive = false;
            if (self.__refreshDeactivate) {
              self.__refreshDeactivate();
            }
            self.scrollTo(self.__scrollLeft, self.__scrollTop, true);
          }, self.__refreshTailTime);
        }, delay);
      },
      getValues: function() {
        var self = this;
        return {
          left: self.__scrollLeft,
          top: self.__scrollTop,
          zoom: self.__zoomLevel
        };
      },
      getScrollMax: function() {
        var self = this;
        return {
          left: self.__maxScrollLeft,
          top: self.__maxScrollTop
        };
      },
      zoomTo: function(level, animate, originLeft, originTop) {
        var self = this;
        if (!self.options.zooming) {
          throw new Error("Zooming is not enabled!");
        }
        if (self.__isDecelerating) {
          zyngaCore.effect.Animate.stop(self.__isDecelerating);
          self.__isDecelerating = false;
        }
        var oldLevel = self.__zoomLevel;
        if (originLeft == null) {
          originLeft = self.__clientWidth / 2;
        }
        if (originTop == null) {
          originTop = self.__clientHeight / 2;
        }
        level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
        self.__computeScrollMax(level);
        var left = (originLeft + self.__scrollLeft) * level / oldLevel - originLeft;
        var top = (originTop + self.__scrollTop) * level / oldLevel - originTop;
        if (left > self.__maxScrollLeft) {
          left = self.__maxScrollLeft;
        } else if (left < 0) {
          left = 0;
        }
        if (top > self.__maxScrollTop) {
          top = self.__maxScrollTop;
        } else if (top < 0) {
          top = 0;
        }
        self.__publish(left, top, level, animate);
      },
      zoomBy: function(factor, animate, originLeft, originTop) {
        var self = this;
        self.zoomTo(self.__zoomLevel * factor, animate, originLeft, originTop);
      },
      scrollTo: function(left, top, animate, zoom, wasResize) {
        var self = this;
        if (self.__isDecelerating) {
          zyngaCore.effect.Animate.stop(self.__isDecelerating);
          self.__isDecelerating = false;
        }
        if (zoom != null && zoom !== self.__zoomLevel) {
          if (!self.options.zooming) {
            throw new Error("Zooming is not enabled!");
          }
          left *= zoom;
          top *= zoom;
          self.__computeScrollMax(zoom);
        } else {
          zoom = self.__zoomLevel;
        }
        if (!self.options.scrollingX) {
          left = self.__scrollLeft;
        } else {
          if (self.options.paging) {
            left = Math.round(left / self.__clientWidth) * self.__clientWidth;
          } else if (self.options.snapping) {
            left = Math.round(left / self.__snapWidth) * self.__snapWidth;
          }
        }
        if (!self.options.scrollingY) {
          top = self.__scrollTop;
        } else {
          if (self.options.paging) {
            top = Math.round(top / self.__clientHeight) * self.__clientHeight;
          } else if (self.options.snapping) {
            top = Math.round(top / self.__snapHeight) * self.__snapHeight;
          }
        }
        left = Math.max(Math.min(self.__maxScrollLeft, left), 0);
        top = Math.max(Math.min(self.__maxScrollTop, top), 0);
        if (left === self.__scrollLeft && top === self.__scrollTop) {
          animate = false;
        }
        self.__publish(left, top, zoom, animate, wasResize);
      },
      scrollBy: function(left, top, animate) {
        var self = this;
        var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
        var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
        self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
      },
      doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {
        var self = this;
        var change = wheelDelta > 0 ? .97 : 1.03;
        return self.zoomTo(self.__zoomLevel * change, false, pageX - self.__clientLeft, pageY - self.__clientTop);
      },
      doTouchStart: function(touches, timeStamp) {
        this.hintResize();
        if (timeStamp instanceof Date) {
          timeStamp = timeStamp.valueOf();
        }
        if (typeof timeStamp !== "number") {
          timeStamp = Date.now();
        }
        var self = this;
        self.__interruptedAnimation = true;
        if (self.__isDecelerating) {
          zyngaCore.effect.Animate.stop(self.__isDecelerating);
          self.__isDecelerating = false;
          self.__interruptedAnimation = true;
        }
        if (self.__isAnimating) {
          zyngaCore.effect.Animate.stop(self.__isAnimating);
          self.__isAnimating = false;
          self.__interruptedAnimation = true;
        }
        var currentTouchLeft, currentTouchTop;
        var isSingleTouch = touches.length === 1;
        if (isSingleTouch) {
          currentTouchLeft = touches[0].pageX;
          currentTouchTop = touches[0].pageY;
        } else {
          currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
          currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
        }
        self.__initialTouchLeft = currentTouchLeft;
        self.__initialTouchTop = currentTouchTop;
        self.__initialTouches = touches;
        self.__zoomLevelStart = self.__zoomLevel;
        self.__lastTouchLeft = currentTouchLeft;
        self.__lastTouchTop = currentTouchTop;
        self.__lastTouchMove = timeStamp;
        self.__lastScale = 1;
        self.__enableScrollX = !isSingleTouch && self.options.scrollingX;
        self.__enableScrollY = !isSingleTouch && self.options.scrollingY;
        self.__isTracking = true;
        self.__didDecelerationComplete = false;
        self.__isDragging = !isSingleTouch;
        self.__isSingleTouch = isSingleTouch;
        self.__positions = [];
      },
      doTouchMove: function(touches, timeStamp, scale) {
        if (timeStamp instanceof Date) {
          timeStamp = timeStamp.valueOf();
        }
        if (typeof timeStamp !== "number") {
          timeStamp = Date.now();
        }
        var self = this;
        if (!self.__isTracking) {
          return;
        }
        var currentTouchLeft, currentTouchTop;
        if (touches.length === 2) {
          currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
          currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
          if (!scale && self.options.zooming) {
            scale = self.__getScale(self.__initialTouches, touches);
          }
        } else {
          currentTouchLeft = touches[0].pageX;
          currentTouchTop = touches[0].pageY;
        }
        var positions = self.__positions;
        if (self.__isDragging) {
          var moveX = currentTouchLeft - self.__lastTouchLeft;
          var moveY = currentTouchTop - self.__lastTouchTop;
          var scrollLeft = self.__scrollLeft;
          var scrollTop = self.__scrollTop;
          var level = self.__zoomLevel;
          if (scale != null && self.options.zooming) {
            var oldLevel = level;
            level = level / self.__lastScale * scale;
            level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
            if (oldLevel !== level) {
              var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;
              var currentTouchTopRel = currentTouchTop - self.__clientTop;
              scrollLeft = (currentTouchLeftRel + scrollLeft) * level / oldLevel - currentTouchLeftRel;
              scrollTop = (currentTouchTopRel + scrollTop) * level / oldLevel - currentTouchTopRel;
              self.__computeScrollMax(level);
            }
          }
          if (self.__enableScrollX) {
            scrollLeft -= moveX * this.options.speedMultiplier;
            var maxScrollLeft = self.__maxScrollLeft;
            if (scrollLeft > maxScrollLeft || scrollLeft < 0) {
              if (self.options.bouncing) {
                scrollLeft += moveX / 2 * this.options.speedMultiplier;
              } else if (scrollLeft > maxScrollLeft) {
                scrollLeft = maxScrollLeft;
              } else {
                scrollLeft = 0;
              }
            }
          }
          if (self.__enableScrollY) {
            scrollTop -= moveY * this.options.speedMultiplier;
            var maxScrollTop = self.__maxScrollTop;
            if (scrollTop > maxScrollTop || scrollTop < 0) {
              if (self.options.bouncing || self.__refreshHeight && scrollTop < 0) {
                scrollTop += moveY / 2 * this.options.speedMultiplier;
                if (!self.__enableScrollX && self.__refreshHeight != null) {
                  if (scrollTop < 0) {
                    self.__refreshHidden = false;
                    self.__refreshShow();
                  } else {
                    self.__refreshHide();
                    self.__refreshHidden = true;
                  }
                  if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {
                    self.__refreshActive = true;
                    if (self.__refreshActivate) {
                      self.__refreshActivate();
                    }
                  } else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {
                    self.__refreshActive = false;
                    if (self.__refreshDeactivate) {
                      self.__refreshDeactivate();
                    }
                  }
                }
              } else if (scrollTop > maxScrollTop) {
                scrollTop = maxScrollTop;
              } else {
                scrollTop = 0;
              }
            } else if (self.__refreshHeight && !self.__refreshHidden) {
              self.__refreshHide();
              self.__refreshHidden = true;
            }
          }
          if (positions.length > 60) {
            positions.splice(0, 30);
          }
          positions.push(scrollLeft, scrollTop, timeStamp);
          self.__publish(scrollLeft, scrollTop, level);
        } else {
          var minimumTrackingForScroll = self.options.locking ? 3 : 0;
          var minimumTrackingForDrag = 5;
          var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);
          var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);
          self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;
          self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;
          positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);
          self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);
          if (self.__isDragging) {
            self.__interruptedAnimation = false;
            self.__fadeScrollbars("in");
          }
        }
        self.__lastTouchLeft = currentTouchLeft;
        self.__lastTouchTop = currentTouchTop;
        self.__lastTouchMove = timeStamp;
        self.__lastScale = scale;
      },
      doTouchEnd: function(timeStamp) {
        if (timeStamp instanceof Date) {
          timeStamp = timeStamp.valueOf();
        }
        if (typeof timeStamp !== "number") {
          timeStamp = Date.now();
        }
        var self = this;
        if (!self.__isTracking) {
          return;
        }
        self.__isTracking = false;
        if (self.__isDragging) {
          self.__isDragging = false;
          if (self.__isSingleTouch && self.options.animating && timeStamp - self.__lastTouchMove <= 100) {
            var positions = self.__positions;
            var endPos = positions.length - 1;
            var startPos = endPos;
            for (var i = endPos; i > 0 && positions[i] > self.__lastTouchMove - 100; i -= 3) {
              startPos = i;
            }
            if (startPos !== endPos) {
              var timeOffset = positions[endPos] - positions[startPos];
              var movedLeft = self.__scrollLeft - positions[startPos - 2];
              var movedTop = self.__scrollTop - positions[startPos - 1];
              self.__decelerationVelocityX = movedLeft / timeOffset * (1e3 / 60);
              self.__decelerationVelocityY = movedTop / timeOffset * (1e3 / 60);
              var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? 4 : 1;
              if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {
                if (!self.__refreshActive) {
                  self.__startDeceleration(timeStamp);
                }
              }
            } else {
              self.__scrollingComplete();
            }
          } else if (timeStamp - self.__lastTouchMove > 100) {
            self.__scrollingComplete();
          }
        }
        if (!self.__isDecelerating) {
          if (self.__refreshActive && self.__refreshStart) {
            self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);
            var d = new Date();
            self.refreshStartTime = d.getTime();
            if (self.__refreshStart) {
              self.__refreshStart();
            }
            if (!ionic.Platform.isAndroid()) self.__startDeceleration();
          } else {
            if (self.__interruptedAnimation || self.__isDragging) {
              self.__scrollingComplete();
            }
            self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);
            if (self.__refreshActive) {
              self.__refreshActive = false;
              if (self.__refreshDeactivate) {
                self.__refreshDeactivate();
              }
            }
          }
        }
        self.__positions.length = 0;
      },
      __publish: function(left, top, zoom, animate, wasResize) {
        var self = this;
        var wasAnimating = self.__isAnimating;
        if (wasAnimating) {
          zyngaCore.effect.Animate.stop(wasAnimating);
          self.__isAnimating = false;
        }
        if (animate && self.options.animating) {
          self.__scheduledLeft = left;
          self.__scheduledTop = top;
          self.__scheduledZoom = zoom;
          var oldLeft = self.__scrollLeft;
          var oldTop = self.__scrollTop;
          var oldZoom = self.__zoomLevel;
          var diffLeft = left - oldLeft;
          var diffTop = top - oldTop;
          var diffZoom = zoom - oldZoom;
          var step = function(percent, now, render) {
            if (render) {
              self.__scrollLeft = oldLeft + diffLeft * percent;
              self.__scrollTop = oldTop + diffTop * percent;
              self.__zoomLevel = oldZoom + diffZoom * percent;
              if (self.__callback) {
                self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel, wasResize);
              }
            }
          };
          var verify = function(id) {
            return self.__isAnimating === id;
          };
          var completed = function(renderedFramesPerSecond, animationId, wasFinished) {
            if (animationId === self.__isAnimating) {
              self.__isAnimating = false;
            }
            if (self.__didDecelerationComplete || wasFinished) {
              self.__scrollingComplete();
            }
            if (self.options.zooming) {
              self.__computeScrollMax();
            }
          };
          self.__isAnimating = zyngaCore.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);
        } else {
          self.__scheduledLeft = self.__scrollLeft = left;
          self.__scheduledTop = self.__scrollTop = top;
          self.__scheduledZoom = self.__zoomLevel = zoom;
          if (self.__callback) {
            self.__callback(left, top, zoom, wasResize);
          }
          if (self.options.zooming) {
            self.__computeScrollMax();
          }
        }
      },
      __computeScrollMax: function(zoomLevel) {
        var self = this;
        if (zoomLevel == null) {
          zoomLevel = self.__zoomLevel;
        }
        self.__maxScrollLeft = Math.max(self.__contentWidth * zoomLevel - self.__clientWidth, 0);
        self.__maxScrollTop = Math.max(self.__contentHeight * zoomLevel - self.__clientHeight, 0);
        if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
          self.__didWaitForSize = true;
          self.__waitForSize();
        }
      },
      __waitForSize: function() {
        var self = this;
        clearTimeout(self.__sizerTimeout);
        var sizer = function() {
          self.resize();
          if (self.options.scrollingX && !self.__maxScrollLeft || self.options.scrollingY && !self.__maxScrollTop) {}
        };
        sizer();
        self.__sizerTimeout = setTimeout(sizer, 1e3);
      },
      __startDeceleration: function(timeStamp) {
        var self = this;
        if (self.options.paging) {
          var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);
          var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);
          var clientWidth = self.__clientWidth;
          var clientHeight = self.__clientHeight;
          self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;
          self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;
          self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;
          self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;
        } else {
          self.__minDecelerationScrollLeft = 0;
          self.__minDecelerationScrollTop = 0;
          self.__maxDecelerationScrollLeft = self.__maxScrollLeft;
          self.__maxDecelerationScrollTop = self.__maxScrollTop;
          if (self.__refreshActive) self.__minDecelerationScrollTop = self.__refreshHeight * -1;
        }
        var step = function(percent, now, render) {
          self.__stepThroughDeceleration(render);
        };
        self.__minVelocityToKeepDecelerating = self.options.snapping ? 4 : .1;
        var verify = function() {
          var shouldContinue = Math.abs(self.__decelerationVelocityX) >= self.__minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= self.__minVelocityToKeepDecelerating;
          if (!shouldContinue) {
            self.__didDecelerationComplete = true;
            if (self.options.bouncing && !self.__refreshActive) {
              self.scrollTo(Math.min(Math.max(self.__scrollLeft, 0), self.__maxScrollLeft), Math.min(Math.max(self.__scrollTop, 0), self.__maxScrollTop), self.__refreshActive);
            }
          }
          return shouldContinue;
        };
        var completed = function(renderedFramesPerSecond, animationId, wasFinished) {
          self.__isDecelerating = false;
          if (self.__didDecelerationComplete) {
            self.__scrollingComplete();
          }
          if (self.options.paging) {
            self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);
          }
        };
        self.__isDecelerating = zyngaCore.effect.Animate.start(step, verify, completed);
      },
      __stepThroughDeceleration: function(render) {
        var self = this;
        var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;
        var scrollTop = self.__scrollTop + self.__decelerationVelocityY;
        if (!self.options.bouncing) {
          var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);
          if (scrollLeftFixed !== scrollLeft) {
            scrollLeft = scrollLeftFixed;
            self.__decelerationVelocityX = 0;
          }
          var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);
          if (scrollTopFixed !== scrollTop) {
            scrollTop = scrollTopFixed;
            self.__decelerationVelocityY = 0;
          }
        }
        if (render) {
          self.__publish(scrollLeft, scrollTop, self.__zoomLevel);
        } else {
          self.__scrollLeft = scrollLeft;
          self.__scrollTop = scrollTop;
        }
        if (!self.options.paging) {
          var frictionFactor = self.options.deceleration;
          self.__decelerationVelocityX *= frictionFactor;
          self.__decelerationVelocityY *= frictionFactor;
        }
        if (self.options.bouncing) {
          var scrollOutsideX = 0;
          var scrollOutsideY = 0;
          var penetrationDeceleration = self.options.penetrationDeceleration;
          var penetrationAcceleration = self.options.penetrationAcceleration;
          if (scrollLeft < self.__minDecelerationScrollLeft) {
            scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;
          } else if (scrollLeft > self.__maxDecelerationScrollLeft) {
            scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;
          }
          if (scrollTop < self.__minDecelerationScrollTop) {
            scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;
          } else if (scrollTop > self.__maxDecelerationScrollTop) {
            scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;
          }
          if (scrollOutsideX !== 0) {
            var isHeadingOutwardsX = scrollOutsideX * self.__decelerationVelocityX <= self.__minDecelerationScrollLeft;
            if (isHeadingOutwardsX) {
              self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;
            }
            var isStoppedX = Math.abs(self.__decelerationVelocityX) <= self.__minVelocityToKeepDecelerating;
            if (!isHeadingOutwardsX || isStoppedX) {
              self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;
            }
          }
          if (scrollOutsideY !== 0) {
            var isHeadingOutwardsY = scrollOutsideY * self.__decelerationVelocityY <= self.__minDecelerationScrollTop;
            if (isHeadingOutwardsY) {
              self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;
            }
            var isStoppedY = Math.abs(self.__decelerationVelocityY) <= self.__minVelocityToKeepDecelerating;
            if (!isHeadingOutwardsY || isStoppedY) {
              self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;
            }
          }
        }
      },
      __getDistance: function getDistance(touch1, touch2) {
        var x = touch2.pageX - touch1.pageX, y = touch2.pageY - touch1.pageY;
        return Math.sqrt(x * x + y * y);
      },
      __getScale: function getScale(start, end) {
        var self = this;
        if (start.length >= 2 && end.length >= 2) {
          return self.__getDistance(end[0], end[1]) / self.__getDistance(start[0], start[1]);
        }
        return 1;
      }
    });
    ionic.scroll = {
      isScrolling: false,
      lastTop: 0
    };
  })(ionic);
  (function(ionic) {
    "use strict";
    ionic.views.HeaderBar = ionic.views.View.inherit({
      initialize: function(opts) {
        this.el = opts.el;
        ionic.extend(this, {
          alignTitle: "center"
        }, opts);
        this.align();
      },
      align: function(align) {
        align || (align = this.alignTitle);
        var titleEl = this.el.querySelector(".title");
        if (!titleEl) {
          return;
        }
        var self = this;
        ionic.requestAnimationFrame(function() {
          var i, c, childSize;
          var childNodes = self.el.childNodes;
          var leftWidth = 0;
          var rightWidth = 0;
          var isCountingRightWidth = false;
          for (i = 0; i < childNodes.length; i++) {
            c = childNodes[i];
            if (c.tagName && c.tagName.toLowerCase() == "h1") {
              isCountingRightWidth = true;
              continue;
            }
            childSize = null;
            if (c.nodeType == 3) {
              var bounds = ionic.DomUtil.getTextBounds(c);
              if (bounds) {
                childSize = bounds.width;
              }
            } else if (c.nodeType == 1) {
              childSize = c.offsetWidth;
            }
            if (childSize) {
              if (isCountingRightWidth) {
                rightWidth += childSize;
              } else {
                leftWidth += childSize;
              }
            }
          }
          var margin = Math.max(leftWidth, rightWidth) + 10;
          titleEl.style.left = titleEl.style.right = "";
          if (align == "center") {
            if (margin > 10) {
              titleEl.style.left = margin + "px";
              titleEl.style.right = margin + "px";
            }
            if (titleEl.offsetWidth < titleEl.scrollWidth) {
              if (rightWidth > 0) {
                titleEl.style.right = rightWidth + 5 + "px";
              }
            }
          } else if (align == "left") {
            titleEl.classList.add("title-left");
            if (leftWidth > 0) {
              titleEl.style.left = leftWidth + 15 + "px";
            }
          } else if (align == "right") {
            titleEl.classList.add("title-right");
            if (rightWidth > 0) {
              titleEl.style.right = rightWidth + 15 + "px";
            }
          }
        });
      }
    });
  })(ionic);
  (function(ionic) {
    "use strict";
    var ITEM_CLASS = "item";
    var ITEM_CONTENT_CLASS = "item-content";
    var ITEM_SLIDING_CLASS = "item-sliding";
    var ITEM_OPTIONS_CLASS = "item-options";
    var ITEM_PLACEHOLDER_CLASS = "item-placeholder";
    var ITEM_REORDERING_CLASS = "item-reordering";
    var ITEM_REORDER_BTN_CLASS = "item-reorder";
    var DragOp = function() {};
    DragOp.prototype = {
      start: function(e) {},
      drag: function(e) {},
      end: function(e) {},
      isSameItem: function(item) {
        return false;
      }
    };
    var SlideDrag = function(opts) {
      this.dragThresholdX = opts.dragThresholdX || 10;
      this.el = opts.el;
      this.canSwipe = opts.canSwipe;
    };
    SlideDrag.prototype = new DragOp();
    SlideDrag.prototype.start = function(e) {
      var content, buttons, offsetX, buttonsWidth;
      if (!this.canSwipe()) {
        return;
      }
      if (e.target.classList.contains(ITEM_CONTENT_CLASS)) {
        content = e.target;
      } else if (e.target.classList.contains(ITEM_CLASS)) {
        content = e.target.querySelector("." + ITEM_CONTENT_CLASS);
      } else {
        content = ionic.DomUtil.getParentWithClass(e.target, ITEM_CONTENT_CLASS);
      }
      if (!content) {
        return;
      }
      content.classList.remove(ITEM_SLIDING_CLASS);
      offsetX = parseFloat(content.style[ionic.CSS.TRANSFORM].replace("translate3d(", "").split(",")[0]) || 0;
      buttons = content.parentNode.querySelector("." + ITEM_OPTIONS_CLASS);
      if (!buttons) {
        return;
      }
      buttons.classList.remove("invisible");
      buttonsWidth = buttons.offsetWidth;
      this._currentDrag = {
        buttons: buttons,
        buttonsWidth: buttonsWidth,
        content: content,
        startOffsetX: offsetX
      };
    };
    SlideDrag.prototype.isSameItem = function(op) {
      if (op._lastDrag && this._currentDrag) {
        return this._currentDrag.content == op._lastDrag.content;
      }
      return false;
    };
    SlideDrag.prototype.clean = function(e) {
      var lastDrag = this._lastDrag;
      if (!lastDrag) return;
      lastDrag.content.style[ionic.CSS.TRANSITION] = "";
      lastDrag.content.style[ionic.CSS.TRANSFORM] = "";
      ionic.requestAnimationFrame(function() {
        setTimeout(function() {
          lastDrag.buttons && lastDrag.buttons.classList.add("invisible");
        }, 250);
      });
    };
    SlideDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
      var buttonsWidth;
      if (!this._currentDrag) {
        return;
      }
      if (!this._isDragging && (Math.abs(e.gesture.deltaX) > this.dragThresholdX || Math.abs(this._currentDrag.startOffsetX) > 0)) {
        this._isDragging = true;
      }
      if (this._isDragging) {
        buttonsWidth = this._currentDrag.buttonsWidth;
        var newX = Math.min(0, this._currentDrag.startOffsetX + e.gesture.deltaX);
        if (newX < -buttonsWidth) {
          newX = Math.min(-buttonsWidth, -buttonsWidth + (e.gesture.deltaX + buttonsWidth) * .4);
        }
        this._currentDrag.content.style[ionic.CSS.TRANSFORM] = "translate3d(" + newX + "px, 0, 0)";
        this._currentDrag.content.style[ionic.CSS.TRANSITION] = "none";
      }
    });
    SlideDrag.prototype.end = function(e, doneCallback) {
      var _this = this;
      if (!this._currentDrag) {
        doneCallback && doneCallback();
        return;
      }
      var restingPoint = -this._currentDrag.buttonsWidth;
      if (e.gesture.deltaX > -(this._currentDrag.buttonsWidth / 2)) {
        if (e.gesture.direction == "left" && Math.abs(e.gesture.velocityX) < .3) {
          restingPoint = 0;
        } else if (e.gesture.direction == "right") {
          restingPoint = 0;
        }
      }
      ionic.requestAnimationFrame(function() {
        if (restingPoint === 0) {
          _this._currentDrag.content.style[ionic.CSS.TRANSFORM] = "";
          var buttons = _this._currentDrag.buttons;
          setTimeout(function() {
            buttons && buttons.classList.add("invisible");
          }, 250);
        } else {
          _this._currentDrag.content.style[ionic.CSS.TRANSFORM] = "translate3d(" + restingPoint + "px, 0, 0)";
        }
        _this._currentDrag.content.style[ionic.CSS.TRANSITION] = "";
        _this._lastDrag = _this._currentDrag;
        _this._currentDrag = null;
        doneCallback && doneCallback();
      });
    };
    var ReorderDrag = function(opts) {
      this.dragThresholdY = opts.dragThresholdY || 0;
      this.onReorder = opts.onReorder;
      this.listEl = opts.listEl;
      this.el = opts.el;
      this.scrollEl = opts.scrollEl;
      this.scrollView = opts.scrollView;
      this.listElTrueTop = 0;
      if (this.listEl.offsetParent) {
        var obj = this.listEl;
        do {
          this.listElTrueTop += obj.offsetTop;
          obj = obj.offsetParent;
        } while (obj);
      }
    };
    ReorderDrag.prototype = new DragOp();
    ReorderDrag.prototype._moveElement = function(e) {
      var y = e.gesture.center.pageY + this.scrollView.getValues().top - this._currentDrag.elementHeight / 2 - this.listElTrueTop;
      this.el.style[ionic.CSS.TRANSFORM] = "translate3d(0, " + y + "px, 0)";
    };
    ReorderDrag.prototype.start = function(e) {
      var content;
      var startIndex = ionic.DomUtil.getChildIndex(this.el, this.el.nodeName.toLowerCase());
      var elementHeight = this.el.scrollHeight;
      var placeholder = this.el.cloneNode(true);
      placeholder.classList.add(ITEM_PLACEHOLDER_CLASS);
      this.el.parentNode.insertBefore(placeholder, this.el);
      this.el.classList.add(ITEM_REORDERING_CLASS);
      this._currentDrag = {
        elementHeight: elementHeight,
        startIndex: startIndex,
        placeholder: placeholder,
        scrollHeight: scroll,
        list: placeholder.parentNode
      };
      this._moveElement(e);
    };
    ReorderDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
      var self = this;
      if (!this._currentDrag) {
        return;
      }
      var scrollY = 0;
      var pageY = e.gesture.center.pageY;
      var offset = this.listElTrueTop;
      if (this.scrollView) {
        var container = this.scrollView.__container;
        scrollY = this.scrollView.getValues().top;
        var containerTop = container.offsetTop;
        var pixelsPastTop = containerTop - pageY + this._currentDrag.elementHeight / 2;
        var pixelsPastBottom = pageY + this._currentDrag.elementHeight / 2 - containerTop - container.offsetHeight;
        if (e.gesture.deltaY < 0 && pixelsPastTop > 0 && scrollY > 0) {
          this.scrollView.scrollBy(null, -pixelsPastTop);
          ionic.requestAnimationFrame(function() {
            self.drag(e);
          });
        }
        if (e.gesture.deltaY > 0 && pixelsPastBottom > 0) {
          if (scrollY < this.scrollView.getScrollMax().top) {
            this.scrollView.scrollBy(null, pixelsPastBottom);
            ionic.requestAnimationFrame(function() {
              self.drag(e);
            });
          }
        }
      }
      if (!this._isDragging && Math.abs(e.gesture.deltaY) > this.dragThresholdY) {
        this._isDragging = true;
      }
      if (this._isDragging) {
        this._moveElement(e);
        this._currentDrag.currentY = scrollY + pageY - offset;
      }
    });
    ReorderDrag.prototype._getReorderIndex = function() {
      var self = this;
      var placeholder = this._currentDrag.placeholder;
      var siblings = Array.prototype.slice.call(this._currentDrag.placeholder.parentNode.children).filter(function(el) {
        return el.nodeName === self.el.nodeName && el !== self.el;
      });
      var dragOffsetTop = this._currentDrag.currentY;
      var el;
      for (var i = 0, len = siblings.length; i < len; i++) {
        el = siblings[i];
        if (i === len - 1) {
          if (dragOffsetTop > el.offsetTop) {
            return i;
          }
        } else if (i === 0) {
          if (dragOffsetTop < el.offsetTop + el.offsetHeight) {
            return i;
          }
        } else if (dragOffsetTop > el.offsetTop - el.offsetHeight / 2 && dragOffsetTop < el.offsetTop + el.offsetHeight) {
          return i;
        }
      }
      return this._currentDrag.startIndex;
    };
    ReorderDrag.prototype.end = function(e, doneCallback) {
      if (!this._currentDrag) {
        doneCallback && doneCallback();
        return;
      }
      var placeholder = this._currentDrag.placeholder;
      var finalIndex = this._getReorderIndex();
      this.el.classList.remove(ITEM_REORDERING_CLASS);
      this.el.style[ionic.CSS.TRANSFORM] = "";
      placeholder.parentNode.insertBefore(this.el, placeholder);
      placeholder.parentNode.removeChild(placeholder);
      this.onReorder && this.onReorder(this.el, this._currentDrag.startIndex, finalIndex);
      this._currentDrag = null;
      doneCallback && doneCallback();
    };
    ionic.views.ListView = ionic.views.View.inherit({
      initialize: function(opts) {
        var _this = this;
        opts = ionic.extend({
          onReorder: function(el, oldIndex, newIndex) {},
          virtualRemoveThreshold: -200,
          virtualAddThreshold: 200,
          canSwipe: function() {
            return true;
          }
        }, opts);
        ionic.extend(this, opts);
        if (!this.itemHeight && this.listEl) {
          this.itemHeight = this.listEl.children[0] && parseInt(this.listEl.children[0].style.height, 10);
        }
        this.onRefresh = opts.onRefresh || function() {};
        this.onRefreshOpening = opts.onRefreshOpening || function() {};
        this.onRefreshHolding = opts.onRefreshHolding || function() {};
        window.ionic.onGesture("release", function(e) {
          _this._handleEndDrag(e);
        }, this.el);
        window.ionic.onGesture("drag", function(e) {
          _this._handleDrag(e);
        }, this.el);
        this._initDrag();
      },
      stopRefreshing: function() {
        var refresher = this.el.querySelector(".list-refresher");
        refresher.style.height = "0px";
      },
      didScroll: function(e) {
        if (this.isVirtual) {
          var itemHeight = this.itemHeight;
          var totalItems = this.listEl.children.length;
          var scrollHeight = e.target.scrollHeight;
          var viewportHeight = this.el.parentNode.offsetHeight;
          var scrollTop = e.scrollTop;
          var highWater = Math.max(0, e.scrollTop + this.virtualRemoveThreshold);
          var lowWater = Math.min(scrollHeight, Math.abs(e.scrollTop) + viewportHeight + this.virtualAddThreshold);
          var itemsPerViewport = Math.floor((lowWater - highWater) / itemHeight);
          var first = parseInt(Math.abs(highWater / itemHeight), 10);
          var last = parseInt(Math.abs(lowWater / itemHeight), 10);
          this._virtualItemsToRemove = Array.prototype.slice.call(this.listEl.children, 0, first);
          var nodes = Array.prototype.slice.call(this.listEl.children, first, first + itemsPerViewport);
          this.renderViewport && this.renderViewport(highWater, lowWater, first, last);
        }
      },
      didStopScrolling: function(e) {
        if (this.isVirtual) {
          for (var i = 0; i < this._virtualItemsToRemove.length; i++) {
            var el = this._virtualItemsToRemove[i];
            this.didHideItem && this.didHideItem(i);
          }
        }
      },
      clearDragEffects: function() {
        if (this._lastDragOp) {
          this._lastDragOp.clean && this._lastDragOp.clean();
          this._lastDragOp = null;
        }
      },
      _initDrag: function() {
        this._lastDragOp = this._dragOp;
        this._dragOp = null;
      },
      _getItem: function(target) {
        while (target) {
          if (target.classList && target.classList.contains(ITEM_CLASS)) {
            return target;
          }
          target = target.parentNode;
        }
        return null;
      },
      _startDrag: function(e) {
        var _this = this;
        var didStart = false;
        this._isDragging = false;
        var lastDragOp = this._lastDragOp;
        var item;
        if (ionic.DomUtil.getParentOrSelfWithClass(e.target, ITEM_REORDER_BTN_CLASS) && (e.gesture.direction == "up" || e.gesture.direction == "down")) {
          item = this._getItem(e.target);
          if (item) {
            this._dragOp = new ReorderDrag({
              listEl: this.el,
              el: item,
              scrollEl: this.scrollEl,
              scrollView: this.scrollView,
              onReorder: function(el, start, end) {
                _this.onReorder && _this.onReorder(el, start, end);
              }
            });
            this._dragOp.start(e);
            e.preventDefault();
          }
        } else if (!this._didDragUpOrDown && (e.gesture.direction == "left" || e.gesture.direction == "right") && Math.abs(e.gesture.deltaX) > 5) {
          item = this._getItem(e.target);
          if (item && item.querySelector(".item-options")) {
            this._dragOp = new SlideDrag({
              el: this.el,
              canSwipe: this.canSwipe
            });
            this._dragOp.start(e);
            e.preventDefault();
          }
        }
        if (lastDragOp && this._dragOp && !this._dragOp.isSameItem(lastDragOp) && e.defaultPrevented) {
          lastDragOp.clean && lastDragOp.clean();
        }
      },
      _handleEndDrag: function(e) {
        var _this = this;
        this._didDragUpOrDown = false;
        if (!this._dragOp) {
          return;
        }
        this._dragOp.end(e, function() {
          _this._initDrag();
        });
      },
      _handleDrag: function(e) {
        var _this = this, content, buttons;
        if (Math.abs(e.gesture.deltaY) > 5) {
          this._didDragUpOrDown = true;
        }
        if (!this.isDragging && !this._dragOp) {
          this._startDrag(e);
        }
        if (!this._dragOp) {
          return;
        }
        e.gesture.srcEvent.preventDefault();
        this._dragOp.drag(e);
      }
    });
  })(ionic);
  (function(ionic) {
    "use strict";
    ionic.views.Modal = ionic.views.View.inherit({
      initialize: function(opts) {
        opts = ionic.extend({
          focusFirstInput: false,
          unfocusOnHide: true,
          focusFirstDelay: 600,
          backdropClickToClose: true,
          hardwareBackButtonClose: true
        }, opts);
        ionic.extend(this, opts);
        this.el = opts.el;
      },
      show: function() {
        var self = this;
        if (self.focusFirstInput) {
          window.setTimeout(function() {
            var input = self.el.querySelector("input, textarea");
            input && input.focus && input.focus();
          }, self.focusFirstDelay);
        }
      },
      hide: function() {
        if (this.unfocusOnHide) {
          var inputs = this.el.querySelectorAll("input, textarea");
          window.setTimeout(function() {
            for (var i = 0; i < inputs.length; i++) {
              inputs[i].blur && inputs[i].blur();
            }
          });
        }
      }
    });
  })(ionic);
  (function(ionic) {
    "use strict";
    ionic.views.SideMenu = ionic.views.View.inherit({
      initialize: function(opts) {
        this.el = opts.el;
        this.isEnabled = typeof opts.isEnabled === "undefined" ? true : opts.isEnabled;
        this.setWidth(opts.width);
      },
      getFullWidth: function() {
        return this.width;
      },
      setWidth: function(width) {
        this.width = width;
        this.el.style.width = width + "px";
      },
      setIsEnabled: function(isEnabled) {
        this.isEnabled = isEnabled;
      },
      bringUp: function() {
        if (this.el.style.zIndex !== "0") {
          this.el.style.zIndex = "0";
        }
      },
      pushDown: function() {
        if (this.el.style.zIndex !== "-1") {
          this.el.style.zIndex = "-1";
        }
      }
    });
    ionic.views.SideMenuContent = ionic.views.View.inherit({
      initialize: function(opts) {
        ionic.extend(this, {
          animationClass: "menu-animated",
          onDrag: function(e) {},
          onEndDrag: function(e) {}
        }, opts);
        ionic.onGesture("drag", ionic.proxy(this._onDrag, this), this.el);
        ionic.onGesture("release", ionic.proxy(this._onEndDrag, this), this.el);
      },
      _onDrag: function(e) {
        this.onDrag && this.onDrag(e);
      },
      _onEndDrag: function(e) {
        this.onEndDrag && this.onEndDrag(e);
      },
      disableAnimation: function() {
        this.el.classList.remove(this.animationClass);
      },
      enableAnimation: function() {
        this.el.classList.add(this.animationClass);
      },
      getTranslateX: function() {
        return parseFloat(this.el.style[ionic.CSS.TRANSFORM].replace("translate3d(", "").split(",")[0]);
      },
      setTranslateX: ionic.animationFrameThrottle(function(x) {
        this.el.style[ionic.CSS.TRANSFORM] = "translate3d(" + x + "px, 0, 0)";
      })
    });
  })(ionic);
  (function(ionic) {
    "use strict";
    ionic.views.Slider = ionic.views.View.inherit({
      initialize: function(options) {
        var slider = this;
        var noop = function() {};
        var offloadFn = function(fn) {
          setTimeout(fn || noop, 0);
        };
        var browser = {
          addEventListener: !!window.addEventListener,
          touch: "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch,
          transitions: function(temp) {
            var props = [ "transitionProperty", "WebkitTransition", "MozTransition", "OTransition", "msTransition" ];
            for (var i in props) if (temp.style[props[i]] !== undefined) return true;
            return false;
          }(document.createElement("swipe"))
        };
        var container = options.el;
        if (!container) return;
        var element = container.children[0];
        var slides, slidePos, width, length;
        options = options || {};
        var index = parseInt(options.startSlide, 10) || 0;
        var speed = options.speed || 300;
        options.continuous = options.continuous !== undefined ? options.continuous : true;
        function setup() {
          slides = element.children;
          length = slides.length;
          if (slides.length < 2) options.continuous = false;
          if (browser.transitions && options.continuous && slides.length < 3) {
            element.appendChild(slides[0].cloneNode(true));
            element.appendChild(element.children[1].cloneNode(true));
            slides = element.children;
          }
          slidePos = new Array(slides.length);
          width = container.offsetWidth || container.getBoundingClientRect().width;
          element.style.width = slides.length * width + "px";
          var pos = slides.length;
          while (pos--) {
            var slide = slides[pos];
            slide.style.width = width + "px";
            slide.setAttribute("data-index", pos);
            if (browser.transitions) {
              slide.style.left = pos * -width + "px";
              move(pos, index > pos ? -width : index < pos ? width : 0, 0);
            }
          }
          if (options.continuous && browser.transitions) {
            move(circle(index - 1), -width, 0);
            move(circle(index + 1), width, 0);
          }
          if (!browser.transitions) element.style.left = index * -width + "px";
          container.style.visibility = "visible";
          options.slidesChanged && options.slidesChanged();
        }
        function prev() {
          if (options.continuous) slide(index - 1); else if (index) slide(index - 1);
        }
        function next() {
          if (options.continuous) slide(index + 1); else if (index < slides.length - 1) slide(index + 1);
        }
        function circle(index) {
          return (slides.length + index % slides.length) % slides.length;
        }
        function slide(to, slideSpeed) {
          if (index == to) return;
          if (browser.transitions) {
            var direction = Math.abs(index - to) / (index - to);
            if (options.continuous) {
              var natural_direction = direction;
              direction = -slidePos[circle(to)] / width;
              if (direction !== natural_direction) to = -direction * slides.length + to;
            }
            var diff = Math.abs(index - to) - 1;
            while (diff--) move(circle((to > index ? to : index) - diff - 1), width * direction, 0);
            to = circle(to);
            move(index, width * direction, slideSpeed || speed);
            move(to, 0, slideSpeed || speed);
            if (options.continuous) move(circle(to - direction), -(width * direction), 0);
          } else {
            to = circle(to);
            animate(index * -width, to * -width, slideSpeed || speed);
          }
          index = to;
          offloadFn(options.callback && options.callback(index, slides[index]));
        }
        function move(index, dist, speed) {
          translate(index, dist, speed);
          slidePos[index] = dist;
        }
        function translate(index, dist, speed) {
          var slide = slides[index];
          var style = slide && slide.style;
          if (!style) return;
          style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + "ms";
          style.webkitTransform = "translate(" + dist + "px,0)" + "translateZ(0)";
          style.msTransform = style.MozTransform = style.OTransform = "translateX(" + dist + "px)";
        }
        function animate(from, to, speed) {
          if (!speed) {
            element.style.left = to + "px";
            return;
          }
          var start = +new Date();
          var timer = setInterval(function() {
            var timeElap = +new Date() - start;
            if (timeElap > speed) {
              element.style.left = to + "px";
              if (delay) begin();
              options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
              clearInterval(timer);
              return;
            }
            element.style.left = (to - from) * (Math.floor(timeElap / speed * 100) / 100) + from + "px";
          }, 4);
        }
        var delay = options.auto || 0;
        var interval;
        function begin() {
          interval = setTimeout(next, delay);
        }
        function stop() {
          delay = options.auto || 0;
          clearTimeout(interval);
        }
        var start = {};
        var delta = {};
        var isScrolling;
        var events = {
          handleEvent: function(event) {
            if (event.type == "mousedown" || event.type == "mouseup" || event.type == "mousemove") {
              event.touches = [ {
                pageX: event.pageX,
                pageY: event.pageY
              } ];
            }
            switch (event.type) {
             case "mousedown":
              this.start(event);
              break;

             case "touchstart":
              this.start(event);
              break;

             case "touchmove":
              this.touchmove(event);
              break;

             case "mousemove":
              this.touchmove(event);
              break;

             case "touchend":
              offloadFn(this.end(event));
              break;

             case "mouseup":
              offloadFn(this.end(event));
              break;

             case "webkitTransitionEnd":
             case "msTransitionEnd":
             case "oTransitionEnd":
             case "otransitionend":
             case "transitionend":
              offloadFn(this.transitionEnd(event));
              break;

             case "resize":
              offloadFn(setup);
              break;
            }
            if (options.stopPropagation) event.stopPropagation();
          },
          start: function(event) {
            var touches = event.touches[0];
            start = {
              x: touches.pageX,
              y: touches.pageY,
              time: +new Date()
            };
            isScrolling = undefined;
            delta = {};
            if (browser.touch) {
              element.addEventListener("touchmove", this, false);
              element.addEventListener("touchend", this, false);
            } else {
              element.addEventListener("mousemove", this, false);
              element.addEventListener("mouseup", this, false);
              document.addEventListener("mouseup", this, false);
            }
          },
          touchmove: function(event) {
            if (event.touches.length > 1 || event.scale && event.scale !== 1 || slider.slideIsDisabled) {
              return;
            }
            if (options.disableScroll) event.preventDefault();
            var touches = event.touches[0];
            delta = {
              x: touches.pageX - start.x,
              y: touches.pageY - start.y
            };
            if (typeof isScrolling == "undefined") {
              isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
            }
            if (!isScrolling) {
              event.preventDefault();
              stop();
              if (options.continuous) {
                translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);
                translate(index, delta.x + slidePos[index], 0);
                translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);
              } else {
                delta.x = delta.x / (!index && delta.x > 0 || index == slides.length - 1 && delta.x < 0 ? Math.abs(delta.x) / width + 1 : 1);
                translate(index - 1, delta.x + slidePos[index - 1], 0);
                translate(index, delta.x + slidePos[index], 0);
                translate(index + 1, delta.x + slidePos[index + 1], 0);
              }
            }
          },
          end: function(event) {
            var duration = +new Date() - start.time;
            var isValidSlide = Number(duration) < 250 && Math.abs(delta.x) > 20 || Math.abs(delta.x) > width / 2;
            var isPastBounds = !index && delta.x > 0 || index == slides.length - 1 && delta.x < 0;
            if (options.continuous) isPastBounds = false;
            var direction = delta.x < 0;
            if (!isScrolling) {
              if (isValidSlide && !isPastBounds) {
                if (direction) {
                  if (options.continuous) {
                    move(circle(index - 1), -width, 0);
                    move(circle(index + 2), width, 0);
                  } else {
                    move(index - 1, -width, 0);
                  }
                  move(index, slidePos[index] - width, speed);
                  move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);
                  index = circle(index + 1);
                } else {
                  if (options.continuous) {
                    move(circle(index + 1), width, 0);
                    move(circle(index - 2), -width, 0);
                  } else {
                    move(index + 1, width, 0);
                  }
                  move(index, slidePos[index] + width, speed);
                  move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);
                  index = circle(index - 1);
                }
                options.callback && options.callback(index, slides[index]);
              } else {
                if (options.continuous) {
                  move(circle(index - 1), -width, speed);
                  move(index, 0, speed);
                  move(circle(index + 1), width, speed);
                } else {
                  move(index - 1, -width, speed);
                  move(index, 0, speed);
                  move(index + 1, width, speed);
                }
              }
            }
            if (browser.touch) {
              element.removeEventListener("touchmove", events, false);
              element.removeEventListener("touchend", events, false);
            } else {
              element.removeEventListener("mousemove", events, false);
              element.removeEventListener("mouseup", events, false);
              document.removeEventListener("mouseup", events, false);
            }
          },
          transitionEnd: function(event) {
            if (parseInt(event.target.getAttribute("data-index"), 10) == index) {
              if (delay) begin();
              options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
            }
          }
        };
        this.update = function() {
          setTimeout(setup);
        };
        this.setup = function() {
          setup();
        };
        this.enableSlide = function(shouldEnable) {
          if (arguments.length) {
            this.slideIsDisabled = !shouldEnable;
          }
          return !this.slideIsDisabled;
        }, this.slide = function(to, speed) {
          stop();
          slide(to, speed);
        };
        this.prev = this.previous = function() {
          stop();
          prev();
        };
        this.next = function() {
          stop();
          next();
        };
        this.stop = function() {
          stop();
        };
        this.start = function() {
          begin();
        };
        this.currentIndex = function() {
          return index;
        };
        this.slidesCount = function() {
          return length;
        };
        this.kill = function() {
          stop();
          element.style.width = "";
          element.style.left = "";
          var pos = slides.length;
          while (pos--) {
            var slide = slides[pos];
            slide.style.width = "";
            slide.style.left = "";
            if (browser.transitions) translate(pos, 0, 0);
          }
          if (browser.addEventListener) {
            element.removeEventListener("touchstart", events, false);
            element.removeEventListener("webkitTransitionEnd", events, false);
            element.removeEventListener("msTransitionEnd", events, false);
            element.removeEventListener("oTransitionEnd", events, false);
            element.removeEventListener("otransitionend", events, false);
            element.removeEventListener("transitionend", events, false);
            window.removeEventListener("resize", events, false);
          } else {
            window.onresize = null;
          }
        };
        this.load = function() {
          setup();
          if (delay) begin();
          if (browser.addEventListener) {
            if (browser.touch) {
              element.addEventListener("touchstart", events, false);
            } else {
              element.addEventListener("mousedown", events, false);
            }
            if (browser.transitions) {
              element.addEventListener("webkitTransitionEnd", events, false);
              element.addEventListener("msTransitionEnd", events, false);
              element.addEventListener("oTransitionEnd", events, false);
              element.addEventListener("otransitionend", events, false);
              element.addEventListener("transitionend", events, false);
            }
            window.addEventListener("resize", events, false);
          } else {
            window.onresize = function() {
              setup();
            };
          }
        };
      }
    });
  })(ionic);
  (function(ionic) {
    "use strict";
    ionic.views.Toggle = ionic.views.View.inherit({
      initialize: function(opts) {
        var self = this;
        this.el = opts.el;
        this.checkbox = opts.checkbox;
        this.track = opts.track;
        this.handle = opts.handle;
        this.openPercent = -1;
        this.onChange = opts.onChange || function() {};
        this.triggerThreshold = opts.triggerThreshold || 20;
        this.dragStartHandler = function(e) {
          self.dragStart(e);
        };
        this.dragHandler = function(e) {
          self.drag(e);
        };
        this.holdHandler = function(e) {
          self.hold(e);
        };
        this.releaseHandler = function(e) {
          self.release(e);
        };
        this.dragStartGesture = ionic.onGesture("dragstart", this.dragStartHandler, this.el);
        this.dragGesture = ionic.onGesture("drag", this.dragHandler, this.el);
        this.dragHoldGesture = ionic.onGesture("hold", this.holdHandler, this.el);
        this.dragReleaseGesture = ionic.onGesture("release", this.releaseHandler, this.el);
      },
      destroy: function() {
        ionic.offGesture(this.dragStartGesture, "dragstart", this.dragStartGesture);
        ionic.offGesture(this.dragGesture, "drag", this.dragGesture);
        ionic.offGesture(this.dragHoldGesture, "hold", this.holdHandler);
        ionic.offGesture(this.dragReleaseGesture, "release", this.releaseHandler);
      },
      tap: function(e) {
        if (this.el.getAttribute("disabled") !== "disabled") {
          this.val(!this.checkbox.checked);
        }
      },
      dragStart: function(e) {
        if (this.checkbox.disabled) return;
        this._dragInfo = {
          width: this.el.offsetWidth,
          left: this.el.offsetLeft,
          right: this.el.offsetLeft + this.el.offsetWidth,
          triggerX: this.el.offsetWidth / 2,
          initialState: this.checkbox.checked
        };
        e.gesture.srcEvent.preventDefault();
        this.hold(e);
      },
      drag: function(e) {
        var self = this;
        if (!this._dragInfo) {
          return;
        }
        e.gesture.srcEvent.preventDefault();
        ionic.requestAnimationFrame(function(amount) {
          if (!self._dragInfo) {
            return;
          }
          var slidePageLeft = self.track.offsetLeft + self.handle.offsetWidth / 2;
          var slidePageRight = self.track.offsetLeft + self.track.offsetWidth - self.handle.offsetWidth / 2;
          var dx = e.gesture.deltaX;
          var px = e.gesture.touches[0].pageX - self._dragInfo.left;
          var mx = self._dragInfo.width - self.triggerThreshold;
          if (self._dragInfo.initialState) {
            if (px < self.triggerThreshold) {
              self.setOpenPercent(0);
            } else if (px > self._dragInfo.triggerX) {
              self.setOpenPercent(100);
            }
          } else {
            if (px < self._dragInfo.triggerX) {
              self.setOpenPercent(0);
            } else if (px > mx) {
              self.setOpenPercent(100);
            }
          }
        });
      },
      endDrag: function(e) {
        this._dragInfo = null;
      },
      hold: function(e) {
        this.el.classList.add("dragging");
      },
      release: function(e) {
        this.el.classList.remove("dragging");
        this.endDrag(e);
      },
      setOpenPercent: function(openPercent) {
        if (this.openPercent < 0 || (openPercent < this.openPercent - 3 || openPercent > this.openPercent + 3)) {
          this.openPercent = openPercent;
          if (openPercent === 0) {
            this.val(false);
          } else if (openPercent === 100) {
            this.val(true);
          } else {
            var openPixel = Math.round(openPercent / 100 * this.track.offsetWidth - this.handle.offsetWidth);
            openPixel = openPixel < 1 ? 0 : openPixel;
            this.handle.style[ionic.CSS.TRANSFORM] = "translate3d(" + openPixel + "px,0,0)";
          }
        }
      },
      val: function(value) {
        if (value === true || value === false) {
          if (this.handle.style[ionic.CSS.TRANSFORM] !== "") {
            this.handle.style[ionic.CSS.TRANSFORM] = "";
          }
          this.checkbox.checked = value;
          this.openPercent = value ? 100 : 0;
          this.onChange && this.onChange();
        }
        return this.checkbox.checked;
      }
    });
  })(ionic);
})();
(function() {
  var deprecated = {
    method: function(msg, log, fn) {
      var called = false;
      return function deprecatedMethod() {
        if (!called) {
          called = true;
          log(msg);
        }
        return fn.apply(this, arguments);
      };
    },
    field: function(msg, log, parent, field, val) {
      var called = false;
      var getter = function() {
        if (!called) {
          called = true;
          log(msg);
        }
        return val;
      };
      var setter = function(v) {
        if (!called) {
          called = true;
          log(msg);
        }
        val = v;
        return v;
      };
      Object.defineProperty(parent, field, {
        get: getter,
        set: setter,
        enumerable: true
      });
      return;
    }
  };
  var IonicModule = angular.module("ionic", [ "ngAnimate", "ngSanitize", "ui.router" ]), extend = angular.extend, forEach = angular.forEach, isDefined = angular.isDefined, isString = angular.isString, jqLite = angular.element;
  IonicModule.factory("$ionicActionSheet", [ "$rootScope", "$compile", "$animate", "$timeout", "$ionicTemplateLoader", "$ionicPlatform", "$ionicBody", function($rootScope, $compile, $animate, $timeout, $ionicTemplateLoader, $ionicPlatform, $ionicBody) {
    return {
      show: actionSheet
    };
    function actionSheet(opts) {
      var scope = $rootScope.$new(true);
      angular.extend(scope, {
        cancel: angular.noop,
        destructiveButtonClicked: angular.noop,
        buttonClicked: angular.noop,
        $deregisterBackButton: angular.noop,
        buttons: [],
        cancelOnStateChange: true
      }, opts || {});
      var element = scope.element = $compile('<ion-action-sheet buttons="buttons"></ion-action-sheet>')(scope);
      var sheetEl = jqLite(element[0].querySelector(".action-sheet-wrapper"));
      var stateChangeListenDone = scope.cancelOnStateChange ? $rootScope.$on("$stateChangeSuccess", function() {
        scope.cancel();
      }) : angular.noop;
      scope.removeSheet = function(done) {
        if (scope.removed) return;
        scope.removed = true;
        sheetEl.removeClass("action-sheet-up");
        $timeout(function() {
          $ionicBody.removeClass("action-sheet-open");
        }, 400);
        scope.$deregisterBackButton();
        stateChangeListenDone();
        $animate.removeClass(element, "active", function() {
          scope.$destroy();
          element.remove();
          scope.cancel.$scope = null;
          (done || angular.noop)();
        });
      };
      scope.showSheet = function(done) {
        if (scope.removed) return;
        $ionicBody.append(element).addClass("action-sheet-open");
        $animate.addClass(element, "active", function() {
          if (scope.removed) return;
          (done || angular.noop)();
        });
        $timeout(function() {
          if (scope.removed) return;
          sheetEl.addClass("action-sheet-up");
        }, 20, false);
      };
      scope.$deregisterBackButton = $ionicPlatform.registerBackButtonAction(function() {
        $timeout(scope.cancel);
      }, PLATFORM_BACK_BUTTON_PRIORITY_ACTION_SHEET);
      scope.cancel = function() {
        scope.removeSheet(opts.cancel);
      };
      scope.buttonClicked = function(index) {
        if (opts.buttonClicked(index, opts.buttons[index]) === true) {
          scope.removeSheet();
        }
      };
      scope.destructiveButtonClicked = function() {
        if (opts.destructiveButtonClicked() === true) {
          scope.removeSheet();
        }
      };
      scope.showSheet();
      scope.cancel.$scope = scope;
      return scope.cancel;
    }
  } ]);
  jqLite.prototype.addClass = function(cssClasses) {
    var x, y, cssClass, el, splitClasses, existingClasses;
    if (cssClasses && cssClasses != "ng-scope" && cssClasses != "ng-isolate-scope") {
      for (x = 0; x < this.length; x++) {
        el = this[x];
        if (el.setAttribute) {
          if (cssClasses.indexOf(" ") < 0 && el.classList.add) {
            el.classList.add(cssClasses);
          } else {
            existingClasses = (" " + (el.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            splitClasses = cssClasses.split(" ");
            for (y = 0; y < splitClasses.length; y++) {
              cssClass = splitClasses[y].trim();
              if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
                existingClasses += cssClass + " ";
              }
            }
            el.setAttribute("class", existingClasses.trim());
          }
        }
      }
    }
    return this;
  };
  jqLite.prototype.removeClass = function(cssClasses) {
    var x, y, splitClasses, cssClass, el;
    if (cssClasses) {
      for (x = 0; x < this.length; x++) {
        el = this[x];
        if (el.getAttribute) {
          if (cssClasses.indexOf(" ") < 0 && el.classList.remove) {
            el.classList.remove(cssClasses);
          } else {
            splitClasses = cssClasses.split(" ");
            for (y = 0; y < splitClasses.length; y++) {
              cssClass = splitClasses[y];
              el.setAttribute("class", (" " + (el.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + cssClass.trim() + " ", " ").trim());
            }
          }
        }
      }
    }
    return this;
  };
  IonicModule.factory("$ionicBackdrop", [ "$document", "$timeout", function($document, $timeout) {
    var el = jqLite('<div class="backdrop">');
    var backdropHolds = 0;
    $document[0].body.appendChild(el[0]);
    return {
      retain: retain,
      release: release,
      getElement: getElement,
      _element: el
    };
    function retain() {
      if (++backdropHolds === 1) {
        el.addClass("visible");
        ionic.requestAnimationFrame(function() {
          backdropHolds && el.addClass("active");
        });
      }
    }
    function release() {
      if (--backdropHolds === 0) {
        el.removeClass("active");
        $timeout(function() {
          !backdropHolds && el.removeClass("visible");
        }, 400, false);
      }
    }
    function getElement() {
      return el;
    }
  } ]);
  IonicModule.factory("$ionicBind", [ "$parse", "$interpolate", function($parse, $interpolate) {
    var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
    return function(scope, attrs, bindDefinition) {
      forEach(bindDefinition || {}, function(definition, scopeName) {
        var match = definition.match(LOCAL_REGEXP) || [], attrName = match[3] || scopeName, mode = match[1], parentGet, unwatch;
        switch (mode) {
         case "@":
          if (!attrs[attrName]) {
            return;
          }
          attrs.$observe(attrName, function(value) {
            scope[scopeName] = value;
          });
          if (attrs[attrName]) {
            scope[scopeName] = $interpolate(attrs[attrName])(scope);
          }
          break;

         case "=":
          if (!attrs[attrName]) {
            return;
          }
          unwatch = scope.$watch(attrs[attrName], function(value) {
            scope[scopeName] = value;
          });
          scope.$on("$destroy", unwatch);
          break;

         case "&":
          if (attrs[attrName] && attrs[attrName].match(RegExp(scopeName + "(.*?)"))) {
            throw new Error('& expression binding "' + scopeName + '" looks like it will recursively call "' + attrs[attrName] + '" and cause a stack overflow! Please choose a different scopeName.');
          }
          parentGet = $parse(attrs[attrName]);
          scope[scopeName] = function(locals) {
            return parentGet(scope, locals);
          };
          break;
        }
      });
    };
  } ]);
  IonicModule.factory("$ionicBody", [ "$document", function($document) {
    return {
      addClass: function() {
        for (var x = 0; x < arguments.length; x++) {
          $document[0].body.classList.add(arguments[x]);
        }
        return this;
      },
      removeClass: function() {
        for (var x = 0; x < arguments.length; x++) {
          $document[0].body.classList.remove(arguments[x]);
        }
        return this;
      },
      enableClass: function(shouldEnableClass) {
        var args = Array.prototype.slice.call(arguments).slice(1);
        if (shouldEnableClass) {
          this.addClass.apply(this, args);
        } else {
          this.removeClass.apply(this, args);
        }
        return this;
      },
      append: function(ele) {
        $document[0].body.appendChild(ele.length ? ele[0] : ele);
        return this;
      },
      get: function() {
        return $document[0].body;
      }
    };
  } ]);
  IonicModule.factory("$ionicClickBlock", [ "$document", "$ionicBody", "$timeout", function($document, $ionicBody, $timeout) {
    var cb = $document[0].createElement("div");
    cb.className = "click-block";
    return {
      show: function() {
        if (cb.parentElement) {
          cb.classList.remove("hide");
        } else {
          $ionicBody.append(cb);
        }
        $timeout(function() {
          cb.classList.add("hide");
        }, 500);
      },
      hide: function() {
        cb.classList.add("hide");
      }
    };
  } ]);
  IonicModule.factory("$collectionDataSource", [ "$cacheFactory", "$parse", "$rootScope", function($cacheFactory, $parse, $rootScope) {
    function hideWithTransform(element) {
      element.css(ionic.CSS.TRANSFORM, "translate3d(-2000px,-2000px,0)");
    }
    function CollectionRepeatDataSource(options) {
      var self = this;
      this.scope = options.scope;
      this.transcludeFn = options.transcludeFn;
      this.transcludeParent = options.transcludeParent;
      this.element = options.element;
      this.keyExpr = options.keyExpr;
      this.listExpr = options.listExpr;
      this.trackByExpr = options.trackByExpr;
      this.heightGetter = options.heightGetter;
      this.widthGetter = options.widthGetter;
      this.dimensions = [];
      this.data = [];
      this.attachedItems = {};
      this.BACKUP_ITEMS_LENGTH = 20;
      this.backupItemsArray = [];
    }
    CollectionRepeatDataSource.prototype = {
      setup: function() {
        if (this.isSetup) return;
        this.isSetup = true;
        for (var i = 0; i < this.BACKUP_ITEMS_LENGTH; i++) {
          this.detachItem(this.createItem());
        }
      },
      destroy: function() {
        this.dimensions.length = 0;
        this.data = null;
        this.backupItemsArray.length = 0;
        this.attachedItems = {};
      },
      calculateDataDimensions: function() {
        var locals = {};
        this.dimensions = this.data.map(function(value, index) {
          locals[this.keyExpr] = value;
          locals.$index = index;
          return {
            width: this.widthGetter(this.scope, locals),
            height: this.heightGetter(this.scope, locals)
          };
        }, this);
        this.dimensions = this.beforeSiblings.concat(this.dimensions).concat(this.afterSiblings);
        this.dataStartIndex = this.beforeSiblings.length;
      },
      createItem: function() {
        var item = {};
        item.scope = this.scope.$new();
        this.transcludeFn(item.scope, function(clone) {
          clone.css("position", "absolute");
          item.element = clone;
        });
        this.transcludeParent.append(item.element);
        return item;
      },
      getItem: function(index) {
        if (item = this.attachedItems[index]) {} else if (item = this.backupItemsArray.pop()) {
          reconnectScope(item.scope);
        } else {
          item = this.createItem();
        }
        return item;
      },
      attachItemAtIndex: function(index) {
        if (index < this.dataStartIndex) {
          return this.beforeSiblings[index];
        }
        index -= this.dataStartIndex;
        if (index > this.data.length - 1) {
          return this.afterSiblings[index - this.dataStartIndex];
        }
        var item = this.getItem(index);
        var value = this.data[index];
        if (item.index !== index || item.scope[this.keyExpr] !== value) {
          item.index = item.scope.$index = index;
          item.scope[this.keyExpr] = value;
          item.scope.$first = index === 0;
          item.scope.$last = index === this.getLength() - 1;
          item.scope.$middle = !(item.scope.$first || item.scope.$last);
          item.scope.$odd = !(item.scope.$even = (index & 1) === 0);
          if (!$rootScope.$$phase) {
            item.scope.$digest();
          }
        }
        this.attachedItems[index] = item;
        return item;
      },
      destroyItem: function(item) {
        item.element.remove();
        item.scope.$destroy();
        item.scope = null;
        item.element = null;
      },
      detachItem: function(item) {
        delete this.attachedItems[item.index];
        if (item.isOutside) {
          hideWithTransform(item.element);
        } else if (this.backupItemsArray.length >= this.BACKUP_ITEMS_LENGTH) {
          this.destroyItem(item);
        } else {
          this.backupItemsArray.push(item);
          hideWithTransform(item.element);
          disconnectScope(item.scope);
        }
      },
      getLength: function() {
        return this.dimensions && this.dimensions.length || 0;
      },
      setData: function(value, beforeSiblings, afterSiblings) {
        this.data = value || [];
        this.beforeSiblings = beforeSiblings || [];
        this.afterSiblings = afterSiblings || [];
        this.calculateDataDimensions();
        this.afterSiblings.forEach(function(item) {
          item.element.css({
            position: "absolute",
            top: "0",
            left: "0"
          });
          hideWithTransform(item.element);
        });
      }
    };
    return CollectionRepeatDataSource;
  } ]);
  function disconnectScope(scope) {
    if (scope.$root === scope) {
      return;
    }
    var parent = scope.$parent;
    scope.$$disconnected = true;
    if (parent.$$childHead === scope) {
      parent.$$childHead = scope.$$nextSibling;
    }
    if (parent.$$childTail === scope) {
      parent.$$childTail = scope.$$prevSibling;
    }
    if (scope.$$prevSibling) {
      scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
    }
    if (scope.$$nextSibling) {
      scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
    }
    scope.$$nextSibling = scope.$$prevSibling = null;
  }
  function reconnectScope(scope) {
    if (scope.$root === scope) {
      return;
    }
    if (!scope.$$disconnected) {
      return;
    }
    var parent = scope.$parent;
    scope.$$disconnected = false;
    scope.$$prevSibling = parent.$$childTail;
    if (parent.$$childHead) {
      parent.$$childTail.$$nextSibling = scope;
      parent.$$childTail = scope;
    } else {
      parent.$$childHead = parent.$$childTail = scope;
    }
  }
  IonicModule.factory("$collectionRepeatManager", [ "$rootScope", "$timeout", function($rootScope, $timeout) {
    function CollectionRepeatManager(options) {
      var self = this;
      this.dataSource = options.dataSource;
      this.element = options.element;
      this.scrollView = options.scrollView;
      this.isVertical = !!this.scrollView.options.scrollingY;
      this.renderedItems = {};
      this.dimensions = [];
      this.setCurrentIndex(0);
      this.scrollView.__$callback = this.scrollView.__callback;
      this.scrollView.__callback = angular.bind(this, this.renderScroll);
      function getViewportSize() {
        return self.viewportSize;
      }
      if (this.isVertical) {
        this.scrollView.options.getContentHeight = getViewportSize;
        this.scrollValue = function() {
          return this.scrollView.__scrollTop;
        };
        this.scrollMaxValue = function() {
          return this.scrollView.__maxScrollTop;
        };
        this.scrollSize = function() {
          return this.scrollView.__clientHeight;
        };
        this.secondaryScrollSize = function() {
          return this.scrollView.__clientWidth;
        };
        this.transformString = function(y, x) {
          return "translate3d(" + x + "px," + y + "px,0)";
        };
        this.primaryDimension = function(dim) {
          return dim.height;
        };
        this.secondaryDimension = function(dim) {
          return dim.width;
        };
      } else {
        this.scrollView.options.getContentWidth = getViewportSize;
        this.scrollValue = function() {
          return this.scrollView.__scrollLeft;
        };
        this.scrollMaxValue = function() {
          return this.scrollView.__maxScrollLeft;
        };
        this.scrollSize = function() {
          return this.scrollView.__clientWidth;
        };
        this.secondaryScrollSize = function() {
          return this.scrollView.__clientHeight;
        };
        this.transformString = function(x, y) {
          return "translate3d(" + x + "px," + y + "px,0)";
        };
        this.primaryDimension = function(dim) {
          return dim.width;
        };
        this.secondaryDimension = function(dim) {
          return dim.height;
        };
      }
    }
    CollectionRepeatManager.prototype = {
      destroy: function() {
        this.renderedItems = {};
        this.render = angular.noop;
        this.calculateDimensions = angular.noop;
        this.dimensions = [];
      },
      calculateDimensions: function() {
        var primaryPos = 0;
        var secondaryPos = 0;
        var secondaryScrollSize = this.secondaryScrollSize();
        var previousItem;
        this.dataSource.beforeSiblings && this.dataSource.beforeSiblings.forEach(calculateSize, this);
        var beforeSize = primaryPos + (previousItem ? previousItem.primarySize : 0);
        primaryPos = secondaryPos = 0;
        previousItem = null;
        var dimensions = this.dataSource.dimensions.map(calculateSize, this);
        var totalSize = primaryPos + (previousItem ? previousItem.primarySize : 0);
        return {
          beforeSize: beforeSize,
          totalSize: totalSize,
          dimensions: dimensions
        };
        function calculateSize(dim) {
          var rect = {
            primarySize: this.primaryDimension(dim),
            secondarySize: Math.min(this.secondaryDimension(dim), secondaryScrollSize)
          };
          if (previousItem) {
            secondaryPos += previousItem.secondarySize;
            if (previousItem.primaryPos === primaryPos && secondaryPos + rect.secondarySize > secondaryScrollSize) {
              secondaryPos = 0;
              primaryPos += previousItem.primarySize;
            }
          }
          rect.primaryPos = primaryPos;
          rect.secondaryPos = secondaryPos;
          previousItem = rect;
          return rect;
        }
      },
      resize: function() {
        var result = this.calculateDimensions();
        this.dimensions = result.dimensions;
        this.viewportSize = result.totalSize;
        this.beforeSize = result.beforeSize;
        this.setCurrentIndex(0);
        this.render(true);
        this.dataSource.setup();
      },
      setCurrentIndex: function(index, height) {
        var currentPos = (this.dimensions[index] || {}).primaryPos || 0;
        this.currentIndex = index;
        this.hasPrevIndex = index > 0;
        if (this.hasPrevIndex) {
          this.previousPos = Math.max(currentPos - this.dimensions[index - 1].primarySize, this.dimensions[index - 1].primaryPos);
        }
        this.hasNextIndex = index + 1 < this.dataSource.getLength();
        if (this.hasNextIndex) {
          this.nextPos = Math.min(currentPos + this.dimensions[index + 1].primarySize, this.dimensions[index + 1].primaryPos);
        }
      },
      renderScroll: ionic.animationFrameThrottle(function(transformLeft, transformTop, zoom, wasResize) {
        if (this.isVertical) {
          this.renderIfNeeded(transformTop);
        } else {
          this.renderIfNeeded(transformLeft);
        }
        return this.scrollView.__$callback(transformLeft, transformTop, zoom, wasResize);
      }),
      renderIfNeeded: function(scrollPos) {
        if (this.hasNextIndex && scrollPos >= this.nextPos || this.hasPrevIndex && scrollPos < this.previousPos) {
          this.render();
        }
      },
      getIndexForScrollValue: function(i, scrollValue) {
        var rect;
        if (scrollValue <= this.dimensions[i].primaryPos) {
          while ((rect = this.dimensions[i - 1]) && rect.primaryPos > scrollValue) {
            i--;
          }
        } else {
          while ((rect = this.dimensions[i + 1]) && rect.primaryPos < scrollValue) {
            i++;
          }
        }
        return i;
      },
      render: function(shouldRedrawAll) {
        var self = this;
        var i;
        var isOutOfBounds = this.currentIndex >= this.dataSource.getLength();
        if (isOutOfBounds || shouldRedrawAll) {
          for (i in this.renderedItems) {
            this.removeItem(i);
          }
          if (isOutOfBounds) return;
        }
        var rect;
        var scrollValue = this.scrollValue();
        var scrollSize = this.scrollSize();
        var scrollSizeEnd = scrollSize + scrollValue;
        var startIndex = this.getIndexForScrollValue(this.currentIndex, scrollValue);
        var renderStartIndex = Math.max(startIndex - 1, 0);
        while (renderStartIndex > 0 && (rect = this.dimensions[renderStartIndex]) && rect.primaryPos === this.dimensions[startIndex - 1].primaryPos) {
          renderStartIndex--;
        }
        i = renderStartIndex;
        while ((rect = this.dimensions[i]) && rect.primaryPos - rect.primarySize < scrollSizeEnd) {
          doRender(i, rect);
          i++;
        }
        if (self.dimensions[i]) {
          doRender(i, self.dimensions[i]);
          i++;
        }
        if (self.dimensions[i]) {
          doRender(i, self.dimensions[i]);
        }
        var renderEndIndex = i;
        for (var renderIndex in this.renderedItems) {
          if (renderIndex < renderStartIndex || renderIndex > renderEndIndex) {
            this.removeItem(renderIndex);
          }
        }
        this.setCurrentIndex(startIndex);
        function doRender(dataIndex, rect) {
          if (dataIndex < self.dataSource.dataStartIndex) {} else {
            self.renderItem(dataIndex, rect.primaryPos - self.beforeSize, rect.secondaryPos);
          }
        }
      },
      renderItem: function(dataIndex, primaryPos, secondaryPos) {
        var item = this.dataSource.attachItemAtIndex(dataIndex);
        if (item && item.element) {
          if (item.primaryPos !== primaryPos || item.secondaryPos !== secondaryPos) {
            item.element.css(ionic.CSS.TRANSFORM, this.transformString(primaryPos, secondaryPos));
            item.primaryPos = primaryPos;
            item.secondaryPos = secondaryPos;
          }
          this.renderedItems[dataIndex] = item;
        } else {
          delete this.renderedItems[dataIndex];
        }
      },
      removeItem: function(dataIndex) {
        var item = this.renderedItems[dataIndex];
        if (item) {
          item.primaryPos = item.secondaryPos = null;
          this.dataSource.detachItem(item);
          delete this.renderedItems[dataIndex];
        }
      }
    };
    return CollectionRepeatManager;
  } ]);
  function delegateService(methodNames) {
    return [ "$log", function($log) {
      var delegate = this;
      var instances = this._instances = [];
      this._registerInstance = function(instance, handle) {
        instance.$$delegateHandle = handle;
        instances.push(instance);
        return function deregister() {
          var index = instances.indexOf(instance);
          if (index !== -1) {
            instances.splice(index, 1);
          }
        };
      };
      this.$getByHandle = function(handle) {
        if (!handle) {
          return delegate;
        }
        return new InstanceForHandle(handle);
      };
      function InstanceForHandle(handle) {
        this.handle = handle;
      }
      methodNames.forEach(function(methodName) {
        InstanceForHandle.prototype[methodName] = function() {
          var handle = this.handle;
          var args = arguments;
          var matchingInstancesFound = 0;
          var finalResult;
          var result;
          instances.forEach(function(instance) {
            if (instance.$$delegateHandle === handle) {
              matchingInstancesFound++;
              result = instance[methodName].apply(instance, args);
              if (matchingInstancesFound === 1) {
                finalResult = result;
              }
            }
          });
          if (!matchingInstancesFound) {
            return $log.warn('Delegate for handle "' + this.handle + '" could not find a ' + 'corresponding element with delegate-handle="' + this.handle + '"! ' + methodName + "() was not called!\n" + "Possible cause: If you are calling " + methodName + "() immediately, and " + 'your element with delegate-handle="' + this.handle + '" is a child of your ' + "controller, then your element may not be compiled yet. Put a $timeout " + "around your call to " + methodName + "() and try again.");
          }
          return finalResult;
        };
        delegate[methodName] = function() {
          var args = arguments;
          var finalResult;
          var result;
          instances.forEach(function(instance, index) {
            result = instance[methodName].apply(instance, args);
            if (index === 0) {
              finalResult = result;
            }
          });
          return finalResult;
        };
        function callMethod(instancesToUse, methodName, args) {
          var finalResult;
          var result;
          instancesToUse.forEach(function(instance, index) {
            result = instance[methodName].apply(instance, args);
            if (index === 0) {
              finalResult = result;
            }
          });
          return finalResult;
        }
      });
    } ];
  }
  IonicModule.factory("$ionicGesture", [ function() {
    return {
      on: function(eventType, cb, $element, options) {
        return window.ionic.onGesture(eventType, cb, $element[0], options);
      },
      off: function(gesture, eventType, cb) {
        return window.ionic.offGesture(gesture, eventType, cb);
      }
    };
  } ]);
  IonicModule.provider("$ionicConfig", function() {
    var provider = this;
    var config = {
      prefetchTemplates: true
    };
    this.prefetchTemplates = function(newValue) {
      if (arguments.length) {
        config.prefetchTemplates = newValue;
      }
      return config.prefetchTemplates;
    };
    this.$get = function() {
      return config;
    };
  });
  var LOADING_TPL = '<div class="loading-container">' + '<div class="loading">' + "</div>" + "</div>";
  var LOADING_HIDE_DEPRECATED = "$ionicLoading instance.hide() has been deprecated. Use $ionicLoading.hide().";
  var LOADING_SHOW_DEPRECATED = "$ionicLoading instance.show() has been deprecated. Use $ionicLoading.show().";
  var LOADING_SET_DEPRECATED = "$ionicLoading instance.setContent() has been deprecated. Use $ionicLoading.show({ template: 'my content' }).";
  IonicModule.constant("$ionicLoadingConfig", {
    template: '<i class="icon ion-loading-d"></i>'
  }).factory("$ionicLoading", [ "$ionicLoadingConfig", "$ionicBody", "$ionicTemplateLoader", "$ionicBackdrop", "$timeout", "$q", "$log", "$compile", "$ionicPlatform", function($ionicLoadingConfig, $ionicBody, $ionicTemplateLoader, $ionicBackdrop, $timeout, $q, $log, $compile, $ionicPlatform) {
    var loaderInstance;
    var deregisterBackAction = angular.noop;
    var loadingShowDelay = $q.when();
    return {
      show: showLoader,
      hide: hideLoader,
      _getLoader: getLoader
    };
    function getLoader() {
      if (!loaderInstance) {
        loaderInstance = $ionicTemplateLoader.compile({
          template: LOADING_TPL,
          appendTo: $ionicBody.get()
        }).then(function(loader) {
          var self = loader;
          loader.show = function(options) {
            var templatePromise = options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : $q.when(options.template || options.content || "");
            if (!this.isShown) {
              this.hasBackdrop = !options.noBackdrop && options.showBackdrop !== false;
              if (this.hasBackdrop) {
                $ionicBackdrop.retain();
                $ionicBackdrop.getElement().addClass("backdrop-loading");
              }
            }
            if (options.duration) {
              $timeout.cancel(this.durationTimeout);
              this.durationTimeout = $timeout(angular.bind(this, this.hide), +options.duration);
            }
            templatePromise.then(function(html) {
              if (html) {
                var loading = self.element.children();
                loading.html(html);
                $compile(loading.contents())(self.scope);
              }
              if (self.isShown) {
                self.element.addClass("visible");
                ionic.requestAnimationFrame(function() {
                  if (self.isShown) {
                    self.element.addClass("active");
                    $ionicBody.addClass("loading-active");
                  }
                });
              }
            });
            this.isShown = true;
          };
          loader.hide = function() {
            if (this.isShown) {
              if (this.hasBackdrop) {
                $ionicBackdrop.release();
                $ionicBackdrop.getElement().removeClass("backdrop-loading");
              }
              self.element.removeClass("active");
              $ionicBody.removeClass("loading-active");
              setTimeout(function() {
                !self.isShown && self.element.removeClass("visible");
              }, 200);
            }
            $timeout.cancel(this.durationTimeout);
            this.isShown = false;
          };
          return loader;
        });
      }
      return loaderInstance;
    }
    function showLoader(options) {
      options = extend($ionicLoadingConfig || {}, options || {});
      var delay = options.delay || options.showDelay || 0;
      loadingShowDelay && $timeout.cancel(loadingShowDelay);
      loadingShowDelay = $timeout(angular.noop, delay);
      loadingShowDelay.then(getLoader).then(function(loader) {
        deregisterBackAction();
        deregisterBackAction = $ionicPlatform.registerBackButtonAction(angular.noop, PLATFORM_BACK_BUTTON_PRIORITY_LOADING);
        return loader.show(options);
      });
      return {
        hide: deprecated.method(LOADING_HIDE_DEPRECATED, $log.error, hideLoader),
        show: deprecated.method(LOADING_SHOW_DEPRECATED, $log.error, function() {
          showLoader(options);
        }),
        setContent: deprecated.method(LOADING_SET_DEPRECATED, $log.error, function(content) {
          getLoader().then(function(loader) {
            loader.show({
              template: content
            });
          });
        })
      };
    }
    function hideLoader() {
      deregisterBackAction();
      $timeout.cancel(loadingShowDelay);
      getLoader().then(function(loader) {
        loader.hide();
      });
    }
  } ]);
  IonicModule.factory("$ionicModal", [ "$rootScope", "$ionicBody", "$compile", "$timeout", "$ionicPlatform", "$ionicTemplateLoader", "$q", "$log", function($rootScope, $ionicBody, $compile, $timeout, $ionicPlatform, $ionicTemplateLoader, $q, $log) {
    var ModalView = ionic.views.Modal.inherit({
      initialize: function(opts) {
        ionic.views.Modal.prototype.initialize.call(this, opts);
        this.animation = opts.animation || "slide-in-up";
      },
      show: function(target) {
        var self = this;
        if (self.scope.$$destroyed) {
          $log.error("Cannot call " + self.viewType + ".show() after remove(). Please create a new " + self.viewType + " instance.");
          return;
        }
        var modalEl = jqLite(self.modalEl);
        self.el.classList.remove("hide");
        $timeout(function() {
          $ionicBody.addClass(self.viewType + "-open");
        }, 400);
        if (!self.el.parentElement) {
          modalEl.addClass(self.animation);
          $ionicBody.append(self.el);
        }
        if (target && self.positionView) {
          self.positionView(target, modalEl);
        }
        modalEl.addClass("ng-enter active").removeClass("ng-leave ng-leave-active");
        self._isShown = true;
        self._deregisterBackButton = $ionicPlatform.registerBackButtonAction(self.hardwareBackButtonClose ? angular.bind(self, self.hide) : angular.noop, PLATFORM_BACK_BUTTON_PRIORITY_MODAL);
        self._isOpenPromise = $q.defer();
        ionic.views.Modal.prototype.show.call(self);
        $timeout(function() {
          modalEl.addClass("ng-enter-active");
          ionic.trigger("resize");
          self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + ".shown", self);
          self.el.classList.add("active");
        }, 20);
        return $timeout(function() {
          self.$el.on("click", function(e) {
            if (self.backdropClickToClose && e.target === self.el) {
              self.hide();
            }
          });
        }, 400);
      },
      hide: function() {
        var self = this;
        var modalEl = jqLite(self.modalEl);
        self.el.classList.remove("active");
        modalEl.addClass("ng-leave");
        $timeout(function() {
          modalEl.addClass("ng-leave-active").removeClass("ng-enter ng-enter-active active");
        }, 20);
        self.$el.off("click");
        self._isShown = false;
        self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + ".hidden", self);
        self._deregisterBackButton && self._deregisterBackButton();
        ionic.views.Modal.prototype.hide.call(self);
        return $timeout(function() {
          $ionicBody.removeClass(self.viewType + "-open");
          self.el.classList.add("hide");
        }, self.hideDelay || 320);
      },
      remove: function() {
        var self = this;
        self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + ".removed", self);
        return self.hide().then(function() {
          self.scope.$destroy();
          self.$el.remove();
        });
      },
      isShown: function() {
        return !!this._isShown;
      }
    });
    var createModal = function(templateString, options) {
      var scope = options.scope && options.scope.$new() || $rootScope.$new(true);
      options.viewType = options.viewType || "modal";
      extend(scope, {
        $hasHeader: false,
        $hasSubheader: false,
        $hasFooter: false,
        $hasSubfooter: false,
        $hasTabs: false,
        $hasTabsTop: false
      });
      var element = $compile("<ion-" + options.viewType + ">" + templateString + "</ion-" + options.viewType + ">")(scope);
      options.$el = element;
      options.el = element[0];
      options.modalEl = options.el.querySelector("." + options.viewType);
      var modal = new ModalView(options);
      modal.scope = scope;
      if (!options.scope) {
        scope[options.viewType] = modal;
      }
      return modal;
    };
    return {
      fromTemplate: function(templateString, options) {
        var modal = createModal(templateString, options || {});
        return modal;
      },
      fromTemplateUrl: function(url, options, _) {
        var cb;
        if (angular.isFunction(options)) {
          cb = options;
          options = _;
        }
        return $ionicTemplateLoader.load(url).then(function(templateString) {
          var modal = createModal(templateString, options || {});
          cb && cb(modal);
          return modal;
        });
      }
    };
  } ]);
  IonicModule.service("$ionicNavBarDelegate", delegateService([ "back", "align", "showBackButton", "showBar", "setTitle", "changeTitle", "getTitle", "getPreviousTitle" ]));
  var PLATFORM_BACK_BUTTON_PRIORITY_VIEW = 100;
  var PLATFORM_BACK_BUTTON_PRIORITY_SIDE_MENU = 150;
  var PLATFORM_BACK_BUTTON_PRIORITY_MODAL = 200;
  var PLATFORM_BACK_BUTTON_PRIORITY_ACTION_SHEET = 300;
  var PLATFORM_BACK_BUTTON_PRIORITY_POPUP = 400;
  var PLATFORM_BACK_BUTTON_PRIORITY_LOADING = 500;
  function componentConfig(defaults) {
    defaults.$get = function() {
      return defaults;
    };
    return defaults;
  }
  IonicModule.constant("$ionicPlatformDefaults", {
    ios: {
      $ionicNavBarConfig: {
        transition: "nav-title-slide-ios",
        alignTitle: "center",
        backButtonIcon: "ion-ios7-arrow-back"
      },
      $ionicNavViewConfig: {
        transition: "slide-ios"
      },
      $ionicTabsConfig: {
        type: "",
        position: ""
      }
    },
    android: {
      $ionicNavBarConfig: {
        transition: "nav-title-slide-full",
        alignTitle: "center",
        backButtonIcon: "ion-ios7-arrow-back"
      },
      $ionicNavViewConfig: {
        transition: "slide-full"
      },
      $ionicTabsConfig: {
        type: "tabs-striped",
        position: ""
      }
    }
  });
  IonicModule.config([ "$ionicPlatformDefaults", "$injector", function($ionicPlatformDefaults, $injector) {
    var platform = ionic.Platform.platform();
    var applyConfig = function(platformDefaults) {
      forEach(platformDefaults, function(defaults, constantName) {
        extend($injector.get(constantName), defaults);
      });
    };
    switch (platform) {
     case "ios":
      applyConfig($ionicPlatformDefaults.ios);
      break;

     case "android":
      applyConfig($ionicPlatformDefaults.android);
      break;
    }
  } ]);
  IonicModule.provider("$ionicPlatform", function() {
    return {
      $get: [ "$q", "$rootScope", function($q, $rootScope) {
        var self = {
          onHardwareBackButton: function(cb) {
            ionic.Platform.ready(function() {
              document.addEventListener("backbutton", cb, false);
            });
          },
          offHardwareBackButton: function(fn) {
            ionic.Platform.ready(function() {
              document.removeEventListener("backbutton", fn);
            });
          },
          $backButtonActions: {},
          registerBackButtonAction: function(fn, priority, actionId) {
            if (!self._hasBackButtonHandler) {
              self.$backButtonActions = {};
              self.onHardwareBackButton(self.hardwareBackButtonClick);
              self._hasBackButtonHandler = true;
            }
            var action = {
              id: actionId ? actionId : ionic.Utils.nextUid(),
              priority: priority ? priority : 0,
              fn: fn
            };
            self.$backButtonActions[action.id] = action;
            return function() {
              delete self.$backButtonActions[action.id];
            };
          },
          hardwareBackButtonClick: function(e) {
            var priorityAction, actionId;
            for (actionId in self.$backButtonActions) {
              if (!priorityAction || self.$backButtonActions[actionId].priority >= priorityAction.priority) {
                priorityAction = self.$backButtonActions[actionId];
              }
            }
            if (priorityAction) {
              priorityAction.fn(e);
              return priorityAction;
            }
          },
          is: function(type) {
            return ionic.Platform.is(type);
          },
          on: function(type, cb) {
            ionic.Platform.ready(function() {
              document.addEventListener(type, cb, false);
            });
            return function() {
              ionic.Platform.ready(function() {
                document.removeEventListener(type, cb);
              });
            };
          },
          ready: function(cb) {
            var q = $q.defer();
            ionic.Platform.ready(function() {
              q.resolve();
              cb && cb();
            });
            return q.promise;
          }
        };
        return self;
      } ]
    };
  });
  IonicModule.factory("$ionicPopover", [ "$ionicModal", "$ionicPosition", "$document", "$window", function($ionicModal, $ionicPosition, $document, $window) {
    var POPOVER_BODY_PADDING = 6;
    var POPOVER_OPTIONS = {
      viewType: "popover",
      hideDelay: 1,
      animation: "none",
      positionView: positionView
    };
    function positionView(target, popoverEle) {
      var targetEle = angular.element(target.target || target);
      var buttonOffset = $ionicPosition.offset(targetEle);
      var popoverWidth = popoverEle.prop("offsetWidth");
      var popoverHeight = popoverEle.prop("offsetHeight");
      var bodyWidth = $document[0].body.clientWidth;
      var bodyHeight = $window.innerHeight;
      var popoverCSS = {
        left: buttonOffset.left + buttonOffset.width / 2 - popoverWidth / 2
      };
      var arrowEle = jqLite(popoverEle[0].querySelector(".popover-arrow"));
      if (popoverCSS.left < POPOVER_BODY_PADDING) {
        popoverCSS.left = POPOVER_BODY_PADDING;
      } else if (popoverCSS.left + popoverWidth + POPOVER_BODY_PADDING > bodyWidth) {
        popoverCSS.left = bodyWidth - popoverWidth - POPOVER_BODY_PADDING;
      }
      if (buttonOffset.top + buttonOffset.height + popoverHeight > bodyHeight) {
        popoverCSS.top = buttonOffset.top - popoverHeight;
        popoverEle.addClass("popover-bottom");
      } else {
        popoverCSS.top = buttonOffset.top + buttonOffset.height;
        popoverEle.removeClass("popover-bottom");
      }
      arrowEle.css({
        left: buttonOffset.left + buttonOffset.width / 2 - arrowEle.prop("offsetWidth") / 2 - popoverCSS.left + "px"
      });
      popoverEle.css({
        top: popoverCSS.top + "px",
        left: popoverCSS.left + "px",
        marginLeft: "0",
        opacity: "1"
      });
    }
    return {
      fromTemplate: function(templateString, options) {
        return $ionicModal.fromTemplate(templateString, ionic.Utils.extend(options || {}, POPOVER_OPTIONS));
      },
      fromTemplateUrl: function(url, options, _) {
        return $ionicModal.fromTemplateUrl(url, options, ionic.Utils.extend(options || {}, POPOVER_OPTIONS));
      }
    };
  } ]);
  var POPUP_TPL = '<div class="popup-container">' + '<div class="popup">' + '<div class="popup-head">' + '<h3 class="popup-title" ng-bind-html="title"></h3>' + '<h5 class="popup-sub-title" ng-bind-html="subTitle" ng-if="subTitle"></h5>' + "</div>" + '<div class="popup-body">' + "</div>" + '<div class="popup-buttons">' + '<button ng-repeat="button in buttons" ng-click="$buttonTapped(button, $event)" class="button" ng-class="button.type || \'button-default\'" ng-bind-html="button.text"></button>' + "</div>" + "</div>" + "</div>";
  IonicModule.factory("$ionicPopup", [ "$ionicTemplateLoader", "$ionicBackdrop", "$q", "$timeout", "$rootScope", "$ionicBody", "$compile", "$ionicPlatform", function($ionicTemplateLoader, $ionicBackdrop, $q, $timeout, $rootScope, $ionicBody, $compile, $ionicPlatform) {
    var config = {
      stackPushDelay: 75
    };
    var popupStack = [];
    var $ionicPopup = {
      show: showPopup,
      alert: showAlert,
      confirm: showConfirm,
      prompt: showPrompt,
      _createPopup: createPopup,
      _popupStack: popupStack
    };
    return $ionicPopup;
    function createPopup(options) {
      options = extend({
        scope: null,
        title: "",
        buttons: []
      }, options || {});
      var popupPromise = $ionicTemplateLoader.compile({
        template: POPUP_TPL,
        scope: options.scope && options.scope.$new(),
        appendTo: $ionicBody.get()
      });
      var contentPromise = options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : $q.when(options.template || options.content || "");
      return $q.all([ popupPromise, contentPromise ]).then(function(results) {
        var self = results[0];
        var content = results[1];
        var responseDeferred = $q.defer();
        self.responseDeferred = responseDeferred;
        var body = jqLite(self.element[0].querySelector(".popup-body"));
        if (content) {
          body.html(content);
          $compile(body.contents())(self.scope);
        } else {
          body.remove();
        }
        extend(self.scope, {
          title: options.title,
          buttons: options.buttons,
          subTitle: options.subTitle,
          $buttonTapped: function(button, event) {
            var result = (button.onTap || angular.noop)(event);
            event = event.originalEvent || event;
            if (!event.defaultPrevented) {
              responseDeferred.resolve(result);
            }
          }
        });
        self.show = function() {
          if (self.isShown) return;
          self.isShown = true;
          ionic.requestAnimationFrame(function() {
            if (!self.isShown) return;
            self.element.removeClass("popup-hidden");
            self.element.addClass("popup-showing active");
            focusInput(self.element);
          });
        };
        self.hide = function(callback) {
          callback = callback || angular.noop;
          if (!self.isShown) return callback();
          self.isShown = false;
          self.element.removeClass("active");
          self.element.addClass("popup-hidden");
          $timeout(callback, 250);
        };
        self.remove = function() {
          if (self.removed) return;
          self.hide(function() {
            self.element.remove();
            self.scope.$destroy();
          });
          self.removed = true;
        };
        return self;
      });
    }
    function onHardwareBackButton(e) {
      popupStack[0] && popupStack[0].responseDeferred.resolve();
    }
    function showPopup(options) {
      var popupPromise = $ionicPopup._createPopup(options);
      var previousPopup = popupStack[0];
      if (previousPopup) {
        previousPopup.hide();
      }
      var resultPromise = $timeout(angular.noop, previousPopup ? config.stackPushDelay : 0).then(function() {
        return popupPromise;
      }).then(function(popup) {
        if (!previousPopup) {
          $ionicBody.addClass("popup-open");
          $ionicBackdrop.retain();
          $ionicPopup._backButtonActionDone = $ionicPlatform.registerBackButtonAction(onHardwareBackButton, PLATFORM_BACK_BUTTON_PRIORITY_POPUP);
        }
        popupStack.unshift(popup);
        popup.show();
        popup.responseDeferred.notify({
          close: resultPromise.close
        });
        return popup.responseDeferred.promise.then(function(result) {
          var index = popupStack.indexOf(popup);
          if (index !== -1) {
            popupStack.splice(index, 1);
          }
          popup.remove();
          var previousPopup = popupStack[0];
          if (previousPopup) {
            previousPopup.show();
          } else {
            $timeout(function() {
              $ionicBody.removeClass("popup-open");
            }, 400);
            $ionicBackdrop.release();
            ($ionicPopup._backButtonActionDone || angular.noop)();
          }
          return result;
        });
      });
      function close(result) {
        popupPromise.then(function(popup) {
          if (!popup.removed) {
            popup.responseDeferred.resolve(result);
          }
        });
      }
      resultPromise.close = close;
      return resultPromise;
    }
    function focusInput(element) {
      var focusOn = element[0].querySelector("[autofocus]");
      if (focusOn) {
        focusOn.focus();
      }
    }
    function showAlert(opts) {
      return showPopup(extend({
        buttons: [ {
          text: opts.okText || "OK",
          type: opts.okType || "button-positive",
          onTap: function(e) {
            return true;
          }
        } ]
      }, opts || {}));
    }
    function showConfirm(opts) {
      return showPopup(extend({
        buttons: [ {
          text: opts.cancelText || "Cancel",
          type: opts.cancelType || "button-default",
          onTap: function(e) {
            return false;
          }
        }, {
          text: opts.okText || "OK",
          type: opts.okType || "button-positive",
          onTap: function(e) {
            return true;
          }
        } ]
      }, opts || {}));
    }
    function showPrompt(opts) {
      var scope = $rootScope.$new(true);
      scope.data = {};
      var text = "";
      if (opts.template && /<[a-z][\s\S]*>/i.test(opts.template) === false) {
        text = "<span>" + opts.template + "</span>";
        delete opts.template;
      }
      return showPopup(extend({
        template: text + '<input ng-model="data.response" type="' + (opts.inputType || "text") + '" placeholder="' + (opts.inputPlaceholder || "") + '">',
        scope: scope,
        buttons: [ {
          text: opts.cancelText || "Cancel",
          type: opts.cancelType || "button-default",
          onTap: function(e) {}
        }, {
          text: opts.okText || "OK",
          type: opts.okType || "button-positive",
          onTap: function(e) {
            return scope.data.response || "";
          }
        } ]
      }, opts || {}));
    }
  } ]);
  IonicModule.factory("$ionicPosition", [ "$document", "$window", function($document, $window) {
    function getStyle(el, cssprop) {
      if (el.currentStyle) {
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      return el.style[cssprop];
    }
    function isStaticPositioned(element) {
      return (getStyle(element, "position") || "static") === "static";
    }
    var parentOffsetEl = function(element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };
    return {
      position: function(element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = {
          top: 0,
          left: 0
        };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop("offsetWidth"),
          height: boundingClientRect.height || element.prop("offsetHeight"),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },
      offset: function(element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop("offsetWidth"),
          height: boundingClientRect.height || element.prop("offsetHeight"),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
        };
      }
    };
  } ]);
  IonicModule.service("$ionicScrollDelegate", delegateService([ "resize", "scrollTop", "scrollBottom", "scrollTo", "scrollBy", "zoomTo", "zoomBy", "getScrollPosition", "anchorScroll", "getScrollView", "rememberScrollPosition", "forgetScrollPosition", "scrollToRememberedPosition" ]));
  IonicModule.service("$ionicSideMenuDelegate", delegateService([ "toggleLeft", "toggleRight", "getOpenRatio", "isOpen", "isOpenLeft", "isOpenRight", "canDragContent", "edgeDragThreshold" ]));
  IonicModule.service("$ionicSlideBoxDelegate", delegateService([ "update", "slide", "enableSlide", "previous", "next", "stop", "start", "currentIndex", "slidesCount" ]));
  IonicModule.service("$ionicTabsDelegate", delegateService([ "select", "selectedIndex" ]));
  (function() {
    var templatesToCache = [];
    IonicModule.factory("$ionicTemplateCache", [ "$http", "$templateCache", "$timeout", "$ionicConfig", function($http, $templateCache, $timeout, $ionicConfig) {
      var toCache = templatesToCache, hasRun = false;
      function $ionicTemplateCache(templates) {
        if (toCache.length > 500) return false;
        if (typeof templates === "undefined") return run();
        if (isString(templates)) templates = [ templates ];
        forEach(templates, function(template) {
          toCache.push(template);
        });
        if (hasRun) run();
      }
      var run = function() {
        if ($ionicConfig.prefetchTemplates === false) return;
        $ionicTemplateCache._runCount++;
        hasRun = true;
        if (toCache.length === 0) return;
        var i = 0;
        while (i < 5 && (template = toCache.pop())) {
          if (isString(template)) $http.get(template, {
            cache: $templateCache
          });
          i++;
        }
        if (toCache.length) $timeout(function() {
          run();
        }, 1e3);
      };
      $ionicTemplateCache._runCount = 0;
      return $ionicTemplateCache;
    } ]).config([ "$stateProvider", "$ionicConfigProvider", function($stateProvider, $ionicConfigProvider) {
      var stateProviderState = $stateProvider.state;
      $stateProvider.state = function(stateName, definition) {
        if (typeof definition === "object" && $ionicConfigProvider.prefetchTemplates() !== false) {
          var enabled = definition.prefetchTemplate !== false;
          if (enabled && isString(definition.templateUrl)) templatesToCache.push(definition.templateUrl);
          if (angular.isObject(definition.views)) {
            for (var key in definition.views) {
              enabled = definition.views[key].prefetchTemplate !== false;
              if (enabled && isString(definition.views[key].templateUrl)) templatesToCache.push(definition.views[key].templateUrl);
            }
          }
        }
        return stateProviderState.call($stateProvider, stateName, definition);
      };
    } ]).run([ "$ionicTemplateCache", function($ionicTemplateCache) {
      $ionicTemplateCache();
    } ]);
  })();
  IonicModule.factory("$ionicTemplateLoader", [ "$compile", "$controller", "$http", "$q", "$rootScope", "$templateCache", function($compile, $controller, $http, $q, $rootScope, $templateCache) {
    return {
      load: fetchTemplate,
      compile: loadAndCompile
    };
    function fetchTemplate(url) {
      return $http.get(url, {
        cache: $templateCache
      }).then(function(response) {
        return response.data && response.data.trim();
      });
    }
    function loadAndCompile(options) {
      options = extend({
        template: "",
        templateUrl: "",
        scope: null,
        controller: null,
        locals: {},
        appendTo: null
      }, options || {});
      var templatePromise = options.templateUrl ? this.load(options.templateUrl) : $q.when(options.template);
      return templatePromise.then(function(template) {
        var controller;
        var scope = options.scope || $rootScope.$new();
        var element = jqLite("<div>").html(template).contents();
        if (options.controller) {
          controller = $controller(options.controller, extend(options.locals, {
            $scope: scope
          }));
          element.children().data("$ngControllerController", controller);
        }
        if (options.appendTo) {
          jqLite(options.appendTo).append(element);
        }
        $compile(element)(scope);
        return {
          element: element,
          scope: scope
        };
      });
    }
  } ]);
  IonicModule.run([ "$rootScope", "$state", "$location", "$document", "$animate", "$ionicPlatform", "$ionicViewService", function($rootScope, $state, $location, $document, $animate, $ionicPlatform, $ionicViewService) {
    $rootScope.$viewHistory = {
      histories: {
        root: {
          historyId: "root",
          parentHistoryId: null,
          stack: [],
          cursor: -1
        }
      },
      views: {},
      backView: null,
      forwardView: null,
      currentView: null,
      disabledRegistrableTagNames: []
    };
    if ($ionicViewService.disableRegisterByTagName) {
      $ionicViewService.disableRegisterByTagName("ion-tabs");
      $ionicViewService.disableRegisterByTagName("ion-side-menus");
    }
    $rootScope.$on("$stateChangeStart", function() {
      ionic.keyboard.hide();
    });
    $rootScope.$on("viewState.changeHistory", function(e, data) {
      if (!data) return;
      var hist = data.historyId ? $rootScope.$viewHistory.histories[data.historyId] : null;
      if (hist && hist.cursor > -1 && hist.cursor < hist.stack.length) {
        var view = hist.stack[hist.cursor];
        return view.go(data);
      }
      if (!data.url && data.uiSref) {
        data.url = $state.href(data.uiSref);
      }
      if (data.url) {
        if (data.url.indexOf("#") === 0) {
          data.url = data.url.replace("#", "");
        }
        if (data.url !== $location.url()) {
          $location.url(data.url);
        }
      }
    });
    $rootScope.$on("viewState.viewEnter", function(e, data) {
      if (data && data.title) {
        $document[0].title = data.title;
      }
    });
    function onHardwareBackButton(e) {
      if ($rootScope.$viewHistory.backView) {
        $rootScope.$viewHistory.backView.go();
      } else {
        ionic.Platform.exitApp();
      }
      e.preventDefault();
      return false;
    }
    $ionicPlatform.registerBackButtonAction(onHardwareBackButton, PLATFORM_BACK_BUTTON_PRIORITY_VIEW);
  } ]).factory("$ionicViewService", [ "$rootScope", "$state", "$location", "$window", "$injector", "$animate", "$ionicNavViewConfig", "$ionicClickBlock", function($rootScope, $state, $location, $window, $injector, $animate, $ionicNavViewConfig, $ionicClickBlock) {
    var View = function() {};
    View.prototype.initialize = function(data) {
      if (data) {
        for (var name in data) this[name] = data[name];
        return this;
      }
      return null;
    };
    View.prototype.go = function() {
      if (this.stateName) {
        return $state.go(this.stateName, this.stateParams);
      }
      if (this.url && this.url !== $location.url()) {
        if ($rootScope.$viewHistory.backView === this) {
          return $window.history.go(-1);
        } else if ($rootScope.$viewHistory.forwardView === this) {
          return $window.history.go(1);
        }
        $location.url(this.url);
        return;
      }
      return null;
    };
    View.prototype.destroy = function() {
      if (this.scope) {
        this.scope.$destroy && this.scope.$destroy();
        this.scope = null;
      }
    };
    function createViewId(stateId) {
      return ionic.Utils.nextUid();
    }
    return {
      register: function(containerScope, element) {
        var viewHistory = $rootScope.$viewHistory, currentStateId = this.getCurrentStateId(), hist = this._getHistory(containerScope), currentView = viewHistory.currentView, backView = viewHistory.backView, forwardView = viewHistory.forwardView, nextViewOptions = this.nextViewOptions(), rsp = {
          viewId: null,
          navAction: null,
          navDirection: null,
          historyId: hist.historyId
        };
        if (element && !this.isTagNameRegistrable(element)) {
          rsp.navAction = "disabledByTagName";
          return rsp;
        }
        if (currentView && currentView.stateId === currentStateId && currentView.historyId === hist.historyId) {
          rsp.navAction = "noChange";
          return rsp;
        }
        if (viewHistory.forcedNav) {
          ionic.Utils.extend(rsp, viewHistory.forcedNav);
          $rootScope.$viewHistory.forcedNav = null;
        } else if (backView && backView.stateId === currentStateId) {
          rsp.viewId = backView.viewId;
          rsp.navAction = "moveBack";
          rsp.viewId = backView.viewId;
          if (backView.historyId === currentView.historyId) {
            rsp.navDirection = "back";
          }
        } else if (forwardView && forwardView.stateId === currentStateId) {
          rsp.viewId = forwardView.viewId;
          rsp.navAction = "moveForward";
          if (forwardView.historyId === currentView.historyId) {
            rsp.navDirection = "forward";
          }
          var parentHistory = this._getParentHistoryObj(containerScope);
          if (forwardView.historyId && parentHistory.scope) {
            parentHistory.scope.$historyId = forwardView.historyId;
            rsp.historyId = forwardView.historyId;
          }
        } else if (currentView && currentView.historyId !== hist.historyId && hist.cursor > -1 && hist.stack.length > 0 && hist.cursor < hist.stack.length && hist.stack[hist.cursor].stateId === currentStateId) {
          var switchToView = hist.stack[hist.cursor];
          rsp.viewId = switchToView.viewId;
          rsp.navAction = "moveBack";
          var switchToViewBackView = this._getViewById(switchToView.backViewId);
          if (switchToViewBackView && switchToView.historyId !== switchToViewBackView.historyId) {
            hist.stack[hist.cursor].backViewId = currentView.viewId;
          }
        } else {
          rsp.viewId = createViewId(currentStateId);
          if (currentView) {
            currentView.forwardViewId = rsp.viewId;
            if (hist.historyId === currentView.historyId) {
              rsp.navDirection = "forward";
            }
            rsp.navAction = "newView";
            if (forwardView && currentView.stateId !== forwardView.stateId && currentView.historyId === forwardView.historyId) {
              var forwardsHistory = this._getHistoryById(forwardView.historyId);
              if (forwardsHistory) {
                for (var x = forwardsHistory.stack.length - 1; x >= forwardView.index; x--) {
                  forwardsHistory.stack[x].destroy();
                  forwardsHistory.stack.splice(x);
                }
              }
            }
          } else {
            rsp.navAction = "initialView";
          }
          viewHistory.views[rsp.viewId] = this.createView({
            viewId: rsp.viewId,
            index: hist.stack.length,
            historyId: hist.historyId,
            backViewId: currentView && currentView.viewId ? currentView.viewId : null,
            forwardViewId: null,
            stateId: currentStateId,
            stateName: this.getCurrentStateName(),
            stateParams: this.getCurrentStateParams(),
            url: $location.url()
          });
          if (rsp.navAction == "moveBack") {
            $rootScope.$emit("$viewHistory.viewBack", currentView.viewId, rsp.viewId);
          }
          hist.stack.push(viewHistory.views[rsp.viewId]);
        }
        if (nextViewOptions) {
          if (nextViewOptions.disableAnimate) rsp.navDirection = null;
          if (nextViewOptions.disableBack) viewHistory.views[rsp.viewId].backViewId = null;
          this.nextViewOptions(null);
        }
        this.setNavViews(rsp.viewId);
        hist.cursor = viewHistory.currentView.index;
        return rsp;
      },
      setNavViews: function(viewId) {
        var viewHistory = $rootScope.$viewHistory;
        viewHistory.currentView = this._getViewById(viewId);
        viewHistory.backView = this._getBackView(viewHistory.currentView);
        viewHistory.forwardView = this._getForwardView(viewHistory.currentView);
        $rootScope.$broadcast("$viewHistory.historyChange", {
          showBack: viewHistory.backView && viewHistory.backView.historyId === viewHistory.currentView.historyId
        });
      },
      registerHistory: function(scope) {
        scope.$historyId = ionic.Utils.nextUid();
      },
      createView: function(data) {
        var newView = new View();
        return newView.initialize(data);
      },
      getCurrentView: function() {
        return $rootScope.$viewHistory.currentView;
      },
      getBackView: function() {
        return $rootScope.$viewHistory.backView;
      },
      getForwardView: function() {
        return $rootScope.$viewHistory.forwardView;
      },
      getNavDirection: function() {
        return $rootScope.$viewHistory.navDirection;
      },
      getCurrentStateName: function() {
        return $state && $state.current ? $state.current.name : null;
      },
      isCurrentStateNavView: function(navView) {
        return $state && $state.current && $state.current.views && $state.current.views[navView] ? true : false;
      },
      getCurrentStateParams: function() {
        var rtn;
        if ($state && $state.params) {
          for (var key in $state.params) {
            if ($state.params.hasOwnProperty(key)) {
              rtn = rtn || {};
              rtn[key] = $state.params[key];
            }
          }
        }
        return rtn;
      },
      getCurrentStateId: function() {
        var id;
        if ($state && $state.current && $state.current.name) {
          id = $state.current.name;
          if ($state.params) {
            for (var key in $state.params) {
              if ($state.params.hasOwnProperty(key) && $state.params[key]) {
                id += "_" + key + "=" + $state.params[key];
              }
            }
          }
          return id;
        }
        return ionic.Utils.nextUid();
      },
      goToHistoryRoot: function(historyId) {
        if (historyId) {
          var hist = $rootScope.$viewHistory.histories[historyId];
          if (hist && hist.stack.length) {
            if ($rootScope.$viewHistory.currentView && $rootScope.$viewHistory.currentView.viewId === hist.stack[0].viewId) {
              return;
            }
            $rootScope.$viewHistory.forcedNav = {
              viewId: hist.stack[0].viewId,
              navAction: "moveBack",
              navDirection: "back"
            };
            hist.stack[0].go();
          }
        }
      },
      _getViewById: function(viewId) {
        return viewId ? $rootScope.$viewHistory.views[viewId] : null;
      },
      _getBackView: function(view) {
        return view ? this._getViewById(view.backViewId) : null;
      },
      _getForwardView: function(view) {
        return view ? this._getViewById(view.forwardViewId) : null;
      },
      _getHistoryById: function(historyId) {
        return historyId ? $rootScope.$viewHistory.histories[historyId] : null;
      },
      _getHistory: function(scope) {
        var histObj = this._getParentHistoryObj(scope);
        if (!$rootScope.$viewHistory.histories[histObj.historyId]) {
          $rootScope.$viewHistory.histories[histObj.historyId] = {
            historyId: histObj.historyId,
            parentHistoryId: this._getParentHistoryObj(histObj.scope.$parent).historyId,
            stack: [],
            cursor: -1
          };
        }
        return $rootScope.$viewHistory.histories[histObj.historyId];
      },
      _getParentHistoryObj: function(scope) {
        var parentScope = scope;
        while (parentScope) {
          if (parentScope.hasOwnProperty("$historyId")) {
            return {
              historyId: parentScope.$historyId,
              scope: parentScope
            };
          }
          parentScope = parentScope.$parent;
        }
        return {
          historyId: "root",
          scope: $rootScope
        };
      },
      nextViewOptions: function(opts) {
        if (arguments.length) {
          this._nextOpts = opts;
        } else {
          return this._nextOpts;
        }
      },
      getRenderer: function(navViewElement, navViewAttrs, navViewScope) {
        var service = this;
        var registerData;
        var doAnimation;
        var animationClass = getParentAnimationClass(navViewElement[0]);
        function getParentAnimationClass(el) {
          var className = "";
          while (!className && el) {
            className = el.getAttribute("animation");
            el = el.parentElement;
          }
          if (!className) {
            return $ionicNavViewConfig.transition;
          }
          return className;
        }
        function setAnimationClass() {
          if (animationClass) {
            navViewElement[0].classList.add(animationClass);
          }
          if (registerData.navDirection === "back") {
            navViewElement[0].classList.add("reverse");
          } else {
            navViewElement[0].classList.remove("reverse");
          }
        }
        return function(shouldAnimate) {
          return {
            enter: function(element) {
              if (doAnimation && shouldAnimate) {
                setAnimationClass();
                element.addClass("ng-enter");
                $ionicClickBlock.show();
                $animate.enter(element, navViewElement, null, function() {
                  $ionicClickBlock.hide();
                  if (animationClass) {
                    navViewElement[0].classList.remove(animationClass);
                  }
                });
                return;
              } else if (!doAnimation) {
                $ionicClickBlock.hide();
              }
              navViewElement.append(element);
            },
            leave: function() {
              var element = navViewElement.contents();
              if (doAnimation && shouldAnimate) {
                setAnimationClass();
                $animate.leave(element, function() {
                  element.remove();
                });
                return;
              }
              element.remove();
            },
            register: function(element) {
              registerData = service.register(navViewScope, element);
              doAnimation = animationClass !== null && registerData.navDirection !== null;
              return registerData;
            }
          };
        };
      },
      disableRegisterByTagName: function(tagName) {
        $rootScope.$viewHistory.disabledRegistrableTagNames.push(tagName.toUpperCase());
      },
      isTagNameRegistrable: function(element) {
        var x, y, disabledTags = $rootScope.$viewHistory.disabledRegistrableTagNames;
        for (x = 0; x < element.length; x++) {
          if (element[x].nodeType !== 1) continue;
          for (y = 0; y < disabledTags.length; y++) {
            if (element[x].tagName === disabledTags[y]) {
              return false;
            }
          }
        }
        return true;
      },
      clearHistory: function() {
        var histories = $rootScope.$viewHistory.histories, currentView = $rootScope.$viewHistory.currentView;
        if (histories) {
          for (var historyId in histories) {
            if (histories[historyId].stack) {
              histories[historyId].stack = [];
              histories[historyId].cursor = -1;
            }
            if (currentView && currentView.historyId === historyId) {
              currentView.backViewId = null;
              currentView.forwardViewId = null;
              histories[historyId].stack.push(currentView);
            } else if (histories[historyId].destroy) {
              histories[historyId].destroy();
            }
          }
        }
        for (var viewId in $rootScope.$viewHistory.views) {
          if (viewId !== currentView.viewId) {
            delete $rootScope.$viewHistory.views[viewId];
          }
        }
        if (currentView) {
          this.setNavViews(currentView.viewId);
        }
      }
    };
  } ]);
  IonicModule.config([ "$provide", function($provide) {
    function $LocationDecorator($location, $timeout) {
      $location.__hash = $location.hash;
      $location.hash = function(value) {
        if (angular.isDefined(value)) {
          $timeout(function() {
            var scroll = document.querySelector(".scroll-content");
            if (scroll) scroll.scrollTop = 0;
          }, 0, false);
        }
        return $location.__hash(value);
      };
      return $location;
    }
    $provide.decorator("$location", [ "$delegate", "$timeout", $LocationDecorator ]);
  } ]);
  IonicModule.service("$ionicListDelegate", delegateService([ "showReorder", "showDelete", "canSwipeItems", "closeOptionButtons" ])).controller("$ionicList", [ "$scope", "$attrs", "$parse", "$ionicListDelegate", function($scope, $attrs, $parse, $ionicListDelegate) {
    var isSwipeable = true;
    var isReorderShown = false;
    var isDeleteShown = false;
    var deregisterInstance = $ionicListDelegate._registerInstance(this, $attrs.delegateHandle);
    $scope.$on("$destroy", deregisterInstance);
    this.showReorder = function(show) {
      if (arguments.length) {
        isReorderShown = !!show;
      }
      return isReorderShown;
    };
    this.showDelete = function(show) {
      if (arguments.length) {
        isDeleteShown = !!show;
      }
      return isDeleteShown;
    };
    this.canSwipeItems = function(can) {
      if (arguments.length) {
        isSwipeable = !!can;
      }
      return isSwipeable;
    };
    this.closeOptionButtons = function() {
      this.listView && this.listView.clearDragEffects();
    };
  } ]);
  IonicModule.controller("$ionicNavBar", [ "$scope", "$element", "$attrs", "$ionicViewService", "$animate", "$compile", "$ionicNavBarDelegate", function($scope, $element, $attrs, $ionicViewService, $animate, $compile, $ionicNavBarDelegate) {
    $element.parent().data("$ionNavBarController", this);
    var deregisterInstance = $ionicNavBarDelegate._registerInstance(this, $attrs.delegateHandle);
    $scope.$on("$destroy", deregisterInstance);
    $scope.$on("$viewHistory.historyChange", function(e, data) {
      backIsShown = !!data.showBack;
    });
    var self = this;
    this.leftButtonsElement = jqLite($element[0].querySelector(".buttons.left-buttons"));
    this.rightButtonsElement = jqLite($element[0].querySelector(".buttons.right-buttons"));
    this.back = function() {
      var backView = $ionicViewService.getBackView();
      backView && backView.go();
      return false;
    };
    this.align = function(direction) {
      this._headerBarView.align(direction);
    };
    this.showBackButton = function(show) {
      if (arguments.length) {
        $scope.backButtonShown = !!show;
      }
      return !!($scope.hasBackButton && $scope.backButtonShown);
    };
    this.showBar = function(show) {
      if (arguments.length) {
        $scope.isInvisible = !show;
        $scope.$parent.$hasHeader = !!show;
      }
      return !$scope.isInvisible;
    };
    this.setTitle = function(title) {
      if ($scope.title === title) {
        return;
      }
      $scope.oldTitle = $scope.title;
      $scope.title = title || "";
    };
    this.changeTitle = function(title, direction) {
      if ($scope.title === title) {
        if (typeof backIsShown != "undefined" && !backIsShown && $scope.backButtonShown) {
          jqLite($element[0].querySelector(".back-button")).addClass("ng-hide");
        }
        return false;
      }
      this.setTitle(title);
      $scope.isReverse = direction == "back";
      $scope.shouldAnimate = !!direction;
      if (!$scope.shouldAnimate) {
        this._headerBarView.align();
      } else {
        this._animateTitles();
      }
      return true;
    };
    this.getTitle = function() {
      return $scope.title || "";
    };
    this.getPreviousTitle = function() {
      return $scope.oldTitle || "";
    };
    this._animateTitles = function() {
      var oldTitleEl, newTitleEl, currentTitles;
      currentTitles = $element[0].querySelectorAll(".title");
      if (currentTitles.length) {
        oldTitleEl = $compile('<h1 class="title" ng-bind-html="oldTitle"></h1>')($scope);
        jqLite(currentTitles[currentTitles.length - 1]).replaceWith(oldTitleEl);
      }
      newTitleEl = $compile('<h1 class="title invisible" ng-bind-html="title"></h1>')($scope);
      ionic.requestAnimationFrame(function() {
        oldTitleEl && $animate.leave(jqLite(oldTitleEl));
        var insert = oldTitleEl && jqLite(oldTitleEl) || null;
        $animate.enter(newTitleEl, $element, insert, function() {
          self._headerBarView.align();
        });
        forEach(currentTitles, function(el) {
          if (el && el.parentNode) {
            jqLite(el).remove();
          }
        });
        $scope.$digest();
        ionic.requestAnimationFrame(function() {
          newTitleEl[0].classList.remove("invisible");
        });
      });
    };
  } ]);
  IonicModule.factory("$$scrollValueCache", function() {
    return {};
  }).controller("$ionicScroll", [ "$scope", "scrollViewOptions", "$timeout", "$window", "$$scrollValueCache", "$location", "$rootScope", "$document", "$ionicScrollDelegate", function($scope, scrollViewOptions, $timeout, $window, $$scrollValueCache, $location, $rootScope, $document, $ionicScrollDelegate) {
    var self = this;
    this.__timeout = $timeout;
    this._scrollViewOptions = scrollViewOptions;
    var element = this.element = scrollViewOptions.el;
    var $element = this.$element = jqLite(element);
    var scrollView = this.scrollView = new ionic.views.Scroll(scrollViewOptions);
    ($element.parent().length ? $element.parent() : $element).data("$$ionicScrollController", this);
    var deregisterInstance = $ionicScrollDelegate._registerInstance(this, scrollViewOptions.delegateHandle);
    if (!angular.isDefined(scrollViewOptions.bouncing)) {
      ionic.Platform.ready(function() {
        scrollView.options.bouncing = true;
        if (ionic.Platform.isAndroid()) {
          scrollView.options.bouncing = false;
          scrollView.options.deceleration = .95;
        } else {}
      });
    }
    var resize = angular.bind(scrollView, scrollView.resize);
    ionic.on("resize", resize, $window);
    var backListenDone = angular.noop;
    var viewContentLoaded = angular.noop;
    var scrollFunc = function(e) {
      var detail = (e.originalEvent || e).detail || {};
      $scope.$onScroll && $scope.$onScroll({
        event: e,
        scrollTop: detail.scrollTop || 0,
        scrollLeft: detail.scrollLeft || 0
      });
    };
    $element.on("scroll", scrollFunc);
    $scope.$on("$destroy", function() {
      deregisterInstance();
      scrollView.__cleanup();
      ionic.off("resize", resize, $window);
      $window.removeEventListener("resize", resize);
      viewContentLoaded();
      backListenDone();
      if (self._rememberScrollId) {
        $$scrollValueCache[self._rememberScrollId] = scrollView.getValues();
      }
      scrollViewOptions = null;
      self._scrollViewOptions = null;
      self.element = null;
      $element.off("scroll", scrollFunc);
      $element = null;
      self.$element = null;
      self.scrollView = null;
      scrollView = null;
    });
    viewContentLoaded = $scope.$on("$viewContentLoaded", function(e, historyData) {
      if (e.defaultPrevented) {
        return;
      }
      e.preventDefault();
      var viewId = historyData && historyData.viewId || $scope.$historyId;
      if (viewId) {
        $timeout(function() {
          self.rememberScrollPosition(viewId);
          self.scrollToRememberedPosition();
          backListenDone = $rootScope.$on("$viewHistory.viewBack", function(e, fromViewId, toViewId) {
            if (viewId === fromViewId) {
              self.forgetScrollPosition();
            }
          });
        }, 0, false);
      }
    });
    $timeout(function() {
      scrollView && scrollView.run && scrollView.run();
    });
    this._rememberScrollId = null;
    this.getScrollView = function() {
      return this.scrollView;
    };
    this.getScrollPosition = function() {
      return this.scrollView.getValues();
    };
    this.resize = function() {
      return $timeout(resize).then(function() {
        $element && $element.triggerHandler("scroll.resize");
      });
    };
    this.scrollTop = function(shouldAnimate) {
      this.resize().then(function() {
        scrollView.scrollTo(0, 0, !!shouldAnimate);
      });
    };
    this.scrollBottom = function(shouldAnimate) {
      this.resize().then(function() {
        var max = scrollView.getScrollMax();
        scrollView.scrollTo(max.left, max.top, !!shouldAnimate);
      });
    };
    this.scrollTo = function(left, top, shouldAnimate) {
      this.resize().then(function() {
        scrollView.scrollTo(left, top, !!shouldAnimate);
      });
    };
    this.zoomTo = function(zoom, shouldAnimate, originLeft, originTop) {
      this.resize().then(function() {
        scrollView.zoomTo(zoom, !!shouldAnimate, originLeft, originTop);
      });
    };
    this.zoomBy = function(zoom, shouldAnimate, originLeft, originTop) {
      this.resize().then(function() {
        scrollView.zoomBy(zoom, !!shouldAnimate, originLeft, originTop);
      });
    };
    this.scrollBy = function(left, top, shouldAnimate) {
      this.resize().then(function() {
        scrollView.scrollBy(left, top, !!shouldAnimate);
      });
    };
    this.anchorScroll = function(shouldAnimate) {
      this.resize().then(function() {
        var hash = $location.hash();
        var elm = hash && $document[0].getElementById(hash);
        if (!(hash && elm)) {
          scrollView.scrollTo(0, 0, !!shouldAnimate);
          return;
        }
        var curElm = elm;
        var scrollLeft = 0, scrollTop = 0, levelsClimbed = 0;
        do {
          if (curElm !== null) scrollLeft += curElm.offsetLeft;
          if (curElm !== null) scrollTop += curElm.offsetTop;
          curElm = curElm.offsetParent;
          levelsClimbed++;
        } while (curElm.attributes != self.element.attributes && curElm.offsetParent);
        scrollView.scrollTo(scrollLeft, scrollTop, !!shouldAnimate);
      });
    };
    this.rememberScrollPosition = function(id) {
      if (!id) {
        throw new Error("Must supply an id to remember the scroll by!");
      }
      this._rememberScrollId = id;
    };
    this.forgetScrollPosition = function() {
      delete $$scrollValueCache[this._rememberScrollId];
      this._rememberScrollId = null;
    };
    this.scrollToRememberedPosition = function(shouldAnimate) {
      var values = $$scrollValueCache[this._rememberScrollId];
      if (values) {
        this.resize().then(function() {
          scrollView && scrollView.scrollTo && scrollView.scrollTo(+values.left, +values.top, shouldAnimate);
        });
      }
    };
    this._setRefresher = function(refresherScope, refresherElement) {
      var refresher = this.refresher = refresherElement;
      var refresherHeight = self.refresher.clientHeight || 60;
      scrollView.activatePullToRefresh(refresherHeight, function() {
        refresher.classList.add("active");
        refresherScope.$onPulling();
      }, function() {
        $timeout(function() {
          refresher.classList.remove("active");
          refresher.classList.remove("refreshing");
          refresher.classList.remove("refreshing-tail");
          refresher.classList.add("invisible");
        }, 300);
      }, function() {
        refresher.classList.add("refreshing");
        refresherScope.$onRefresh();
      }, function() {
        refresher.classList.remove("invisible");
      }, function() {
        refresher.classList.add("invisible");
      }, function() {
        refresher.classList.add("refreshing-tail");
      });
    };
  } ]);
  IonicModule.controller("$ionicSideMenus", [ "$scope", "$attrs", "$ionicSideMenuDelegate", "$ionicPlatform", "$ionicBody", function($scope, $attrs, $ionicSideMenuDelegate, $ionicPlatform, $ionicBody) {
    var self = this;
    var rightShowing, leftShowing, isDragging;
    var startX, lastX, offsetX, isAsideExposed;
    self.$scope = $scope;
    self.initialize = function(options) {
      self.left = options.left;
      self.right = options.right;
      self.setContent(options.content);
      self.dragThresholdX = options.dragThresholdX || 10;
    };
    self.setContent = function(content) {
      if (content) {
        self.content = content;
        self.content.onDrag = function(e) {
          self._handleDrag(e);
        };
        self.content.endDrag = function(e) {
          self._endDrag(e);
        };
      }
    };
    self.isOpenLeft = function() {
      return self.getOpenAmount() > 0;
    };
    self.isOpenRight = function() {
      return self.getOpenAmount() < 0;
    };
    self.toggleLeft = function(shouldOpen) {
      if (isAsideExposed || !self.left.isEnabled) return;
      var openAmount = self.getOpenAmount();
      if (arguments.length === 0) {
        shouldOpen = openAmount <= 0;
      }
      self.content.enableAnimation();
      if (!shouldOpen) {
        self.openPercentage(0);
      } else {
        self.openPercentage(100);
      }
    };
    self.toggleRight = function(shouldOpen) {
      if (isAsideExposed || !self.right.isEnabled) return;
      var openAmount = self.getOpenAmount();
      if (arguments.length === 0) {
        shouldOpen = openAmount >= 0;
      }
      self.content.enableAnimation();
      if (!shouldOpen) {
        self.openPercentage(0);
      } else {
        self.openPercentage(-100);
      }
    };
    self.close = function() {
      self.openPercentage(0);
    };
    self.getOpenAmount = function() {
      return self.content && self.content.getTranslateX() || 0;
    };
    self.getOpenRatio = function() {
      var amount = self.getOpenAmount();
      if (amount >= 0) {
        return amount / self.left.width;
      }
      return amount / self.right.width;
    };
    self.isOpen = function() {
      return self.getOpenAmount() !== 0;
    };
    self.getOpenPercentage = function() {
      return self.getOpenRatio() * 100;
    };
    self.openPercentage = function(percentage) {
      var p = percentage / 100;
      if (self.left && percentage >= 0) {
        self.openAmount(self.left.width * p);
      } else if (self.right && percentage < 0) {
        var maxRight = self.right.width;
        self.openAmount(self.right.width * p);
      }
      $ionicBody.enableClass(percentage !== 0, "menu-open");
    };
    self.openAmount = function(amount) {
      var maxLeft = self.left && self.left.width || 0;
      var maxRight = self.right && self.right.width || 0;
      if (!(self.left && self.left.isEnabled) && amount > 0) {
        self.content.setTranslateX(0);
        return;
      }
      if (!(self.right && self.right.isEnabled) && amount < 0) {
        self.content.setTranslateX(0);
        return;
      }
      if (leftShowing && amount > maxLeft) {
        self.content.setTranslateX(maxLeft);
        return;
      }
      if (rightShowing && amount < -maxRight) {
        self.content.setTranslateX(-maxRight);
        return;
      }
      self.content.setTranslateX(amount);
      if (amount >= 0) {
        leftShowing = true;
        rightShowing = false;
        if (amount > 0) {
          self.right && self.right.pushDown && self.right.pushDown();
          self.left && self.left.bringUp && self.left.bringUp();
        }
      } else {
        rightShowing = true;
        leftShowing = false;
        self.right && self.right.bringUp && self.right.bringUp();
        self.left && self.left.pushDown && self.left.pushDown();
      }
    };
    self.snapToRest = function(e) {
      self.content.enableAnimation();
      isDragging = false;
      var ratio = self.getOpenRatio();
      if (ratio === 0) {
        self.openPercentage(0);
        return;
      }
      var velocityThreshold = .3;
      var velocityX = e.gesture.velocityX;
      var direction = e.gesture.direction;
      if (ratio > 0 && ratio < .5 && direction == "right" && velocityX < velocityThreshold) {
        self.openPercentage(0);
      } else if (ratio > .5 && direction == "left" && velocityX < velocityThreshold) {
        self.openPercentage(100);
      } else if (ratio < 0 && ratio > -.5 && direction == "left" && velocityX < velocityThreshold) {
        self.openPercentage(0);
      } else if (ratio < .5 && direction == "right" && velocityX < velocityThreshold) {
        self.openPercentage(-100);
      } else if (direction == "right" && ratio >= 0 && (ratio >= .5 || velocityX > velocityThreshold)) {
        self.openPercentage(100);
      } else if (direction == "left" && ratio <= 0 && (ratio <= -.5 || velocityX > velocityThreshold)) {
        self.openPercentage(-100);
      } else {
        self.openPercentage(0);
      }
    };
    self.isAsideExposed = function() {
      return !!isAsideExposed;
    };
    self.exposeAside = function(shouldExposeAside) {
      if (!self.left || !self.left.isEnabled) return;
      self.close();
      isAsideExposed = shouldExposeAside;
      self.content.setMarginLeft(isAsideExposed ? self.left.width : 0);
      self.$scope.$emit("$ionicExposeAside", isAsideExposed);
    };
    self.activeAsideResizing = function(isResizing) {
      $ionicBody.enableClass(isResizing, "aside-resizing");
    };
    self._endDrag = function(e) {
      if (isAsideExposed) return;
      if (isDragging) {
        self.snapToRest(e);
      }
      startX = null;
      lastX = null;
      offsetX = null;
    };
    self._handleDrag = function(e) {
      if (isAsideExposed) return;
      if (!startX) {
        startX = e.gesture.touches[0].pageX;
        lastX = startX;
      } else {
        lastX = e.gesture.touches[0].pageX;
      }
      if (!isDragging && Math.abs(lastX - startX) > self.dragThresholdX) {
        startX = lastX;
        isDragging = true;
        self.content.disableAnimation();
        offsetX = self.getOpenAmount();
      }
      if (isDragging) {
        self.openAmount(offsetX + (lastX - startX));
      }
    };
    self.canDragContent = function(canDrag) {
      if (arguments.length) {
        $scope.dragContent = !!canDrag;
      }
      return $scope.dragContent;
    };
    self.edgeThreshold = 25;
    self.edgeThresholdEnabled = false;
    self.edgeDragThreshold = function(value) {
      if (arguments.length) {
        if (angular.isNumber(value) && value > 0) {
          self.edgeThreshold = value;
          self.edgeThresholdEnabled = true;
        } else {
          self.edgeThresholdEnabled = !!value;
        }
      }
      return self.edgeThresholdEnabled;
    };
    self.isDraggableTarget = function(e) {
      var shouldOnlyAllowEdgeDrag = self.edgeThresholdEnabled && !self.isOpen();
      var startX = e.gesture.startEvent && e.gesture.startEvent.center && e.gesture.startEvent.center.pageX;
      var dragIsWithinBounds = !shouldOnlyAllowEdgeDrag || startX <= self.edgeThreshold || startX >= self.content.element.offsetWidth - self.edgeThreshold;
      return ($scope.dragContent || self.isOpen()) && dragIsWithinBounds && !e.gesture.srcEvent.defaultPrevented && !e.target.tagName.match(/input|textarea|select|object|embed/i) && !e.target.isContentEditable && !(e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute("data-prevent-scroll") == "true");
    };
    $scope.sideMenuContentTranslateX = 0;
    var deregisterBackButtonAction = angular.noop;
    var closeSideMenu = angular.bind(self, self.close);
    $scope.$watch(function() {
      return self.getOpenAmount() !== 0;
    }, function(isOpen) {
      deregisterBackButtonAction();
      if (isOpen) {
        deregisterBackButtonAction = $ionicPlatform.registerBackButtonAction(closeSideMenu, PLATFORM_BACK_BUTTON_PRIORITY_SIDE_MENU);
      }
    });
    var deregisterInstance = $ionicSideMenuDelegate._registerInstance(self, $attrs.delegateHandle);
    $scope.$on("$destroy", function() {
      deregisterInstance();
      deregisterBackButtonAction();
    });
    self.initialize({
      left: {
        width: 275
      },
      right: {
        width: 275
      }
    });
  } ]);
  IonicModule.controller("$ionicTab", [ "$scope", "$ionicViewService", "$attrs", "$location", "$state", function($scope, $ionicViewService, $attrs, $location, $state) {
    this.$scope = $scope;
    this.hrefMatchesState = function() {
      return $attrs.href && $location.path().indexOf($attrs.href.replace(/^#/, "").replace(/\/$/, "")) === 0;
    };
    this.srefMatchesState = function() {
      return $attrs.uiSref && $state.includes($attrs.uiSref.split("(")[0]);
    };
    this.navNameMatchesState = function() {
      return this.navViewName && $ionicViewService.isCurrentStateNavView(this.navViewName);
    };
    this.tabMatchesState = function() {
      return this.hrefMatchesState() || this.srefMatchesState() || this.navNameMatchesState();
    };
  } ]);
  IonicModule.controller("$ionicTabs", [ "$scope", "$ionicViewService", "$element", function($scope, $ionicViewService, $element) {
    var _selectedTab = null;
    var self = this;
    self.tabs = [];
    self.selectedIndex = function() {
      return self.tabs.indexOf(_selectedTab);
    };
    self.selectedTab = function() {
      return _selectedTab;
    };
    self.add = function(tab) {
      $ionicViewService.registerHistory(tab);
      self.tabs.push(tab);
      if (self.tabs.length === 1) {
        self.select(tab);
      }
    };
    self.remove = function(tab) {
      var tabIndex = self.tabs.indexOf(tab);
      if (tabIndex === -1) {
        return;
      }
      if (tab.$tabSelected) {
        self.deselect(tab);
        if (self.tabs.length === 1) {} else {
          var newTabIndex = tabIndex === self.tabs.length - 1 ? tabIndex - 1 : tabIndex + 1;
          self.select(self.tabs[newTabIndex]);
        }
      }
      self.tabs.splice(tabIndex, 1);
    };
    self.deselect = function(tab) {
      if (tab.$tabSelected) {
        _selectedTab = null;
        tab.$tabSelected = false;
        (tab.onDeselect || angular.noop)();
      }
    };
    self.select = function(tab, shouldEmitEvent) {
      var tabIndex;
      if (angular.isNumber(tab)) {
        tabIndex = tab;
        tab = self.tabs[tabIndex];
      } else {
        tabIndex = self.tabs.indexOf(tab);
      }
      if (arguments.length === 1) {
        shouldEmitEvent = !!(tab.navViewName || tab.uiSref);
      }
      if (_selectedTab && _selectedTab.$historyId == tab.$historyId) {
        if (shouldEmitEvent) {
          $ionicViewService.goToHistoryRoot(tab.$historyId);
        }
      } else {
        forEach(self.tabs, function(tab) {
          self.deselect(tab);
        });
        _selectedTab = tab;
        tab.$tabSelected = true;
        (tab.onSelect || angular.noop)();
        if (shouldEmitEvent) {
          var viewData = {
            type: "tab",
            tabIndex: tabIndex,
            historyId: tab.$historyId,
            navViewName: tab.navViewName,
            hasNavView: !!tab.navViewName,
            title: tab.title,
            url: tab.href,
            uiSref: tab.uiSref
          };
          $scope.$emit("viewState.changeHistory", viewData);
        }
      }
    };
  } ]);
  IonicModule.directive("ionActionSheet", [ "$document", function($document) {
    return {
      restrict: "E",
      scope: true,
      replace: true,
      link: function($scope, $element) {
        var keyUp = function(e) {
          if (e.which == 27) {
            $scope.cancel();
            $scope.$apply();
          }
        };
        var backdropClick = function(e) {
          if (e.target == $element[0]) {
            $scope.cancel();
            $scope.$apply();
          }
        };
        $scope.$on("$destroy", function() {
          $element.remove();
          $document.unbind("keyup", keyUp);
        });
        $document.bind("keyup", keyUp);
        $element.bind("click", backdropClick);
      },
      template: '<div class="action-sheet-backdrop">' + '<div class="action-sheet-wrapper">' + '<div class="action-sheet">' + '<div class="action-sheet-group">' + '<div class="action-sheet-title" ng-if="titleText" ng-bind-html="titleText"></div>' + '<button class="button" ng-click="buttonClicked($index)" ng-repeat="button in buttons" ng-bind-html="button.text"></button>' + "</div>" + '<div class="action-sheet-group" ng-if="destructiveText">' + '<button class="button destructive" ng-click="destructiveButtonClicked()" ng-bind-html="destructiveText"></button>' + "</div>" + '<div class="action-sheet-group" ng-if="cancelText">' + '<button class="button" ng-click="cancel()" ng-bind-html="cancelText"></button>' + "</div>" + "</div>" + "</div>" + "</div>"
    };
  } ]);
  IonicModule.directive("ionCheckbox", function() {
    return {
      restrict: "E",
      replace: true,
      require: "?ngModel",
      transclude: true,
      template: '<label class="item item-checkbox">' + '<div class="checkbox checkbox-input-hidden disable-pointer-events">' + '<input type="checkbox">' + '<i class="checkbox-icon"></i>' + "</div>" + '<div class="item-content disable-pointer-events" ng-transclude></div>' + "</label>",
      compile: function(element, attr) {
        var input = element.find("input");
        forEach({
          name: attr.name,
          "ng-value": attr.ngValue,
          "ng-model": attr.ngModel,
          "ng-checked": attr.ngChecked,
          "ng-disabled": attr.ngDisabled,
          "ng-true-value": attr.ngTrueValue,
          "ng-false-value": attr.ngFalseValue,
          "ng-change": attr.ngChange
        }, function(value, name) {
          if (isDefined(value)) {
            input.attr(name, value);
          }
        });
      }
    };
  });
  var COLLECTION_REPEAT_SCROLLVIEW_XY_ERROR = "Cannot create a collection-repeat within a scrollView that is scrollable on both x and y axis.  Choose either x direction or y direction.";
  var COLLECTION_REPEAT_ATTR_HEIGHT_ERROR = "collection-repeat expected attribute collection-item-height to be a an expression that returns a number (in pixels) or percentage.";
  var COLLECTION_REPEAT_ATTR_WIDTH_ERROR = "collection-repeat expected attribute collection-item-width to be a an expression that returns a number (in pixels) or percentage.";
  var COLLECTION_REPEAT_ATTR_REPEAT_ERROR = "collection-repeat expected expression in form of '_item_ in _collection_[ track by _id_]' but got '%'";
  IonicModule.directive("collectionRepeat", [ "$collectionRepeatManager", "$collectionDataSource", "$parse", function($collectionRepeatManager, $collectionDataSource, $parse) {
    return {
      priority: 1e3,
      transclude: "element",
      terminal: true,
      $$tlb: true,
      require: "^$ionicScroll",
      controller: [ function() {} ],
      link: function($scope, $element, $attr, scrollCtrl, $transclude) {
        var wrap = jqLite('<div style="position:relative;">');
        $element.parent()[0].insertBefore(wrap[0], $element[0]);
        wrap.append($element);
        var scrollView = scrollCtrl.scrollView;
        if (scrollView.options.scrollingX && scrollView.options.scrollingY) {
          throw new Error(COLLECTION_REPEAT_SCROLLVIEW_XY_ERROR);
        }
        var isVertical = !!scrollView.options.scrollingY;
        if (isVertical && !$attr.collectionItemHeight) {
          throw new Error(COLLECTION_REPEAT_ATTR_HEIGHT_ERROR);
        } else if (!isVertical && !$attr.collectionItemWidth) {
          throw new Error(COLLECTION_REPEAT_ATTR_WIDTH_ERROR);
        }
        var heightParsed = $parse($attr.collectionItemHeight || '"100%"');
        var widthParsed = $parse($attr.collectionItemWidth || '"100%"');
        var heightGetter = function(scope, locals) {
          var result = heightParsed(scope, locals);
          if (isString(result) && result.indexOf("%") > -1) {
            return Math.floor(parseInt(result, 10) / 100 * scrollView.__clientHeight);
          }
          return result;
        };
        var widthGetter = function(scope, locals) {
          var result = widthParsed(scope, locals);
          if (isString(result) && result.indexOf("%") > -1) {
            return Math.floor(parseInt(result, 10) / 100 * scrollView.__clientWidth);
          }
          return result;
        };
        var match = $attr.collectionRepeat.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
        if (!match) {
          throw new Error(COLLECTION_REPEAT_ATTR_REPEAT_ERROR.replace("%", $attr.collectionRepeat));
        }
        var keyExpr = match[1];
        var listExpr = match[2];
        var trackByExpr = match[3];
        var dataSource = new $collectionDataSource({
          scope: $scope,
          transcludeFn: $transclude,
          transcludeParent: $element.parent(),
          keyExpr: keyExpr,
          listExpr: listExpr,
          trackByExpr: trackByExpr,
          heightGetter: heightGetter,
          widthGetter: widthGetter
        });
        var collectionRepeatManager = new $collectionRepeatManager({
          dataSource: dataSource,
          element: scrollCtrl.$element,
          scrollView: scrollCtrl.scrollView
        });
        $scope.$watchCollection(listExpr, function(value) {
          if (value && !angular.isArray(value)) {
            throw new Error("collection-repeat expects an array to repeat over, but instead got '" + typeof value + "'.");
          }
          rerender(value);
        });
        var scrollViewContent = scrollCtrl.scrollView.__content;
        function rerender(value) {
          var beforeSiblings = [];
          var afterSiblings = [];
          var before = true;
          forEach(scrollViewContent.children, function(node, i) {
            if (ionic.DomUtil.elementIsDescendant($element[0], node, scrollViewContent)) {
              before = false;
            } else {
              if (node.hasAttribute("collection-repeat-ignore")) return;
              var width = node.offsetWidth;
              var height = node.offsetHeight;
              if (width && height) {
                var element = jqLite(node);
                (before ? beforeSiblings : afterSiblings).push({
                  width: node.offsetWidth,
                  height: node.offsetHeight,
                  element: element,
                  scope: element.isolateScope() || element.scope(),
                  isOutside: true
                });
              }
            }
          });
          scrollView.resize();
          dataSource.setData(value, beforeSiblings, afterSiblings);
          collectionRepeatManager.resize();
        }
        function rerenderOnResize() {
          rerender($scope.$eval(listExpr));
        }
        scrollCtrl.$element.on("scroll.resize", rerenderOnResize);
        ionic.on("resize", rerenderOnResize, window);
        $scope.$on("$destroy", function() {
          collectionRepeatManager.destroy();
          dataSource.destroy();
          ionic.off("resize", rerenderOnResize, window);
        });
      }
    };
  } ]).directive({
    ngSrc: collectionRepeatSrcDirective("ngSrc", "src"),
    ngSrcset: collectionRepeatSrcDirective("ngSrcset", "srcset"),
    ngHref: collectionRepeatSrcDirective("ngHref", "href")
  });
  function collectionRepeatSrcDirective(ngAttrName, attrName) {
    return [ function() {
      return {
        priority: "99",
        link: function(scope, element, attr) {
          attr.$observe(ngAttrName, function(value) {
            if (!value) {
              element[0].removeAttribute(attrName);
            }
          });
        }
      };
    } ];
  }
  IonicModule.directive("ionContent", [ "$timeout", "$controller", "$ionicBind", function($timeout, $controller, $ionicBind) {
    return {
      restrict: "E",
      require: "^?ionNavView",
      scope: true,
      priority: 800,
      compile: function(element, attr) {
        var innerElement;
        element.addClass("scroll-content ionic-scroll");
        if (attr.scroll != "false") {
          innerElement = jqLite('<div class="scroll"></div>');
          innerElement.append(element.contents());
          element.append(innerElement);
        } else {
          element.addClass("scroll-content-false");
        }
        return {
          pre: prelink
        };
        function prelink($scope, $element, $attr, navViewCtrl) {
          var parentScope = $scope.$parent;
          $scope.$watch(function() {
            return (parentScope.$hasHeader ? " has-header" : "") + (parentScope.$hasSubheader ? " has-subheader" : "") + (parentScope.$hasFooter ? " has-footer" : "") + (parentScope.$hasSubfooter ? " has-subfooter" : "") + (parentScope.$hasTabs ? " has-tabs" : "") + (parentScope.$hasTabsTop ? " has-tabs-top" : "");
          }, function(className, oldClassName) {
            $element.removeClass(oldClassName);
            $element.addClass(className);
          });
          $scope.$hasHeader = $scope.$hasSubheader = $scope.$hasFooter = $scope.$hasSubfooter = $scope.$hasTabs = $scope.$hasTabsTop = false;
          $ionicBind($scope, $attr, {
            $onScroll: "&onScroll",
            $onScrollComplete: "&onScrollComplete",
            hasBouncing: "@",
            padding: "@",
            direction: "@",
            scrollbarX: "@",
            scrollbarY: "@",
            startX: "@",
            startY: "@",
            scrollEventInterval: "@"
          });
          $scope.direction = $scope.direction || "y";
          if (angular.isDefined($attr.padding)) {
            $scope.$watch($attr.padding, function(newVal) {
              (innerElement || $element).toggleClass("padding", !!newVal);
            });
          }
          if ($attr.scroll === "false") {} else if (attr.overflowScroll === "true") {
            $element.addClass("overflow-scroll");
          } else {
            var scrollViewOptions = {
              el: $element[0],
              delegateHandle: attr.delegateHandle,
              locking: (attr.locking || "true") === "true",
              bouncing: $scope.$eval($scope.hasBouncing),
              startX: $scope.$eval($scope.startX) || 0,
              startY: $scope.$eval($scope.startY) || 0,
              scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
              scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
              scrollingX: $scope.direction.indexOf("x") >= 0,
              scrollingY: $scope.direction.indexOf("y") >= 0,
              scrollEventInterval: parseInt($scope.scrollEventInterval, 10) || 10,
              scrollingComplete: function() {
                $scope.$onScrollComplete({
                  scrollTop: this.__scrollTop,
                  scrollLeft: this.__scrollLeft
                });
              }
            };
            $controller("$ionicScroll", {
              $scope: $scope,
              scrollViewOptions: scrollViewOptions
            });
            $scope.$on("$destroy", function() {
              scrollViewOptions.scrollingComplete = angular.noop;
              delete scrollViewOptions.el;
              innerElement = null;
              $element = null;
              attr.$$element = null;
            });
          }
        }
      }
    };
  } ]);
  IonicModule.directive("exposeAsideWhen", [ "$window", function($window) {
    return {
      restrict: "A",
      require: "^ionSideMenus",
      link: function($scope, $element, $attr, sideMenuCtrl) {
        function checkAsideExpose() {
          var mq = $attr.exposeAsideWhen == "large" ? "(min-width:768px)" : $attr.exposeAsideWhen;
          sideMenuCtrl.exposeAside($window.matchMedia(mq).matches);
          sideMenuCtrl.activeAsideResizing(false);
        }
        function onResize() {
          sideMenuCtrl.activeAsideResizing(true);
          debouncedCheck();
        }
        var debouncedCheck = ionic.debounce(function() {
          $scope.$apply(function() {
            checkAsideExpose();
          });
        }, 300, false);
        checkAsideExpose();
        ionic.on("resize", onResize, $window);
        $scope.$on("$destroy", function() {
          ionic.off("resize", onResize, $window);
        });
      }
    };
  } ]);
  var GESTURE_DIRECTIVES = "onHold onTap onTouch onRelease onDrag onDragUp onDragRight onDragDown onDragLeft onSwipe onSwipeUp onSwipeRight onSwipeDown onSwipeLeft".split(" ");
  GESTURE_DIRECTIVES.forEach(function(name) {
    IonicModule.directive(name, gestureDirective(name));
  });
  function gestureDirective(directiveName) {
    return [ "$ionicGesture", "$parse", function($ionicGesture, $parse) {
      var eventType = directiveName.substr(2).toLowerCase();
      return function(scope, element, attr) {
        var fn = $parse(attr[directiveName]);
        var listener = function(ev) {
          scope.$apply(function() {
            fn(scope, {
              $event: ev
            });
          });
        };
        var gesture = $ionicGesture.on(eventType, listener, element);
        scope.$on("$destroy", function() {
          $ionicGesture.off(gesture, eventType, listener);
        });
      };
    } ];
  }
  IonicModule.directive("ionNavBar", tapScrollToTopDirective()).directive("ionHeaderBar", tapScrollToTopDirective()).directive("ionHeaderBar", headerFooterBarDirective(true)).directive("ionFooterBar", headerFooterBarDirective(false));
  function tapScrollToTopDirective() {
    return [ "$ionicScrollDelegate", function($ionicScrollDelegate) {
      return {
        restrict: "E",
        link: function($scope, $element, $attr) {
          if ($attr.noTapScroll == "true") {
            return;
          }
          ionic.on("tap", onTap, $element[0]);
          $scope.$on("$destroy", function() {
            ionic.off("tap", onTap, $element[0]);
          });
          function onTap(e) {
            var depth = 3;
            var current = e.target;
            while (depth-- && current) {
              if (current.classList.contains("button") || current.tagName.match(/input|textarea|select/i) || current.isContentEditable) {
                return;
              }
              current = current.parentNode;
            }
            var touch = e.gesture && e.gesture.touches[0] || e.detail.touches[0];
            var bounds = $element[0].getBoundingClientRect();
            if (ionic.DomUtil.rectContains(touch.pageX, touch.pageY, bounds.left, bounds.top - 20, bounds.left + bounds.width, bounds.top + bounds.height)) {
              $ionicScrollDelegate.scrollTop(true);
            }
          }
        }
      };
    } ];
  }
  function headerFooterBarDirective(isHeader) {
    return [ function() {
      return {
        restrict: "E",
        compile: function($element, $attr) {
          $element.addClass(isHeader ? "bar bar-header" : "bar bar-footer");
          var parent = $element[0].parentNode;
          if (parent.querySelector(".tabs-top")) $element.addClass("has-tabs-top");
          return {
            pre: prelink
          };
          function prelink($scope, $element, $attr) {
            var hb = new ionic.views.HeaderBar({
              el: $element[0],
              alignTitle: $attr.alignTitle || "center"
            });
            var el = $element[0];
            if (isHeader) {
              $scope.$watch(function() {
                return el.className;
              }, function(value) {
                var isShown = value.indexOf("ng-hide") === -1;
                var isSubheader = value.indexOf("bar-subheader") !== -1;
                $scope.$hasHeader = isShown && !isSubheader;
                $scope.$hasSubheader = isShown && isSubheader;
              });
              $scope.$on("$destroy", function() {
                delete $scope.$hasHeader;
                delete $scope.$hasSubheader;
              });
            } else {
              $scope.$watch(function() {
                return el.className;
              }, function(value) {
                var isShown = value.indexOf("ng-hide") === -1;
                var isSubfooter = value.indexOf("bar-subfooter") !== -1;
                $scope.$hasFooter = isShown && !isSubfooter;
                $scope.$hasSubfooter = isShown && isSubfooter;
              });
              $scope.$on("$destroy", function() {
                delete $scope.$hasFooter;
                delete $scope.$hasSubfooter;
              });
              $scope.$watch("$hasTabs", function(val) {
                $element.toggleClass("has-tabs", !!val);
              });
            }
          }
        }
      };
    } ];
  }
  IonicModule.directive("ionInfiniteScroll", [ "$timeout", function($timeout) {
    function calculateMaxValue(distance, maximum, isPercent) {
      return isPercent ? maximum * (1 - parseFloat(distance, 10) / 100) : maximum - parseFloat(distance, 10);
    }
    return {
      restrict: "E",
      require: [ "^$ionicScroll", "ionInfiniteScroll" ],
      template: '<i class="icon {{icon()}} icon-refreshing"></i>',
      scope: true,
      controller: [ "$scope", "$attrs", function($scope, $attrs) {
        this.isLoading = false;
        this.scrollView = null;
        this.getMaxScroll = function() {
          var distance = ($attrs.distance || "2.5%").trim();
          var isPercent = distance.indexOf("%") !== -1;
          var maxValues = this.scrollView.getScrollMax();
          return {
            left: this.scrollView.options.scrollingX ? calculateMaxValue(distance, maxValues.left, isPercent) : -1,
            top: this.scrollView.options.scrollingY ? calculateMaxValue(distance, maxValues.top, isPercent) : -1
          };
        };
      } ],
      link: function($scope, $element, $attrs, ctrls) {
        var scrollCtrl = ctrls[0];
        var infiniteScrollCtrl = ctrls[1];
        var scrollView = infiniteScrollCtrl.scrollView = scrollCtrl.scrollView;
        $scope.icon = function() {
          return angular.isDefined($attrs.icon) ? $attrs.icon : "ion-loading-d";
        };
        var onInfinite = function() {
          $element[0].classList.add("active");
          infiniteScrollCtrl.isLoading = true;
          $scope.$parent && $scope.$parent.$apply($attrs.onInfinite || "");
        };
        var finishInfiniteScroll = function() {
          $element[0].classList.remove("active");
          $timeout(function() {
            scrollView.resize();
            checkBounds();
          }, 0, false);
          infiniteScrollCtrl.isLoading = false;
        };
        $scope.$on("scroll.infiniteScrollComplete", function() {
          finishInfiniteScroll();
        });
        $scope.$on("$destroy", function() {
          void 0;
          if (scrollCtrl && scrollCtrl.$element) scrollCtrl.$element.off("scroll", checkBounds);
        });
        var checkBounds = ionic.animationFrameThrottle(checkInfiniteBounds);
        setTimeout(checkBounds);
        scrollCtrl.$element.on("scroll", checkBounds);
        function checkInfiniteBounds() {
          if (infiniteScrollCtrl.isLoading) return;
          var scrollValues = scrollView.getValues();
          var maxScroll = infiniteScrollCtrl.getMaxScroll();
          if (maxScroll.left !== -1 && scrollValues.left >= maxScroll.left || maxScroll.top !== -1 && scrollValues.top >= maxScroll.top) {
            onInfinite();
          }
        }
      }
    };
  } ]);
  var ITEM_TPL_CONTENT_ANCHOR = '<a class="item-content" ng-href="{{$href()}}" target="{{$target()}}"></a>';
  var ITEM_TPL_CONTENT = '<div class="item-content"></div>';
  IonicModule.directive("ionItem", [ "$animate", "$compile", function($animate, $compile) {
    return {
      restrict: "E",
      controller: [ "$scope", "$element", function($scope, $element) {
        this.$scope = $scope;
        this.$element = $element;
      } ],
      scope: true,
      compile: function($element, $attrs) {
        var isAnchor = angular.isDefined($attrs.href) || angular.isDefined($attrs.ngHref) || angular.isDefined($attrs.uiSref);
        var isComplexItem = isAnchor || /ion-(delete|option|reorder)-button/i.test($element.html());
        if (isComplexItem) {
          var innerElement = jqLite(isAnchor ? ITEM_TPL_CONTENT_ANCHOR : ITEM_TPL_CONTENT);
          innerElement.append($element.contents());
          $element.append(innerElement);
          $element.addClass("item item-complex");
        } else {
          $element.addClass("item");
        }
        return function link($scope, $element, $attrs) {
          $scope.$href = function() {
            return $attrs.href || $attrs.ngHref;
          };
          $scope.$target = function() {
            return $attrs.target || "_self";
          };
        };
      }
    };
  } ]);
  var ITEM_TPL_DELETE_BUTTON = '<div class="item-left-edit item-delete enable-pointer-events">' + "</div>";
  IonicModule.directive("ionDeleteButton", [ "$animate", function($animate) {
    return {
      restrict: "E",
      require: [ "^ionItem", "^?ionList" ],
      priority: Number.MAX_VALUE,
      compile: function($element, $attr) {
        $attr.$set("class", ($attr["class"] || "") + " button icon button-icon", true);
        return function($scope, $element, $attr, ctrls) {
          var itemCtrl = ctrls[0];
          var listCtrl = ctrls[1];
          var container = jqLite(ITEM_TPL_DELETE_BUTTON);
          container.append($element);
          itemCtrl.$element.append(container).addClass("item-left-editable");
          if (listCtrl && listCtrl.showDelete()) {
            container.addClass("visible active");
          }
        };
      }
    };
  } ]);
  IonicModule.directive("itemFloatingLabel", function() {
    return {
      restrict: "C",
      link: function(scope, element) {
        var el = element[0];
        var input = el.querySelector("input, textarea");
        var inputLabel = el.querySelector(".input-label");
        if (!input || !inputLabel) return;
        var onInput = function() {
          if (input.value) {
            inputLabel.classList.add("has-input");
          } else {
            inputLabel.classList.remove("has-input");
          }
        };
        input.addEventListener("input", onInput);
        var ngModelCtrl = angular.element(input).controller("ngModel");
        if (ngModelCtrl) {
          ngModelCtrl.$render = function() {
            input.value = ngModelCtrl.$viewValue || "";
            onInput();
          };
        }
        scope.$on("$destroy", function() {
          input.removeEventListener("input", onInput);
        });
      }
    };
  });
  var ITEM_TPL_OPTION_BUTTONS = '<div class="item-options invisible">' + "</div>";
  IonicModule.directive("ionOptionButton", [ "$compile", function($compile) {
    function stopPropagation(e) {
      e.stopPropagation();
    }
    return {
      restrict: "E",
      require: "^ionItem",
      priority: Number.MAX_VALUE,
      compile: function($element, $attr) {
        $attr.$set("class", ($attr["class"] || "") + " button", true);
        return function($scope, $element, $attr, itemCtrl) {
          if (!itemCtrl.optionsContainer) {
            itemCtrl.optionsContainer = jqLite(ITEM_TPL_OPTION_BUTTONS);
            itemCtrl.$element.append(itemCtrl.optionsContainer);
          }
          itemCtrl.optionsContainer.append($element);
          $element.on("click", stopPropagation);
        };
      }
    };
  } ]);
  var ITEM_TPL_REORDER_BUTTON = '<div data-prevent-scroll="true" class="item-right-edit item-reorder enable-pointer-events">' + "</div>";
  IonicModule.directive("ionReorderButton", [ "$animate", "$parse", function($animate, $parse) {
    return {
      restrict: "E",
      require: [ "^ionItem", "^?ionList" ],
      priority: Number.MAX_VALUE,
      compile: function($element, $attr) {
        $attr.$set("class", ($attr["class"] || "") + " button icon button-icon", true);
        $element[0].setAttribute("data-prevent-scroll", true);
        return function($scope, $element, $attr, ctrls) {
          var itemCtrl = ctrls[0];
          var listCtrl = ctrls[1];
          var onReorderFn = $parse($attr.onReorder);
          $scope.$onReorder = function(oldIndex, newIndex) {
            onReorderFn($scope, {
              $fromIndex: oldIndex,
              $toIndex: newIndex
            });
          };
          if (!$attr.ngClick && !$attr.onClick && !$attr.onclick) {
            $element[0].onclick = function(e) {
              e.stopPropagation();
              return false;
            };
          }
          var container = jqLite(ITEM_TPL_REORDER_BUTTON);
          container.append($element);
          itemCtrl.$element.append(container).addClass("item-right-editable");
          if (listCtrl && listCtrl.showReorder()) {
            container.addClass("visible active");
          }
        };
      }
    };
  } ]);
  IonicModule.directive("keyboardAttach", function() {
    return function(scope, element, attrs) {
      ionic.on("native.keyboardshow", onShow, window);
      ionic.on("native.keyboardhide", onHide, window);
      ionic.on("native.showkeyboard", onShow, window);
      ionic.on("native.hidekeyboard", onHide, window);
      var scrollCtrl;
      function onShow(e) {
        if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
          return;
        }
        var keyboardHeight = e.keyboardHeight || e.detail.keyboardHeight;
        element.css("bottom", keyboardHeight + "px");
        scrollCtrl = element.controller("$ionicScroll");
        if (scrollCtrl) {
          scrollCtrl.scrollView.__container.style.bottom = keyboardHeight + keyboardAttachGetClientHeight(element[0]) + "px";
        }
      }
      function onHide() {
        if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
          return;
        }
        element.css("bottom", "");
        if (scrollCtrl) {
          scrollCtrl.scrollView.__container.style.bottom = "";
        }
      }
      scope.$on("$destroy", function() {
        ionic.off("native.keyboardshow", onShow, window);
        ionic.off("native.keyboardhide", onHide, window);
        ionic.off("native.showkeyboard", onShow, window);
        ionic.off("native.hidekeyboard", onHide, window);
      });
    };
  });
  function keyboardAttachGetClientHeight(element) {
    return element.clientHeight;
  }
  IonicModule.directive("ionList", [ "$animate", "$timeout", function($animate, $timeout) {
    return {
      restrict: "E",
      require: [ "ionList", "^?$ionicScroll" ],
      controller: "$ionicList",
      compile: function($element, $attr) {
        var listEl = jqLite('<div class="list">').append($element.contents()).addClass($attr.type);
        $element.append(listEl);
        return function($scope, $element, $attrs, ctrls) {
          var listCtrl = ctrls[0];
          var scrollCtrl = ctrls[1];
          $timeout(init);
          function init() {
            var listView = listCtrl.listView = new ionic.views.ListView({
              el: $element[0],
              listEl: $element.children()[0],
              scrollEl: scrollCtrl && scrollCtrl.element,
              scrollView: scrollCtrl && scrollCtrl.scrollView,
              onReorder: function(el, oldIndex, newIndex) {
                var itemScope = jqLite(el).scope();
                if (itemScope && itemScope.$onReorder) {
                  $timeout(function() {
                    itemScope.$onReorder(oldIndex, newIndex);
                  });
                }
              },
              canSwipe: function() {
                return listCtrl.canSwipeItems();
              }
            });
            if (isDefined($attr.canSwipe)) {
              $scope.$watch("!!(" + $attr.canSwipe + ")", function(value) {
                listCtrl.canSwipeItems(value);
              });
            }
            if (isDefined($attr.showDelete)) {
              $scope.$watch("!!(" + $attr.showDelete + ")", function(value) {
                listCtrl.showDelete(value);
              });
            }
            if (isDefined($attr.showReorder)) {
              $scope.$watch("!!(" + $attr.showReorder + ")", function(value) {
                listCtrl.showReorder(value);
              });
            }
            $scope.$watch(function() {
              return listCtrl.showDelete();
            }, function(isShown, wasShown) {
              if (!isShown && !wasShown) {
                return;
              }
              if (isShown) listCtrl.closeOptionButtons();
              listCtrl.canSwipeItems(!isShown);
              $element.children().toggleClass("list-left-editing", isShown);
              $element.toggleClass("disable-pointer-events", isShown);
              var deleteButton = jqLite($element[0].getElementsByClassName("item-delete"));
              setButtonShown(deleteButton, listCtrl.showDelete);
            });
            $scope.$watch(function() {
              return listCtrl.showReorder();
            }, function(isShown, wasShown) {
              if (!isShown && !wasShown) {
                return;
              }
              if (isShown) listCtrl.closeOptionButtons();
              listCtrl.canSwipeItems(!isShown);
              $element.children().toggleClass("list-right-editing", isShown);
              $element.toggleClass("disable-pointer-events", isShown);
              var reorderButton = jqLite($element[0].getElementsByClassName("item-reorder"));
              setButtonShown(reorderButton, listCtrl.showReorder);
            });
            function setButtonShown(el, shown) {
              shown() && el.addClass("visible") || el.removeClass("active");
              ionic.requestAnimationFrame(function() {
                shown() && el.addClass("active") || el.removeClass("visible");
              });
            }
          }
        };
      }
    };
  } ]);
  IonicModule.directive("menuClose", [ "$ionicViewService", function($ionicViewService) {
    return {
      restrict: "AC",
      require: "^ionSideMenus",
      link: function($scope, $element, $attr, sideMenuCtrl) {
        $element.bind("click", function() {
          sideMenuCtrl.close();
        });
      }
    };
  } ]);
  IonicModule.directive("menuToggle", [ "$ionicViewService", function($ionicViewService) {
    return {
      restrict: "AC",
      require: "^ionSideMenus",
      link: function($scope, $element, $attr, sideMenuCtrl) {
        var side = $attr.menuToggle || "left";
        $element.bind("click", function() {
          if (side === "left") {
            sideMenuCtrl.toggleLeft();
          } else if (side === "right") {
            sideMenuCtrl.toggleRight();
          }
        });
      }
    };
  } ]);
  IonicModule.directive("ionModal", [ function() {
    return {
      restrict: "E",
      transclude: true,
      replace: true,
      controller: [ function() {} ],
      template: '<div class="modal-backdrop">' + '<div class="modal-wrapper" ng-transclude></div>' + "</div>"
    };
  } ]);
  IonicModule.directive("ionModalView", function() {
    return {
      restrict: "E",
      compile: function(element, attr) {
        element.addClass("modal");
      }
    };
  });
  IonicModule.directive("ionNavBackButton", [ "$animate", "$rootScope", "$sanitize", "$ionicNavBarConfig", "$ionicNgClick", function($animate, $rootScope, $sanitize, $ionicNavBarConfig, $ionicNgClick) {
    var backIsShown = false;
    $rootScope.$on("$viewHistory.historyChange", function(e, data) {
      backIsShown = !!data.showBack;
    });
    return {
      restrict: "E",
      require: "^ionNavBar",
      compile: function(tElement, tAttrs) {
        tElement.addClass("button back-button ng-hide");
        var hasIconChild = !!(tElement.html() || "").match(/class=.*?ion-/);
        return function($scope, $element, $attr, navBarCtrl) {
          if (!hasIconChild && $element[0].className.indexOf("ion-") === -1) {
            $element.addClass($ionicNavBarConfig.backButtonIcon);
          }
          if (!isDefined($attr.ngClick)) {
            $ionicNgClick($scope, $element, navBarCtrl.back);
          }
          $scope.$watch(function() {
            if (isDefined($attr.fromTitle)) {
              $element[0].innerHTML = '<span class="back-button-title">' + $sanitize($scope.oldTitle) + "</span>";
            }
            return !!(backIsShown && $scope.backButtonShown);
          }, ionic.animationFrameThrottle(function(show) {
            if (show) $animate.removeClass($element, "ng-hide"); else $animate.addClass($element, "ng-hide");
          }));
        };
      }
    };
  } ]);
  IonicModule.constant("$ionicNavBarConfig", {
    transition: "nav-title-slide-ios7",
    alignTitle: "center",
    backButtonIcon: "ion-ios7-arrow-back"
  });
  IonicModule.directive("ionNavBar", [ "$ionicViewService", "$rootScope", "$animate", "$compile", "$ionicNavBarConfig", function($ionicViewService, $rootScope, $animate, $compile, $ionicNavBarConfig) {
    return {
      restrict: "E",
      controller: "$ionicNavBar",
      scope: true,
      compile: function(tElement, tAttrs) {
        tElement.addClass("bar bar-header nav-bar").append('<div class="buttons left-buttons"> ' + "</div>" + '<h1 ng-bind-html="title" class="title"></h1>' + '<div class="buttons right-buttons"> ' + "</div>");
        if (isDefined(tAttrs.animation)) {
          tElement.addClass(tAttrs.animation);
        } else {
          tElement.addClass($ionicNavBarConfig.transition);
        }
        return {
          pre: prelink
        };
        function prelink($scope, $element, $attr, navBarCtrl) {
          navBarCtrl._headerBarView = new ionic.views.HeaderBar({
            el: $element[0],
            alignTitle: $attr.alignTitle || $ionicNavBarConfig.alignTitle || "center"
          });
          $scope.backButtonShown = false;
          $scope.shouldAnimate = true;
          $scope.isReverse = false;
          $scope.isInvisible = true;
          $scope.$on("$destroy", function() {
            $scope.$parent.$hasHeader = false;
          });
          $scope.$watch(function() {
            return ($scope.isReverse ? " reverse" : "") + ($scope.isInvisible ? " invisible" : "") + (!$scope.shouldAnimate ? " no-animation" : "");
          }, function(className, oldClassName) {
            $element.removeClass(oldClassName);
            $element.addClass(className);
          });
        }
      }
    };
  } ]);
  IonicModule.directive("ionNavButtons", [ "$compile", "$animate", function($compile, $animate) {
    return {
      require: "^ionNavBar",
      restrict: "E",
      compile: function($element, $attrs) {
        var content = $element.contents().remove();
        return function($scope, $element, $attrs, navBarCtrl) {
          var navElement = $attrs.side === "right" ? navBarCtrl.rightButtonsElement : navBarCtrl.leftButtonsElement;
          var buttons = jqLite("<span>").append(content);
          $element.append(buttons);
          $compile(buttons)($scope);
          ionic.requestAnimationFrame(function() {
            if (!$scope.$$destroyed) {
              $animate.enter(buttons, navElement);
            }
          });
          $scope.$on("$destroy", function() {
            $animate.leave(buttons);
          });
          $element.css("display", "none");
        };
      }
    };
  } ]);
  IonicModule.directive("navClear", [ "$ionicViewService", "$state", "$location", "$window", "$rootScope", function($ionicViewService, $location, $state, $window, $rootScope) {
    $rootScope.$on("$stateChangeError", function() {
      $ionicViewService.nextViewOptions(null);
    });
    return {
      priority: 100,
      restrict: "AC",
      compile: function($element) {
        return {
          pre: prelink
        };
        function prelink($scope, $element, $attrs) {
          var unregisterListener;
          function listenForStateChange() {
            unregisterListener = $scope.$on("$stateChangeStart", function() {
              $ionicViewService.nextViewOptions({
                disableAnimate: true,
                disableBack: true
              });
              unregisterListener();
            });
            $window.setTimeout(unregisterListener, 300);
          }
          $element.on("click", listenForStateChange);
        }
      }
    };
  } ]);
  IonicModule.constant("$ionicNavViewConfig", {
    transition: "slide-left-right-ios7"
  });
  IonicModule.directive("ionNavView", [ "$ionicViewService", "$state", "$compile", "$controller", "$animate", function($ionicViewService, $state, $compile, $controller, $animate) {
    var viewIsUpdating = false;
    var directive = {
      restrict: "E",
      terminal: true,
      priority: 2e3,
      transclude: true,
      controller: function() {},
      compile: function(element, attr, transclude) {
        return function(scope, element, attr, navViewCtrl) {
          var viewScope, viewLocals, name = attr[directive.name] || attr.name || "", onloadExp = attr.onload || "", initialView = transclude(scope);
          element.append(initialView);
          var parent = element.parent().inheritedData("$uiView");
          if (name.indexOf("@") < 0) name = name + "@" + (parent && parent.state ? parent.state.name : "");
          var view = {
            name: name,
            state: null
          };
          element.data("$uiView", view);
          var eventHook = function() {
            if (viewIsUpdating) return;
            viewIsUpdating = true;
            try {
              updateView(true);
            } catch (e) {
              viewIsUpdating = false;
              throw e;
            }
            viewIsUpdating = false;
          };
          scope.$on("$stateChangeSuccess", eventHook);
          updateView(false);
          function updateView(doAnimate) {
            if ($animate.enabled() === false) {
              doAnimate = false;
            }
            var locals = $state.$current && $state.$current.locals[name];
            if (locals === viewLocals) return;
            var renderer = $ionicViewService.getRenderer(element, attr, scope);
            if (viewScope) {
              viewScope.$destroy();
              viewScope = null;
            }
            if (!locals) {
              viewLocals = null;
              view.state = null;
              return element.append(initialView);
            }
            var newElement = jqLite("<div></div>").html(locals.$template).contents();
            var viewRegisterData = renderer().register(newElement);
            renderer(doAnimate).leave();
            viewLocals = locals;
            view.state = locals.$$state;
            renderer(doAnimate).enter(newElement);
            var link = $compile(newElement);
            viewScope = scope.$new();
            viewScope.$navDirection = viewRegisterData.navDirection;
            if (locals.$$controller) {
              locals.$scope = viewScope;
              var controller = $controller(locals.$$controller, locals);
              element.children().data("$ngControllerController", controller);
            }
            link(viewScope);
            var viewHistoryData = $ionicViewService._getViewById(viewRegisterData.viewId) || {};
            viewScope.$broadcast("$viewContentLoaded", viewHistoryData);
            if (onloadExp) viewScope.$eval(onloadExp);
            newElement = null;
          }
        };
      }
    };
    return directive;
  } ]);
  IonicModule.config([ "$provide", function($provide) {
    $provide.decorator("ngClickDirective", [ "$delegate", function($delegate) {
      $delegate.shift();
      return $delegate;
    } ]);
  } ]).factory("$ionicNgClick", [ "$parse", function($parse) {
    return function(scope, element, clickExpr) {
      var clickHandler = angular.isFunction(clickExpr) ? clickExpr : $parse(clickExpr);
      element.on("click", function(event) {
        scope.$apply(function() {
          clickHandler(scope, {
            $event: event
          });
        });
      });
      element.onclick = function(event) {};
    };
  } ]).directive("ngClick", [ "$ionicNgClick", function($ionicNgClick) {
    return function(scope, element, attr) {
      $ionicNgClick(scope, element, attr.ngClick);
    };
  } ]).directive("ionStopEvent", function() {
    return {
      restrict: "A",
      link: function(scope, element, attr) {
        element.bind(attr.ionStopEvent, eventStopPropagation);
      }
    };
  });
  function eventStopPropagation(e) {
    e.stopPropagation();
  }
  IonicModule.directive("ionPane", function() {
    return {
      restrict: "E",
      link: function(scope, element, attr) {
        element.addClass("pane");
      }
    };
  });
  IonicModule.directive("ionPopover", [ function() {
    return {
      restrict: "E",
      transclude: true,
      replace: true,
      controller: [ function() {} ],
      template: '<div class="popover-backdrop">' + '<div class="popover-wrapper" ng-transclude></div>' + "</div>"
    };
  } ]);
  IonicModule.directive("ionPopoverView", function() {
    return {
      restrict: "E",
      compile: function(element) {
        element.append(angular.element('<div class="popover-arrow"></div>'));
        element.addClass("popover");
      }
    };
  });
  IonicModule.directive("ionRadio", function() {
    return {
      restrict: "E",
      replace: true,
      require: "?ngModel",
      transclude: true,
      template: '<label class="item item-radio">' + '<input type="radio" name="radio-group">' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '<i class="radio-icon disable-pointer-events icon ion-checkmark"></i>' + "</label>",
      compile: function(element, attr) {
        if (attr.icon) element.children().eq(2).removeClass("ion-checkmark").addClass(attr.icon);
        var input = element.find("input");
        forEach({
          name: attr.name,
          value: attr.value,
          disabled: attr.disabled,
          "ng-value": attr.ngValue,
          "ng-model": attr.ngModel,
          "ng-disabled": attr.ngDisabled,
          "ng-change": attr.ngChange
        }, function(value, name) {
          if (isDefined(value)) {
            input.attr(name, value);
          }
        });
        return function(scope, element, attr) {
          scope.getValue = function() {
            return scope.ngValue || attr.value;
          };
        };
      }
    };
  });
  IonicModule.directive("ionRefresher", [ "$ionicBind", function($ionicBind) {
    return {
      restrict: "E",
      replace: true,
      require: "^$ionicScroll",
      template: '<div class="scroll-refresher" collection-repeat-ignore>' + '<div class="ionic-refresher-content" ' + "ng-class=\"{'ionic-refresher-with-text': pullingText || refreshingText}\">" + '<div class="icon-pulling" ng-class="{\'pulling-rotation-disabled\':disablePullingRotation}">' + '<i class="icon {{pullingIcon}}"></i>' + "</div>" + '<div class="text-pulling" ng-bind-html="pullingText"></div>' + '<i class="icon {{refreshingIcon}} icon-refreshing"></i>' + '<div class="text-refreshing" ng-bind-html="refreshingText"></div>' + "</div>" + "</div>",
      compile: function($element, $attrs) {
        if (angular.isUndefined($attrs.pullingIcon)) {
          $attrs.$set("pullingIcon", "ion-ios7-arrow-down");
        }
        if (angular.isUndefined($attrs.refreshingIcon)) {
          $attrs.$set("refreshingIcon", "ion-loading-d");
        }
        return function($scope, $element, $attrs, scrollCtrl) {
          $ionicBind($scope, $attrs, {
            pullingIcon: "@",
            pullingText: "@",
            refreshingIcon: "@",
            refreshingText: "@",
            disablePullingRotation: "@",
            $onRefresh: "&onRefresh",
            $onPulling: "&onPulling"
          });
          scrollCtrl._setRefresher($scope, $element[0]);
          $scope.$on("scroll.refreshComplete", function() {
            $scope.$evalAsync(function() {
              scrollCtrl.scrollView.finishPullToRefresh();
            });
          });
        };
      }
    };
  } ]);
  IonicModule.directive("ionScroll", [ "$timeout", "$controller", "$ionicBind", function($timeout, $controller, $ionicBind) {
    return {
      restrict: "E",
      scope: true,
      controller: function() {},
      compile: function(element, attr) {
        element.addClass("scroll-view ionic-scroll");
        var innerElement = jqLite('<div class="scroll"></div>');
        innerElement.append(element.contents());
        element.append(innerElement);
        return {
          pre: prelink
        };
        function prelink($scope, $element, $attr) {
          var scrollView, scrollCtrl;
          $ionicBind($scope, $attr, {
            direction: "@",
            paging: "@",
            $onScroll: "&onScroll",
            scroll: "@",
            scrollbarX: "@",
            scrollbarY: "@",
            zooming: "@",
            minZoom: "@",
            maxZoom: "@"
          });
          $scope.direction = $scope.direction || "y";
          if (angular.isDefined($attr.padding)) {
            $scope.$watch($attr.padding, function(newVal) {
              innerElement.toggleClass("padding", !!newVal);
            });
          }
          if ($scope.$eval($scope.paging) === true) {
            innerElement.addClass("scroll-paging");
          }
          if (!$scope.direction) {
            $scope.direction = "y";
          }
          var isPaging = $scope.$eval($scope.paging) === true;
          var scrollViewOptions = {
            el: $element[0],
            delegateHandle: $attr.delegateHandle,
            locking: ($attr.locking || "true") === "true",
            bouncing: $scope.$eval($attr.hasBouncing),
            paging: isPaging,
            scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
            scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
            scrollingX: $scope.direction.indexOf("x") >= 0,
            scrollingY: $scope.direction.indexOf("y") >= 0,
            zooming: $scope.$eval($scope.zooming) === true,
            maxZoom: $scope.$eval($scope.maxZoom) || 3,
            minZoom: $scope.$eval($scope.minZoom) || .5
          };
          if (isPaging) {
            scrollViewOptions.speedMultiplier = .8;
            scrollViewOptions.bouncing = false;
          }
          scrollCtrl = $controller("$ionicScroll", {
            $scope: $scope,
            scrollViewOptions: scrollViewOptions
          });
          scrollView = $scope.$parent.scrollView = scrollCtrl.scrollView;
        }
      }
    };
  } ]);
  IonicModule.directive("ionSideMenu", function() {
    return {
      restrict: "E",
      require: "^ionSideMenus",
      scope: true,
      compile: function(element, attr) {
        angular.isUndefined(attr.isEnabled) && attr.$set("isEnabled", "true");
        angular.isUndefined(attr.width) && attr.$set("width", "275");
        element.addClass("menu menu-" + attr.side);
        return function($scope, $element, $attr, sideMenuCtrl) {
          $scope.side = $attr.side || "left";
          var sideMenu = sideMenuCtrl[$scope.side] = new ionic.views.SideMenu({
            width: attr.width,
            el: $element[0],
            isEnabled: true
          });
          $scope.$watch($attr.width, function(val) {
            var numberVal = +val;
            if (numberVal && numberVal == val) {
              sideMenu.setWidth(+val);
            }
          });
          $scope.$watch($attr.isEnabled, function(val) {
            sideMenu.setIsEnabled(!!val);
          });
        };
      }
    };
  });
  IonicModule.directive("ionSideMenuContent", [ "$timeout", "$ionicGesture", "$window", function($timeout, $ionicGesture, $window) {
    return {
      restrict: "EA",
      require: "^ionSideMenus",
      scope: true,
      compile: function(element, attr) {
        return {
          pre: prelink
        };
        function prelink($scope, $element, $attr, sideMenuCtrl) {
          var startCoord = null;
          var primaryScrollAxis = null;
          $element.addClass("menu-content pane");
          if (isDefined(attr.dragContent)) {
            $scope.$watch(attr.dragContent, function(value) {
              sideMenuCtrl.canDragContent(value);
            });
          } else {
            sideMenuCtrl.canDragContent(true);
          }
          if (isDefined(attr.edgeDragThreshold)) {
            $scope.$watch(attr.edgeDragThreshold, function(value) {
              sideMenuCtrl.edgeDragThreshold(value);
            });
          }
          function onContentTap(gestureEvt) {
            if (sideMenuCtrl.getOpenAmount() !== 0) {
              sideMenuCtrl.close();
              gestureEvt.gesture.srcEvent.preventDefault();
              startCoord = null;
              primaryScrollAxis = null;
            } else if (!startCoord) {
              startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
            }
          }
          function onDragX(e) {
            if (!sideMenuCtrl.isDraggableTarget(e)) return;
            if (getPrimaryScrollAxis(e) == "x") {
              sideMenuCtrl._handleDrag(e);
              e.gesture.srcEvent.preventDefault();
            }
          }
          function onDragY(e) {
            if (getPrimaryScrollAxis(e) == "x") {
              e.gesture.srcEvent.preventDefault();
            }
          }
          function onDragRelease(e) {
            sideMenuCtrl._endDrag(e);
            startCoord = null;
            primaryScrollAxis = null;
          }
          function getPrimaryScrollAxis(gestureEvt) {
            if (primaryScrollAxis) {
              return primaryScrollAxis;
            }
            if (gestureEvt && gestureEvt.gesture) {
              if (!startCoord) {
                startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
              } else {
                var endCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                var xDistance = Math.abs(endCoord.x - startCoord.x);
                var yDistance = Math.abs(endCoord.y - startCoord.y);
                var scrollAxis = xDistance < yDistance ? "y" : "x";
                if (Math.max(xDistance, yDistance) > 30) {
                  primaryScrollAxis = scrollAxis;
                }
                return scrollAxis;
              }
            }
            return "x";
          }
          var content = {
            element: element[0],
            onDrag: function(e) {},
            endDrag: function(e) {},
            getTranslateX: function() {
              return $scope.sideMenuContentTranslateX || 0;
            },
            setTranslateX: ionic.animationFrameThrottle(function(amount) {
              var xTransform = content.offsetX + amount;
              $element[0].style[ionic.CSS.TRANSFORM] = "translate3d(" + xTransform + "px,0,0)";
              $timeout(function() {
                $scope.sideMenuContentTranslateX = amount;
              });
            }),
            setMarginLeft: ionic.animationFrameThrottle(function(amount) {
              if (amount) {
                amount = parseInt(amount, 10);
                $element[0].style[ionic.CSS.TRANSFORM] = "translate3d(" + amount + "px,0,0)";
                $element[0].style.width = $window.innerWidth - amount + "px";
                content.offsetX = amount;
              } else {
                $element[0].style[ionic.CSS.TRANSFORM] = "translate3d(0,0,0)";
                $element[0].style.width = "";
                content.offsetX = 0;
              }
            }),
            enableAnimation: function() {
              $scope.animationEnabled = true;
              $element[0].classList.add("menu-animated");
            },
            disableAnimation: function() {
              $scope.animationEnabled = false;
              $element[0].classList.remove("menu-animated");
            },
            offsetX: 0
          };
          sideMenuCtrl.setContent(content);
          var gestureOpts = {
            stop_browser_behavior: false
          };
          var contentTapGesture = $ionicGesture.on("tap", onContentTap, $element, gestureOpts);
          var dragRightGesture = $ionicGesture.on("dragright", onDragX, $element, gestureOpts);
          var dragLeftGesture = $ionicGesture.on("dragleft", onDragX, $element, gestureOpts);
          var dragUpGesture = $ionicGesture.on("dragup", onDragY, $element, gestureOpts);
          var dragDownGesture = $ionicGesture.on("dragdown", onDragY, $element, gestureOpts);
          var releaseGesture = $ionicGesture.on("release", onDragRelease, $element, gestureOpts);
          $scope.$on("$destroy", function() {
            $ionicGesture.off(dragLeftGesture, "dragleft", onDragX);
            $ionicGesture.off(dragRightGesture, "dragright", onDragX);
            $ionicGesture.off(dragUpGesture, "dragup", onDragY);
            $ionicGesture.off(dragDownGesture, "dragdown", onDragY);
            $ionicGesture.off(releaseGesture, "release", onDragRelease);
            $ionicGesture.off(contentTapGesture, "tap", onContentTap);
          });
        }
      }
    };
  } ]);
  IonicModule.directive("ionSideMenus", [ "$ionicBody", function($ionicBody) {
    return {
      restrict: "ECA",
      controller: "$ionicSideMenus",
      compile: function(element, attr) {
        attr.$set("class", (attr["class"] || "") + " view");
        return {
          pre: prelink
        };
        function prelink($scope) {
          $scope.$on("$ionicExposeAside", function(evt, isAsideExposed) {
            if (!$scope.$exposeAside) $scope.$exposeAside = {};
            $scope.$exposeAside.active = isAsideExposed;
            $ionicBody.enableClass(isAsideExposed, "aside-open");
          });
          $scope.$on("$destroy", function() {
            $ionicBody.removeClass("menu-open", "aside-open");
          });
        }
      }
    };
  } ]);
  IonicModule.directive("ionSlideBox", [ "$timeout", "$compile", "$ionicSlideBoxDelegate", function($timeout, $compile, $ionicSlideBoxDelegate) {
    return {
      restrict: "E",
      replace: true,
      transclude: true,
      scope: {
        autoPlay: "=",
        doesContinue: "@",
        slideInterval: "@",
        showPager: "@",
        pagerClick: "&",
        disableScroll: "@",
        onSlideChanged: "&",
        activeSlide: "=?"
      },
      controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
        var _this = this;
        var continuous = $scope.$eval($scope.doesContinue) === true;
        var shouldAutoPlay = isDefined($attrs.autoPlay) ? !!$scope.autoPlay : false;
        var slideInterval = shouldAutoPlay ? $scope.$eval($scope.slideInterval) || 4e3 : 0;
        var slider = new ionic.views.Slider({
          el: $element[0],
          auto: slideInterval,
          continuous: continuous,
          startSlide: $scope.activeSlide,
          slidesChanged: function() {
            $scope.currentSlide = slider.currentIndex();
            $timeout(function() {});
          },
          callback: function(slideIndex) {
            $scope.currentSlide = slideIndex;
            $scope.onSlideChanged({
              index: $scope.currentSlide,
              $index: $scope.currentSlide
            });
            $scope.$parent.$broadcast("slideBox.slideChanged", slideIndex);
            $scope.activeSlide = slideIndex;
            $timeout(function() {});
          }
        });
        slider.enableSlide($scope.$eval($attrs.disableScroll) !== true);
        $scope.$watch("activeSlide", function(nv) {
          if (angular.isDefined(nv)) {
            slider.slide(nv);
          }
        });
        $scope.$on("slideBox.nextSlide", function() {
          slider.next();
        });
        $scope.$on("slideBox.prevSlide", function() {
          slider.prev();
        });
        $scope.$on("slideBox.setSlide", function(e, index) {
          slider.slide(index);
        });
        this.__slider = slider;
        var deregisterInstance = $ionicSlideBoxDelegate._registerInstance(slider, $attrs.delegateHandle);
        $scope.$on("$destroy", deregisterInstance);
        this.slidesCount = function() {
          return slider.slidesCount();
        };
        this.onPagerClick = function(index) {
          void 0;
          $scope.pagerClick({
            index: index
          });
        };
        $timeout(function() {
          slider.load();
        });
      } ],
      template: '<div class="slider">' + '<div class="slider-slides" ng-transclude>' + "</div>" + "</div>",
      link: function($scope, $element, $attr, slideBoxCtrl) {
        if ($scope.$eval($scope.showPager) !== false) {
          var childScope = $scope.$new();
          var pager = jqLite("<ion-pager></ion-pager>");
          $element.append(pager);
          $compile(pager)(childScope);
        }
      }
    };
  } ]).directive("ionSlide", function() {
    return {
      restrict: "E",
      require: "^ionSlideBox",
      compile: function(element, attr) {
        element.addClass("slider-slide");
        return function($scope, $element, $attr) {};
      }
    };
  }).directive("ionPager", function() {
    return {
      restrict: "E",
      replace: true,
      require: "^ionSlideBox",
      template: '<div class="slider-pager"><span class="slider-pager-page" ng-repeat="slide in numSlides() track by $index" ng-class="{active: $index == currentSlide}" ng-click="pagerClick($index)"><i class="icon ion-record"></i></span></div>',
      link: function($scope, $element, $attr, slideBox) {
        var selectPage = function(index) {
          var children = $element[0].children;
          var length = children.length;
          for (var i = 0; i < length; i++) {
            if (i == index) {
              children[i].classList.add("active");
            } else {
              children[i].classList.remove("active");
            }
          }
        };
        $scope.pagerClick = function(index) {
          slideBox.onPagerClick(index);
        };
        $scope.numSlides = function() {
          return new Array(slideBox.slidesCount());
        };
        $scope.$watch("currentSlide", function(v) {
          selectPage(v);
        });
      }
    };
  });
  IonicModule.constant("$ionicTabConfig", {
    type: ""
  });
  IonicModule.directive("ionTab", [ "$rootScope", "$animate", "$ionicBind", "$compile", function($rootScope, $animate, $ionicBind, $compile) {
    function attrStr(k, v) {
      return angular.isDefined(v) ? " " + k + '="' + v + '"' : "";
    }
    return {
      restrict: "E",
      require: [ "^ionTabs", "ionTab" ],
      replace: true,
      controller: "$ionicTab",
      scope: true,
      compile: function(element, attr) {
        var tabNavTemplate = "<ion-tab-nav" + attrStr("ng-click", attr.ngClick) + attrStr("title", attr.title) + attrStr("icon", attr.icon) + attrStr("icon-on", attr.iconOn) + attrStr("icon-off", attr.iconOff) + attrStr("badge", attr.badge) + attrStr("badge-style", attr.badgeStyle) + attrStr("hidden", attr.hidden) + attrStr("class", attr["class"]) + "></ion-tab-nav>";
        var tabContent = jqLite('<div class="pane">').append(element.contents().remove());
        return function link($scope, $element, $attr, ctrls) {
          var childScope;
          var childElement;
          var tabsCtrl = ctrls[0];
          var tabCtrl = ctrls[1];
          var navView = tabContent[0].querySelector("ion-nav-view") || tabContent[0].querySelector("data-ion-nav-view");
          var navViewName = navView && navView.getAttribute("name");
          $ionicBind($scope, $attr, {
            animate: "=",
            onSelect: "&",
            onDeselect: "&",
            title: "@",
            uiSref: "@",
            href: "@"
          });
          tabsCtrl.add($scope);
          $scope.$on("$destroy", function() {
            if (!$scope.$tabsDestroy) {
              tabsCtrl.remove($scope);
            }
            tabNavElement.isolateScope().$destroy();
            tabNavElement.remove();
          });
          $element[0].removeAttribute("title");
          if (navViewName) {
            tabCtrl.navViewName = $scope.navViewName = navViewName;
          }
          $scope.$on("$stateChangeSuccess", selectIfMatchesState);
          selectIfMatchesState();
          function selectIfMatchesState() {
            if (tabCtrl.tabMatchesState()) {
              tabsCtrl.select($scope, false);
            }
          }
          var tabNavElement = jqLite(tabNavTemplate);
          tabNavElement.data("$ionTabsController", tabsCtrl);
          tabNavElement.data("$ionTabController", tabCtrl);
          tabsCtrl.$tabsElement.append($compile(tabNavElement)($scope));
          $scope.$watch("$tabSelected", function(value) {
            childScope && childScope.$destroy();
            childScope = null;
            childElement && $animate.leave(childElement);
            childElement = null;
            if (value) {
              childScope = $scope.$new();
              childElement = tabContent.clone();
              $animate.enter(childElement, tabsCtrl.$element);
              $compile(childElement)(childScope);
            }
          });
        };
      }
    };
  } ]);
  IonicModule.directive("ionTabNav", [ function() {
    return {
      restrict: "E",
      replace: true,
      require: [ "^ionTabs", "^ionTab" ],
      template: "<a ng-class=\"{'tab-item-active': isTabActive(), 'has-badge':badge, 'tab-hidden':isHidden()}\" " + ' class="tab-item">' + '<span class="badge {{badgeStyle}}" ng-if="badge">{{badge}}</span>' + '<i class="icon {{getIconOn()}}" ng-if="getIconOn() && isTabActive()"></i>' + '<i class="icon {{getIconOff()}}" ng-if="getIconOff() && !isTabActive()"></i>' + '<span class="tab-title" ng-bind-html="title"></span>' + "</a>",
      scope: {
        title: "@",
        icon: "@",
        iconOn: "@",
        iconOff: "@",
        badge: "=",
        hidden: "@",
        badgeStyle: "@",
        "class": "@"
      },
      compile: function(element, attr, transclude) {
        return function link($scope, $element, $attrs, ctrls) {
          var tabsCtrl = ctrls[0], tabCtrl = ctrls[1];
          $element[0].removeAttribute("title");
          $scope.selectTab = function(e) {
            e.preventDefault();
            tabsCtrl.select(tabCtrl.$scope, true);
          };
          if (!$attrs.ngClick) {
            $element.on("click", function(event) {
              $scope.$apply(function() {
                $scope.selectTab(event);
              });
            });
          }
          $scope.isHidden = function() {
            if ($attrs.hidden === "true" || $attrs.hidden === true) return true;
            return false;
          };
          $scope.getIconOn = function() {
            return $scope.iconOn || $scope.icon;
          };
          $scope.getIconOff = function() {
            return $scope.iconOff || $scope.icon;
          };
          $scope.isTabActive = function() {
            return tabsCtrl.selectedTab() === tabCtrl.$scope;
          };
        };
      }
    };
  } ]);
  IonicModule.constant("$ionicTabsConfig", {
    position: "",
    type: ""
  });
  IonicModule.directive("ionTabs", [ "$ionicViewService", "$ionicTabsDelegate", "$ionicTabsConfig", function($ionicViewService, $ionicTabsDelegate, $ionicTabsConfig) {
    return {
      restrict: "E",
      scope: true,
      controller: "$ionicTabs",
      compile: function(element, attr) {
        element.addClass("view");
        var innerElement = jqLite('<div class="tabs"></div>');
        innerElement.append(element.contents());
        element.append(innerElement);
        element.addClass($ionicTabsConfig.position);
        element.addClass($ionicTabsConfig.type);
        return {
          pre: prelink
        };
        function prelink($scope, $element, $attr, tabsCtrl) {
          var deregisterInstance = $ionicTabsDelegate._registerInstance(tabsCtrl, $attr.delegateHandle);
          $scope.$on("$destroy", function() {
            $scope.$tabsDestroy = true;
            deregisterInstance();
          });
          tabsCtrl.$scope = $scope;
          tabsCtrl.$element = $element;
          tabsCtrl.$tabsElement = jqLite($element[0].querySelector(".tabs"));
          var el = $element[0];
          $scope.$watch(function() {
            return el.className;
          }, function(value) {
            var isTabsTop = value.indexOf("tabs-top") !== -1;
            var isHidden = value.indexOf("tabs-item-hide") !== -1;
            $scope.$hasTabs = !isTabsTop && !isHidden;
            $scope.$hasTabsTop = isTabsTop && !isHidden;
          });
          $scope.$on("$destroy", function() {
            delete $scope.$hasTabs;
            delete $scope.$hasTabsTop;
          });
        }
      }
    };
  } ]);
  IonicModule.directive("ionToggle", [ "$ionicGesture", "$timeout", function($ionicGesture, $timeout) {
    return {
      restrict: "E",
      replace: true,
      require: "?ngModel",
      transclude: true,
      template: '<div class="item item-toggle">' + "<div ng-transclude></div>" + '<label class="toggle">' + '<input type="checkbox">' + '<div class="track">' + '<div class="handle"></div>' + "</div>" + "</label>" + "</div>",
      compile: function(element, attr) {
        var input = element.find("input");
        forEach({
          name: attr.name,
          "ng-value": attr.ngValue,
          "ng-model": attr.ngModel,
          "ng-checked": attr.ngChecked,
          "ng-disabled": attr.ngDisabled,
          "ng-true-value": attr.ngTrueValue,
          "ng-false-value": attr.ngFalseValue,
          "ng-change": attr.ngChange
        }, function(value, name) {
          if (isDefined(value)) {
            input.attr(name, value);
          }
        });
        if (attr.toggleClass) {
          element[0].getElementsByTagName("label")[0].classList.add(attr.toggleClass);
        }
        return function($scope, $element, $attr) {
          var el, checkbox, track, handle;
          el = $element[0].getElementsByTagName("label")[0];
          checkbox = el.children[0];
          track = el.children[1];
          handle = track.children[0];
          var ngModelController = jqLite(checkbox).controller("ngModel");
          $scope.toggle = new ionic.views.Toggle({
            el: el,
            track: track,
            checkbox: checkbox,
            handle: handle,
            onChange: function() {
              if (checkbox.checked) {
                ngModelController.$setViewValue(true);
              } else {
                ngModelController.$setViewValue(false);
              }
              $scope.$apply();
            }
          });
          $scope.$on("$destroy", function() {
            $scope.toggle.destroy();
          });
        };
      }
    };
  } ]);
  IonicModule.directive("ionView", [ "$ionicViewService", "$rootScope", "$animate", function($ionicViewService, $rootScope, $animate) {
    return {
      restrict: "EA",
      priority: 1e3,
      require: [ "^?ionNavBar", "^?ionModal" ],
      compile: function(tElement, tAttrs, transclude) {
        tElement.addClass("pane");
        tElement[0].removeAttribute("title");
        return function link($scope, $element, $attr, ctrls) {
          var navBarCtrl = ctrls[0];
          var modalCtrl = ctrls[1];
          if (!navBarCtrl || modalCtrl) {
            return;
          }
          if (angular.isDefined($attr.title)) {
            var initialTitle = $attr.title;
            navBarCtrl.changeTitle(initialTitle, $scope.$navDirection);
            $attr.$observe("title", function(val, oldVal) {
              navBarCtrl.setTitle(val);
            });
          }
          var hideBackAttr = angular.isDefined($attr.hideBackButton) ? $attr.hideBackButton : "false";
          $scope.$watch(hideBackAttr, function(value) {
            navBarCtrl.showBackButton(!value);
          });
          var hideNavAttr = angular.isDefined($attr.hideNavBar) ? $attr.hideNavBar : "false";
          $scope.$watch(hideNavAttr, function(value) {
            navBarCtrl.showBar(!value);
          });
        };
      }
    };
  } ]);
})();
(function() {
  angular.module("auth0", [ "auth0.service", "auth0.utils" ]).run([ "auth", function(auth) {
    auth.hookEvents();
  } ]);
  angular.module("auth0.utils", []).provider("authUtils", function() {
    var Utils = {
      capitalize: function(string) {
        return string ? string.charAt(0).toUpperCase() + string.substring(1).toLowerCase() : null;
      }
    };
    angular.extend(this, Utils);
    this.$get = [ "$rootScope", "$q", function($rootScope, $q) {
      var authUtils = {};
      angular.extend(authUtils, Utils);
      authUtils.safeApply = function(fn) {
        var phase = $rootScope.$root.$$phase;
        if (phase === "$apply" || phase === "$digest") {
          if (fn && typeof fn === "function") {
            fn();
          }
        } else {
          $rootScope.$apply(fn);
        }
      };
      authUtils.callbackify = function(nodeback, success, error, self) {
        if (angular.isFunction(nodeback)) {
          return function(args) {
            args = Array.prototype.slice.call(arguments);
            var callback = function(err, response, etc) {
              if (err) {
                error && error(err);
                return;
              }
              etc = Array.prototype.slice.call(arguments, 1);
              success && success.apply(null, etc);
            };
            if (success || error) {
              args.push(authUtils.applied(callback));
            }
            nodeback.apply(self, args);
          };
        }
      };
      authUtils.promisify = function(nodeback, self) {
        if (angular.isFunction(nodeback)) {
          return function(args) {
            args = Array.prototype.slice.call(arguments);
            var dfd = $q.defer();
            var callback = function(err, response, etc) {
              if (err) {
                dfd.reject(err);
                return;
              }
              etc = Array.prototype.slice.call(arguments, 1);
              dfd.resolve(etc.length > 1 ? etc : response);
            };
            args.push(authUtils.applied(callback));
            nodeback.apply(self, args);
            dfd.promise.spread = dfd.promise.spread || function(fulfilled, rejected) {
              return dfd.promise.then(function(array) {
                return Array.isArray(array) ? fulfilled.apply(null, array) : fulfilled(array);
              }, rejected);
            };
            return dfd.promise;
          };
        }
      };
      authUtils.applied = function(fn) {
        return function(err, response) {
          err = err;
          response = response;
          var argsCall = arguments;
          authUtils.safeApply(function() {
            fn.apply(null, argsCall);
          });
        };
      };
      return authUtils;
    } ];
  });
  angular.module("auth0.service", [ "auth0.utils" ]).provider("auth", [ "authUtilsProvider", function(authUtilsProvider) {
    var defaultOptions = {
      callbackOnLocationHash: true
    };
    var config = this;
    var innerAuth0libraryConfiguration = {
      Auth0: {
        signin: "login",
        signup: "signup",
        reset: "changePassword",
        library: function() {
          return config.auth0js;
        },
        parseOptions: function(options) {
          var retOptions = angular.copy(options);
          if (retOptions.authParams) {
            angular.extend(retOptions, retOptions.authParams);
            delete retOptions.authParams;
          }
          return retOptions;
        }
      },
      Auth0Lock: {
        signin: "showSignin",
        signup: "showSignup",
        reset: "showReset",
        library: function() {
          return config.auth0lib;
        },
        parseOptions: function(options) {
          return angular.copy(options);
        }
      }
    };
    function getInnerLibraryMethod(name, libName) {
      libName = libName || config.lib;
      var library = innerAuth0libraryConfiguration[libName].library();
      return library[innerAuth0libraryConfiguration[libName][name]];
    }
    function getInnerLibraryConfigField(name, libName) {
      libName = libName || config.lib;
      return innerAuth0libraryConfiguration[libName][name];
    }
    this.init = function(options, Auth0Constructor) {
      if (!options) {
        throw new Error("You must set options when calling init");
      }
      this.loginUrl = options.loginUrl;
      this.loginState = options.loginState;
      this.clientID = options.clientID || options.clientId;
      var domain = options.domain;
      this.sso = options.sso;
      var Constructor = Auth0Constructor;
      if (!Constructor && typeof Auth0Lock !== "undefined") {
        Constructor = Auth0Lock;
      }
      if (!Constructor && typeof Auth0 !== "undefined") {
        Constructor = Auth0;
      }
      if (Constructor.name === "Auth0Widget") {
        throw new Error("Auth0Widget is not supported with this " + " version of auth0-angular anymore. Please try with an older one");
      }
      if (Constructor.name === "Auth0Lock") {
        this.auth0lib = new Constructor(this.clientID, domain, angular.extend(defaultOptions, options));
        this.auth0js = this.auth0lib.getClient();
        this.isLock = true;
        this.lib = "Auth0Lock";
      } else {
        this.auth0lib = new Constructor(angular.extend(defaultOptions, options));
        this.auth0js = this.auth0lib;
        this.isLock = false;
        this.lib = "Auth0";
      }
    };
    this.eventHandlers = {};
    this.on = function(anEvent, handler) {
      if (!this.eventHandlers[anEvent]) {
        this.eventHandlers[anEvent] = [];
      }
      this.eventHandlers[anEvent].push(handler);
    };
    var events = [ "loginSuccess", "loginFailure", "logout", "forbidden", "authenticated" ];
    angular.forEach(events, function(anEvent) {
      config["add" + authUtilsProvider.capitalize(anEvent) + "Handler"] = function(handler) {
        config.on(anEvent, handler);
      };
    });
    this.$get = [ "$rootScope", "$q", "$injector", "$window", "$location", "authUtils", function($rootScope, $q, $injector, $window, $location, authUtils) {
      var auth = {
        isAuthenticated: false
      };
      var getHandlers = function(anEvent) {
        return config.eventHandlers[anEvent];
      };
      var callHandler = function(anEvent, locals) {
        $rootScope.$broadcast("auth0." + anEvent, locals);
        angular.forEach(getHandlers(anEvent) || [], function(handler) {
          $injector.invoke(handler, auth, locals);
        });
      };
      var onSigninOk = function(idToken, accessToken, state, refreshToken, profile, isRefresh) {
        var profilePromise = auth.getProfile(idToken);
        var response = {
          idToken: idToken,
          accessToken: accessToken,
          state: state,
          refreshToken: refreshToken,
          profile: profile,
          isAuthenticated: true
        };
        angular.extend(auth, response);
        callHandler(!isRefresh ? "loginSuccess" : "authenticated", angular.extend({
          profilePromise: profilePromise
        }, response));
        return profilePromise;
      };
      function forbidden() {
        if (config.loginUrl) {
          $location.path(config.loginUrl);
        } else if (config.loginState) {
          $injector.get("$state").go(config.loginState);
        } else {
          callHandler("forbidden");
        }
      }
      $rootScope.$on("$locationChangeStart", function() {
        var hashResult = config.auth0lib.parseHash($window.location.hash);
        if (!auth.isAuthenticated) {
          if (hashResult && hashResult.id_token) {
            onSigninOk(hashResult.id_token, hashResult.access_token, hashResult.state, hashResult.refresh_token);
            return;
          }
          if (config.sso) {
            config.auth0js.getSSOData(authUtils.applied(function(err, ssoData) {
              if (ssoData.sso) {
                auth.signin({
                  popup: false,
                  connection: ssoData.lastUsedConnection.strategy
                }, null, null, "Auth0");
              }
            }));
          }
        }
      });
      $rootScope.$on("auth0.forbiddenRequest", function() {
        forbidden();
      });
      if (config.loginUrl) {
        $rootScope.$on("$routeChangeStart", function(e, nextRoute) {
          if (nextRoute.$$route && nextRoute.$$route.requiresLogin) {
            if (!auth.isAuthenticated && !auth.refreshTokenPromise) {
              $location.path(config.loginUrl);
            }
          }
        });
      }
      if (config.loginState) {
        $rootScope.$on("$stateChangeStart", function(e, to) {
          if (to.data && to.data.requiresLogin) {
            if (!auth.isAuthenticated && !auth.refreshTokenPromise) {
              e.preventDefault();
              $injector.get("$state").go(config.loginState);
            }
          }
        });
      }
      auth.config = config;
      var checkHandlers = function(options, successCallback) {
        var successHandlers = getHandlers("loginSuccess");
        if (!successCallback && !options.username && !options.email && (!successHandlers || successHandlers.length === 0)) {
          throw new Error("You must define a loginSuccess handler " + "if not using popup mode or not doing ro call because that means you are doing a redirect");
        }
      };
      auth.hookEvents = function() {};
      auth.getToken = function(options) {
        options = options || {
          scope: "openid"
        };
        if (!options.id_token && !options.refresh_token) {
          options.id_token = auth.idToken;
        }
        var getDelegationTokenAsync = authUtils.promisify(config.auth0js.getDelegationToken, config.auth0js);
        return getDelegationTokenAsync(options).then(function(delegationResult) {
          return delegationResult.id_token;
        });
      };
      auth.refreshIdToken = function(refresh_token) {
        var refreshTokenAsync = authUtils.promisify(config.auth0js.refreshToken, config.auth0js);
        auth.refreshTokenPromise = refreshTokenAsync(refresh_token || auth.refreshToken).then(function(delegationResult) {
          return delegationResult.id_token;
        })["finally"](function() {
          auth.refreshTokenPromise = null;
        });
        return auth.refreshTokenPromise;
      };
      auth.renewIdToken = function(id_token) {
        var renewIdTokenAsync = authUtils.promisify(config.auth0js.renewIdToken, config.auth0js);
        return renewIdTokenAsync(id_token || auth.idToken).then(function(delegationResult) {
          return delegationResult.id_token;
        });
      };
      auth.signin = function(options, successCallback, errorCallback, libName) {
        options = options || {};
        checkHandlers(options, successCallback, errorCallback);
        options = getInnerLibraryConfigField("parseOptions", libName)(options);
        var signinMethod = getInnerLibraryMethod("signin", libName);
        var successFn = !successCallback ? null : function(profile, idToken, accessToken, state, refreshToken) {
          onSigninOk(idToken, accessToken, state, refreshToken, profile).then(function(profile) {
            if (successCallback) {
              successCallback(profile, idToken, accessToken, state, refreshToken);
            }
          });
        };
        var errorFn = !errorCallback ? null : function(err) {
          callHandler("loginFailure", {
            error: err
          });
          if (errorCallback) {
            errorCallback(err);
          }
        };
        var signinCall = authUtils.callbackify(signinMethod, successFn, errorFn, innerAuth0libraryConfiguration[libName || config.lib].library());
        signinCall(options);
      };
      auth.signup = function(options, successCallback, errorCallback) {
        options = options || {};
        checkHandlers(options, successCallback, errorCallback);
        options = getInnerLibraryConfigField("parseOptions")(options);
        var successFn = !successCallback ? null : function(profile, idToken, accessToken, state, refreshToken) {
          if (!angular.isUndefined(options.auto_login) && !options.auto_login) {
            successCallback();
          } else {
            onSigninOk(idToken, accessToken, state, refreshToken, profile).then(function(profile) {
              if (successCallback) {
                successCallback(profile, idToken, accessToken, state, refreshToken);
              }
            });
          }
        };
        var errorFn = !errorCallback ? null : function(err) {
          callHandler("loginFailure", {
            error: err
          });
          if (errorCallback) {
            errorCallback(err);
          }
        };
        var auth0lib = config.auth0lib;
        var signupCall = authUtils.callbackify(getInnerLibraryMethod("signup"), successFn, errorFn, auth0lib);
        signupCall(options);
      };
      auth.reset = function(options, successCallback, errorCallback) {
        options = options || {};
        options = getInnerLibraryConfigField("parseOptions")(options);
        var auth0lib = config.auth0lib;
        var resetCall = authUtils.callbackify(getInnerLibraryMethod("reset"), successCallback, errorCallback, auth0lib);
        resetCall(options);
      };
      auth.signout = function() {
        auth.isAuthenticated = false;
        auth.profile = null;
        auth.profilePromise = null;
        auth.idToken = null;
        auth.state = null;
        auth.accessToken = null;
        auth.tokenPayload = null;
        callHandler("logout");
      };
      auth.authenticate = function(profile, idToken, accessToken, state, refreshToken) {
        onSigninOk(idToken, accessToken, state, refreshToken, profile, true);
      };
      auth.getProfile = function(idToken) {
        var getProfilePromisify = authUtils.promisify(config.auth0lib.getProfile, config.auth0lib);
        auth.profilePromise = getProfilePromisify(idToken || auth.idToken);
        return auth.profilePromise.then(function(profile) {
          auth.profile = profile;
          return profile;
        });
      };
      return auth;
    } ];
  } ]);
})();
(function(window, angular, localforage, undefined) {
  "use strict";
  var angularLocalForage = angular.module("LocalForageModule", [ "ng" ]);
  angularLocalForage.provider("$localForage", function() {
    var lfInstances = {}, defaultConfig = {
      name: "lf"
    }, notify = {
      setItem: false,
      removeItem: false
    }, watchers = {};
    this.setNotify = function(itemSet, itemRemove) {
      notify = {
        setItem: itemSet,
        removeItem: itemRemove
      };
    };
    this.config = function(config) {
      if (!angular.isObject(config)) {
        throw new Error("The config parameter should be an object");
      }
      angular.extend(defaultConfig, config);
    };
    this.$get = [ "$rootScope", "$q", "$parse", function($rootScope, $q, $parse) {
      var LocalForageInstance = function LocalForageInstance(params) {
        if (angular.isDefined(params)) {
          this._localforage = localforage.createInstance(params);
        } else {
          this._localforage = localforage;
          localforage.config(defaultConfig);
        }
      };
      LocalForageInstance.prototype.createInstance = function createInstance(config) {
        if (angular.isObject(config)) {
          config = angular.extend({}, defaultConfig, config);
          if (angular.isDefined(lfInstances[config.name])) {
            throw new Error("A localForage instance with the name " + config.name + " is already defined.");
          }
          lfInstances[config.name] = new LocalForageInstance(config);
          return lfInstances[config.name];
        } else {
          throw new Error("The parameter should be a config object.");
        }
      };
      LocalForageInstance.prototype.instance = function instance(name) {
        if (angular.isUndefined(name)) {
          return lfInstances[defaultConfig.name];
        } else if (angular.isString(name)) {
          if (angular.isDefined(lfInstances[name])) {
            return lfInstances[name];
          } else {
            throw new Error("No localForage instance of that name exists.");
          }
        } else {
          throw new Error("The parameter should be a string.");
        }
      };
      LocalForageInstance.prototype.setDriver = function setDriver(driver) {
        return this._localforage.setDriver(driver);
      };
      LocalForageInstance.prototype.driver = function driver() {
        return this._localforage.driver();
      };
      LocalForageInstance.prototype.setItem = function setItem(key, value) {
        if (angular.isUndefined(key)) {
          throw new Error("You must define a key to set");
        }
        var deferred = $q.defer(), args = arguments, localCopy = angular.copy(value), self = this;
        if (angular.isObject(localCopy) && angular.isDefined(localCopy.$promise)) {
          delete localCopy.$promise;
        }
        self._localforage.setItem(self.prefix() + key, localCopy).then(function success() {
          if (notify.setItem) {
            $rootScope.$broadcast("LocalForageModule.setItem", {
              key: key,
              newvalue: localCopy,
              driver: self.driver()
            });
          }
          deferred.resolve(localCopy);
        }, function error(data) {
          self.onError(data, args, self.setItem, deferred);
        });
        return deferred.promise;
      };
      LocalForageInstance.prototype.getItem = function getItem(key) {
        if (angular.isUndefined(key)) {
          throw new Error("You must define a key to get");
        }
        var deferred = $q.defer(), args = arguments, self = this;
        self._localforage.getItem(self.prefix() + key).then(function success(item) {
          deferred.resolve(item);
        }, function error(data) {
          self.onError(data, args, self.getItem, deferred);
        });
        return deferred.promise;
      };
      LocalForageInstance.prototype.removeItem = function removeItem(key) {
        if (angular.isUndefined(key)) {
          throw new Error("You must define a key to remove");
        }
        var deferred = $q.defer(), args = arguments, self = this;
        self._localforage.removeItem(self.prefix() + key).then(function success() {
          deferred.resolve();
        }, function error(data) {
          self.onError(data, args, self.removeItem, deferred);
        });
        if (notify.removeItem) {
          return deferred.promise.then(function(value) {
            $rootScope.$broadcast("LocalForageModule.removeItem", {
              key: key,
              driver: self.driver()
            });
          });
        } else {
          return deferred.promise;
        }
      };
      LocalForageInstance.prototype.clear = function clear() {
        var deferred = $q.defer(), args = arguments, self = this;
        self._localforage.clear().then(function success(keys) {
          deferred.resolve();
        }, function error(data) {
          self.onError(data, args, self.clear, deferred);
        });
        return deferred.promise;
      };
      LocalForageInstance.prototype.key = function key(n) {
        if (angular.isUndefined(n)) {
          throw new Error("You must define a position to get for the key function");
        }
        var deferred = $q.defer(), args = arguments, self = this;
        self._localforage.key(n).then(function success(key) {
          deferred.resolve(key);
        }, function error(data) {
          self.onError(data, args, self.key, deferred);
        });
        return deferred.promise;
      };
      var keys = function keys() {
        var deferred = $q.defer(), args = arguments, self = this;
        self._localforage.keys().then(function success(keyList) {
          if (defaultConfig.oldPrefix && self.driver() === "localStorageWrapper") {
            var tempKeyList = [];
            for (var i = 0, len = keyList.length; i < len; i++) {
              tempKeyList.push(keyList[i].substr(self.prefix().length, keyList[i].length));
            }
            keyList = tempKeyList;
          }
          deferred.resolve(keyList);
        }, function error(data) {
          self.onError(data, args, self.keys, deferred);
        });
        return deferred.promise;
      };
      LocalForageInstance.prototype.keys = keys;
      LocalForageInstance.prototype.getKeys = keys;
      LocalForageInstance.prototype.length = function() {
        var deferred = $q.defer(), args = arguments, self = this;
        self._localforage.length().then(function success(length) {
          deferred.resolve(length);
        }, function error(data) {
          self.onError(data, args, length, deferred);
        });
        return deferred.promise;
      };
      LocalForageInstance.prototype.bind = function bind($scope, opts) {
        if (angular.isString(opts)) {
          opts = {
            key: opts
          };
        } else if (!angular.isObject(opts) || angular.isUndefined(opts.key)) {
          throw new Error("You must define a key to bind");
        }
        var defaultOpts = {
          defaultValue: "",
          name: defaultConfig.name
        };
        opts = angular.extend({}, defaultOpts, opts);
        var self = lfInstances[opts.name];
        if (angular.isUndefined(self)) {
          throw new Error("You must use the name of an existing instance");
        }
        var scopeKey = opts.scopeKey || opts.key, model = $parse(scopeKey);
        return self.getItem(opts.key).then(function(item) {
          if (item) {
            model.assign($scope, item);
          } else if (opts.defaultValue) {
            model.assign($scope, opts.defaultValue);
            self.setItem(opts.key, opts.defaultValue);
          }
          if (angular.isDefined(watchers[opts.key])) {
            watchers[opts.key]();
          }
          watchers[opts.key] = $scope.$watch(scopeKey, function(val) {
            if (angular.isDefined(val)) {
              self.setItem(opts.key, val);
            }
          }, true);
          return item;
        });
      };
      LocalForageInstance.prototype.unbind = function unbind($scope, opts) {
        if (angular.isString(opts)) {
          opts = {
            key: opts
          };
        } else if (!angular.isObject(opts) || angular.isUndefined(opts.key)) {
          throw new Error("You must define a key to unbind");
        }
        var defaultOpts = {
          scopeKey: opts.key,
          name: defaultConfig.name
        };
        opts = angular.extend({}, defaultOpts, opts);
        var self = lfInstances[opts.name];
        if (angular.isUndefined(self)) {
          throw new Error("You must use the name of an existing instance");
        }
        $parse(opts.scopeKey).assign($scope, null);
        if (angular.isDefined(watchers[opts.key])) {
          watchers[opts.key]();
          delete watchers[opts.key];
        }
        return self.removeItem(opts.key);
      };
      LocalForageInstance.prototype.prefix = function() {
        return this.driver() === "localStorageWrapper" && defaultConfig.oldPrefix ? this._localforage.config().name + "." : "";
      };
      LocalForageInstance.prototype.onError = function(err, args, fct, deferred) {
        if ((angular.isObject(err) && err.name ? err.name === "InvalidStateError" : angular.isString(err) && err === "InvalidStateError") && this.driver() === "asyncStorage" || angular.isObject(err) && err.code && err.code === 5) {
          var self = this;
          self.setDriver("localStorageWrapper").then(function() {
            fct.apply(self, args).then(function(item) {
              deferred.resolve(item);
            }, function(data) {
              deferred.reject(data);
            });
          }, function() {
            deferred.reject(err);
          });
        } else {
          deferred.reject(err);
        }
      };
      lfInstances[defaultConfig.name] = new LocalForageInstance();
      return lfInstances[defaultConfig.name];
    } ];
  });
  angularLocalForage.directive("localForage", [ "$localForage", function($localForage) {
    return {
      restrict: "A",
      link: function($scope, $element, $attrs) {
        var opts = $scope.$eval($attrs.localForage);
        if (angular.isObject(opts) && angular.isDefined(opts.key)) {
          $localForage.bind($scope, opts);
        } else {
          $localForage.bind($scope, $attrs.localForage);
        }
      }
    };
  } ]);
})(window, window.angular, window.localforage);